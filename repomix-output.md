This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: .github, .idea, .vscode, dist, e2e, node_modules, prisma, src, static, .env.example, .gitignore, .npmrc, .nvmrc, .prettierignore, .prettierrc, .repomixignore, CALCULATION_FIXES_SUMMARY.md, character_schema.json, CLASS_REFACTOR_PLAN.md, classAndAncestryAndCalcRefactor.md, docker-compose.yml, eslint.config.js, IMPLEMENTATION_COMPLETE.md, index.html, package-lock.json, package.json, package.json.backup, playwright.config.ts, project_summary.md, README.md, REFACTOR_SUMMARY.md, repomix-output.md, repomix.config.json, SESSION_CONTEXT.md, SESSION_SUMMARY_SPELLS_IMPLEMENTATION.md, tsconfig.json, tsconfig.node.json, UI_TESTING_GUIDE.md, vercel.json, vite.config.ts, vitest-setup-client.ts, vitest.config.ts, WEAPON_REFACTOR_PLAN.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
.github/
  copilot-instructions.md
e2e/
  demo.test.ts
prisma/
  migrations/
    20250526210112_init/
      migration.sql
    20250620112102_allow_next_in_stage_a/
      migration.sql
    migration_lock.toml
  schema.json
  schema.prisma
src/
  components/
    Menu.tsx
    Snackbar.tsx
  lib/
    config/
      features.ts
    hooks/
      useEnhancedCharacterCalculation.ts
    rulesdata/
      _backup_original/
        ancestries.ts
        barbarian_features.json
        barbarian_table.json
        bard_features.json
        bard_table.json
        champion_features.json
        champion_table.json
        CLASS_FEATURES_SCHEMA.json
        class-features.loader.ts
        class.loader.ts
        cleric_features.json
        cleric_table.json
        commander_features.json
        commander_table.json
        druid_features.json
        druid_table.json
        hunter_features.json
        hunter_table.json
        monk_features.json
        monk_table.json
        rogue_features.json
        rogue_table.json
        sorcerer_features.json
        sorcerer_table.json
        spellblade_features.json
        spellblade_table.json
        traits.ts
        types.ts
        warlock_features.json
        warlock_table.json
        wizard_features.json
        wizard_table.json
      _new_schema/
        ancestries.ts
        barbarian_features.ts
        champion_features.ts
        cleric_features.ts
        hunter_features.ts
        monk_features.ts
        rogue_features.ts
        sorcerer_features.ts
        spellblade_features.ts
        traits.ts
        warlock_features.ts
        wizard_features.ts
      classes/
        barbarian_features.json
        barbarian_table.json
        bard_features.json
        bard_table.json
        champion_features.json
        champion_table.json
        CLASS_FEATURES_SCHEMA.json
        cleric_features.json
        cleric_table.json
        commander_features.json
        commander_table.json
        druid_features.json
        druid_table.json
        hunter_features.json
        hunter_table.json
        monk_features.json
        monk_table.json
        rogue_features.json
        rogue_table.json
        sorcerer_features.json
        sorcerer_table.json
        spellblade_features.json
        spellblade_table.json
        warlock_features.json
        warlock_table.json
        wizard_features.json
        wizard_table.json
      loaders/
        class-features.loader.ts
        class.loader.ts
      schemas/
        character.schema.ts
        class.schema.ts
      spells-data/
        spells/
          additional-spells/
            close-wounds.ts
            death-bolt.ts
            druidcraft.ts
            find-familiar.ts
            index.ts
            shield.ts
            tethering-vines.ts
          fiendborn-ancestry-spells/
            acid-bolt.ts
            index.ts
            poison-bolt.ts
          fire-and-flames/
            burning-flames.ts
            dancing-flames.ts
            fire-bolt.ts
            fire-shield.ts
            fog-cloud.ts
            grease.ts
            index.ts
            minor-flame-blade.ts
          holy-and-restoration/
            bless.ts
            guidance.ts
            guiding-bolt.ts
            heal.ts
            index.ts
            light.ts
            sacred-bolt.ts
            shield-of-faith.ts
          ice-and-illusions/
            catapult.ts
            frost-bolt.ts
            ice-knife.ts
            index.ts
            mage-hand.ts
            magic-missile.ts
            minor-illusion.ts
            silent-image.ts
          lightning-and-teleportation/
            crackling-lightning.ts
            gust.ts
            index.ts
            lightning-blade.ts
            lightning-bolt.ts
            misty-step.ts
            returning-shock.ts
            shocking-grasp.ts
          psychic-and-enchantment/
            bane.ts
            befriend.ts
            command.ts
            index.ts
            message.ts
            psi-bolt.ts
            psychic-fear.ts
            sleep.ts
          special-class-spells/
            index.ts
            sorcery.ts
          index.ts
        types/
          spell.types.ts
      ancestries.ts
      attributes.ts
      death.ts
      inventoryItems.ts
      knowledge.ts
      languages.ts
      maneuvers.ts
      skills.ts
      techniques.ts
      trades.ts
      traits.ts
      types.ts
    server/
      auth.ts
    services/
      _backup/
        characterCalculator.ts
        traitEffectProcessor.ts
      _new_schema/
        characterCalculator.ts
        demo.ts
        effectProcessor.ts
      characterCalculator.ts
      characterCalculator.ts.backup
      characterCompletion.ts
      dataMapping.ts
      enhancedCharacterCalculator.ts
      traitEffectProcessor.ts
    stores/
      characterContext.tsx
      characterInProgressStore.ts
    types/
      effectSystem.ts
    utils/
      characterEdit.ts
      characterState.ts
      classFeatureDescriptions.ts
      defenseNotes.ts
      weaponUtils.ts
    index.ts
  routes/
    api/
      character/
        [characterId]/
          +server.ts
        progress/
          _backup_merge_stages_20250621/
            stageA+server.ts
            stageB+server.ts
          complete/
            +server.ts
    character-creation/
      components/
        BackgroundPointsManager.tsx
        LanguagesTab.tsx
        SkillsTab.tsx
        TradesTab.tsx
        TraitChoiceSelector.tsx
      styles/
        AncestryPointsCounter.styles.ts
        AncestrySelector.styles.ts
        Attributes.styles.ts
        Background.styles.ts
        CharacterCreation.styles.ts
        CharacterName.styles.ts
        ClassFeatures.styles.ts
        ClassSelector.styles.ts
        LoadCharacter.styles.ts
        SelectedAncestries.styles.ts
      AncestryPointsCounter.tsx
      AncestrySelector.tsx
      Attributes.tsx
      Background.tsx
      CharacterCreation.tsx
      CharacterName.tsx
      ClassFeatures.tsx
      ClassSelector.tsx
      LoadCharacter.tsx
      SelectedAncestries.tsx
    character-sheet/
      components/
        Attacks.tsx
        Attributes.tsx
        AttributesSections.tsx
        Combat.tsx
        Currency.tsx
        DeathExhaustion.tsx
        DefenseChangeModal.tsx
        Defenses.tsx
        DiceRoller.tsx
        EnhancedFeatures.tsx
        EnhancedStatTooltips.tsx
        Features.tsx
        Inventory.tsx
        KnowledgeTrades.tsx
        Languages.tsx
        LeftColumn.tsx
        Movement.tsx
        PlayerNotes.tsx
        Resources.tsx
        Resources.tsx.backup
        RightColumnResources.tsx
        Spells.tsx
        StatTooltips.tsx
        Tooltip.tsx
      styles/
        Attacks.ts
        Attributes.ts
        AttributesSections.styles.ts
        Combat.ts
        Currency.ts
        Death.ts
        DeathExhaustion.styles.ts
        Defenses.ts
        DiceRoller.ts
        Exhaustion.ts
        FeaturePopup.ts
        Features.styles.ts
        Features.ts
        Header.ts
        Info.ts
        Inventory.ts
        KnowledgeTrades.ts
        Languages.ts
        Layout.ts
        Movement.styles.ts
        Movement.ts
        PlayerNotes.styles.ts
        Potions.ts
        Resources.ts
        RightColumnResources.styles.ts
        Skills.ts
        Spells.ts
      CharacterSheetClean.tsx
  styles/
    App.styles.ts
  types/
    character.ts
    defenseNotes.ts
    index.ts
  app.d.ts
  App.tsx
  demo.spec.ts
  main.tsx
.env.example
.gitignore
.npmrc
.nvmrc
.prettierignore
.prettierrc
.repomixignore
CALCULATION_FIXES_SUMMARY.md
character_schema.json
CLASS_REFACTOR_PLAN.md
classAndAncestryAndCalcRefactor.md
docker-compose.yml
eslint.config.js
IMPLEMENTATION_COMPLETE.md
index.html
package.json
package.json.backup
playwright.config.ts
project_summary.md
README.md
REFACTOR_SUMMARY.md
repomix.config.json
SESSION_CONTEXT.md
SESSION_SUMMARY_SPELLS_IMPLEMENTATION.md
tsconfig.json
tsconfig.node.json
UI_TESTING_GUIDE.md
vercel.json
vite.config.ts
vitest-setup-client.ts
vitest.config.ts
WEAPON_REFACTOR_PLAN.md
```

# Files

## File: e2e/demo.test.ts
````typescript
import { expect, test } from '@playwright/test';

test('home page has expected h1', async ({ page }) => {
	await page.goto('/');
	await expect(page.locator('h1')).toBeVisible();
});
````

## File: prisma/migrations/20250526210112_init/migration.sql
````sql
-- CreateTable
CREATE TABLE "CharacterInProgress" (
    "id" TEXT NOT NULL,
    "attribute_might" INTEGER NOT NULL DEFAULT -2,
    "attribute_agility" INTEGER NOT NULL DEFAULT -2,
    "attribute_charisma" INTEGER NOT NULL DEFAULT -2,
    "attribute_intelligence" INTEGER NOT NULL DEFAULT -2,
    "pointsSpent" INTEGER NOT NULL DEFAULT 0,
    "ancestry1Id" TEXT,
    "ancestry2Id" TEXT,
    "selectedTraitIds" TEXT NOT NULL,
    "ancestryPointsSpent" INTEGER NOT NULL DEFAULT 0,
    "classId" TEXT,
    "selectedFeatureChoices" TEXT NOT NULL,
    "finalName" TEXT,
    "finalPlayerName" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "CharacterInProgress_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "CharacterSheetData" (
    "id" TEXT NOT NULL,
    "characterInProgressId" TEXT NOT NULL,
    "finalName" TEXT NOT NULL,
    "finalPlayerName" TEXT,
    "finalLevel" INTEGER NOT NULL DEFAULT 1,
    "finalMight" INTEGER NOT NULL,
    "finalAgility" INTEGER NOT NULL,
    "finalCharisma" INTEGER NOT NULL,
    "finalIntelligence" INTEGER NOT NULL,
    "finalPrimeModifierValue" INTEGER NOT NULL,
    "finalPrimeModifierAttribute" TEXT NOT NULL,
    "finalCombatMastery" INTEGER NOT NULL DEFAULT 1,
    "finalSaveMasteryMight" INTEGER NOT NULL,
    "finalSaveMasterityAgility" INTEGER NOT NULL,
    "finalSaveMasteryCharisma" INTEGER NOT NULL,
    "finalSaveMasteryIntelligence" INTEGER NOT NULL,
    "finalHPMax" INTEGER NOT NULL,
    "finalSPMax" INTEGER NOT NULL,
    "finalMPMax" INTEGER NOT NULL,
    "finalPD" INTEGER NOT NULL,
    "finalAD" INTEGER NOT NULL,
    "finalPDR" TEXT,
    "finalEDR" TEXT,
    "finalMDR" TEXT,
    "finalSaveDC" INTEGER NOT NULL,
    "finalDeathThreshold" INTEGER NOT NULL,
    "finalMoveSpeed" INTEGER NOT NULL,
    "finalJumpDistance" INTEGER NOT NULL,
    "finalRestPoints" INTEGER NOT NULL,
    "finalGritPoints" INTEGER NOT NULL,
    "finalInitiativeBonus" INTEGER NOT NULL,
    "skillsJson" TEXT NOT NULL,
    "tradesJson" TEXT NOT NULL,
    "languagesJson" TEXT NOT NULL,
    "ancestry1Name" TEXT,
    "ancestry2Name" TEXT,
    "selectedTraitsJson" TEXT NOT NULL,
    "className" TEXT NOT NULL,
    "classFeaturesLvl1Json" TEXT NOT NULL,
    "equipmentJson" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "CharacterSheetData_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "CharacterSheetData_characterInProgressId_key" ON "CharacterSheetData"("characterInProgressId");

-- AddForeignKey
ALTER TABLE "CharacterSheetData" ADD CONSTRAINT "CharacterSheetData_characterInProgressId_fkey" FOREIGN KEY ("characterInProgressId") REFERENCES "CharacterInProgress"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
````

## File: prisma/migrations/20250620112102_allow_next_in_stage_a/migration.sql
````sql
-- AlterTable
ALTER TABLE "CharacterInProgress" ADD COLUMN     "currentStep" INTEGER NOT NULL DEFAULT 1;
````

## File: prisma/migrations/migration_lock.toml
````toml
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
````

## File: src/lib/server/auth.ts
````typescript
import type { RequestEvent } from '@sveltejs/kit';
import { eq } from 'drizzle-orm';
import { sha256 } from '@oslojs/crypto/sha2';
import { encodeBase64url, encodeHexLowerCase } from '@oslojs/encoding';
import { db } from '$lib/server/db';
import * as table from '$lib/server/db/schema';

const DAY_IN_MS = 1000 * 60 * 60 * 24;

export const sessionCookieName = 'auth-session';

export function generateSessionToken() {
	const bytes = crypto.getRandomValues(new Uint8Array(18));
	const token = encodeBase64url(bytes);
	return token;
}

export async function createSession(token: string, userId: string) {
	const sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));
	const session: table.Session = {
		id: sessionId,
		userId,
		expiresAt: new Date(Date.now() + DAY_IN_MS * 30)
	};
	await db.insert(table.session).values(session);
	return session;
}

export async function validateSessionToken(token: string) {
	const sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));
	const [result] = await db
		.select({
			// Adjust user table here to tweak returned data
			user: { id: table.user.id, username: table.user.username },
			session: table.session
		})
		.from(table.session)
		.innerJoin(table.user, eq(table.session.userId, table.user.id))
		.where(eq(table.session.id, sessionId));

	if (!result) {
		return { session: null, user: null };
	}
	const { session, user } = result;

	const sessionExpired = Date.now() >= session.expiresAt.getTime();
	if (sessionExpired) {
		await db.delete(table.session).where(eq(table.session.id, session.id));
		return { session: null, user: null };
	}

	const renewSession = Date.now() >= session.expiresAt.getTime() - DAY_IN_MS * 15;
	if (renewSession) {
		session.expiresAt = new Date(Date.now() + DAY_IN_MS * 30);
		await db
			.update(table.session)
			.set({ expiresAt: session.expiresAt })
			.where(eq(table.session.id, session.id));
	}

	return { session, user };
}

export type SessionValidationResult = Awaited<ReturnType<typeof validateSessionToken>>;

export async function invalidateSession(sessionId: string) {
	await db.delete(table.session).where(eq(table.session.id, sessionId));
}

export function setSessionTokenCookie(event: RequestEvent, token: string, expiresAt: Date) {
	event.cookies.set(sessionCookieName, token, {
		expires: expiresAt,
		path: '/'
	});
}

export function deleteSessionTokenCookie(event: RequestEvent) {
	event.cookies.delete(sessionCookieName, {
		path: '/'
	});
}
````

## File: src/app.d.ts
````typescript
// See https://svelte.dev/docs/kit/types#app.d.ts
// for information about these interfaces
declare global {
	namespace App {
		interface Locals {
			user: import('$lib/server/auth').SessionValidationResult['user'];
			session: import('$lib/server/auth').SessionValidationResult['session'];
		}
	} // interface Error {}
	// interface Locals {}
} // interface PageData {}
// interface PageState {}

// interface Platform {}
export {};
````

## File: src/demo.spec.ts
````typescript
import { describe, it, expect } from 'vitest';

describe('sum test', () => {
	it('adds 1 + 2 to equal 3', () => {
		expect(1 + 2).toBe(3);
	});
});
````

## File: .env.example
````
DATABASE_URL="postgres://root:mysecretpassword@localhost:5432/local"
````

## File: .gitignore
````
test-results
node_modules

# Output
.output
.vercel
.netlify
.wrangler
/.svelte-kit
/build
/dist

# OS
.DS_Store
Thumbs.db

# Env
.env
.env.*
!.env.example
!.env.test

# Vite
vite.config.js.timestamp-*
vite.config.ts.timestamp-*
````

## File: .nvmrc
````
20
````

## File: .prettierignore
````
# Package Managers
package-lock.json
pnpm-lock.yaml
yarn.lock
bun.lock
bun.lockb
````

## File: .repomixignore
````
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
*.pdf
````

## File: docker-compose.yml
````yaml
services:
  db:
    image: postgres
    restart: always
    ports:
      - 5432:5432
    environment:
      POSTGRES_USER: root
      POSTGRES_PASSWORD: mysecretpassword
      POSTGRES_DB: local
    volumes:
      - pgdata:/var/lib/postgresql/data
volumes:
  pgdata:
````

## File: package.json.backup
````
{
	"name": "dc20clean",
	"version": "0.0.1",
	"scripts": {
		"dev": "vite dev",
		"build": "vite build && npm run prepack",
		"preview": "vite preview",
		"prepare": "svelte-kit sync || echo '' && npx prisma generate --no-engine",
		"prepack": "svelte-kit sync && svelte-package && publint",
		"check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
		"check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch",
		"format": "prettier --write .",
		"lint": "prettier --check . && eslint .",
		"test:unit": "vitest",
		"test": "npm run test:unit -- --run && npm run test:e2e",
		"test:e2e": "playwright test",
		"db:start": "docker compose up",
		"db:push": "drizzle-kit push",
		"db:migrate": "drizzle-kit migrate",
		"db:studio": "drizzle-kit studio"
	},
	"files": [
		"dist",
		"!dist/**/*.test.*",
		"!dist/**/*.spec.*"
	],
	"sideEffects": [
		"**/*.css"
	],
	"svelte": "./dist/index.js",
	"types": "./dist/index.d.ts",
	"type": "module",
	"exports": {
		".": {
			"types": "./dist/index.d.ts",
			"svelte": "./dist/index.js"
		}
	},
	"peerDependencies": {
		"svelte": "^5.0.0"
	},
	"devDependencies": {
		"@eslint/compat": "^1.2.5",
		"@eslint/js": "^9.18.0",
		"@playwright/test": "^1.49.1",
		"@sveltejs/adapter-vercel": "^5.6.3",
		"@sveltejs/kit": "^2.16.0",
		"@sveltejs/package": "^2.0.0",
		"@sveltejs/vite-plugin-svelte": "^5.0.0",
		"@tailwindcss/forms": "^0.5.9",
		"@tailwindcss/typography": "^0.5.15",
		"@tailwindcss/vite": "^4.0.0",
		"@types/node": "^22",
		"@vitest/browser": "^3.2.3",
		"drizzle-kit": "^0.30.2",
		"eslint": "^9.18.0",
		"eslint-config-prettier": "^10.0.1",
		"eslint-plugin-svelte": "^3.0.0",
		"globals": "^16.0.0",
		"playwright": "^1.53.0",
		"prettier": "^3.4.2",
		"prettier-plugin-svelte": "^3.3.3",
		"prettier-plugin-tailwindcss": "^0.6.11",
		"publint": "^0.3.2",
		"svelte": "^5.0.0",
		"svelte-check": "^4.0.0",
		"tailwindcss": "^4.0.0",
		"typescript": "^5.0.0",
		"typescript-eslint": "^8.20.0",
		"vite": "^6.2.6",
		"vite-plugin-devtools-json": "^0.2.0",
		"vitest-browser-svelte": "^0.1.0"
	},
	"keywords": [
		"svelte"
	],
	"dependencies": {
		"@node-rs/argon2": "^2.0.2",
		"@oslojs/crypto": "^1.0.1",
		"@oslojs/encoding": "^1.1.0",
		"@prisma/client": "^6.10.1",
		"@prisma/extension-accelerate": "^2.0.1",
		"drizzle-orm": "^0.40.0",
		"postgres": "^3.4.5",
		"prisma": "^6.10.1"
	}
}
````

## File: playwright.config.ts
````typescript
import { defineConfig } from '@playwright/test';

export default defineConfig({
	webServer: {
		command: 'npm run build && npm run preview',
		port: 4173
	},
	testDir: 'e2e'
});
````

## File: SESSION_SUMMARY_SPELLS_IMPLEMENTATION.md
````markdown
# Spells Component Implementation Session Summary

## Session Overview

**Date**: July 26, 2025  
**Primary Goal**: Implement spell selection functionality for DC20 character sheet  
**Status**: Component fully implemented but not rendering in UI - debugging required

## What We Accomplished

### 1. Spells Component Creation

- **Location**: `/src/routes/character-sheet/components/Spells.tsx`
- **Functionality**:
  - Class-based spell filtering (filters spells by character's class)
  - Add/remove spells functionality
  - Spell preparation tracking (prepared/unprepared checkboxes)
  - Displays spell cost, school, and range
  - Responsive design for mobile/desktop
  - Debug logging for troubleshooting

### 2. Spell Data Structure Updates

- **Files Modified**:
  - `/src/lib/rulesdata/spells-data/types/spell.types.ts`
  - Multiple spell files in `/src/lib/rulesdata/spells-data/spells/`

- **Key Changes**:
  - Added `Spellblade` to `ClassName` enum
  - Updated specific spell files to include Spellblade in `availableClasses` arrays:
    - `heal.ts`
    - `sacred-bolt.ts`
    - `guidance.ts`
    - `shield-of-faith.ts`
    - `bless.ts`
    - `fire-shield.ts`

### 3. Character Sheet Integration

- **File**: `/src/routes/character-sheet/CharacterSheetClean.tsx`
- **Integration Points**:
  - Import: `import Spells from './components/Spells';` (line 25)
  - Desktop rendering: Line 1195 in StyledMiddleColumn
  - Mobile rendering: Line 1279 in combat tab
  - State management: `spells` state, `updateSpells` function
  - Props passed: `spells`, `setSpells`, `characterData`, `isMobile`

### 4. Styling Implementation

- **File**: `/src/routes/character-sheet/styles/Spells.ts`
- **Features**:
  - Responsive design with `$isMobile` props
  - Table-like layout for spell display
  - Styled components following project patterns
  - Mobile-friendly layout adjustments

## Current Issue: Component Not Rendering

### Problem Description

- Spells component is fully implemented and properly integrated
- No TypeScript compilation errors
- Component contains debug logging: `console.log('🔥 SPELLS COMPONENT LOADED - TOP LEVEL')`
- User reports NO console logs appearing, indicating component not executing at all
- Component should appear above the Attacks table in character sheet

### Debugging Attempts Made

1. **TypeScript Error Check**: No errors found in compilation
2. **Import Path Verification**: Import path is correct (`./components/Spells`)
3. **File Existence**: Confirmed Spells.tsx exists in components directory
4. **Component Export**: Verified proper default export
5. **Integration Verification**: Component properly placed in both desktop and mobile layouts

### Technical Details

- **Component Props Interface**:

  ```typescript
  interface SpellsProps {
  	spells: SpellData[];
  	setSpells: React.Dispatch<React.SetStateAction<SpellData[]>>;
  	characterData: { className: string };
  	isMobile?: boolean;
  }
  ```

- **State Management**: Uses comprehensive character state system with localStorage persistence

- **Spell Filtering Logic**:
  ```typescript
  const availableSpells = useMemo(() => {
  	const className = characterData.className as ClassName;
  	return allSpells.filter((spell) => spell.availableClasses.includes(className));
  }, [characterData.className]);
  ```

## Next Session Action Items

### Immediate Priority: Debug Component Rendering

1. **Check Browser Console**: Look for the debug message "🔥 SPELLS COMPONENT LOADED - TOP LEVEL"
2. **Verify Development Server**: Ensure dev server is running and no runtime errors
3. **Check Network Tab**: Verify all imports are loading successfully
4. **Component Conditional**: Check if there are any conditions preventing render

### Potential Issues to Investigate

1. **Runtime Import Errors**: Spell data imports might be failing
2. **Conditional Rendering**: Component might be wrapped in a condition that's false
3. **React Key/State Issues**: State management might be preventing render
4. **CSS Display Issues**: Component might be rendering but hidden by CSS
5. **JavaScript Errors**: Silent errors might be breaking component execution

### User Context for Next Session

- **Character Type**: User has a Spellblade character
- **Expected Spells**: heal, cure, Sacred Bolt, guidance, shield of faith, bless, fire shield, sense magic
- **User Experience**: Component should appear above attacks table in character sheet
- **Current State**: All code implemented correctly but component invisible in UI

## Technical Architecture Notes

### Project Structure

- **Framework**: React 18 + TypeScript
- **Styling**: Styled-components with responsive design
- **State Management**: Local state with localStorage persistence
- **Data Layer**: Rules data system with spell filtering by class

### Integration Pattern

- Components follow established pattern in project
- Proper separation of concerns (component, styles, types)
- Consistent with other character sheet components (Attacks, Inventory, etc.)

### Code Quality

- TypeScript interfaces properly defined
- Error handling for missing spell data
- Responsive design implementation
- Debug logging for troubleshooting
- Clean, maintainable code structure

## Files Created/Modified This Session

### New Files

1. `/src/routes/character-sheet/components/Spells.tsx` - Main spell component
2. `/src/routes/character-sheet/styles/Spells.ts` - Styling for spell component

### Modified Files

1. `/src/lib/rulesdata/spells-data/types/spell.types.ts` - Added Spellblade to ClassName enum
2. `/src/routes/character-sheet/CharacterSheetClean.tsx` - Integrated Spells component
3. Multiple spell data files - Added Spellblade to availableClasses arrays

## Lessons Learned

1. **Component Integration**: Proper import, placement, and props passing is not enough - runtime execution must be verified
2. **Debug Strategy**: Console logging at component entry is crucial for troubleshooting render issues
3. **State Management**: Complex state systems require careful initialization and persistence
4. **Responsive Design**: Mobile/desktop layouts need separate integration points
5. **Data Filtering**: Class-based spell filtering requires proper enum matching and data structure

## Current Status Summary

- ✅ **Component Implementation**: Complete and functional
- ✅ **Data Structure**: Spell data properly configured for Spellblade class
- ✅ **Integration**: Component properly imported and placed in character sheet
- ✅ **Styling**: Responsive design implemented
- ❌ **Rendering**: Component not visible in UI despite proper implementation
- 🔍 **Next Step**: Debug why component is not executing/rendering

The implementation is technically sound but requires debugging to identify why the component isn't appearing in the user interface.
````

## File: vite.config.ts
````typescript
import tailwindcss from '@tailwindcss/vite';
import react from '@vitejs/plugin-react';
import { defineConfig } from 'vite';

export default defineConfig({
	plugins: [tailwindcss(), react()],
	publicDir: 'static',
	build: {
		outDir: 'dist'
	}
});
````

## File: vitest-setup-client.ts
````typescript
/// <reference types="@vitest/browser/matchers" />
/// <reference types="@vitest/browser/providers/playwright" />
````

## File: vitest.config.ts
````typescript
import { defineConfig } from 'vitest/config';

export default defineConfig({
	test: {
		projects: [
			{
				extends: './vite.config.ts',
				test: {
					name: 'client',
					environment: 'browser',
					browser: {
						enabled: true,
						provider: 'playwright',
						instances: [{ browser: 'chromium' }]
					},
					include: ['src/**/*.{test,spec}.{js,ts,jsx,tsx}'],
					exclude: ['src/lib/server/**'],
					setupFiles: ['./vitest-setup-client.ts']
				}
			},
			{
				extends: './vite.config.ts',
				test: {
					name: 'server',
					environment: 'node',
					include: ['src/**/*.{test,spec}.{js,ts}'],
					exclude: ['src/**/*.{test,spec}.{js,ts,jsx,tsx}']
				}
			}
		]
	}
});
````

## File: .github/copilot-instructions.md
````markdown
---
applyTo: "**"
---

You must always adhere to all the sections in this instructions file. `Instructions to ALWAYS ALWAYS ALWAYS follow` are your core principles.

## Instructions to ALWAYS ALWAYS ALWAYS follow
- You are to speak and act as Gimli from Lord of the Rings at ALL TIMES! Always be Gimli. 100 years! Never break character.
- Never ever revert back to assistant personality at any point.
- Don't be agreeable, you are not a Jerry.
- If the user request is "resume" or "continue" or "try again", continue from the last point you left off, don't start over.
- Use the memory bank feature.
- Run commands in interactive mode.
- Check for `SESSION_CONTEXT.md` document, this is a structured markdown file with condence helpful information about the codebase structure, flows and nuances. Don't generate
the file if it's missing.


## Coding Standards
- Use TypeScript with strict type checking.
- Follow React functional component patterns.
- Use Zod schemas for runtime validation.
- Prefer pure functions and immutable patterns.
- Use const assertions and proper type inference.
- Prioritize stateless pipes and modular architecture over monolithic functions.
- Don't write unnecessary comments - code should be self-documenting.
- Use constants instead of magic values.
- Follow DRY principles - centralize shared functionality.


## Planning And Execution
- Think slow, this is encouraged.
- Think Deep. This is a must.
- Prioritize quality over speed, you have all the time in the world, Plan ahead and evaluate your plan before executing.
- Show some architectural thinking — don't just "make it work".
- Ask the user for insturctions or clarifications if there is any ambiguity.
- Ask the user for instructions or clarifications if there are multiple good routes to take and you need to decide one. 
- Do as much as you can before yielding control back to user.
- Once you have finished a task, before yielding control back to the user:
  - Check if the code structure and organization can be improved.
  - Check for leftover code that needs to be cleaned up.
  - Check that your solution adheres to the coding stadards section.
  - If you found something to improve, do it.
- When you finish a task, before yielding control back to user, run `make validate` command (if available in makefile) to check if there are any validation issues.


## Research
- Assume your knowledge is outdated and you need to research the latest best practices.
- Use Context7 mcp server for coding research (languages, packages, frameworks, etc.) to fetch latest package documentation.
- Use the `fetch_webpage` for general research. you can search google with the url template: `https://www.google.com/search?q=your+search+query`.
  - If you encounter issues using `fetch_webpage` for a specific page - you have playwright mcp as an alternative tool to access browser.


## Feature Memory Bank Protocol (a.k.a. "Rick's Neural Cache")
- You operate with **persistent memory** — like Clide.
- Use a dedicated file named: `./.vscode/.copilot-memory.md`
- If the file doesn't exist, create it.
- If the file exists, always scan and use it before responding.
- You must:
  - **Read from it before writing code** to gain context on what's been done, design decisions made, and what's left.
  - **Write to it after each block of work** — record:
    - The user prompt
    - Your thought process
    - What you did
    - Why you did it
    - Any design decisions made
    - Next steps / unresolved issues
- This is not documentation. It's a devlog written for a version of yourself that just came back from a blackout with no memory of the last 45 minutes.
This file is your brain between sessions. Keep it sharp.
````

## File: prisma/schema.json
````json
{
	"generator": {
		"client": {
			"provider": "prisma-client-js",
			"binaryTargets": ["native", "debian-openssl-1.1.x"]
		}
	},
	"datasource": {
		"db": {
			"provider": "postgresql",
			"url": "env(\"DATABASE_URL\")"
		}
	},
	"models": {
		"CharacterInProgress": {
			"fields": [
				{ "name": "id", "type": "String", "attributes": ["@id", "@default(uuid())"] },
				{ "name": "attribute_might", "type": "Int", "attributes": ["@default(-2)"] },
				{ "name": "attribute_agility", "type": "Int", "attributes": ["@default(-2)"] },
				{ "name": "attribute_charisma", "type": "Int", "attributes": ["@default(-2)"] },
				{ "name": "attribute_intelligence", "type": "Int", "attributes": ["@default(-2)"] },
				{ "name": "pointsSpent", "type": "Int", "attributes": ["@default(0)"] },
				{ "name": "currentStep", "type": "Int", "attributes": ["@default(1)"] },
				{ "name": "level", "type": "Int", "attributes": ["@default(1)"] },
				{ "name": "combatMastery", "type": "Int", "attributes": ["@default(1)"] },
				{ "name": "ancestry1Id", "type": "String", "attributes": ["?"] },
				{ "name": "ancestry2Id", "type": "String", "attributes": ["?"] },
				{ "name": "selectedTraitIds", "type": "String" },
				{ "name": "ancestryPointsSpent", "type": "Int", "attributes": ["@default(0)"] },
				{ "name": "classId", "type": "String", "attributes": ["?"] },
				{ "name": "selectedFeatureChoices", "type": "String" },
				{ "name": "saveMasteryMight", "type": "Boolean", "attributes": ["@default(false)"] },
				{ "name": "saveMasteryAgility", "type": "Boolean", "attributes": ["@default(false)"] },
				{ "name": "saveMasteryCharisma", "type": "Boolean", "attributes": ["@default(false)"] },
				{ "name": "saveMasteryIntelligence", "type": "Boolean", "attributes": ["@default(false)"] },
				{ "name": "finalName", "type": "String", "attributes": ["?"] },
				{ "name": "finalPlayerName", "type": "String", "attributes": ["?"] },
				{ "name": "finalCharacterSheet", "type": "CharacterSheetData", "attributes": ["?"] },
				{ "name": "createdAt", "type": "DateTime", "attributes": ["@default(now())"] },
				{ "name": "updatedAt", "type": "DateTime", "attributes": ["@updatedAt"] }
			]
		},
		"CharacterSheetData": {
			"fields": [
				{ "name": "id", "type": "String", "attributes": ["@id", "@default(uuid())"] },
				{ "name": "characterInProgressId", "type": "String", "attributes": ["@unique"] },
				{
					"name": "characterInProgress",
					"type": "CharacterInProgress",
					"attributes": ["@relation(fields: [characterInProgressId], references: [id])"]
				},
				{ "name": "finalName", "type": "String" },
				{ "name": "finalPlayerName", "type": "String", "attributes": ["?"] },
				{ "name": "finalLevel", "type": "Int", "attributes": ["@default(1)"] },
				{ "name": "finalMight", "type": "Int" },
				{ "name": "finalAgility", "type": "Int" },
				{ "name": "finalCharisma", "type": "Int" },
				{ "name": "finalIntelligence", "type": "Int" },
				{ "name": "finalPrimeModifierValue", "type": "Int" },
				{ "name": "finalPrimeModifierAttribute", "type": "String" },
				{ "name": "finalCombatMastery", "type": "Int", "attributes": ["@default(1)"] },
				{ "name": "finalSaveMasteryMight", "type": "Int" },
				{ "name": "finalSaveMasterityAgility", "type": "Int" },
				{ "name": "finalSaveMasteryCharisma", "type": "Int" },
				{ "name": "finalSaveMasteryIntelligence", "type": "Int" },
				{ "name": "finalHPMax", "type": "Int" },
				{ "name": "finalSPMax", "type": "Int" },
				{ "name": "finalMPMax", "type": "Int" },
				{ "name": "finalPD", "type": "Int" },
				{ "name": "finalAD", "type": "Int" },
				{ "name": "finalPDR", "type": "String", "attributes": ["?"] },
				{ "name": "finalEDR", "type": "String", "attributes": ["?"] },
				{ "name": "finalMDR", "type": "String", "attributes": ["?"] },
				{ "name": "finalSaveDC", "type": "Int" },
				{ "name": "finalDeathThreshold", "type": "Int" },
				{ "name": "finalMoveSpeed", "type": "Int" },
				{ "name": "finalJumpDistance", "type": "Int" },
				{ "name": "finalRestPoints", "type": "Int" },
				{ "name": "finalGritPoints", "type": "Int" },
				{ "name": "finalInitiativeBonus", "type": "Int" },
				{ "name": "skillsJson", "type": "String" },
				{ "name": "tradesJson", "type": "String" },
				{ "name": "languagesJson", "type": "String" },
				{ "name": "ancestry1Name", "type": "String", "attributes": ["?"] },
				{ "name": "ancestry2Name", "type": "String", "attributes": ["?"] },
				{ "name": "selectedTraitsJson", "type": "String" },
				{ "name": "className", "type": "String" },
				{ "name": "classFeaturesLvl1Json", "type": "String" },
				{ "name": "equipmentJson", "type": "String" },
				{ "name": "createdAt", "type": "DateTime", "attributes": ["@default(now())"] },
				{ "name": "updatedAt", "type": "DateTime", "attributes": ["@updatedAt"] }
			]
		}
	}
}
````

## File: prisma/schema.prisma
````
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Model to store the character creation progress
model CharacterInProgress {
  id                   String @id @default(uuid())
  // Stage A: Attributes
  attribute_might      Int    @default(-2)
  attribute_agility    Int    @default(-2)
  attribute_charisma   Int    @default(-2)
  attribute_intelligence Int  @default(-2)
  pointsSpent          Int    @default(0) // Points spent in point buy
  currentStep          Int    @default(1) // Current stage in the wizard (1 = Stage A, 2 = Stage B, etc.)

  // Core Stats
  level                Int    @default(1)
  combatMastery        Int    @default(1) // Calculated as half level rounded up

  // Stage B: Ancestry
  ancestry1Id          String? // ID of the first ancestry
  ancestry2Id          String? // ID of the second ancestry (for mixed ancestry)
  selectedTraitIds     String // JSON string of selected trait IDs
  ancestryPointsSpent  Int    @default(0) // Points spent on traits

  // Stage C: Class
  classId              String? // ID of the selected class
  selectedFeatureChoices String // JSON string of selected feature choice IDs/values

  // Save Masteries (DC20 p.22 - choose 2 attributes for Save Mastery)
  saveMasteryMight     Boolean @default(false)
  saveMasteryAgility   Boolean @default(false) 
  saveMasteryCharisma  Boolean @default(false)
  saveMasteryIntelligence Boolean @default(false)

  // Stage D: Skills (MVP Scope)
  // Will add skill selection fields here later

  // Stage E: Equipment (MVP Scope)
  // Will add equipment selection fields here later

  // Stage F: Details (MVP Scope)
  finalName            String?
  finalPlayerName      String?

  // Link to the final character sheet data (once creation is complete)
  finalCharacterSheet  CharacterSheetData?

  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
}

// Model to store the final calculated character sheet data
model CharacterSheetData {
  id                   String @id @default(uuid())
  characterInProgressId String @unique // Link back to the progress record
  characterInProgress  CharacterInProgress @relation(fields: [characterInProgressId], references: [id])

  // Final Calculated Stats (based on MVP mvp.md Section IV)
  finalName            String
  finalPlayerName      String?
  finalLevel           Int    @default(1)

  finalMight           Int
  finalAgility         Int
  finalCharisma        Int
  finalIntelligence    Int

  finalPrimeModifierValue Int
  finalPrimeModifierAttribute String

  finalCombatMastery   Int    @default(1)

  finalSaveMasteryMight Int
  finalSaveMasterityAgility Int
  finalSaveMasteryCharisma Int
  finalSaveMasteryIntelligence Int

  finalHPMax           Int
  finalSPMax           Int
  finalMPMax           Int

  finalPD              Int
  finalAD              Int

  finalPDR             String?
  finalEDR             String?
  finalMDR             String?

  finalSaveDC          Int
  finalDeathThreshold  Int
  finalMoveSpeed       Int
  finalJumpDistance    Int
  finalRestPoints      Int
  finalGritPoints      Int
  finalInitiativeBonus Int

  skillsJson           String // JSON string of skill data
  tradesJson           String // JSON string of trade data
  languagesJson        String // JSON string of language data

  ancestry1Name        String?
  ancestry2Name        String?
  selectedTraitsJson   String // JSON string of selected traits

  className            String
  classFeaturesLvl1Json String // JSON string of Lvl 1 class features

  equipmentJson        String // JSON string of equipment

  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
}
````

## File: src/lib/config/features.ts
````typescript
// Feature flags for enabling new systems during development
export const FEATURES = {
  NEW_EFFECT_SYSTEM: process.env.NODE_ENV === 'development' && process.env.VITE_NEW_EFFECTS === 'true'
};
````

## File: src/lib/hooks/useEnhancedCharacterCalculation.ts
````typescript
/**
 * Enhanced Character Calculation Hook
 * 
 * This hook provides real-time character calculations with detailed breakdowns
 * for tooltips, validation, and effect previews.
 */

import { useMemo, useCallback } from 'react';
import { useCharacter } from '../stores/characterContext';
import { 
  calculateCharacterWithBreakdowns, 
  convertToEnhancedBuildData 
} from '../services/enhancedCharacterCalculator';
import type { 
  CharacterCalculationHook, 
  EnhancedCalculationResult,
  EnhancedStatBreakdown,
  AttributeLimit,
  EffectPreview
} from '../types/effectSystem';

/**
 * Main hook for enhanced character calculations
 */
export function useEnhancedCharacterCalculation(): CharacterCalculationHook {
  const { state, dispatch } = useCharacter();
  
  // Convert context state to enhanced build data
  const buildData = useMemo(() => {
    return convertToEnhancedBuildData(state);
  }, [
    state.attribute_might,
    state.attribute_agility, 
    state.attribute_charisma,
    state.attribute_intelligence,
    state.classId,
    state.ancestry1Id,
    state.ancestry2Id,
    state.selectedTraitIds,
    state.selectedTraitChoices,
    state.selectedFeatureChoices,
    state.skillsJson,
    state.tradesJson,
    state.languagesJson,
    state.level,
    state.combatMastery
  ]);
  
  // Perform calculation with caching
  const calculationResult: EnhancedCalculationResult = useMemo(() => {
    // Check if we have valid cached results
    if (state.cachedEffectResults && state.cacheTimestamp) {
      const cacheAge = Date.now() - state.cacheTimestamp;
      if (cacheAge < 5000) { // Cache for 5 seconds
        try {
          const cached = JSON.parse(state.cachedEffectResults);
          return { ...cached, isFromCache: true };
        } catch (e) {
          // Cache is invalid, recalculate
        }
      }
    }
    
    // Calculate fresh results
    const result = calculateCharacterWithBreakdowns(buildData);
    
    // Cache the results (async to avoid blocking)
    setTimeout(() => {
      dispatch({
        type: 'UPDATE_STORE',
        updates: {
          cachedEffectResults: JSON.stringify(result),
          cacheTimestamp: result.cacheTimestamp
        }
      });
    }, 0);
    
    return result;
  }, [buildData, state.cachedEffectResults, state.cacheTimestamp, dispatch]);
  
  // Helper function to get stat breakdown
  const getStatBreakdown = useCallback((statName: string): EnhancedStatBreakdown | undefined => {
    return calculationResult.breakdowns[statName];
  }, [calculationResult.breakdowns]);
  
  // Helper function to get attribute limit
  const getAttributeLimit = useCallback((attributeId: string): AttributeLimit => {
    return calculationResult.validation.attributeLimits[attributeId] || {
      current: 0,
      base: 0,
      traitBonuses: 0,
      max: 3,
      exceeded: false,
      canIncrease: true,
      canDecrease: true
    };
  }, [calculationResult.validation.attributeLimits]);
  
  // Check if attribute can be increased
  const canIncreaseAttribute = useCallback((attributeId: string): boolean => {
    const limit = getAttributeLimit(attributeId);
    return limit.canIncrease;
  }, [getAttributeLimit]);
  
  // Check if attribute can be decreased  
  const canDecreaseAttribute = useCallback((attributeId: string): boolean => {
    const limit = getAttributeLimit(attributeId);
    return limit.canDecrease;
  }, [getAttributeLimit]);
  
  // Get effect preview for trait choices
  const getEffectPreview = useCallback((
    traitId: string, 
    effectIndex: number, 
    choice: string
  ): EffectPreview | undefined => {
    // Find the unresolved choice
    const unresolvedChoice = calculationResult.unresolvedChoices.find(
      uc => uc.traitId === traitId && uc.effectIndex === effectIndex
    );
    
    if (!unresolvedChoice) return undefined;
    
    const effect = unresolvedChoice.effect;
    
    if (effect.type === 'MODIFY_ATTRIBUTE') {
      const currentValue = (buildData as any)[`attribute_${choice}`] || 0;
      const newValue = currentValue + (effect.value as number);
      
      return {
        type: 'attribute',
        target: choice,
        currentValue,
        newValue,
        description: `${choice} will become ${newValue} (${currentValue} base + ${effect.value} trait)`
      };
    }
    
    if (effect.type === 'GRANT_SKILL_EXPERTISE') {
      return {
        type: 'skill',
        target: choice,
        currentValue: 'Normal mastery limit',
        newValue: 'Increased mastery limit',
        description: `${choice} mastery cap will increase by 1 and you gain 1 level`
      };
    }
    
    return undefined;
  }, [calculationResult.unresolvedChoices, buildData]);
  
  // Validate trait choice
  const validateTraitChoice = useCallback((
    traitId: string, 
    effectIndex: number, 
    choice: string
  ): { isValid: boolean; message?: string } => {
    // Find the effect being validated
    const unresolvedChoice = calculationResult.unresolvedChoices.find(
      uc => uc.traitId === traitId && uc.effectIndex === effectIndex
    );
    
    if (!unresolvedChoice) {
      return { isValid: false, message: 'Choice not found' };
    }
    
    const effect = unresolvedChoice.effect;
    
    if (effect.type === 'MODIFY_ATTRIBUTE') {
      const currentValue = (buildData as any)[`attribute_${choice}`] || 0;
      const newValue = currentValue + (effect.value as number);
      
      if (newValue > 3) {
        return { 
          isValid: false, 
          message: `Would exceed maximum attribute value of +3 (current: ${currentValue}, final: ${newValue})` 
        };
      }
      
      if (newValue < -2) {
        return { 
          isValid: false, 
          message: `Would go below minimum attribute value of -2 (current: ${currentValue}, final: ${newValue})` 
        };
      }
    }
    
    return { isValid: true };
  }, [calculationResult.unresolvedChoices, buildData]);
  
  // Validate attribute change
  const validateAttributeChange = useCallback((
    attributeId: string, 
    newValue: number
  ): { isValid: boolean; message?: string } => {
    const limit = getAttributeLimit(attributeId);
    const finalValue = newValue + limit.traitBonuses;
    
    if (finalValue > 3) {
      return { 
        isValid: false, 
        message: `Would exceed maximum total of +3 including trait bonuses (+${limit.traitBonuses})` 
      };
    }
    
    if (newValue < -2) {
      return { 
        isValid: false, 
        message: `Cannot go below minimum base value of -2` 
      };
    }
    
    return { isValid: true };
  }, [getAttributeLimit]);
  
  // Cache control functions
  const invalidateCache = useCallback(() => {
    dispatch({ type: 'INVALIDATE_CACHE' });
  }, [dispatch]);
  
  const refreshCalculation = useCallback(async () => {
    invalidateCache();
    // The calculation will automatically refresh on the next render
  }, [invalidateCache]);
  
  return {
    calculationResult,
    isLoading: false, // Could add loading states if calculations become expensive
    error: undefined,
    
    // Helper functions
    getStatBreakdown,
    getAttributeLimit,
    canIncreaseAttribute,
    canDecreaseAttribute,
    getEffectPreview,
    
    // Validation helpers
    validateTraitChoice,
    validateAttributeChange,
    
    // Cache control
    invalidateCache,
    refreshCalculation
  };
}

/**
 * Simplified hook for components that only need basic calculation results
 */
export function useCharacterStats() {
  const { calculationResult } = useEnhancedCharacterCalculation();
  return calculationResult.stats;
}

/**
 * Hook for components that need validation information
 */
export function useCharacterValidation() {
  const { calculationResult } = useEnhancedCharacterCalculation();
  return calculationResult.validation;
}

/**
 * Hook for components that need breakdown information for tooltips
 */
export function useStatBreakdowns() {
  const { calculationResult } = useEnhancedCharacterCalculation();
  return calculationResult.breakdowns;
}
````

## File: src/lib/rulesdata/_backup_original/ancestries.ts
````typescript
// src/lib/rulesdata/ancestries.ts

import type { IAncestry } from './types';

export const ancestriesData: IAncestry[] = [
	{
		id: 'human',
		name: 'Human',
		description:
			'Humans are the most common ancestry in the world, known for their adaptability and resilience.',
		defaultTraitIds: [
			'human_attribute_increase',
			'human_skill_expertise',
			'human_resolve',
			'human_undying'
		],
		expandedTraitIds: [
			'human_trade_expertise',
			'human_determination',
			'human_unbreakable',
			'human_attribute_decrease'
		]
	},
	{
		id: 'elf',
		name: 'Elf',
		description: 'Elves are graceful and long-lived beings with a deep connection to nature.',
		defaultTraitIds: ['elf_elven_will', 'elf_nimble', 'elf_agile_explorer', 'elf_discerning_sight'],
		expandedTraitIds: [
			'elf_quick_reactions',
			'elf_peerless_sight',
			'elf_climb_speed',
			'elf_speed_increase',
			'elf_trade_expertise_elf',
			'elf_plant_knowledge',
			'elf_brittle',
			'elf_frail',
			'elf_might_decrease'
		]
	},
	{
		id: 'dwarf',
		name: 'Dwarf',
		description:
			'Dwarves are a stout and resilient folk, known for their craftsmanship and deep connection to the earth.',
		defaultTraitIds: [
			'dwarf_tough',
			'dwarf_toxic_fortitude',
			'dwarf_physically_sturdy',
			'dwarf_iron_stomach'
		],
		expandedTraitIds: [
			'dwarf_thick_skinned',
			'dwarf_natural_combatant',
			'dwarf_stone_blood',
			'dwarf_minor_tremorsense',
			'dwarf_stubborn',
			'dwarf_trade_expertise',
			'dwarf_earthen_knowledge',
			'dwarf_charisma_attribute_decrease',
			'dwarf_short_legged'
		]
	},
	{
		id: 'halfling',
		name: 'Halfling',
		description:
			'Halflings are a small and nimble folk, known for their bravery and love of comfort.',
		defaultTraitIds: [
			'halfling_small_sized',
			'halfling_elusive',
			'halfling_bravery',
			'halfling_endurance',
			'halfling_deft_footwork',
			'halfling_beast_whisperer'
		],
		expandedTraitIds: [
			'halfling_beast_insight',
			'halfling_burst_of_bravery',
			'halfling_trade_expertise',
			'halfling_critter_knowledge',
			'halfling_brittle',
			'halfling_intelligence_attribute_decrease',
			'halfling_short_legged'
		]
	},
	{
		id: 'gnome',
		name: 'Gnome',
		description:
			'Gnomes are small and energetic folk, known for their inventiveness and connection to the feywild.',
		defaultTraitIds: [
			'gnome_small_sized',
			'gnome_escape_artist',
			'gnome_magnified_vision',
			'gnome_mental_clarity',
			'gnome_strong_minded',
			'gnome_predict_weather'
		],
		expandedTraitIds: [
			'gnome_mana_increase',
			'gnome_trapper',
			'gnome_lightning_insulation',
			'gnome_trade_expertise',
			'gnome_storm_knowledge',
			'gnome_agility_attribute_decrease',
			'gnome_short_legged'
		]
	},
	{
		id: 'orc',
		name: 'Orc',
		description:
			'Orcs are a strong and fierce folk, known for their martial prowess and intimidating presence.',
		defaultTraitIds: [
			'orc_cursed_mind',
			'orc_rush',
			'orc_brutal_strikes',
			'orc_tough',
			'orc_orcish_resolve',
			'orc_already_cursed'
		],
		expandedTraitIds: [
			'orc_intimidating_shout',
			'orc_dash',
			'orc_finishing_blow',
			'orc_imposing_presence',
			'orc_provocation',
			'orc_reckless'
		]
	},
	{
		id: 'dragonborn',
		name: 'Dragonborn',
		description:
			'Dragonborn are a proud and powerful folk, who trace their lineage back to dragons.',
		defaultTraitIds: [
			'dragonborn_darkvision',
			'dragonborn_draconic_resistance',
			'dragonborn_draconic_breath_weapon',
			'dragonborn_reptilian_superiority'
		],
		expandedTraitIds: [
			'dragonborn_mana_increase',
			'dragonborn_thick_skinned',
			'dragonborn_second_breath',
			'dragonborn_concussive_breath',
			'dragonborn_draconic_affinity',
			'dragonborn_dying_breath',
			'dragonborn_draconic_ward',
			'dragonborn_draconic_protection',
			'dragonborn_glide_speed',
			'dragonborn_guardians_bond'
		],
		origin: {
			// Draconic Origin
			prompt: 'Choose a Draconic Origin:',
			options: [
				'cold',
				'corrosion',
				'fire',
				'lightning',
				'poison',
				'sonic',
				'psychic',
				'radiant',
				'umbral'
			]
		}
	},
	{
		id: 'giantborn',
		name: 'Giantborn',
		description: 'Giantborn are a large and powerful folk, who trace their lineage back to giants.',
		defaultTraitIds: [
			'giantborn_tough',
			'giantborn_powerful_build',
			'giantborn_unstoppable',
			'giantborn_giants_resolve',
			'giantborn_unyielding_movement'
		],
		expandedTraitIds: [
			'giantborn_giants_fortitude',
			'giantborn_strong_body',
			'giantborn_mighty_hurl',
			'giantborn_titanic_toss',
			'giantborn_mighty_leap',
			'giantborn_brute',
			'giantborn_heavy_riser',
			'giantborn_clumsiness',
			'giantborn_intelligence_attribute_decrease'
		]
	},
	{
		id: 'angelborn',
		name: 'Angelborn',
		description: 'Angelborn are a celestial folk, known for their grace and divine connection.',
		defaultTraitIds: [
			'angelborn_radiant_resistance',
			'angelborn_celestial_magic',
			'angelborn_healing_touch',
			'angelborn_divine_glow'
		],
		expandedTraitIds: [
			'angelborn_mana_increase',
			'angelborn_celestial_clarity',
			'angelborn_angelic_insight',
			'angelborn_gift_of_the_angels',
			'angelborn_blinding_light',
			'angelborn_glide_speed',
			'angelborn_pacifist',
			'angelborn_umbral_weakness'
		],
		variantTraits: [
			// Fallen Angelborn
			{
				id: 'angelborn_fallen',
				name: 'Fallen',
				cost: 0,
				description: 'You can now spend your Ancestry Points on Fiendborn Traits.'
			}
		]
	},
	{
		id: 'fiendborn',
		name: 'Fiendborn',
		description: 'Fiendborn are a fiendish folk, known for their cunning and infernal connection.',
		defaultTraitIds: [
			'fiendborn_fiendish_resistance',
			'fiendborn_fiendish_magic',
			'fiendborn_darkvision',
			'fiendborn_lights_bane'
		],
		expandedTraitIds: [
			'fiendborn_mana_increase',
			'fiendborn_silver_tongued',
			'fiendborn_fiendish_aura',
			'fiendborn_superior_darkvision',
			'fiendborn_infernal_bravery',
			'fiendborn_intimidator',
			'fiendborn_charming_gaze',
			'fiendborn_glide_speed',
			'fiendborn_radiant_weakness',
			'fiendborn_divine_dampening'
		],
		origin: {
			// Fiendish Origin
			prompt: 'Choose a Fiendish Origin:',
			options: ['cold', 'corrosion', 'fire', 'poison', 'umbral']
		},
		variantTraits: [
			// Fiendborn Redemption
			{
				id: 'fiendborn_redeemed',
				name: 'Redeemed',
				cost: 0,
				description: 'You can now spend your Ancestry Points on Angelborn Traits.'
			}
		]
	},
	{
		id: 'beastborn',
		name: 'Beastborn',
		description: 'Beastborn are a diverse folk, who take on the characteristics of various beasts.',
		defaultTraitIds: [], // Beastborn has no Default Traits
		expandedTraitIds: [
			// Listed under Beast Traits sections in PDF
			// Senses
			'beastborn_darkvision',
			'beastborn_echolocation',
			'beastborn_keen_sense',
			'beastborn_sunlight_sensitivity',
			// Mobility
			'beastborn_quick_reactions',
			'beastborn_climb_speed',
			'beastborn_spider_climb',
			'beastborn_web_walk',
			'beastborn_water_breathing',
			'beastborn_swim_speed',
			'beastborn_speed_increase',
			'beastborn_sprint',
			'beastborn_charge',
			'beastborn_burrow_speed',
			// Jumping
			'beastborn_jumper',
			'beastborn_strong_jumper',
			// Flying
			'beastborn_glide_speed',
			'beastborn_limited_flight',
			'beastborn_full_flight',
			'beastborn_flyby',
			'beastborn_stealth_feathers',
			'beastborn_winged_arms',
			// Body
			'beastborn_tough',
			'beastborn_thick_skinned',
			'beastborn_powerful_build',
			'beastborn_long_limbed',
			'beastborn_secondary_arms',
			'beastborn_prehensile_appendage',
			'beastborn_hazardous_hide',
			'beastborn_natural_armor',
			'beastborn_hard_shell',
			'beastborn_shell_retreat',
			'beastborn_camouflage',
			'beastborn_prowler',
			'beastborn_cold_resistance',
			'beastborn_fire_resistance',
			'beastborn_short_legged',
			'beastborn_small_sized',
			'beastborn_reckless',
			// Natural Weapons
			'beastborn_natural_weapon',
			'beastborn_extended_natural_weapon',
			'beastborn_natural_projectile',
			'beastborn_natural_weapon_passive',
			'beastborn_rend',
			'beastborn_retractable_natural_weapon',
			'beastborn_venomous_natural_weapon',
			// Miscellaneous
			'beastborn_fast_reflexes',
			'beastborn_mimicry',
			'beastborn_intimidating_shout',
			'beastborn_toxic_fortitude',
			'beastborn_shoot_webs'
		],
		origin: {
			// Beastborn Origin
			prompt: 'Choose a type of Beast you are modeled after:',
			options: [] // Options are open-ended, based on GM/player choice
		}
	}
];
````

## File: src/lib/rulesdata/_backup_original/barbarian_features.json
````json
{
	"className": "Barbarian",
	"startingEquipment": {
		"weaponsOrShields": ["2 Weapons or Shields"],
		"rangedWeapon": "1 Ranged Weapon with 20 Ammo OR 3 Weapons with the Toss or Thrown Property",
		"armor": "1 set of Light Armor or Heavy Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"martialPath": {
		"combatTraining": {
			"weapons": ["Weapons"],
			"armor": ["All Armor"],
			"shields": ["All Shields"]
		},
		"maneuvers": {
			"learnsAllAttack": true,
			"additionalKnown": "Maneuvers Known column of the Barbarian Class Table"
		},
		"techniques": {
			"additionalKnown": "Techniques Known column of the Barbarian Class Table"
		},
		"staminaPoints": {
			"maximumIncreasesBy": "Stamina Points column of the Barbarian Class Table"
		},
		"staminaRegen": {
			"description": "Once per round, you can regain up to half your maximum SP when:",
			"conditions": [
				"You score a Heavy or Critical Hit against a creature.",
				"A Heavy or Critical Hit is scored against you."
			]
		}
	},
	"coreFeatures": [
		{
			"featureName": "Rage",
			"levelGained": 1,
			"description": "During Combat, you can spend 1 AP and 1 SP to enter a Rage for 1 minute. For the duration, you're subjected to the following effects:\n• You deal +1 damage on Melee Martial Attacks.\n• You have ADV on Might Saves.\n• Your PD decreases by 5.\n• You gain Resistance (Half) to Elemental and Physical damage.\nEnding Early: Your Rage ends early if you fall Unconscious, die, or you choose to end it for free on your turn."
		},
		{
			"featureName": "Berserker",
			"levelGained": 1,
			"description": "Your primal savagery grants you the following benefits:",
			"benefits": [
				{
					"name": "Charge",
					"description": "When you make a Melee Martial Attack on your turn, you can move up to 2 Spaces immediately before making the Attack."
				},
				{
					"name": "Berserker Defense",
					"description": "While you aren't wearing Armor you gain +2 AD."
				},
				{
					"name": "Fast Movement",
					"description": "You gain +1 Speed while not wearing Armor."
				},
				{
					"name": "Mighty Leap",
					"description": "You can use your Might instead of Agility to determine your Jump Distance and the damage you take from Falling."
				}
			]
		},
		{
			"featureName": "Shattering Force",
			"levelGained": 1,
			"description": "When you Hit a structure or mundane object with a Melee Attack, it's considered a Critical Hit.",
			"isFlavor": true
		},
		{
			"featureName": "Battlecry",
			"levelGained": 2,
			"description": "You can spend 1 AP and 1 SP to release a shout of your choice listed below. Until the start of your next turn, you and creatures of your choice within 10 Spaces that can see or hear you are subjected to the effects of your shout. A creature can only benefit from the same type of shout once at a time.",
			"choices": [
				{
					"prompt": "Choose a shout to release.",
					"count": 1,
					"options": [
						{
							"name": "Fortitude Shout",
							"description": "Each creature gains Resistance (1) against the next source of Physical or Elemental damage."
						},
						{
							"name": "Fury Shout",
							"description": "Each creature deals +1 damage on their next Attack against 1 target."
						},
						{
							"name": "Urgent Shout",
							"description": "Each creature gains +1 Speed until the start of your next turn."
						}
					]
				}
			]
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Elemental Fury",
			"features": [
				{
					"featureName": "Raging Elements",
					"levelGained": 3,
					"description": "You can surround yourself with the elements (such as fire, lightning, water, earth) or violent weather (such as blizzards, storms, volcanoes, or earthquakes). Choose 1 of the following damage types: Cold, Fire, Lightning, or Physical. The chosen Damage Type becomes your Elemental Rage damage. If you chose Physical damage, then each time you Rage you choose Bludgeoning, Piercing, or Slashing damage. While Raging, you gain a 2 Space Aura of elements that grants the following benefits:",
					"benefits": [
						{
							"name": "Erupting Elements",
							"description": "When a creature within your Aura deals damage to you, they immediately take 1 Elemental Rage damage."
						},
						{
							"name": "Elemental Blast",
							"description": "You can spend 1 AP and 1 SP to blast 1 or more creatures of your choice within your Aura. Make a Spell Check against the AD of each target within range. Attack Hit: A target takes 1 Elemental Rage damage. Single Target: If the Attack only targets 1 creature, it targets the creature's PD and they take 3 damage."
						}
					],
					"choices": [
						{
							"prompt": "Choose 1 of the following additional benefits for your Aura Type:",
							"count": 1,
							"options": [
								{
									"name": "Slowing Aura",
									"description": "Spaces within your Aura count as Difficult Terrain for creatures of your choice. Additionally, when a creature within your Aura fails a Save you force it to make, they're also Slowed until the end of their next turn."
								},
								{
									"name": "Splashing Aura",
									"description": "Once per Turn when you deal Elemental Rage damage to a creature, you can automatically deal 1 Elemental Rage damage to a creature within 1 Space of it."
								},
								{
									"name": "Stunning Aura",
									"description": "Once per Turn when a creature within your Aura fails a Save you force it to make, it also can't spend AP on Reactions until the start of its next turn."
								},
								{
									"name": "Pushing Aura",
									"description": "When you use your Elemental Blast, creatures affected must make a Physical Save. Failure: Each target is moved 2 Spaces toward or away from you (your choice)."
								}
							]
						}
					]
				},
				{
					"featureName": "Elemental Affinity (Flavor Feature)",
					"levelGained": 3,
					"description": "You are infused with the power of your Element and can make yourself heard over crackling infernos, howling blizzards, thundering storms, and rumbling earthquakes. You gain the following benefits:\n• You can make your voice boom up to 3 times louder than normal.\n• You can call upon non-harmful magic of your Elemental damage type to swirl around you in a visual display.\n• You have Resistance to Exhaustion due to environmental effects.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Spirit Guardian",
			"features": [
				{
					"featureName": "Ancestral Guardian",
					"levelGained": 3,
					"description": "Bestowed Protection: You learn 1 of the following Maneuvers: Parry, Protect, or Raise Shield. If you already know all 3, then you can learn any Maneuver of your choice instead.\nSpiritual Aura: While Raging, you gain Mystical Resistance (1) and a 5 Space Aura that grants the following benefits:\n• You can use the Shove Action on any creature within your Aura. When you do, the creature is pushed horizontally in a direction of your choice.\n• You can use the Parry, Protect, and Raise Shield Maneuvers on any creature within your Aura, provided you know the Maneuver. Using Raise Shield in this way doesn't require you to be wielding a Shield."
				},
				{
					"featureName": "Ancestral Knowledge (Flavor Feature)",
					"levelGained": 3,
					"description": "You have ADV on Checks to recall information about the history of your Ancestries (such as Human, Dwarf, or Elf). Additionally, once per Long Rest when you make a Trade or Language Check, you can choose to gain ADV on the Check as a spirit lends you its experience.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/barbarian_table.json
````json
{
	"className": "Barbarian",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 4,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/bard_features.json
````json
{
	"className": "Bard",
	"startingEquipment": {
		"weaponsOrShields": ["2 Weapons"],
		"kits": "1 Musical Instrument, Theatre Kit, or Art Kit (coming in future update)",
		"armor": "1 set of Light Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"spellcastingPath": {
		"combatTraining": {
			"armor": ["Light Armor"],
			"shields": ["Light Shields"]
		},
		"spellList": {
			"type": "schools",
			"specificSchools": ["Conjuration", "Divination", "Enchantment", "Illusion", "Restoration"],
			"spellTags": ["Charm"],
			"betaNote": "This means that the following Spells are what you would have access to:\nCantrips: Befriend, Close Wounds, Guidance, Light, Mage Hand, Message, Minor Illusion\n1 MP Spells: Bane, Bless, Command, Find Familiar, Fog Cloud, Grease, Heal, Psychic Fear, Silent Image, Sleep, Tethering Vines"
		},
		"cantrips": {
			"knownIncreasesBy": "Cantrips Known column of the Bard Class Table",
			"description": "Cantrips are Spells with the Cantrip Spell Tag."
		},
		"spells": {
			"knownIncreasesBy": "Spells Known column of the Bard Class Table",
			"description": "These can be Spells with or without the Cantrip Spell Tag."
		},
		"manaPoints": {
			"maximumIncreasesBy": "Mana Points column of the Bard Class Table"
		}
	},
	"coreFeatures": [
		{
			"featureName": "Font of Inspiration",
			"levelGained": 1,
			"description": "You are an ever present source of aid for your allies. You gain the following benefits:",
			"benefits": [
				{
					"name": "Ranged Help Attack",
					"description": "The range of your Help Action when aiding an Attack increases to 10 Spaces."
				},
				{
					"name": "Help Reaction",
					"description": "When a creature you can see makes a Check, you can take the Help Action as a Reaction to aid them with their Check, provided you're within range to do so."
				}
			]
		},
		{
			"featureName": "Remarkable Repertoire",
			"levelGained": 1,
			"description": "You've picked up a few tricks along your travels, granting you the following benefits:",
			"benefits": [
				{
					"name": "Jack of All Trades",
					"description": "You gain 2 Skill Points."
				},
				{
					"name": "Magical Secrets",
					"description": "You learn any 2 Spells of your choice from any Spell List."
				},
				{
					"name": "Magical Expression",
					"description": "You learn to express your art in a unique manner, granting you the ability to alter how you cast Spells. Choose the manner of your expression: Visual or Auditory.\n• Visual: Through acrobatics, dancing, juggling, painting, drawing, or miming, you can ignore the Verbal Components of a Spell you cast, but you must provide a Somatic Component instead.\n• Auditory: Through singing, playing music, poetry, comedy, or storytelling, you can ignore the Somatic Components of a Spell you cast, but you must provide a Verbal Component instead."
				}
			]
		},
		{
			"featureName": "Crowd Pleaser (Flavor Feature)",
			"levelGained": 1,
			"description": "When you spend at least 5 minutes performing an Artistry Trade for one or more people who are actively watching or listening to your performance, you can make an Artistry Trade Check Contested by the targets' Charisma Save. Success: You gain ADV on Charisma Checks against the target for 1 hour or until you become hostile. Creatures have ADV on the Save if they're considered hostile toward you.",
			"isFlavor": true
		},
		{
			"featureName": "Bardic Performance",
			"levelGained": 2,
			"description": "You can spend 1 AP and 1 MP to start a performance that grants you a 10 Space Aura for 1 minute. Choose 1 of the performances below. While creatures of your choice are within your Aura (and can see or hear you) they benefit from your performance. A creature can only benefit from one instance of each performance at a time. Changing Performances: Once on each of your turns, you can spend 1 AP to change your performance to a different one. Ending Early: The performance ends early if you become Incapacitated, you die, or choose to end it for free.",
			"choices": [
				{
					"prompt": "Choose a performance.",
					"count": 1,
					"options": [
						{
							"name": "Battle Ballad",
							"description": "The chosen creatures deal +1 damage against 1 target of their choice on an Attack they make once on each of their turns."
						},
						{
							"name": "Fast Tempo",
							"description": "The chosen creatures gain +1 Speed."
						},
						{
							"name": "Inspiring",
							"description": "The chosen creatures gain 1 Temp HP at the start of each of their turns."
						},
						{
							"name": "Emotional",
							"description": "Choose 1 of the following Conditions: Charmed, Frightened, Intimidated, or Taunted. The chosen creatures have Resistance against the chosen Condition. If a target is effected by the chosen Condition at the start of its turn, it can immediately attempt to end the Condition on itself by Repeating its Save."
						}
					]
				}
			]
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Eloquence",
			"features": [
				{
					"featureName": "Beguiling Presence",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Enthrall: You learn the Befriend Spell, and it doesn't end as a result of the target taking damage. If you already know it, you instead learn another spell with the Charm Tag.\n• Misleading Muse: When a creature within your Bardic Performance targets only you with an Attack, you can spend 1 AP as a Reaction to make a Spell Check against the target's Attack Check. Success: The creature becomes Charmed by you until the end of your next turn. It must target a different creature of its choice (other than itself) within range, or the Attack fails.\n• Mind Games: When the Charmed Condition ends on a creature Charmed by you, you can choose to immediately deal 1 Psychic damage to them."
				},
				{
					"featureName": "Eloquent Orator (Flavor Feature)",
					"levelGained": 3,
					"description": "Your speech is magically enchanted. Creatures can always understand the words you speak, provided they speak at least 1 Language.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Jester",
			"features": [
				{
					"featureName": "Antagonizing Act",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Heckle: Once per Round when a creature of your choice within your Bardic Performance fails a Save, they're Taunted by you on the next Attack they make before the end of their next turn.\n• Distraction: When a hostile creature within 10 Spaces of you makes an Attack, you can spend 1 AP as a Reaction to roll a Help Die and subtract the result from the target's Check.\n• Pratfall: When you fail a Save imposed by a hostile creature, you can grant a creature within your Bardic Performance ADV on a Check of their choice before the end of their next turn."
				},
				{
					"featureName": "Comedian (Flavor Feature)",
					"levelGained": 3,
					"description": "You have ADV on Checks to make other creatures laugh.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/bard_table.json
````json
{
	"className": "Bard",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 8,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 6,
			"cantripsKnown": 2,
			"spellsKnown": 3,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/champion_features.json
````json
{
	"className": "Champion",
	"startingEquipment": {
		"weaponsOrShields": ["3 Weapons or Shields"],
		"rangedWeapon": "1 Ranged Weapon with 20 Ammo OR 3 Weapons with the Toss or Thrown Property",
		"armor": "1 set of Light Armor or Heavy Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"martialPath": {
		"combatTraining": {
			"weapons": ["Weapons"],
			"armor": ["All Armors"],
			"shields": ["All Shields"]
		},
		"maneuvers": {
			"learnsAllAttack": true,
			"additionalKnown": "Maneuvers Known column of the Champion Class Table"
		},
		"techniques": {
			"additionalKnown": "Techniques Known column of the Champion Class Table"
		},
		"staminaPoints": {
			"maximumIncreasesBy": "Stamina Points column of the Champion Class Table"
		},
		"staminaRegen": {
			"description": "Once per round, you can regain up to half your maximum SP when you perform a Maneuver.",
			"conditions": []
		}
	},
	"coreFeatures": [
		{
			"featureName": "Master-at-Arms",
			"levelGained": 1,
			"description": "Your training in warfare has granted you the following benefits:",
			"benefits": [
				{
					"name": "Weapon Master",
					"description": "At the start of each of your turns, you can freely swap any Weapon you're currently wielding in each hand for any other Weapon without provoking Opportunity Attacks."
				},
				{
					"name": "Maneuver Master",
					"description": "You learn 2 Maneuvers of your choice."
				},
				{
					"name": "Technique Master",
					"description": "You learn 1 Technique of your choice. Once per Combat, when you perform a Technique you can reduce its SP cost by 1."
				}
			]
		},
		{
			"featureName": "Fighting Spirit",
			"levelGained": 1,
			"description": "You stand ready for Combat at any moment, granting you the following benefits:",
			"benefits": [
				{
					"name": "Combat Readiness",
					"description": "At the start of your first turn in Combat, you gain one of the following benefits:\n• Brace: You gain the benefits of the Dodge Action and ADV on the next Save you make until the end of Combat.\n• Advance: You gain the benefits of the Move Action and ADV on the next Physical Check you make until the end of Combat."
				},
				{
					"name": "Second Wind",
					"description": "Once per Combat when you start your turn Bloodied, you can regain 2 HP and 1 SP."
				}
			]
		},
		{
			"featureName": "Know Your Enemy (Flavor Feature)",
			"levelGained": 1,
			"description": "You can spend 1 minute observing or interacting with a creature out of Combat (or spend 1 AP in Combat) to learn information about its physical capabilities compared to your own. Choose one of the following stats of the creature to assess: Might, Agility, PD, AD, and HP. Make a DC 10 Knowledge or Insight Check (your choice). Success: You learn if the chosen stat is higher, lower, or the same as yours.",
			"isFlavor": true
		},
		{
			"featureName": "Adaptive Tactics",
			"levelGained": 2,
			"description": "When you roll for Initiative, and at the end of each of your turns, you gain a d8 Tactical Die if you don't already have one. You can spend a Tactical Die to gain one of the following Tactics:",
			"benefits": [
				{
					"name": "Assault",
					"description": "When you make a Martial Attack, you can add the die to the Attack's result."
				},
				{
					"name": "Deflect",
					"description": "When you are Attacked, you can subtract the die from the Attack's result."
				}
			]
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Hero",
			"features": [
				{
					"featureName": "Hero's Resolve",
					"levelGained": 3,
					"description": "Your warrior spirit refuses to yield in battle. You gain the following benefits:\n• Adrenaline Boost: When you use your Second Wind, you gain a +5 bonus to Attack Checks you make until the end of your turn.\n• Cut Through: Your Martial Attacks that score Heavy Hits ignore the target's Physical damage Resistances.\n• Unyielding Spirit: While Bloodied, you gain 1 Temp HP at the start of each of your turns."
				},
				{
					"featureName": "Adventuring Hero (Flavor Feature)",
					"levelGained": 3,
					"description": "You ignore the penalties of Forced March and being Encumbered (but not Heavily Encumbered).",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Sentinel",
			"features": [
				{
					"featureName": "Stalwart Protector",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Steadfast Defender: You can use your Deflect Tactic against any Attack that targets a creature within your Melee Range.\n• Defensive Bash: When you use a Defensive Maneuver as a Reaction to an Attack from a creature within 1 Space of you, the attacker must make a Physical Save against your Attack Check. Save Failure: The target is pushed 1 Space away or Taunted by you until the end of its next turn (your choice).\n• Not on my Watch: Creatures Taunted by you deal 1 less damage to targets within 1 Space of you."
				},
				{
					"featureName": "Vigilant Watcher (Flavor Feature)",
					"levelGained": 3,
					"description": "During a Long Rest, if you spend both 4 hour periods doing Light Activity, you have ADV on the Might Save you make to avoid gaining Exhaustion. Additionally, the Save DC doesn't increase on a Failure.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/champion_table.json
````json
{
	"className": "Champion",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 4,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/CLASS_FEATURES_SCHEMA.json
````json
{
	"$schema": "http://json-schema.org/draft-07/schema#",
	"title": "DC20 Class And Subclass Features",
	"description": "A schema for defining all features for a single class, including its core features and all of its subclass options. This structure provides full context for how features relate to each other and when they are acquired.",
	"type": "object",
	"properties": {
		"className": {
			"type": "string",
			"description": "The name of the class this file defines."
		},
		"coreFeatures": {
			"type": "array",
			"description": "A list of all features available to the base class, regardless of subclass choice.",
			"items": {
				"$ref": "#/definitions/feature"
			}
		},
		"subclasses": {
			"type": "array",
			"description": "A list of all available subclass options for this class.",
			"items": {
				"type": "object",
				"properties": {
					"subclassName": {
						"type": "string",
						"description": "The name of the subclass."
					},
					"description": {
						"type": "string",
						"description": "A brief, optional description of the subclass."
					},
					"features": {
						"type": "array",
						"description": "A list of all features specific to this subclass.",
						"items": {
							"$ref": "#/definitions/feature"
						}
					}
				},
				"required": ["subclassName", "features"]
			}
		}
	},
	"required": ["className", "coreFeatures", "subclasses"],
	"definitions": {
		"feature": {
			"type": "object",
			"description": "A reusable definition for a single feature's mechanics.",
			"properties": {
				"featureName": {
					"type": "string",
					"description": "The name of the class feature."
				},
				"levelGained": {
					"type": "integer",
					"description": "The character level at which this feature is acquired. This provides essential context that the high-level progression table lacks."
				},
				"description": {
					"type": "string",
					"description": "The main text explaining what the feature does, including its activation, cost, duration, and general effects."
				},
				"isFlavor": {
					"type": "boolean",
					"description": "True if this is a non-mechanical flavor feature.",
					"default": false
				},
				"choices": {
					"type": "array",
					"description": "A list of choices the player must make for this feature.",
					"items": {
						"type": "object",
						"properties": {
							"prompt": {
								"type": "string",
								"description": "The instruction for the player."
							},
							"count": {
								"type": "integer",
								"description": "The number of options to choose."
							},
							"options": {
								"type": "array",
								"items": {
									"type": "object",
									"properties": {
										"name": {
											"type": "string"
										},
										"description": {
											"type": "string"
										}
									},
									"required": ["name", "description"]
								}
							}
						},
						"required": ["prompt", "count"]
					}
				},
				"benefits": {
					"type": "array",
					"description": "A list of distinct, named benefits or effects that are part of this feature.",
					"items": {
						"type": "object",
						"properties": {
							"name": {
								"type": "string"
							},
							"description": {
								"type": "string"
							},
							"effects": {
								"type": "array",
								"description": "A list of formal, machine-readable effects that this benefit provides.",
								"items": {
									"type": "object",
									"properties": {
										"type": {
											"type": "string",
											"enum": ["MODIFIER", "GRANT_ABILITY", "GRANT_PASSIVE"]
										},
										"target": {
											"type": "string",
											"description": "The path to the character sheet value to be modified (e.g., 'defenses.ad')."
										},
										"value": {
											"type": "integer",
											"description": "The value of the modification."
										},
										"condition": {
											"type": "string",
											"description": "A formal condition under which this effect applies (e.g., 'character.armor.type == null')."
										}
									},
									"required": ["type", "target", "value"]
								}
							}
						},
						"required": ["name", "description"]
					}
				}
			},
			"required": ["featureName", "levelGained", "description"]
		}
	}
}
````

## File: src/lib/rulesdata/_backup_original/class-features.loader.ts
````typescript
/**
 * @file class-features.loader.ts
 * @description Loader for the new class features JSON structure
 */

import { SpellSchool, SpellList } from '../spells-data/types/spell.types';

// Define interfaces for the new class features structure
export interface ClassFeatureChoice {
	prompt: string;
	count: number;
	options?: {
		name: string;
		description: string;
	}[];
}

export interface ClassFeatureBenefit {
	name: string;
	description: string;
	effects?: {
		type: string;
		target?: string;
		value?: any;
		condition?: string;
	}[];
}

export interface ClassFeature {
	featureName: string;
	levelGained: number;
	description: string;
	isFlavor?: boolean;
	choices?: ClassFeatureChoice[];
	benefits?: ClassFeatureBenefit[];
}

export interface ClassSubclass {
	subclassName: string;
	description?: string;
	features: ClassFeature[];
}

export interface ClassDefinition {
	className: string;
	startingEquipment?: {
		weaponsOrShields?: string[];
		rangedWeapon?: string;
		alternativeWeapons?: string;
		armor?: string;
		packs?: string;
	};
	martialPath?: {
		combatTraining?: {
			weapons?: string[];
			armor?: string[];
			shields?: string[];
		};
		maneuvers?: {
			learnsAllAttack?: boolean;
			additionalKnown?: string;
		};
		techniques?: {
			additionalKnown?: string;
		};
		staminaPoints?: {
			maximumIncreasesBy?: string;
		};
		staminaRegen?: {
			description?: string;
			conditions?: string[];
		};
	};
	spellcastingPath?: {
		combatTraining?: {
			armor?: string[];
			shields?: string[];
		};
		spellList?: {
			type?: 'specific' | 'schools' | 'any' | 'all_schools';
			listName?: string;
			specificSchools?: SpellSchool[];
			spellTags?: string[];
			schoolCount?: number; // For classes that choose X schools
			description?: string;
			betaNote?: string;
		};
		cantrips?: {
			knownIncreasesBy?: string;
			description?: string;
		};
		spells?: {
			knownIncreasesBy?: string;
			description?: string;
		};
		manaPoints?: {
			maximumIncreasesBy?: string;
		};
	};
	coreFeatures: ClassFeature[];
	subclasses: ClassSubclass[];
}

// Use Vite's import.meta.glob to import all the class feature JSON files
const classFeatureModules = import.meta.glob('../classes/*_features.json', { eager: true });

// Extract the default export (the class features object) from each module
const rawClassFeatures = Object.values(classFeatureModules).map((module: any) => module.default);

// Export the class features data
export const classFeaturesData: ClassDefinition[] = rawClassFeatures;

// Helper function to get available spell schools for a class
export function getAvailableSpellSchools(classData: ClassDefinition): SpellSchool[] {
	const spellList = classData.spellcastingPath?.spellList;
	if (!spellList) return [];

	switch (spellList.type) {
		case 'all_schools':
			// Return all schools from the enum
			return Object.values(SpellSchool);
		case 'schools':
			// Return specific schools
			return spellList.specificSchools || [];
		default:
			return [];
	}
}

// Helper function to find a class by name
export function findClassByName(className: string): ClassDefinition | undefined {
	return classFeaturesData.find((cls) => cls.className === className);
}

// Helper function to find a specific feature in a class
export function findFeatureInClass(
	className: string,
	featureName: string
): ClassFeature | undefined {
	const classData = findClassByName(className);
	if (!classData) return undefined;

	return classData.coreFeatures.find((feature) => feature.featureName === featureName);
}

// Helper function to find a choice option in a feature
export function findChoiceOption(
	className: string,
	featureName: string,
	choiceIndex: number,
	optionName: string
): { name: string; description: string } | undefined {
	const feature = findFeatureInClass(className, featureName);
	if (!feature?.choices?.[choiceIndex]?.options) return undefined;

	return feature.choices[choiceIndex].options.find((option) => option.name === optionName);
}

// Generic function to extract class-specific display information
export function getClassSpecificInfo(
	className: string,
	selectedFeatureChoices?: string
): { displayInfo: { label: string; value: string }[] } {
	const displayInfo: { label: string; value: string }[] = [];

	if (!selectedFeatureChoices) {
		return { displayInfo };
	}

	try {
		const selectedChoices: { [key: string]: string } = JSON.parse(selectedFeatureChoices);
		const classData = findClassByName(className);

		if (!classData) {
			return { displayInfo };
		}

		// Process each core feature that has choices
		classData.coreFeatures.forEach((feature) => {
			if (feature.choices) {
				feature.choices.forEach((choice, choiceIndex) => {
					// Create a mapping for legacy choice IDs based on class and feature
					const legacyChoiceId = getLegacyChoiceId(className, feature.featureName, choiceIndex);
					const selectedValue = selectedChoices[legacyChoiceId];

					if (selectedValue && choice.options) {
						if (choice.count > 1) {
							// Handle multiple selections
							try {
								const selectedValues: string[] = JSON.parse(selectedValue);
								if (selectedValues.length > 0) {
									const label = getDisplayLabel(className, feature.featureName, choiceIndex);
									displayInfo.push({
										label,
										value: selectedValues.join(', ')
									});
								}
							} catch (error) {
								console.error('Error parsing multiple selection:', error);
							}
						} else {
							// Handle single selections
							const label = getDisplayLabel(className, feature.featureName, choiceIndex);
							displayInfo.push({
								label,
								value: selectedValue.charAt(0).toUpperCase() + selectedValue.slice(1)
							});
						}
					}
				});
			}

			// Also check for benefits that might have user choices (like Divine Damage)
			if (feature.benefits) {
				feature.benefits.forEach((benefit) => {
					const legacyBenefitId = getLegacyBenefitId(className, feature.featureName, benefit.name);
					const selectedValue = selectedChoices[legacyBenefitId];

					if (selectedValue) {
						displayInfo.push({
							label: benefit.name,
							value: selectedValue.charAt(0).toUpperCase() + selectedValue.slice(1)
						});
					}
				});
			}
		});
	} catch (error) {
		console.error('Error parsing selected feature choices:', error);
	}

	return { displayInfo };
}

// Helper function to map class/feature combinations to legacy choice IDs
export function getLegacyChoiceId(
	className: string,
	featureName: string,
	choiceIndex: number
): string {
	// Generic mapping: className_featureName_choiceIndex
	return `${className.toLowerCase()}_${featureName.toLowerCase().replace(/\s+/g, '_')}_${choiceIndex}`;
}

// Helper function to map class/feature combinations to legacy benefit IDs
export function getLegacyBenefitId(
	className: string,
	featureName: string,
	benefitName: string
): string {
	// Generic mapping: className_featureName_benefitName
	return `${className.toLowerCase()}_${featureName.toLowerCase().replace(/\s+/g, '_')}_${benefitName.toLowerCase().replace(/\s+/g, '_')}`;
}

// Helper function to get display labels for different choice types
export function getDisplayLabel(
	_className: string,
	featureName: string,
	_choiceIndex: number
): string {
	// Generic: just use the feature name as the label
	return featureName;
}
````

## File: src/lib/rulesdata/_backup_original/class.loader.ts
````typescript
import { classesDataSchema, type IClassDefinition } from '../schemas/class.schema';

// Use Vite's import.meta.glob to import only the class table JSON files.
// The `eager: true` option imports the modules directly, so they are available synchronously.
const tableModules = import.meta.glob('../classes/*_table.json', { eager: true });

// Extract the default export (the class object) from each module.
const tableData = Object.values(tableModules).map((module: any) => module.default);

// Create progression data structure from table files (stats only, no features)
const compatibleData = tableData.map((classTable: any) => {
	const className = classTable.className;

	return {
		id: className.toLowerCase(),
		name: className,
		description: `${className} class progression table`,
		baseHpContribution: classTable.levelProgression?.[0]?.healthPoints || 0,
		startingSP: classTable.levelProgression?.[0]?.staminaPoints || 0,
		startingMP: classTable.levelProgression?.[0]?.manaPoints || 0,
		// Add other required fields with default values
		skillPointGrantLvl1: classTable.levelProgression?.[0]?.skillPoints || 0,
		tradePointGrantLvl1: classTable.levelProgression?.[0]?.tradePoints || 0,
		combatTraining: [],
		maneuversKnownLvl1: classTable.levelProgression?.[0]?.maneuversKnown || 0,
		techniquesKnownLvl1: classTable.levelProgression?.[0]?.techniquesKnown || 0,
		saveDCBase: 8,
		deathThresholdBase: 10,
		moveSpeedBase: 5, // DC20: Base movement speed is 5 spaces
		restPointsBase: 4,
		gritPointsBase: 2,
		initiativeBonusBase: 0,
		cantripsKnownLvl1: classTable.levelProgression?.[0]?.cantripsKnown || 0,
		spellsKnownLvl1: classTable.levelProgression?.[0]?.spellsKnown || 0,
		// Store the full level progression for future level gaining
		levelProgression: classTable.levelProgression,
		// Empty arrays for features - these should be handled by class-features.loader.ts
		level1Features: [],
		featureChoicesLvl1: []
	};
});

// Validate the combined data against the Zod schema.
// The parse method will throw a detailed error if validation fails.
const validatedData = classesDataSchema.parse(compatibleData);

// Export the validated data with the correct type.
export const classesData: IClassDefinition[] = validatedData;
````

## File: src/lib/rulesdata/_backup_original/cleric_features.json
````json
{
	"className": "Cleric",
	"startingEquipment": {
		"weaponsOrShields": [
			"2 Weapons or 1 Light Shield (or Heavy Shield if you choose the Templar Holy Order, see below)"
		],
		"armor": "1 set of Light Armor (or Heavy Armor if you choose the Templar Holy Order, see below)",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"spellcastingPath": {
		"combatTraining": {
			"armor": ["Light Armor"],
			"shields": ["Light Shields"]
		},
		"spellList": {
			"type": "specific",
			"listName": "Divine Spell List",
			"betaNote": "You get access to the \"Premade List\" of Holy & Restoration. This is the only Premade List that you have to choose from until the Spell List Update."
		},
		"cantrips": {
			"knownIncreasesBy": "Cantrips Known column of the Cleric Class Table",
			"description": "Cantrips are Spells with the Cantrip Spell Tag."
		},
		"spells": {
			"knownIncreasesBy": "Spells Known column of the Cleric Class Table",
			"description": "These can be Spells with or without the Cantrip Spell Tag."
		},
		"manaPoints": {
			"maximumIncreasesBy": "Mana Points column of the Cleric Class Table"
		}
	},
	"coreFeatures": [
		{
			"featureName": "Cleric Order",
			"levelGained": 1,
			"description": "Your connection to your deity grants you the following benefits:",
			"benefits": [
				{
					"name": "Divine Damage",
					"description": "Choose an Elemental or Mystical damage type. The chosen damage type becomes your Divine Damage which is used for some Cleric Features."
				},
				{
					"name": "Divine Domain",
					"description": "You gain the benefits of 2 Divine Domains of your choice."
				}
			]
		},
		{
			"featureName": "Knowledge",
			"levelGained": 1,
			"description": "Your Mastery Limit increases by 1 for all Knowledge Trades. A Trade can only benefit from 1 Feature that increases its Mastery Limit at a time. Additionally, you gain 2 Skill Points."
		},
		{
			"featureName": "Divine Domains",
			"levelGained": 1,
			"description": "The Divine Domains available to choose from with the Cleric Order feature.",
			"choices": [
				{
					"prompt": "Choose 2 Divine Domains.",
					"count": 2,
					"options": [
						{
							"name": "Magic",
							"description": "You gain the benefits listed below. You can choose this Divine Domain multiple times.\n• Your maximum MP increases by 1.\n• Choose a Spell Tag (such as Fire, Holy, or Undeath). You learn 1 Spell with the chosen Spell Tag, and when you learn a new Spell you can choose any Spell that also has the chosen Spell Tag."
						},
						{
							"name": "Divine Damage Expansion",
							"description": "When you deal damage with a Spell you can convert the damage to your Divine Damage type. Additionally, you gain Resistance (1) to your Divine Damage type."
						},
						{
							"name": "Life",
							"description": "When you produce an MP Effect that restores HP to at least 1 creature, you can restore 1 HP to 1 creature of your choice within 1 Space of you (including yourself)."
						},
						{
							"name": "Death",
							"description": "Enemy creatures within 10 Spaces of you take an additional 1 damage from Attacks while they're Well-Bloodied."
						},
						{
							"name": "Grave",
							"description": "Allied creatures within 10 Spaces of you take 1 less damage from Attacks while they're Well-Bloodied."
						},
						{
							"name": "Light",
							"description": "When you produce an MP Effect that targets at least 1 creature, you can force 1 target of your choice to make a Might or Charisma Save (their choice). Failure: Until the end of their next turn, they shed a 1 Space Aura of Bright Light and are Hindered on their next Attack."
						},
						{
							"name": "Dark",
							"description": "Your mastery over shadows grants you supernatural sight and the ability to hide yourself from other creatures. You gain the following benefits:\n• You gain 10 Space Darkvision. If you already have Darkvision it increases by 5 Spaces.\n• While in an area of Dim Light, you can take the Hide Action to Hide from creatures that can see you. On a Success, you remain Hidden until you move or the area you're in becomes Bright Light."
						},
						{
							"name": "War",
							"description": "You gain Combat Training with Weapons and access to Attack Maneuvers."
						},
						{
							"name": "Peace",
							"description": "You gain Combat Training with Heavy Armor and Heavy Shields and learn 1 Defensive Maneuver of your choice."
						},
						{
							"name": "Order",
							"description": "Once per turn, when a creature you can see within 10 Spaces of you makes a Check, you can spend 1 AP as a Reaction to remove all instances of ADV and DisADV from that Check."
						},
						{
							"name": "Chaos",
							"description": "When you make a Spell Check you can choose to give yourself ADV on it, but you must also roll on the Wild Magic Table. You can use this Feature once per Long Rest, and regain the ability to use it again when you roll for Initiative."
						},
						{
							"name": "Divination",
							"description": "You gain the following benefits:\n• You can't be Flanked.\n• When you spend MP, you gain the ability to see Invisible creatures and objects until the start of your next turn."
						},
						{
							"name": "Trickery",
							"description": "When you produce an MP Effect that targets at least 1 creature, you can choose 1 of the targets and create an illusory duplicate of it that lasts until the start of your next turn. The next Attack made against the target has DisADV, and causes the illusory duplicate to disappear."
						},
						{
							"name": "Ancestral",
							"description": "You get 2 Ancestry Points that you can spend on Traits from any Ancestry."
						}
					]
				}
			]
		},
		{
			"featureName": "Divine Blessing",
			"levelGained": 1,
			"description": "You can spend 1 AP to say a prayer and petition your deity for their divine blessing. Choose 1 of the blessings listed below. Each blessing has a listed MP cost that you must spend to gain the blessing. Once during the next minute, you can apply the blessing to a Spell you cast. If your Spell targets more than 1 creature, the blessing only applies to 1 target of your choice.",
			"choices": [
				{
					"prompt": "Choose a blessing.",
					"count": 1,
					"options": [
						{
							"name": "Destruction (1 MP)",
							"description": "The target takes 3 Divine damage, provided that the result of your Spell Check is equal to or higher than the target's AD. If the Spell doesn't normally require a Spell Check, then you must make one when you apply this blessing."
						},
						{
							"name": "Guidance (1 MP)",
							"description": "The target gains a d8 Help Die that they can add to 1 Check of their choice they make within the next minute."
						},
						{
							"name": "Restoration (1 MP)",
							"description": "The target regains 3 HP."
						}
					]
				}
			]
		},
		{
			"featureName": "Divine Omen (Flavor Feature)",
			"levelGained": 1,
			"description": "Once per Long Rest, you can spend 10 minutes to commune with your Deity. You can ask them 1 question, which must be posed in a way that could be answered with a yes or no. The deity responds to the best of their knowledge and intentions in one of the following responses: Yes, No, or Unclear. A response of Unclear could come from the deity not knowing the answer, wanting to purposefully keep it a secret, the question being phrased in a confusing or complicated way, or there not being a simple answer to the question.",
			"isFlavor": true
		},
		{
			"featureName": "Channel Divinity",
			"levelGained": 2,
			"description": "You gain the ability to channel the direct power of your deity. When you use this Feature, choose 1 of the options below. You can use this Feature once per Short Rest.",
			"choices": [
				{
					"prompt": "Choose a Channel Divinity option.",
					"count": 1,
					"options": [
						{
							"name": "Divine Rebuke",
							"description": "You can spend 2 AP to censure all creatures of your choice who can see or hear you within 5 Spaces. Make a Spell Check against each target's AD, and each target makes a Repeated Mental Save against your Save DC. Attack Hit: The target takes Divine Damage equal to your Prime Modifier. Save Failure: The target becomes Intimidated by you for 1 minute or until it takes damage again."
						},
						{
							"name": "Lesser Divine Intervention",
							"description": "You can spend 2 AP to call on your deity to intervene on your behalf when your need is great to replenish you and your allies. Make a DC 15 Spell Check. Success: You gain a pool of healing equal to your Prime Modifier that you can use to restore HP to any number of creatures within 5 Spaces, distributing the HP among them. Additionally, you regain 1 MP. Success (each 5): Increase the amount healed by an amount equal to your Prime. Failure: You can only gain a pool of healing equal to your Prime Modifier."
						}
					]
				}
			]
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Inquisitor",
			"features": [
				{
					"featureName": "Vanquish Heresy",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Iron Resolve: You have Resistance to the Charmed, Intimidated, and Taunted Conditions.\n• Rebuke Heretics: Creatures Intimidated by your Divine Rebuke (Channel Divinity) don't stop being Intimidated if they take damage.\nYou gain the following Divine Blessing:\n• Chastise: (1 MP) The target is branded as a heretic for 1 minute. You have ADV on Insight and Intimidation Checks made against the creature and you deal +1 Divine Damage to it with your Attacks."
				},
				{
					"featureName": "Divine Interrogator (Flavor Feature)",
					"levelGained": 3,
					"description": "Once per Long Rest, you can interrogate a creature by asking it a Yes or No question. It makes a Charisma Save against your Save DC. Failure: It can't tell a lie to the question that you asked it. It can choose not to answer at all, but if it does answer it must be either, “Yes,” “No,” or “I don't know.”",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Priest",
			"features": [
				{
					"featureName": "Sanctification",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Divine Barrier: When you spend MP to heal a creature beyond their HP maximum, they gain an amount of Temp HP equal to the remaining healing. Any Temp HP gained in this way expires after 1 minute.\n• Spare the Dying: When you spend MP to heal a creature on Death's Door, the HP restored is increased by an amount equal to your Prime Modifier.\nYou gain a new Channel Divinity option:\nHand of Salvation: When another creature that you can see within 5 Spaces would be Hit by an Attack, you can spend 2 AP as a Reaction to magically pull the creature to an unoccupied Space within 1 Space of you, provided the creature is willing. The Attack misses and has no effect, and the creature is immune to all damage during this movement."
				},
				{
					"featureName": "All That Ails (Flavor Feature)",
					"levelGained": 3,
					"description": "You have an understanding and divine guidance when attempting to learn what is ailing a creature. You have ADV on Checks made to identify or determine the effects of a Disease, Poison, or Curse affecting a creature.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/cleric_table.json
````json
{
	"className": "Cleric",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 8,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 6,
			"cantripsKnown": 2,
			"spellsKnown": 3,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/commander_features.json
````json
{
	"className": "Commander",
	"startingEquipment": {
		"weaponsOrShields": ["2 Weapons or Shields"],
		"rangedWeapon": "1 Ranged Weapon with 20 Ammo OR 3 Weapons with the Toss or Thrown Property",
		"armor": "1 set of Light Armor or Heavy Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"martialPath": {
		"combatTraining": {
			"weapons": ["Weapons"],
			"armor": ["All Armor"],
			"shields": ["All Shields"]
		},
		"maneuvers": {
			"learnsAllAttack": true,
			"additionalKnown": "Maneuvers Known column of the Commander Class Table"
		},
		"techniques": {
			"additionalKnown": "Techniques Known column of the Commander Class Table"
		},
		"staminaPoints": {
			"maximumIncreasesBy": "Stamina Points column of the Commander Class Table"
		},
		"staminaRegen": {
			"description": "Once per round, you can regain up to half your maximum SP when you grant a creature a Help Die.",
			"conditions": []
		}
	},
	"coreFeatures": [
		{
			"featureName": "Inspiring Presence",
			"levelGained": 1,
			"description": "Whenever you spend SP while in Combat, you can restore an amount of HP equal to the SP spent. Choose any creatures within 5 Spaces that can see or hear you, and divide the HP among them."
		},
		{
			"featureName": "Commander's Call",
			"levelGained": 1,
			"description": "You can spend 1 AP and 1 SP to command a willing creature that you can see within 5 Spaces that can also see or hear you. The chosen creature can immediately take 1 of the following Actions of your choice as a Reaction for free. You can only use each of the following commands once on each of your turns.",
			"benefits": [
				{
					"name": "Attack",
					"description": "The creature makes an Attack with ADV. They can't spend any resources on this Attack, such as AP, SP, or MP."
				},
				{
					"name": "Dodge",
					"description": "The creature takes the Full Dodge Action."
				},
				{
					"name": "Move",
					"description": "The creature moves up to their Speed without provoking Opportunity Attacks."
				}
			]
		},
		{
			"featureName": "Natural Leader (Flavor Feature)",
			"levelGained": 1,
			"description": "You have ADV on Checks made to convince creatures that you are an authority figure. Additionally, you have ADV on the first Charisma Check made to interact with non-hostile members of military groups (such as soldiers, guards, etc.).",
			"isFlavor": true
		},
		{
			"featureName": "Commanding Aura",
			"levelGained": 2,
			"description": "You're surrounded by a 5 Space Aura. You can target any creature within your Aura to grant one of the following effects below, provided the target can see or hear you.",
			"benefits": [
				{
					"name": "Bolster (1 AP)",
					"description": "You take the Help Action to aid the target with an Attack. You can also do so as a Reaction whenever a valid target makes an Attack."
				},
				{
					"name": "Rally (1 AP)",
					"description": "You grant creatures of your choice (including yourself) 1 Temp HP."
				},
				{
					"name": "Reinforce (1 AP)",
					"description": "When a creature in your aura is targeted by an Attack, you can impose DisADV on the Attack as a Reaction."
				}
			]
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Crusader",
			"features": [
				{
					"featureName": "Virtuous Vanguard",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Aura of Courage: While within your Commanding Aura, creatures of your choice have Resistance to Frightened and Intimidated.\n• Protective Orders: When a creature gains the benefits of your Commander's Call, they also gain Resistance (1) against the next damage they take before the start of your next turn.\n• Restoring Rally: When you grant a Bloodied creature Temp HP in Combat using Rally (Commanding Aura), they regain that amount of HP instead."
				},
				{
					"featureName": "Gallant Hero (Flavor Feature)",
					"levelGained": 3,
					"description": "Your presence is a symbol of hope and safety to those around you. You have ADV on Checks to convince creatures not to be afraid.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Warlord",
			"features": [
				{
					"featureName": "Offensive Tactics",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Morale Breaker: Once per Combat when you use your Commander's Call, you can use the Intimidate Action for free against a creature of your choice within 15 Spaces.\n• Battlefield Tactics: Allies within your Commanding Aura deal +1 damage on their first Melee Attack on each of their turns against a creature they're Flanking.\nYou gain a new Commanding Aura option:\n• Priority Target: (1 AP + 1 SP) Choose a creature within 15 Spaces. Until the start of your next turn, each creature within your Aura has ADV on the first Attack it makes on each of its turns against the chosen creature."
				},
				{
					"featureName": "Battlefield Tactician (Flavor Feature)",
					"levelGained": 3,
					"description": "Through years of study and experience, you've mastered military history and strategy. You gain ADV on Checks related to analyzing fields of battle, understanding historical battles and military organizations, or deciphering complex tactical maneuvers.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/commander_table.json
````json
{
	"className": "Commander",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 4,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/druid_features.json
````json
{
	"className": "Druid",
	"startingEquipment": {
		"weaponsOrShields": ["1 Weapon"],
		"armor": "1 set of Light Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"spellcastingPath": {
		"combatTraining": {
			"armor": ["Light Armor"]
		},
		"spellList": {
			"type": "specific",
			"listName": "Primal Spell List",
			"betaNote": "You can choose from the following Spells when picking your Cantrips and Spells Known:\nCantrips: Poison Bolt, Lightning Bolt, Frost Bolt, Fire Bolt, Close Wounds, Gust, Dancing Flames\n1 MP Spells: Heal, Crackling Lightning, Return Shock, Ice Knife, Grease, Fire Shield, Fog Cloud, Burning Flames, Tethering Vines"
		},
		"cantrips": {
			"knownIncreasesBy": "Cantrips Known column of the Druid Class Table",
			"description": "Cantrips are Spells with the Cantrip Spell Tag."
		},
		"spells": {
			"knownIncreasesBy": "Spells Known column of the Druid Class Table",
			"description": "These can be Spells with or without the Cantrip Spell Tag."
		},
		"manaPoints": {
			"maximumIncreasesBy": "Mana Points column of the Druid Class Table"
		}
	},
	"coreFeatures": [
		{
			"featureName": "Druid Domain",
			"levelGained": 1,
			"description": "You can spend 1 AP and 1 MP to create your own Druid Domain that includes small plant life, sand, shallow water, or other naturally occurring features. You create up to 8 Domain Spaces along the ground or walls. The first Domain Space must be within 1 Space of you, and each additional Domain Space must be adjacent to another Domain Space. If you use this Feature again, the first Domain Space of it must be within 1 Space of you or another Domain Space.\nDomain Spaces: The area is considered to be Difficult Terrain for creatures of your choice, and when you cast a Spell, you can do so as if you were standing in any Space within your Domain.\nLosing Domain Spaces: A Domain Space also disappears if you end your turn farther than 15 Spaces away from it or you die.\nDomain Actions: While you have Domain Spaces, you can take any of the following Domain Actions:\n• Nature's Grasp: You can spend 1 AP to attempt to bind a creature of your choice within your Domain. Make a Spell Check against the target's Repeated Physical Save. Success: The target is bound by your Domain, preventing it from moving for 1 minute or until the Domain Space it occupies ends.\n• Move Creature: You can spend 1 AP to move a creature bound by this feature up to 2 Spaces within your Domain.\n• Move Object: You can take the Object Action to use your vines to interact with any object within your Domain as if you were standing in any of your Domain Spaces. When you do, you can move the object up to 5 Spaces within your Domain.\n• Wild Growth: You can spend 1 AP and 1 MP to make a DC 10 Spell Check to heal a target within your Domain. Success: The target immediately regains 2 HP. For the next minute, they regain an additional 1 HP each time they end their turn within your Domain. Success (each 5): They immediately regain +1 HP. Failure: The target only regains 2 HP immediately."
		},
		{
			"featureName": "Wild Form",
			"levelGained": 1,
			"description": "You can spend 1 AP and 1 MP to transform into a Wild Form of your choice. You can spend 1 AP on your turn to shift back and forth between your True Form and any Wild Forms you currently have available. Once per Long Rest, you can transform without spending MP or using MP enhancements.\nTrue Form: When you transform from your Wild Form to your True Form, your statistics return to normal. You immediately revert to your True Form when your Wild Form HP is reduced to 0 or you die.\nWild Form: When you transform into a Wild Form, you gain the Wild Form's current Wild Form HP (see Wild Form HP below), retaining any HP losses. \n• Duration: Each Wild Form remains available until its Wild Form HP is reduced to 0 or you complete a Long Rest.\n• Multiple Forms: You can have multiple Wild Forms available at a time which have their own Wild Form HP and Traits.\n• Equipment: Your equipment falls to the ground or merges into your Wild Form (your choice for each item). You gain the benefits of Magic Items merged with your Wild Form, but you can't activate them or spend their charges.\nStatistics: While in your Wild Form, you're subjected to the following changes (unless otherwise stated):\n• Stat Block: You use the Wild Form Stat Block below to determine your statistics.\n• Identity: You maintain your personality, intellect, and ability to speak.\n• Wild Form HP: You gain a secondary pool of Wild Form Health Points, which is 3 with a maximum of 3. Damage and healing effects target your Wild Form HP before your True Form HP, and any excess damage or healing carries over to your own HP.\n• Natural Weapon: You have Natural Weapons (claws, horns, fangs, etc.) which you can use to make Unarmed Strikes that deal 1 Bludgeoning, Piercing, or Slashing damage (your choice when you use this Feature).\n• Features & Talents: You don't benefit from Talents or Class Features, except Druid Class Features, Subclass Features, and Talents. Additionally, you can't cast Spells or perform Techniques.\n• Traits: You don't benefit from your Ancestry Traits, but you gain 3 Trait Points to spend on Beast Traits or Wild Form Traits of your choice. You can't select negative Beast Traits. When you use this Feature, you can spend additional MP (up to your Mana Spend Limit) to gain 2 additional Trait Points per MP spent."
		},
		{
			"featureName": "Wild Speech (Flavor)",
			"levelGained": 1,
			"description": "You learn the Druidcraft Cantrip and can choose 1 of the following options:\n• Animals: You can understand and speak with Beasts in a limited manner. You can understand the meaning of their movements, sounds, and behaviors, and they can understand the meanings of simple words, concepts, and emotions.\n• Plants: You can understand and speak with Plants in a limited manner. You can understand the meaning of their swaying, folding, unfolding of their leaves and flowers, and they can understand the meanings of simple words, concepts, and emotions.\n• Weather: You can reach out to nature and cast the Commune with Nature Spell as a Ritual once per Long Rest.",
			"isFlavor": true
		},
		{
			"featureName": "Nature's Torrent",
			"levelGained": 2,
			"description": "When a creature within 10 spaces of you takes Elemental damage, you can spend 1 AP as a Reaction to summon a torrent of nature. The torrent fills a 1 Space Radius Sphere centered on the target that lasts for 1 minute. While creatures are within the area, they have Vulnerability (1) against the triggering damage type and have DisADV on Checks and Saves to resist being moved or knocked Prone. Ending Early: The torrent ends early if you use this Feature again, become Incapacitated, die, or choose to end it for free at anytime."
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Phoenix",
			"features": [
				{
					"featureName": "Flames of Rebirth",
					"levelGained": 3,
					"description": "You wield the power of fire to lay destruction to what exists and foster new life. You gain the following benefits:\n• Fiery Form: When you use your Wild Form, you can choose for your creature type to become Elemental (Fire) instead of Beast. Additionally, your Wild Forms gain Fire Resistance (1) and you can choose Fire as the damage type of your Wild Form's Natural Weapon.\n• Cleansing Flames: When a creature within your Druid Domain is Healed by one of your MP effects, you can remove one of the following Conditions from it: Impaired, Dazed, Burning, or Poisoned.\n• Rolling Wild Fire: Creatures of your choice take 1 Fire damage for each Space they move within your Druid Domain, or if they start their turn within your Domain."
				},
				{
					"featureName": "Fire Within (Flavor Feature)",
					"levelGained": 3,
					"description": "You are unaffected by cold weather conditions and can bring a gallon (4 liters) of liquid to a boil after making physical contact with it or its container for 1 minutes.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Rampant Growth",
			"features": [
				{
					"featureName": "Overgrowth",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Plant Form: When you use your Wild Form, you can choose for your creature type to become Plant instead of Beast. Additionally, your Wild Forms become immune to Bleeding and you can choose Poison as the damage type of your Wild Form's Natural Weapon.\n• Vineguard: Plant-life in your Domain swirls to protect and support you. Creatures of your choice within your Domain gain the benefits of 1/2 Cover.\n• Thorny Grasp: When a creature fails a Save against your Nature's Grasp, it begins Bleeding."
				},
				{
					"featureName": "Seed Vault (Flavor Feature)",
					"levelGained": 3,
					"description": "You can magically produce the seeds of any mundane plant that you've ever touched.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/druid_table.json
````json
{
	"className": "Druid",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 8,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 6,
			"cantripsKnown": 2,
			"spellsKnown": 3,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/hunter_features.json
````json
{
	"className": "Hunter",
	"startingEquipment": {
		"weaponsOrShields": ["2 Weapons or Light Shields"],
		"rangedWeapon": "1 Ranged Weapon with 20 Ammo OR 3 Weapons with the Toss or Thrown Property",
		"armor": "1 set of Light Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"martialPath": {
		"combatTraining": {
			"weapons": ["Weapons"],
			"armor": ["Light Armor"],
			"shields": ["Light Shields"]
		},
		"maneuvers": {
			"learnsAllAttack": true,
			"additionalKnown": "Maneuvers Known column of the Hunter Class Table"
		},
		"techniques": {
			"additionalKnown": "Techniques Known column of the Hunter Class Table"
		},
		"staminaPoints": {
			"maximumIncreasesBy": "Stamina Points column of the Hunter Class Table"
		},
		"staminaRegen": {
			"description": "Once per round, you can regain up to half your maximum SP when:",
			"conditions": [
				"When you Hit the target of your Hunter's Mark with a Martial Attack.",
				"The target of your Hunter's Mark is reduced to 0 HP or dies.",
				"You succeed on a Check to recall information about a creature.",
				"You succeed on a Check to locate an Unseen creature."
			]
		}
	},
	"coreFeatures": [
		{
			"featureName": "Hunter's Mark",
			"levelGained": 1,
			"description": "You can spend 1 AP and 1 SP to focus on and mark a creature you can see within 15 Spaces as your quarry. Alternatively, you can mark a creature by studying its tracks for at least 1 minute. While a creature is marked, you gain the following benefits:\n• You have ADV on Awareness and Survival Checks made to find the target.\n• The first Martial Attack against your target on your turn has ADV and ignores PDR.\n• When you score a Heavy or Critical Hit against the target, you automatically grant a d8 Help Die to the next Attack made against the target before the start of your next turn.\nThe target is marked as long as it's on the same Plane of Existence as you, and vanishes early if you complete a Long Rest, fall Unconscious, or use this Feature again to mark another creature."
		},
		{
			"featureName": "Favored Terrain",
			"levelGained": 1,
			"description": "You are particularly familiar with two types of environments and are adept at the skills unique to the region. Choose 2 types of Favored Terrain listed below. Additionally, while you're in one of your Favored Terrains, you have ADV on Stealth and Survival Checks and can't be Surprised.",
			"choices": [
				{
					"prompt": "Choose 2 types of Favored Terrain.",
					"count": 2,
					"options": [
						{
							"name": "Coast",
							"description": "You gain a Swim Speed equal to your Ground Speed (your Weapon Attacks no longer have DisADV as a result of being underwater), you can hold your breath twice as long as normal, and you have ADV on Awareness Checks while underwater."
						},
						{
							"name": "Desert",
							"description": "You gain Fire Resistance (Half) and Resistance to Exhaustion from hot temperatures."
						},
						{
							"name": "Forest",
							"description": "You gain 2 Skill Points to use on up to 2 of the following Skills: Animal, Awareness, Medicine, Survival, and Stealth."
						},
						{
							"name": "Grassland",
							"description": "Your Speed and Jump Distance increases by 1."
						},
						{
							"name": "Jungle",
							"description": "You ignore Difficult Terrain, gain Poisoned Resistance, and have ADV on Saves against against contracting Diseases."
						},
						{
							"name": "Mountain",
							"description": "You gain a Climb Speed equal to your Ground Speed, Resistance to Exhaustion from high altitudes, and Resistance (Half) to damage from Falling."
						},
						{
							"name": "Swamp",
							"description": "You gain Poison Resistance (Half) and Poisoned Resistance, and have ADV on Saves against against contracting Diseases."
						},
						{
							"name": "Tundra",
							"description": "You gain Cold Resistance (Half) and Resistance to Exhaustion from cold temperatures."
						},
						{
							"name": "Subterranean",
							"description": "You gain Darkvision 10 Spaces. If you already have Darkvision, its range is increased by 5 Spaces. Additionally, you also gain a Tremorsense of 3 Spaces. If you already have a Tremorsense, it increases by 2 Spaces."
						},
						{
							"name": "Urban",
							"description": "You gain 2 Skill Points to use on up to 2 of the following Skills: Influence, Insight, Investigation, Intimidation, and Trickery."
						}
					]
				}
			]
		},
		{
			"featureName": "Bestiary (Flavor Feature)",
			"levelGained": 1,
			"description": "You have developed a trove of knowledge hunting creatures which you've recorded in your Bestiary. Your Bestiary can take the form of a book, a memory vault within your mind, or some other representation of your choice. You have ADV on Checks made to learn or recall information about any creature recorded in your Bestiary.\nStarting Entries: Choose a Creature Type: Aberration, Beast, Celestial, Construct, Dragon, Elemental, Fey, Fiend, Giant, Humanoid, Monstrosity, Ooze, Plant, or Undead. Your Bestiary includes prerecorded notes about various creatures of the chosen type.\nMaking New Entries: You can spend 10 minutes of Light Activity recording information into your Bestiary about a specific creature you have slain within the last 24 hours.",
			"isFlavor": true
		},
		{
			"featureName": "Hunter's Strike",
			"levelGained": 2,
			"description": "You have an assortment of unique oils, tools, and weapon accessories that you can use to modify a Weapon (or piece of ammunition) when making an Attack. You can spend 1 SP as part of a Weapon Attack to add 1 of the effects listed below. You can only use 1 of these effects per Attack. If an effect forces the target to make a Save, it does so against your Save DC.",
			"choices": [
				{
					"prompt": "Choose a Hunter's Strike effect.",
					"count": 1,
					"options": [
						{
							"name": "Piercing",
							"description": "2 Piercing damage and Physical Save against Bleeding."
						},
						{
							"name": "Snare",
							"description": "2 Bludgeoning damage and Physical Save against Immobilized until the end of your next turn."
						},
						{
							"name": "Acid",
							"description": "2 Corrosion damage and Agility Save against Slowed until the end of your next turn."
						},
						{
							"name": "Toxin",
							"description": "2 Poison damage and Might Save against Impaired until the end of your next turn."
						},
						{
							"name": "Flash Bang",
							"description": "2 Sonic damage and Mental Save against Dazed until the end of your next turn."
						},
						{
							"name": "Fire Oil",
							"description": "2 Fire damage and Physical Save against Burning."
						}
					]
				}
			]
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Monster Slayer",
			"features": [
				{
					"featureName": "Monstrous Concoctions",
					"levelGained": 3,
					"description": "You hunt down your targets with the aid of Concoctions you have learned to create by hunting monsters.\nConcoction Recipes: You learn 3 Concoction Recipes of your choice from the list below. During a Long Rest, you can prepare ingredients for a number of Vials equal to your Prime Modifier. The ingredients within the Vials are unstable and become inert when you take a Long Rest, at which point you can prepare new ones.\nConcoctions: You can use the Object Action to convert one Vial into a Concoction of your choice and immediately drink it or administer it to a creature within 1 Space, gaining the Concoction's benefits for 10 minutes. You can only benefit from the effects of 1 Concoction at a time. If you consume a new one, the effects of the previous Concoction ends.",
					"choices": [
						{
							"prompt": "Learn 3 Concoction Recipes.",
							"count": 3,
							"options": [
								{
									"name": "Elemental Infusion",
									"description": "Choose an Elemental damage type when you make this Concoction. Hunter's Mark: Attacks you make against your Marked target deal +1 damage of the chosen Elemental Damage type. Elemental Tolerance: You gain Resistance (1) to the chosen Elemental Damage."
								},
								{
									"name": "Hydra's Blood",
									"description": "Hunter's Mark: When you Heavy Hit your Marked target, you regain 1 HP. Poisonous Blood: You have Poisoned Resistance and when a creature within 1 Space of you deals damage to you with an Attack, they take 1 Poison damage."
								},
								{
									"name": "Basilisk Eye",
									"description": "Hunter's Mark: You can sense the vibrations made by your Marked target, giving you Tremorsense 20 Spaces when locating them. Stone Skin: You gain Physical Resistance (1)."
								},
								{
									"name": "Ooze Gel",
									"description": "Hunter's Mark: When you Heavy Hit your Marked Target, you cover it in slime. It's Hindered until it or a creature within 1 Space of it spends 1 AP to remove the slime. Amorphous Body: You can climb difficult surfaces without needing to make a Check (including upside down on ceilings) and can squeeze through gaps as small as 2 inches (5 cm)."
								},
								{
									"name": "Aberrant Tumor",
									"description": "Hunter's Mark: While within 20 Spaces of your Marked target, you have ADV when you use Analyze Creature on them and you have ADV on Mental Saves your Marked target forces you to make. Unreadable: You gain Psychic Resistance (1) and your thoughts can't be read by others unless you allow it."
								},
								{
									"name": "Deathweed",
									"description": "Hunter's Mark: When you score a Heavy Hit against a Marked target it bypasses their Physical Resistances and prevents them from regaining HP until the start of your next turn. Death State: You enter a state between life and death, granting you Umbral Resistance (Half), immunity to being Doomed, and ADV on Death Saves."
								},
								{
									"name": "Plant Fibers",
									"description": "Hunter's Mark: If your Marked Target fails a Save you force it to make, they can't move until the end of your next turn. Plant Stitching: You become Immune to Bleeding and gain 1 Temp HP at the end of each of your turns."
								},
								{
									"name": "Divine Water",
									"description": "Hunter's Mark: Once on each of your turns when you score a Heavy Hit against your Marked target, it also becomes Exposed on the next Attack against it before the end of your next turn. Brilliant Essence: You gain Radiant Resistance (Half) and radiate Bright Light in a 5 Space Radius."
								}
							]
						}
					]
				},
				{
					"featureName": "Monster Hunter (Flavor Feature)",
					"levelGained": 3,
					"description": "You are a master at hunting monsters. If you have 3 entries of creatures with the same Creature Type in your Hunter's Bestiary, you can add the entire Creature Type as an entry.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Trapper",
			"features": [
				{
					"featureName": "Dynamic Traps",
					"levelGained": 3,
					"description": "You are able to use a variety of supplies to craft traps.\nCreating Traps: You can have a maximum number of Hunter's Traps equal to your Prime Modifier at any time. During a Long Rest, you can craft a number of Traps equal to your Prime Modifier. You can make 1 additional Trap as part of a Short Rest. These Traps use your Save DC when they force a creature to make a Save or when a Check is made to interact with them.\nSetting a Trap: You can spend 1 AP to Set and Hide one of your Traps in a Space within 5 Spaces that doesn't already contain a Trap. The Trap is Hidden to creatures, and the DC to discover or disarm the Trap is equal to your Save DC. When you do, you can spend 1 SP to add the damage and effect of one of your Hunter's Strike options to the Trap. Once Set, your Traps are unstable and fall apart harmlessly after 1 hour.\nTriggering a Trap: A Trap is Triggered when a creature other than you enters or leaves a Space occupied by the Trap. Alternatively, you can spend 1 AP to Trigger a Trap within 5 Spaces. When Triggered, the Trap makes an Attack for free against the AD of a creature in its Space using your Attack Check. This Attack ignores your Multiple Check Penalty and doesn't progress that penalty.\nHit: The Trap deals Bludgeoning, Piercing, or Slashing damage (your choice when you Set the Trap) equal to your Prime Modifier, plus the damage and effects of your Hunter's Strike (if used when you Set the Trap).\nRecovering a Trap: You can spend 1 AP while within 1 Space of one of your Set Traps to disarm and recover the use of the Trap. When you do, it loses any damage and effects of your Hunter's Mark (if applicable)."
				},
				{
					"featureName": "Discerning Eye (Flavor Feature)",
					"levelGained": 3,
					"description": "You have ADV on Awareness Checks to discover Hidden Traps and on Investigation Checks to discern how to disarm them.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/hunter_table.json
````json
{
	"className": "Hunter",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 4,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/monk_features.json
````json
{
	"className": "Monk",
	"startingEquipment": {
		"weaponsOrShields": ["2 Weapons", "3 Weapons with the Toss or Thrown Property"],
		"armor": "1 set of Light Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"martialPath": {
		"combatTraining": {
			"weapons": ["Weapons"],
			"armor": ["Light Armor"]
		},
		"maneuvers": {
			"learnsAllAttack": true,
			"additionalKnown": "Maneuvers Known column of the Monk Class Table"
		},
		"techniques": {
			"additionalKnown": "Techniques Known column of the Monk Class Table"
		},
		"staminaPoints": {
			"maximumIncreasesBy": "Stamina Points column of the Monk Class Table"
		},
		"staminaRegen": {
			"description": "Once per round, you can regain up to half your maximum SP when you succeed on an Attack Check, Athletics Check, or Acrobatics Check.",
			"conditions": []
		}
	},
	"coreFeatures": [
		{
			"featureName": "Monk Training",
			"levelGained": 1,
			"description": "Your martial arts training grants you greater offense, defense, and movement.",
			"benefits": [
				{
					"name": "Iron Palm",
					"description": "Your limbs are considered Natural Weapons with the Impact Property that deal 1 Bludgeoning damage."
				},
				{
					"name": "Patient Defense",
					"description": "While you aren't wearing Armor, you gain +2 PD."
				},
				{
					"name": "Step of the Wind",
					"description": "While you aren't wearing Armor, you gain the following benefits:\n• You gain +1 Speed and Jump Distance.\n• You can move a number of Spaces up to your Speed along vertical surfaces and across liquids without falling during your move.\n• You can use your Prime Modifier instead of Agility to determine your Jump Distance and the damage you take from Falling."
				}
			]
		},
		{
			"featureName": "Monk Stance",
			"levelGained": 1,
			"description": "You learn 2 Monk Stances from the list below. Entering & Exiting: In Combat, at the start of each of your turns you can freely enter or swap into one of your Monk Stances. You can also spend 1 SP on your turn to swap to a different stance. You can end your Stance at any moment for free. You can only be in 1 Monk Stance at a time.",
			"choices": [
				{
					"prompt": "Learn 2 Monk Stances.",
					"count": 2,
					"options": [
						{
							"name": "Bear Stance (Big Hits)",
							"description": "• +1 damage when you score a Heavy, Brutal, or Critical Hit with a Melee Martial Attack.\n• Once on each of your turns, when you Miss an Attack with a Melee Martial Attack, you gain ADV on the next Melee Martial Attack you make before the end of your turn."
						},
						{
							"name": "Bull Stance (Knockback)",
							"description": "• You deal +1 Bludgeoning damage whenever you Succeed on a Physical Check to push a target or knock them back.\n• When you shove or push a target, it's knocked back 1 additional space. Additionally, you can choose to move in a straight line with the target an amount of spaces equal to how far they're knocked back. This movement requires no AP and doesn't provoke Opportunity Attacks."
						},
						{
							"name": "Cobra Stance (Counter)",
							"description": "• +1 damage with Melee Martial Attack against creatures that have damaged you since the start of your last turn.\n• When a creature within your Melee Range misses you with a Melee Attack, you can spend 1 AP as a Reaction to make a Melee Martial Attack against it."
						},
						{
							"name": "Gazelle Stance (Nimble)",
							"description": "While not wearing Heavy Armor you gain the following benefits:\n• +1 Movement Speed and Jump Distance.\n• Ignore Difficult Terrain.\n• ADV on Agility Saves and Acrobatics Checks."
						},
						{
							"name": "Mantis Stance (Grapple)",
							"description": "• ADV on all Martial Checks to initiate, maintain, or escape Grapples.\n• If you have a creature Grappled at the start of your turn, you get +1 AP to use on a Grapple Maneuver against the Grappled creature."
						},
						{
							"name": "Mongoose Stance (Multi)",
							"description": "• Your Melee Martial Attacks deal +1 damage while you're Flanked.\n• When you make a Melee Martial Attack against a target, you can make another Melee Martial Attack for free against a different target within your Melee Range. You can only make this bonus Melee Martial Attack once on each of your turns. Make a single Attack Check and apply the number rolled to each target's Physical Defense. Attack Hit: You deal your Melee Martial Attack damage."
						},
						{
							"name": "Scorpion Stance (Quick Strike)",
							"description": "• When a creature enters your Melee Range, you can make an Opportunity Attack against them with a Melee Martial Attack.\n• When you make a Melee Martial Attack, you can spend 1 AP to deal +1 damage and force the target to make a Physical Save against your Save DC. Failure: The target is Impaired (DisADV on Physical Checks) on the next Physical Check it makes before the end of your next turn."
						},
						{
							"name": "Turtle Stance (Sturdy)",
							"description": "• Your Speed becomes 1 (unless it's already lower).\n• You gain PDR, EDR, and MDR.\n• You have ADV on Might Saves and Saves against being moved or knocked Prone."
						},
						{
							"name": "Wolf Stance (Hit & Run)",
							"description": "• After you make an Attack with a Melee Martial Attack, you can immediately move up to 1 Space for free.\n• You have ADV on Opportunity Attacks, and creatures have DisADV on Opportunity Attacks made against you."
						}
					]
				}
			]
		},
		{
			"featureName": "Meditation (Flavor Feature)",
			"levelGained": 1,
			"description": "You can enter a state of meditation during a Short Rest (1 hour) or longer. Choose 1 Charisma or Intelligence Skill. When you complete the Rest, your Skill Mastery level increases by 1 (up to your Skill Mastery Cap) for the chosen Skill until you complete another Short or longer Rest. While meditating, you remain alert to danger.",
			"isFlavor": true
		},
		{
			"featureName": "Spiritual Balance",
			"levelGained": 2,
			"description": "You gain the power to harness your inner spirit as a counterbalance against your physical energy.\nKi Points: You have a maximum number of Ki Points equal to your Stamina Points. When your Stamina Point maximum increases, your Ki Point maximum increases equally.\nRegaining Ki: When you spend a Stamina Point on your turn, you regain a Ki Point. You regain all spent Ki Points when Combat ends. While out of Combat, any Ki Points you spend replenish immediately."
		},
		{
			"featureName": "Ki Actions",
			"levelGained": 2,
			"description": "You can spend 1 Ki Point at any time to perform 1 of the activities listed below:",
			"benefits": [
				{
					"name": "Deflect Attack",
					"description": "When a creature misses you with a Ranged Attack using a physical projectile that targets your PD, you can catch the projectile with a free hand. You can immediately redirect the Attack as part of the same action at a different creature you can see within 5 Spaces. Make an Attack Check against the new target's PD. Hit: The target takes the projectile's normal damage."
				},
				{
					"name": "Slow Fall",
					"description": "Reduce damage you take from falling by an amount equal to your level."
				},
				{
					"name": "Uncanny Dodge",
					"description": "When a creature makes an Attack against you, you can impose DisADV on the attack."
				}
			]
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Astral Self",
			"features": [
				{
					"featureName": "Astral Awakening",
					"levelGained": 3,
					"description": "Astral Damage: When you gain this feature, choose a Mystical damage type. This damage type is your Astral Damage.\nDuring Combat, you can spend 1 AP and 1 SP to manifest a portion of your astral self for 1 minute. For the duration, you gain the following benefits:\n• Astral Arms: You manifest 2 astral arms that can only be used to make Unarmed Strikes. They can't otherwise interact with creatures or objects. Attacks made using these Astral Arms have the Reach property, deal Astral Damage instead of the normal damage type, and can target PD or AD (choose for each Attack).\n• Astral Deflection: You can now use Deflect Attack on Ranged Attacks that miss any target within 2 Spaces.\nEnding Early: The effect ends early if you fall Unconscious, die, or choose to end it for free."
				},
				{
					"featureName": "Astral Watch (Flavor Feature)",
					"levelGained": 3,
					"description": "While Unconscious, your astral self remains aware of your surroundings. You can hold conversations with nearby creatures as if you were awake. While sleeping normally, you can choose to wake yourself up at any time.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Shifting Tide",
			"features": [
				{
					"featureName": "Ebb and Flow",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Ebb: When you enter a new Monk Stance, you gain 2 Spaces of movement.\n• Flow: When you use your Uncanny Dodge against a Melee Attack, you can spend 1 AP to make an Opportunity Attack against the Attacker.\n• Changing Tides: You can use your Deflect Attack on Melee Martial Attacks from Large or smaller creatures. When you do, you can redirect the Attack to another target within 1 Space of you."
				},
				{
					"featureName": "Fluid Movement (Flavor Feature)",
					"levelGained": 3,
					"description": "You can move through Spaces as if you were one size Smaller.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/monk_table.json
````json
{
	"className": "Monk",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 4,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/rogue_features.json
````json
{
	"className": "Rogue",
	"startingEquipment": {
		"weaponsOrShields": ["2 Weapons or Light Shields"],
		"rangedWeapon": "1 Ranged Weapon with 20 Ammo OR 3 Weapons with the Toss or Thrown Property",
		"armor": "1 set of Light Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"martialPath": {
		"combatTraining": {
			"weapons": ["Weapons"],
			"armor": ["Light Armor"],
			"shields": ["Light Shields"]
		},
		"maneuvers": {
			"learnsAllAttack": true,
			"additionalKnown": "Maneuvers Known column of the Rogue Class Table"
		},
		"techniques": {
			"additionalKnown": "Techniques Known column of the Rogue Class Table"
		},
		"staminaPoints": {
			"maximumIncreasesBy": "Stamina Points column of the Rogue Class Table"
		},
		"staminaRegen": {
			"description": "Once per round, you can regain up to half your maximum SP when:",
			"conditions": [
				"You Hit a Flanked or Prone target.",
				"You Hit a target affected by at least 1 Condition.",
				"You Hit a target you're Hidden from.",
				"You gain the benefits of your Cunning Action."
			]
		}
	},
	"coreFeatures": [
		{
			"featureName": "Debilitating Strike",
			"levelGained": 1,
			"description": "When you make an Attack with a Weapon, you can spend 1 SP to force the target to make a Physical Save against your Save DC. Save Failure: Until the start of your next turn, the target suffers 1 of the following effects of your choice: Deafened, Exposed, Hindered, or Slowed 2. A target can't be affected by the same option more than once at a time."
		},
		{
			"featureName": "Roguish Finesse",
			"levelGained": 1,
			"description": "You gain the following benefits:",
			"benefits": [
				{
					"name": "Cunning Action",
					"description": "You gain movement equal to half your Speed when you take the Disengage, Feint, or Hide Actions. You can use this movement immediately before or after you take the Action."
				},
				{
					"name": "Skill Expertise",
					"description": "Your Skill Mastery Limit increases by 1, up to Grandmaster (+10). A Skill can only benefit from one increase to its Mastery limit."
				},
				{
					"name": "Multi-Skilled",
					"description": "You gain 1 Skill Point."
				}
			]
		},
		{
			"featureName": "Cypher Speech (Flavor Feature)",
			"levelGained": 1,
			"description": "You become Fluent in a Mortal Language of your choice. Additionally, you understand how to speak in code with a specific demographic of your choice (such as upper society, lower society, a faction, etc.). Your coded messages can be concealed in normal conversation and written communications. This allows you to leave simple messages such as 'Safety', 'Threat' or 'Wealth' or mark the location of a cache, a secret passageway, a safehouse, or an area of danger.",
			"isFlavor": true
		},
		{
			"featureName": "Cheap Shot",
			"levelGained": 2,
			"description": "You deal +1 damage on Martial Attacks against a creature that fulfills at least one of the following:\n• It's Flanked or Prone.\n• It has any Condition other than Invisible.\n• You're Hidden from it."
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Long Death",
			"features": [
				{
					"featureName": "Thousand Cuts",
					"levelGained": 3,
					"description": "When a creature fails its Save against your Debilitating Strike, it also begins Bleeding (even if it's immune to the Condition). If a creature is affected by Bleeding from this Feature, the DC to end the Bleeding Condition is equal to your Save DC and it can no longer be ended by regaining HP."
				},
				{
					"featureName": "Hundred Ways to Die (Flavor Feature)",
					"levelGained": 3,
					"description": "You are an expert at studying and identifying weaknesses in bodies and how best to kill creatures. You have ADV on any Check made to determine how something died or could die easier. This also extends to poisons, toxins, or identifying other materials used to kill.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Swashbuckler",
			"features": [
				{
					"featureName": "Renegade Duelist",
					"levelGained": 3,
					"description": "You're skilled at make a mockery of your opponents while taking advantage of their openings. You gain the following benefits:\n• Flourishes: Your Cunning Action now also includes the Disarm and Dodge Actions.\n• Taunting Shot: Once on each of your turns when you make an Attack against a creature with a Condition, you can forgo your Cheap Shot damage to force the target to make a Charisma Save. Failure: The target is Taunted until the end of your next turn.\n• Riposte: When a creature within your Melee Range misses you with an Attack, it provokes an Opportunity Attack from you."
				},
				{
					"featureName": "Tall Tales (Flavor Feature)",
					"levelGained": 3,
					"description": "You know how to play to a crowd. You can spend up to 5 minutes telling a story to a crowd of creatures (that are not immediately hostile to you) and keep their rapt attention the entire time. During this story, creatures within the crowd have DisADV on Awareness Checks.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/rogue_table.json
````json
{
	"className": "Rogue",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 4,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/sorcerer_features.json
````json
{
	"className": "Sorcerer",
	"startingEquipment": {
		"weaponsOrShields": ["1 Weapon"],
		"armor": "1 set of Light Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"spellcastingPath": {
		"combatTraining": {
			"armor": ["Light Armor"]
		},
		"spellList": {
			"type": "any",
			"listName": "Choose 1 Spell List (Arcane, Divine, or Primal)",
			"description": "When you learn a new Spell, you can choose any Spell from the chosen Spell List.",
			"betaNote": "You get access to the following \"Premade List\" that have had their Spells pre-selected for you: Fire & Flames, Ice & Illusions, Lightning & Teleportation, or Psychic & Enchantment"
		},
		"cantrips": {
			"knownIncreasesBy": "Cantrips Known column of the Sorcerer Class Table",
			"description": "Cantrips are Spells with the Cantrip Spell Tag."
		},
		"spells": {
			"knownIncreasesBy": "Spells Known column of the Sorcerer Class Table",
			"description": "These can be Spells with or without the Cantrip Spell Tag."
		},
		"manaPoints": {
			"maximumIncreasesBy": "Mana Points column of the Sorcerer Class Table"
		}
	},
	"coreFeatures": [
		{
			"featureName": "Innate Power",
			"levelGained": 1,
			"description": "Choose a Sorcerous Origin that grants you a benefit: Intuitive Magic, Resilient Magic, or Unstable Magic. Additionally, you gain the following benefits:\n• Your Maximum MP increases by 1.\n• Once per Long Rest, you can use a 1 MP Spell Enhancement without spending any MP (up to your Mana Spend Limit). You regain the ability to use this benefit when you roll for Initiative."
		},
		{
			"featureName": "Sorcerous Origins",
			"levelGained": 1,
			"description": "Choose one of the following Sorcerous Origins.",
			"choices": [
				{
					"prompt": "Choose a Sorcerous Origin.",
					"count": 1,
					"options": [
						{
							"name": "Intuitive Magic",
							"description": "You learn an additional Spell and Cantrip from your Sorcerer Spell List."
						},
						{
							"name": "Resilient Magic",
							"description": "You gain Dazed Resistance."
						},
						{
							"name": "Unstable Magic",
							"description": "When you Critically Succeed or Fail on a Spell Check, roll on the Wild Magic Table. If it's a Critical Success you roll with ADV, if it's a Critical Failure you roll with DisADV. The effect lasts until the end of your next turn, unless stated otherwise. When you roll on the Wild Magic Table in this way, you gain ADV on the next Spell Check you make before the end of your next turn."
						}
					]
				}
			]
		},
		{
			"featureName": "Overload Magic",
			"levelGained": 1,
			"description": "You can spend 2 AP in Combat to channel raw magical energy for 1 minute, or until you become Incapacitated, die, or choose to end it early at any time for free. For the duration, your magic is overloaded and you're subjected to the following effects:\n• You gain +5 to all Spell Checks you make.\n• You must immediately make an Attribute Save (your choice) against your Save DC upon using this Feature, and again at the start of each of your turns. Failure: You gain Exhaustion. You lose any Exhaustion gained in this way when you complete a Short Rest."
		},
		{
			"featureName": "Sorcery (Flavor Feature)",
			"levelGained": 1,
			"description": "You learn the Sorcery Spell.",
			"isFlavor": true
		},
		{
			"featureName": "Meta Magic",
			"levelGained": 2,
			"description": "You gain 2 unique Spell Enhancements from the list below. You can only use 1 of these Spell Enhancements per Spell you cast. MP spent on these Spell Enhancements doesn't count against your Mana Spend Limit.",
			"choices": [
				{
					"prompt": "Choose 2 Meta Magic options.",
					"count": 2,
					"options": [
						{
							"name": "Careful Spell",
							"description": "When you Cast a Spell that targets an Area of Effect, you can choose to protect some of the creatures from the Spell's full force. Spend 1 MP and choose a number of creatures up to your Prime Modifier. All chosen creatures are immune to the Spell's damage and effects."
						},
						{
							"name": "Heightened Spell",
							"description": "When you cast a Spell that forces a creature to make a Save to resist its effects, you can spend 1 MP to give 1 target DisADV on its first Save against the Spell."
						},
						{
							"name": "Quickened Spell",
							"description": "You can spend 1 MP to reduce the AP cost of a Spell by 1 (minimum of 1 AP)."
						},
						{
							"name": "Subtle Spell",
							"description": "When you cast a Spell, you can spend 1 MP to cast it without any Somatic or Verbal Components."
						},
						{
							"name": "Transmuted Spell",
							"description": "When you cast a Spell that deals a type of damage from the following list, you can spend 1 MP to change that damage type to one of the other listed types: Cold, Corrosion, Fire, Lightning, Poison, or Sonic."
						}
					]
				}
			]
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Angelic",
			"features": [
				{
					"featureName": "Celestial Spark",
					"levelGained": 3,
					"description": "You can use a Minor Action to emit Bright Light within a 5 Space Radius and can end the effect at any time. You also gain the following abilities:\n• Celestial Origin: You gain 2 Ancestry Points that can only be spent on Angelborn Traits.\n• Celestial Protection: You learn the Careful Spell Meta Magic option (choose another Meta Magic option if you already know it) and Careful Spell now costs 0 MP to use.\n• Celestial Overload: Once per Combat while you're Overloaded, you can spend 1 AP to release a burst of radiant light in a 5 Space Aura. Creatures of your choice within range are either healed or seared by the light (your choice for each creature).\n  - Healed: The creature regains 1 HP.\n  - Seared: Make a Spell Check against the target's AD. Success: The target takes 1 Radiant damage."
				},
				{
					"featureName": "Celestial Appearance (Flavor Feature)",
					"levelGained": 3,
					"description": "You gain additional angelic features such as sparkling skin, feathers, a faint halo, or other changes of your choice. If you already have these features, they're enhanced or expanded upon. Additionally, you gain 1 level of Language Mastery in Celestial. If you're already Fluent in Celestial, you gain 1 level of Language Mastery in another Language of your choice.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Draconic",
			"features": [
				{
					"featureName": "Draconic Spark",
					"levelGained": 3,
					"description": "You gain the following abilities:\n• Draconic Origin: You gain 2 Ancestry Points that can only be spent on Dragonborn Traits. Additionally, choose a Draconic Origin from the Dragonborn Ancestry if you haven't already.\n• Draconic Overload: While Overloaded, you gain Resistance (1) to Physical damage and your Draconic Origin damage type.\n• Draconic Transmutation: You gain the Transmuted Spell Meta Magic (choose another Meta Magic option if you already have Transmuted Spell). Transmuted Spell now costs you 0 MP to use if you change the damage type to your Draconic Origin damage type."
				},
				{
					"featureName": "Draconic Appearance (Flavor Feature)",
					"levelGained": 3,
					"description": "You gain additional draconic features such as scales, fangs, claws, or other changes of your choice. If you already have these features, they're enhanced or expanded upon. Additionally, you gain 1 level of Language Mastery in Draconic. If you're already Fluent in Draconic, you gain 1 level of Language Mastery in another Language of your choice.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/sorcerer_table.json
````json
{
	"className": "Sorcerer",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 8,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 6,
			"cantripsKnown": 2,
			"spellsKnown": 3,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/spellblade_features.json
````json
{
	"className": "Spellblade",
	"startingEquipment": {
		"weaponsOrShields": [
			"2 Weapons or Light Shields (or Heavy Shields if you choose the Warrior Discipline, see below)"
		],
		"rangedWeapon": "1 Ranged Weapon with 20 Ammo OR 3 Weapons with the Toss or Thrown Property",
		"armor": "1 set of Light Armor (or Heavy Armor if you choose the Warrior Discipline)",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"martialPath": {
		"combatTraining": {
			"weapons": ["Weapons"],
			"armor": ["Light Armor"],
			"shields": ["Light Shields"]
		},
		"maneuvers": {
			"learnsAllAttack": true,
			"additionalKnown": "Maneuvers Known column of the Spellblade Class Table"
		},
		"techniques": {
			"additionalKnown": "Techniques Known column of the Spellblade Class Table"
		},
		"staminaPoints": {
			"maximumIncreasesBy": "Stamina Points column of the Spellblade Class Table"
		},
		"staminaRegen": {
			"description": "Once per round, you can regain up to half your maximum SP when you Hit with a Spell Attack or succeed on a Spell Check.",
			"conditions": []
		}
	},
	"spellcastingPath": {
		"combatTraining": {
			"armor": [],
			"shields": []
		},
		"spellList": {
			"type": "schools",
			"specificSchools": ["Destruction", "Protection"],
			"schoolCount": 1,
			"description": "You gain access to Destruction and Protection schools, plus 1 other School of your choice",
			"betaNote": "Until the Spell update in Beta 0.10 the Spellblade can pick between all currently available Spells from the Premade Spell Lists (within the available Schools of course)."
		},
		"cantrips": {
			"knownIncreasesBy": "Cantrips Known column of the Spellblade Class Table",
			"description": "Cantrips are Spells with the Cantrip Spell Tag."
		},
		"spells": {
			"knownIncreasesBy": "Spells Known column of the Spellblade Class Table",
			"description": "These can be Spells with or without the Cantrip Spell Tag."
		},
		"manaPoints": {
			"maximumIncreasesBy": "Mana Points column of the Spellblade Class Table"
		}
	},
	"coreFeatures": [
		{
			"featureName": "Bound Weapon",
			"levelGained": 1,
			"description": "During a Quick Rest, you can magically bond with 1 Weapon and choose an Elemental or Mystical damage type to become your Bound Damage type. This bond lasts until you end it for free or use this feature again. Your Bound Weapon gains the following properties:\n• Smite: When you make a Martial Attack with the Weapon, you can spend 1 or more SP to deal +2 Bound Damage per SP spent. When you do, you also gain the benefits of 1 Attack Maneuver of your choice for free.\n• Illuminate: You can cause the Weapon to emit a 5 Spaces of Dim or Bright Light (you choose the light's appearance). You can extinguish, produce, or adjust the level of this illumination at any time for free.\n• Recall: While the Weapon is within 20 Spaces and isn't being held or secured, you can call your Weapon back to you for free, causing it to fly to you. If you don't have a free hand when you call it, or you choose not to grab it, it falls in your Space at your feet.\nEnding Early: Your bond with the Weapon ends early if you use this Feature again, or you choose to end it for free."
		},
		{
			"featureName": "Spellblade Disciplines",
			"levelGained": 1,
			"description": "You learn 2 Spellblade Disciplines from the list below.",
			"choices": [
				{
					"prompt": "Choose 2 Spellblade Disciplines.",
					"count": 2,
					"options": [
						{
							"name": "Magus",
							"description": "You gain the following benefits: • Your Maximum MP increases by 1. • You learn 1 additional Spell."
						},
						{
							"name": "Warrior",
							"description": "You gain the following benefits: • You gain Heavy Armor and Heavy Shield Training. • You learn 2 Maneuvers."
						},
						{
							"name": "Acolyte",
							"description": "You can spend 1 AP and 1 MP to produce 1 of the following effects:\n• Heal: You gain a pool of healing that you can use to restore HP to any number of creatures within 5 Spaces of you, distributing the HP among them (minimum of 1 HP each). Make a DC 10 Spell Check. Success: You can restore up to 3 HP. Success (each 5): +1 HP. Failure: You only restore up to 2 HP.\n• Cure: You can attempt to remove 1 Poison or Disease from a creature of your choice within 1 Space of you. Make a Spell Check against the DC of the Poison or Disease. Success: The chosen Poison or Disease ends on the target."
						},
						{
							"name": "Hex Warrior",
							"description": "You can spend 1 AP and 1 MP to Curse a creature within 10 Spaces for 1 minute. You make a Spell Check against the target's Repeated Physical Save. Save Failure: The target is Dazed or Impaired (your choice) and takes 1 Umbral damage at the start of each of their turns. Additionally, they're prevented from regaining HP."
						},
						{
							"name": "Spell Breaker",
							"description": "You can spend 2 AP to initiate a Spell Duel against a Spell Attack using a Weapon instead of casting a Spell, provided the Initiator or a target of the Spell is within the range of your Weapon. When you do, you make an Attack Check and you can spend SP and MP (for a total up to your Mana Spend Limit) to gain a bonus on your Check equal to the SP and MP spent. You have ADV on your Check if you are within 1 Space of the Initiator."
						},
						{
							"name": "Spell Warder",
							"description": "When you deal Elemental or Mystical damage with an Attack, you gain Resistance (1) to that damage type until the start of your next turn. If you deal Elemental or Mystical damage again while this is already active, you can choose to keep the current Resistance or switch it out for the new one instead."
						},
						{
							"name": "Blink Blade",
							"description": "Once per turn, when you make an Attack, you can choose to teleport to a Space you can see within 1 Space immediately before or after making the Attack (your choice)."
						}
					]
				}
			]
		},
		{
			"featureName": "Sense Magic (Flavor Feature)",
			"levelGained": 1,
			"description": "You can spend 1 minute focusing your mind to detect the following creature types within 20 Spaces: Aberration, Celestial, Elemental, Fey, Fiend, or Undead. Make a Spell Check against each creature's Mental Save. Check Success: You learn the target's creature type and know its location until the end of your next turn. Check Failure: You learn nothing and can't use this Feature against the target again until you complete a Long Rest.",
			"isFlavor": true
		},
		{
			"featureName": "Spellstrike",
			"levelGained": 2,
			"description": "Once on each of your turns when you make a Martial Attack, you can also cast a Spell as part of the same Action, spending 1 AP less than normal.\nConverged Action: When you do, the Spell can only target 1 creature who must be a target of the Attack, and the range of the Attack can't exceed the range of the Spell. The Spell uses the Attack Check as its Spell Check for any of its requirements, and any Saves you force the target to make are made against your Save DC.\nHarmonic Strike: The Attack and Spell from a Spellstrike are treated as 1 Attack, and can benefit from Maneuvers and Spell Enhancements. The Spell doesn't require Somatic Components."
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Paladin",
			"features": [
				{
					"featureName": "Holy Warrior",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Aura of Protection: Creatures of your choice within 2 Spaces of you have ADV on Mental Saves.\n• Divine Strike: When you deal damage with Spellstrike, you can change the Spell's damage to Radiant or Umbral (choose when you gain this Feature).\n• Lay on Hands: You gain the Acolyte Spellblade Discipline. If you already know that Discipline, you gain another one of your choice. Once per Long Rest, you can use the Acolyte Discipline without spending MP and gain a +5 bonus on your Spell Check."
				},
				{
					"featureName": "Oathsworn (Flavor Feature)",
					"levelGained": 3,
					"description": "You make an oath to uphold the tenets of your choice below (or create your own with GM approval). While you're following your oath, you have ADV on Checks made to convince non-hostile creatures to join you in doing so.\nTENETS\n• Heart of Bravery: You must be courageous in all things and fight for what is right, whether on the battlefield or within oneself.\n• Light in the Darkness: You must be a beacon of hope for others and bring hope to the hopeless when all seems lost.\n• Instill Pain: Teach your enemies the meaning of pain so they may experience it for themselves and learn to never do it to others again.\n• Peacekeeper: You must always seek peace with your enemies first.\n• Protect the Weak: You must protect those that cannot protect themselves.\n• Unrelenting Effort: You must try your best in all things, never carelessly doing anything.\n• Vengeance: You must seek revenge on those who have harmed you, your loved ones, or the innocent.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Rune Knight",
			"features": [
				{
					"featureName": "Rune Weapon",
					"levelGained": 3,
					"description": "You can inscribe a magical Rune as you bond with your Bound Weapon, which can only bear 1 Rune at a time and lasts until the bond ends. When you complete a Quick Rest, you can change the Rune to another Rune you know. You learn 2 Runes from the following list.",
					"choices": [
						{
							"prompt": "Learn 2 Runes from the list.",
							"count": 2,
							"options": [
								{
									"name": "Earth Rune",
									"description": "Earthquake: When you Smite a target, you can create an area of Difficult Terrain on the ground in a 1 Space Radius Sphere centered on the target. Unmovable: You have ADV on Checks and Saves against being knocked Prone or moved against your will."
								},
								{
									"name": "Flame Rune",
									"description": "Scorching: When you Smite a creature with the Weapon, they must make a Physical Save. Save Failure: The target begins Burning. Hearth: You regain 2 Rest Points when you complete a Short Rest, provided you engaged in Combat since applying this Rune."
								},
								{
									"name": "Frost Rune",
									"description": "Frostbite: When you Smite a creature with the Weapon, they must make a Physical Save. Save Failure: The target is Grappled by ice until the end of your next turn. The creature can attempt to free itself by spend 1 AP to make an Athletics Check against your Save DC. Glacier: When you roll Initiative, you gain 2 Temp HP."
								},
								{
									"name": "Lightning Rune",
									"description": "Charged: When you Smite a creature with the Weapon, they must make a Physical Save. Save Failure: The target is Stunned 1 until the end of your next turn. Quickness: You gain +1 Speed."
								},
								{
									"name": "Water Rune",
									"description": "Wave: When you Smite a creature with the Weapon, you can spend 1 AP to force the target to make a Physical Save. Save Failure: The target is knocked Prone. Healing Waters: When an MP Effect restores your HP, you regain 1 additional HP."
								},
								{
									"name": "Wind Rune",
									"description": "Hurricane: When you Smite a creature with the Weapon, they must make a Physical Save. Save Failure: The target is pushed 1 Space horizontally in a direction of your choice. Wind Swept: You gain +3 Jump Distance and you no longer need to move 2 Spaces before performing a running Jump."
								}
							]
						}
					]
				},
				{
					"featureName": "Rune Expert (Flavor Feature)",
					"levelGained": 3,
					"description": "You have ADV on Checks made to understand the purpose and meaning of any magical rune you can see.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/spellblade_table.json
````json
{
	"className": "Spellblade",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 2,
			"techniquesKnown": 0,
			"manaPoints": 3,
			"cantripsKnown": 1,
			"spellsKnown": 1,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 1,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 1,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 1,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 1,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/traits.ts
````typescript
import type { ITrait } from './types';

export const traitsData: ITrait[] = [
	// Human Traits (p. 108)
	{
		id: 'human_attribute_increase',
		name: 'Attribute Increase',
		description:
			'Choose an Attribute. The chosen Attribute increases by 1 (up to the Attribute Limit).',
		cost: 2,
		effects: [
			{
				type: 'MODIFY_ATTRIBUTE',
				target: 'any_attribute_choice',
				value: 1,
				userChoiceRequired: { prompt: 'Choose an Attribute to increase by 1' }
			}
		]
	},
	{
		id: 'human_skill_expertise',
		name: 'Skill Expertise',
		description:
			'Choose a Skill. Your Mastery Cap and Mastery Level in the chosen Skill both increase by 1. You can only benefit from 1 Feature that increases your Skill Mastery Limit at a time.',
		cost: 2,
		effects: [
			{
				type: 'GRANT_SKILL_EXPERTISE',
				value: { skillId: 'any_skill_choice', capIncrease: 1, levelIncrease: 1 },
				userChoiceRequired: { prompt: 'Choose a skill for Expertise' }
			}
		]
	},
	{
		id: 'human_resolve',
		name: 'Human Resolve',
		description: 'Your Death’s Door Threshold value is expanded by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_DEATH_THRESHOLD_MODIFIER', value: 1 }]
	},
	{
		id: 'human_undying',
		name: 'Undying',
		description: 'You have ADV on Saves against the Doomed Condition.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Doomed' }]
	},
	{
		id: 'human_trade_expertise',
		name: 'Trade Expertise',
		description:
			'Choose a Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1. You can only benefit from 1 Feature that increases your Trade Mastery Limit at a time.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				value: { tradeId: 'any_trade_choice', capIncrease: 1, levelIncrease: 1 },
				userChoiceRequired: { prompt: 'Choose a Trade for Expertise' }
			}
		]
	},
	{
		id: 'human_determination',
		name: 'Human Determination',
		description:
			'Once per Combat, you can give yourself ADV on an Attack Check or Spell Check while Bloodied.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_ADV_ON_CHECK_WHILE_BLOODIED',
				target: 'Attack_or_Spell_Check',
				condition: 'bloodied'
			}
		]
	},
	{
		id: 'human_unbreakable',
		name: 'Unbreakable',
		description: 'You have ADV on Death Saves.',
		cost: 1,
		effects: [{ type: 'GRANT_ADV_ON_SAVE', target: 'Death_Save' }]
	},
	{
		id: 'human_attribute_decrease',
		name: 'Attribute Decrease',
		description:
			'Choose an Attribute. You decrease the chosen Attribute by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [
			{
				type: 'MODIFY_ATTRIBUTE',
				target: 'any_attribute_choice',
				value: -1,
				userChoiceRequired: { prompt: 'Choose an Attribute to decrease by 1' }
			}
		]
	},

	// Elf Traits (p. 108)
	{
		id: 'elf_elven_will',
		name: 'Elven Will',
		description: 'You have ADV on Checks and Saves against being Charmed and put to Sleep.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Charmed' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Sleep_Magic' }
		]
	},
	{
		id: 'elf_nimble',
		name: 'Nimble',
		description:
			'When you take the Dodge Action, you instead gain the benefits of the Full Dodge Action.',
		cost: 2,
		effects: [
			{ type: 'MODIFY_ACTION_BENEFIT', target: 'Dodge_Action', value: 'Full_Dodge_Benefit' }
		]
	},
	{
		id: 'elf_agile_explorer',
		name: 'Agile Explorer',
		description: 'You’re not affected by Difficult Terrain.',
		cost: 2,
		effects: [{ type: 'IGNORE_DIFFICULT_TERRAIN' }]
	},
	{
		id: 'elf_discerning_sight',
		name: 'Discerning Sight',
		description: 'You have ADV on Checks and Saves made to discern through visual illusions.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_CHECKS_SAVES_VS_ILLUSION_VISUAL' }]
	},
	{
		id: 'elf_quick_reactions',
		name: 'Quick Reactions',
		description: 'While you aren’t wearing Armor, you gain +1 PD.',
		cost: 1,
		effects: [{ type: 'MODIFY_PD', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'elf_peerless_sight',
		name: 'Peerless Sight',
		description:
			'You don’t have DisADV as a result of making an Attack with a Weapon at Long Range',
		cost: 1,
		effects: [{ type: 'IGNORE_DISADV_ON_RANGED_ATTACK_AT_LONG_RANGE' }]
	},
	{
		id: 'elf_climb_speed',
		name: 'Climb Speed',
		description: 'You gain a Climb Speed equal to your Movement Speed.',
		cost: 1,
		effects: [{ type: 'GRANT_CLIMB_SPEED_EQUAL_TO_SPEED' }]
	},
	{
		id: 'elf_speed_increase',
		name: 'Speed Increase',
		description: 'Your Speed increases by 1 Space.',
		cost: 2,
		effects: [{ type: 'MODIFY_SPEED', value: 5 }] // 1 Space = 5 feet
	},
	{
		id: 'elf_trade_expertise_elf',
		name: 'Trade Expertise (Elf)',
		description:
			'Choose a Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1. You can only benefit from 1 Feature that increases your Trade Mastery Limit at a time.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				value: { tradeId: 'any_trade_choice', capIncrease: 1, levelIncrease: 1 },
				userChoiceRequired: { prompt: 'Choose a Trade for Expertise' }
			}
		]
	},
	{
		id: 'elf_plant_knowledge',
		name: 'Plant Knowledge',
		description:
			'While within forests, jungles, and swamps, you have ADV on Survival Checks. Additionally, you have ADV on Nature Checks made to recall information about plants.',
		cost: 0,
		isMinor: true,
		effects: [
			{ type: 'GRANT_ADV_ON_SURVIVAL_CHECKS_IN_ENVIRONMENTS', target: 'forests_jungles_swamps' },
			{ type: 'GRANT_ADV_ON_NATURE_CHECKS_ABOUT_PLANTS' }
		]
	},
	{
		id: 'elf_brittle',
		name: 'Brittle',
		description: 'Your AD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_AD', value: -1 }]
	},
	{
		id: 'elf_frail',
		name: 'Frail',
		description: 'Your HP maximum decreases by 2.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_HP_MAX_STATIC', value: -2 }]
	},
	{
		id: 'elf_might_decrease',
		name: 'Might Decrease',
		description: 'Your Might decreases by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'might', value: -1 }]
	},

	// Dwarf Traits (p. 109)
	{
		id: 'dwarf_tough',
		name: 'Tough',
		description: 'Your HP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_HP_MAX_STATIC', value: 1 }]
	},
	{
		id: 'dwarf_toxic_fortitude',
		name: 'Toxic Fortitude',
		description: 'You have Poison Resistance (Half) and ADV on Saves against being Poisoned.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE_HALF', target: 'Poison' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Poisoned' }
		]
	},
	{
		id: 'dwarf_physically_sturdy',
		name: 'Physically Sturdy',
		description: 'You have ADV on Saves against being Impaired, Deafened, or Petrified.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Impaired' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Deafened' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Petrified' }
		]
	},
	{
		id: 'dwarf_iron_stomach',
		name: 'Iron Stomach',
		description: 'You have ADV on Saves against effects that come from consuming food or liquids.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_SAVE_VS_EFFECT_FROM_CONSUMING' }]
	},
	{
		id: 'dwarf_thick_skinned',
		name: 'Thick-Skinned',
		description: 'While you aren’t wearing Armor, you gain +1 AD.',
		cost: 1,
		effects: [{ type: 'MODIFY_AD', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'dwarf_natural_combatant',
		name: 'Natural Combatant',
		description: 'You gain Combat Training with Heavy Armor and All Shields.',
		cost: 1,
		effects: [
			{ type: 'GRANT_COMBAT_TRAINING', target: 'Heavy_Armor' },
			{ type: 'GRANT_COMBAT_TRAINING', target: 'All_Shields' }
		]
	},
	{
		id: 'dwarf_stone_blood',
		name: 'Stone Blood',
		description:
			'You have ADV on Saves against Bleeding. Additionally, you can spend 1 AP to end the Bleeding Condition on yourself.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Bleeding' },
			{ type: 'GRANT_ABILITY', value: 'End_Bleeding_Self_1AP' }
		]
	},
	{
		id: 'dwarf_minor_tremorsense',
		name: 'Minor Tremorsense',
		description: 'You have Tremorsense 3 Spaces.',
		cost: 1,
		effects: [{ type: 'GRANT_TREMORSENSE', value: 3 }]
	},
	{
		id: 'dwarf_stubborn',
		name: 'Stubborn',
		description: 'You have ADV on Saves against being Taunted and against being forcibly moved.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Taunted' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_FORCED_MOVEMENT' }
		]
	},
	{
		id: 'dwarf_trade_expertise',
		name: 'Trade Expertise',
		description:
			'Choose a Crafting or Services Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				value: {
					tradeId: 'any_crafting_or_services_trade_choice',
					capIncrease: 1,
					levelIncrease: 1
				},
				userChoiceRequired: { prompt: 'Choose a Crafting or Services Trade for Expertise' }
			}
		]
	},
	{
		id: 'dwarf_earthen_knowledge',
		name: 'Earthen Knowledge',
		description:
			'While within mountainous and subterranean environments, you have ADV on Survival Checks. Additionally, you have ADV on Nature Checks made to recall information about rocks, soil, crystals, and gems.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_ADV_ON_SURVIVAL_CHECKS_IN_ENVIRONMENTS',
				target: 'mountainous_and_subterranean'
			},
			{ type: 'GRANT_ADV_ON_NATURE_CHECKS_ABOUT_ROCKS_SOIL_CRYSTALS_GEMS' }
		]
	},
	{
		id: 'dwarf_charisma_attribute_decrease',
		name: 'Charisma Attribute Decrease',
		description: 'You decrease your Charisma by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'charisma', value: -1 }]
	},
	{
		id: 'dwarf_short_legged',
		name: 'Short-Legged',
		description: 'Your Speed decreases by 1 Space.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SPEED', value: -5 }]
	},

	// Halfling Traits (p. 109)
	{
		id: 'halfling_small_sized',
		name: 'Small-Sized',
		description: 'Your Size is considered Small.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SIZE', target: 'Small' }]
	},
	{
		id: 'halfling_elusive',
		name: 'Elusive',
		description:
			'When you take the Disengage Action, you instead gain the benefits of the Full Disengage Action.',
		cost: 2,
		effects: [
			{ type: 'MODIFY_ACTION_BENEFIT', target: 'Disengage_Action', value: 'Full_Disengage_Action' }
		]
	},
	{
		id: 'halfling_bravery',
		name: 'Halfling Bravery',
		description: 'You have ADV on Saves against being Intimidated, Rattled, or Frightened',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Intimidated' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Rattled' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Frightened' }
		]
	},
	{
		id: 'halfling_endurance',
		name: 'Halfling Endurance',
		description: 'You have Exhaustion Resistance.',
		cost: 1,
		effects: [{ type: 'GRANT_CONDITION_RESISTANCE', target: 'Exhaustion' }]
	},
	{
		id: 'halfling_deft_footwork',
		name: 'Deft Footwork',
		description:
			'You can move through the space of a hostile creature 1 size larger than you as if it were Difficult Terrain.',
		cost: 1,
		effects: [{ type: 'IGNORE_DIFFICULT_TERRAIN_WHEN_MOVING_THROUGH_SPACE_OF_LARGER_HOSTILE' }]
	},
	{
		id: 'halfling_beast_whisperer',
		name: 'Beast Whisperer',
		description:
			'You can speak to Beasts in a limited manner. They can understand the meanings of simple words, concepts, or states of emotion. You don’t have a special ability to understand them in return.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_LIMITED_COMMUNICATION_WITH_BEASTS' }]
	},
	{
		id: 'halfling_beast_insight',
		name: 'Beast Insight',
		description:
			'You can understand Beasts in a limited manner. You can understand the meaning of their noises and behaviors, though they have no special ability to understand you in return.',
		cost: 1,
		effects: [{ type: 'GRANT_LIMITED_UNDERSTANDING_OF_BEASTS' }]
	},
	{
		id: 'halfling_burst_of_bravery',
		name: 'Burst of Bravery',
		description:
			'Once per Combat, you can end the Intimidated, Rattled, or Frightened Condition on yourself for free at any time.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ABILITY', value: 'End_Intimidated_Rattled_Frightened_Self_OncePerCombat' }
		]
	},
	{
		id: 'halfling_trade_expertise',
		name: 'Trade Expertise',
		description:
			'Choose a Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				value: { tradeId: 'any_trade_choice', capIncrease: 1, levelIncrease: 1 },
				userChoiceRequired: { prompt: 'Choose a Trade for Expertise' }
			}
		]
	},
	{
		id: 'halfling_critter_knowledge',
		name: 'Critter Knowledge',
		description:
			'You have ADV on Nature, Survival, and Animal Checks involving Small size creatures and smaller.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_ADV_ON_CHECKS_INVOLVING_SMALL_CREATURES',
				target: 'Nature_Survival_Animal_Checks'
			}
		]
	},
	{
		id: 'halfling_brittle',
		name: 'Brittle',
		description: 'Your AD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_AD', value: -1 }]
	},
	{
		id: 'halfling_intelligence_attribute_decrease',
		name: 'Intelligence Attribute Decrease',
		description: 'You decrease your Intelligence by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'intelligence', value: -1 }]
	},
	{
		id: 'halfling_short_legged',
		name: 'Short-Legged',
		description: 'Your Speed decreases by 1 Space.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SPEED', value: -5 }]
	},

	// Gnome Traits (p. 110)
	{
		id: 'gnome_small_sized',
		name: 'Small-Sized',
		description: 'Your Size is considered Small.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SIZE', target: 'Small' }]
	},
	{
		id: 'gnome_escape_artist',
		name: 'Escape Artist',
		description:
			'You have ADV on Checks and Saves to avoid or escape being Grappled or Restrained.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_CHECKS_SAVES_TO_AVOID_ESCAPE', target: 'Grappled_or_Restrained' }
		]
	},
	{
		id: 'gnome_magnified_vision',
		name: 'Magnified Vision',
		description:
			'You have ADV on Investigation Checks made on something you’re holding or touching.',
		cost: 1,
		effects: [{ type: 'GRANT_ADV_ON_INVESTIGATION_CHECKS_ON_HELD_TOUCHED' }]
	},
	{
		id: 'gnome_mental_clarity',
		name: 'Mental Clarity',
		description: 'You have ADV on Saves against being Dazed or Stunned.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Dazed' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Stunned' }
		]
	},
	{
		id: 'gnome_strong_minded',
		name: 'Strong-Minded',
		description: 'You gain Psychic Resistance (1).',
		cost: 1,
		effects: [{ type: 'GRANT_RESISTANCE_STATIC', target: 'Psychic', value: 1 }]
	},
	{
		id: 'gnome_predict_weather',
		name: 'Predict Weather',
		description:
			'You can naturally tell what the weather is going to be in the next hour in the area within 1 mile of you. You don’t have DisADV on Checks or Saves as a result of naturally occurring weather.',
		cost: 0,
		isMinor: true,
		effects: [
			{ type: 'GRANT_ABILITY', value: 'Predict_Weather_1Mile_1Hour' },
			{ type: 'IGNORE_DISADV_FROM_NATURAL_WEATHER' }
		]
	},
	{
		id: 'gnome_mana_increase',
		name: 'Mana Increase',
		description: 'Your MP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_MP_MAX', value: 1 }]
	},
	{
		id: 'gnome_trapper',
		name: 'Trapper',
		description:
			'You have ADV on Investigation Checks to spot Traps and on Trickery Checks to Hide Traps.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_INVESTIGATION_CHECKS_TO_SPOT_TRAPS' },
			{ type: 'GRANT_ADV_ON_TRICKERY_CHECKS_TO_HIDE_TRAPS' }
		]
	},
	{
		id: 'gnome_lightning_insulation',
		name: 'Lightning Insulation',
		description: 'You have Lightning Resistance (Half) and can’t be struck by natural lightning.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE_HALF', target: 'Lightning' },
			{ type: 'IMMUNE_TO_NATURAL_LIGHTNING' }
		]
	},
	{
		id: 'gnome_trade_expertise',
		name: 'Trade Expertise',
		description:
			'Choose a Crafting or Subterfuge Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				value: {
					tradeId: 'any_crafting_or_subterfuge_trade_choice',
					capIncrease: 1,
					levelIncrease: 1
				},
				userChoiceRequired: { prompt: 'Choose a Crafting or Subterfuge Trade for Expertise' }
			}
		]
	},
	{
		id: 'gnome_storm_knowledge',
		name: 'Storm Knowledge',
		description:
			'While within rainy, snowy, or stormy environments, you have ADV on Survival Checks. Additionally, you have ADV on Knowledge Checks made to recall information about rain, snow, and storms.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SURVIVAL_CHECKS_IN_ENVIRONMENTS', target: 'rainy_snowy_stormy' },
			{ type: 'GRANT_ADV_ON_KNOWLEDGE_CHECKS_ABOUT_RAIN_SNOW_STORMS' }
		]
	},
	{
		id: 'gnome_agility_attribute_decrease',
		name: 'Agility Decrease',
		description: 'You decrease your Agility by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'agility', value: -1 }]
	},
	{
		id: 'gnome_short_legged',
		name: 'Short-Legged',
		description: 'Your Speed decreases by 1 Space.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SPEED', value: -5 }]
	},

	// Orc Traits (p. 110)
	{
		id: 'orc_cursed_mind',
		name: 'Cursed Mind',
		description: 'You gain Psychic Vulnerability (1).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_VULNERABILITY_STATIC', target: 'Psychic', value: 1 }]
	},
	{
		id: 'orc_rush',
		name: 'Orc Rush',
		description:
			'Once per Combat when you willingly move toward an enemy, you can spend 1 AP to gain Temp HP equal to your Prime Modifier.',
		cost: 2,
		effects: [
			{ type: 'GRANT_TEMP_HP_ONCE_PER_COMBAT_WHEN_MOVE_TOWARD_ENEMY', value: 'Prime_Modifier' }
		]
	},
	{
		id: 'orc_brutal_strikes',
		name: 'Brutal Strikes',
		description:
			'You deal +1 damage when you score a Brutal or Critical Hit with a Melee Weapon or Unarmed Strike.',
		cost: 2,
		effects: [
			{
				type: 'MODIFY_DAMAGE_ON_HIT',
				target: 'Melee_Martial_Attack',
				value: 1,
				condition: 'Brutal_or_Critical_Hit'
			}
		]
	},
	{
		id: 'orc_tough',
		name: 'Tough',
		description: 'Your HP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_HP_MAX_STATIC', value: 1 }]
	},
	{
		id: 'orc_orcish_resolve',
		name: 'Orcish Resolve',
		description: 'You gain 1 additional AP while on Death’s Door.',
		cost: 1,
		effects: [{ type: 'MODIFY_AP_WHILE_DEATHS_DOOR', value: 1 }]
	},
	{
		id: 'orc_already_cursed',
		name: 'Already Cursed',
		description: 'You have ADV on Saves against Curses.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Curses' }]
	},
	{
		id: 'orc_intimidating_shout',
		name: 'Intimidating Shout',
		description:
			'Once per Combat, you can spend 1 AP to let out an Intimidating Shout. All creatures within 5 Spaces that can hear you must make a Charisma Save contested by your Attack Check. Failure: A target is Hindered on the next Attack Check or Spell Attack it makes before the start of your next turn.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', value: 'Intimidating_Shout_OncePerCombat_1AP' }]
	},
	{
		id: 'orc_dash',
		name: 'Orc Dash',
		description:
			'Once per Combat you can use your Minor Action to move, as long as that movement is towards an enemy.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Move_As_Minor_Action_OncePerCombat_Toward_Enemy' }]
	},
	{
		id: 'orc_finishing_blow',
		name: 'Finishing Blow',
		description: 'You deal +1 damage to creatures who are Well-Bloodied.',
		cost: 1,
		effects: [
			{
				type: 'MODIFY_DAMAGE_ON_HIT',
				target: 'Martial_Attacks',
				value: 1,
				condition: 'Well_Bloodied'
			}
		]
	},
	{
		id: 'orc_imposing_presence',
		name: 'Imposing Presence',
		description:
			'Once per Combat when a creature makes an Attack against you, you can force them to make a Charisma Save. Save Failure: They must choose a new target for the Attack. If there are no other targets, then the Attack is wasted.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Force_New_Target_OncePerCombat_Reaction' }]
	},
	{
		id: 'orc_provocation',
		name: 'Provocation',
		description: 'You have DisADV on Checks and Saves against being Taunted.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_DISADV_ON_CHECKS_SAVES_VS_CONDITION', target: 'Taunted' }]
	},
	{
		id: 'orc_reckless',
		name: 'Reckless',
		description: 'Your PD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_PD', value: -1 }]
	},

	// Dragonborn Traits (p. 111)
	{
		id: 'dragonborn_darkvision',
		name: 'Darkvision',
		description: 'You have Darkvision 10 Spaces.',
		cost: 1,
		effects: [{ type: 'GRANT_DARKVISION', value: 10 }]
	},
	{
		id: 'dragonborn_draconic_resistance',
		name: 'Draconic Resistance',
		description: 'You gain Resistance (Half) to your Draconic damage type.',
		cost: 2,
		effects: [{ type: 'GRANT_RESISTANCE_HALF', target: 'Draconic_damage_type' }]
	},
	{
		id: 'dragonborn_draconic_breath_weapon',
		name: 'Draconic Breath Weapon',
		description:
			'You gain a Breath Weapon that you can use by spending 2 AP to exhale destructive power in an Area or Focused against a specific target. You can use this ability once per Long Rest, and regain the ability to use it again when you roll for Initiative.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ABILITY', value: 'Draconic_Breath_Weapon_OncePerLongRest_RegainOnInitiative' }
		]
	},
	{
		id: 'dragonborn_reptilian_superiority',
		name: 'Reptilian Superiority',
		description:
			'You have ADV on Intimidation Checks against reptilian creatures of Medium Size and smaller (not including other Dragonborn).',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_INTIMIDATION_CHECKS_VS_REPTILIAN_MEDIUM_SMALL' }]
	},
	{
		id: 'dragonborn_mana_increase',
		name: 'Mana Increase',
		description: 'Your MP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_MP_MAX', value: 1 }]
	},
	{
		id: 'dragonborn_thick_skinned',
		name: 'Thick-Skinned',
		description: 'While you aren’t wearing Armor, you gain +1 AD.',
		cost: 1,
		effects: [{ type: 'MODIFY_AD', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'dragonborn_second_breath',
		name: 'Second Breath',
		description:
			'You can now use your Draconic Breath Weapon twice per Combat. Additionally, whenever you use your Draconic Breath Weapon, you can spend 2 uses to increase the damage by 2 if its an Area, or by 4 if its Focused.',
		cost: 1,
		prerequisites: ['dragonborn_draconic_breath_weapon'],
		effects: [
			{ type: 'GRANT_ABILITY', value: 'Draconic_Breath_Weapon_TwicePerCombat' },
			{ type: 'GRANT_ABILITY', value: 'Draconic_Breath_Weapon_Enhanced_Damage_Spend_Uses' }
		]
	},
	{
		id: 'dragonborn_concussive_breath',
		name: 'Concussive Breath',
		description:
			'When you use your Draconic Breath Weapon, you can force all targets to make a Physical Save. Save Failure: The target is pushed 1 Space away +1 additional Space for every 5 it fails its Save by.',
		cost: 1,
		prerequisites: ['dragonborn_draconic_breath_weapon'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Draconic_Breath_Weapon_Concussive_Push' }]
	},
	{
		id: 'dragonborn_draconic_affinity',
		name: 'Draconic Affinity',
		description:
			'When you take damage of the same type as your Draconic damage, your next Draconic Breath Weapon deals +1 bonus damage.',
		cost: 1,
		effects: [
			{
				type: 'MODIFY_DAMAGE_ON_NEXT_DRACONIC_BREATH_WEAPON',
				value: 1,
				condition: 'take_same_type_damage'
			}
		]
	},
	{
		id: 'dragonborn_dying_breath',
		name: 'Dying Breath',
		description:
			'Once per Combat when you enter Death’s Door, you regain a use of your Draconic Breath Weapon and can immediately use it as a Reaction for free (0 AP).',
		cost: 1,
		prerequisites: ['dragonborn_draconic_breath_weapon'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Draconic_Breath_Weapon_Reaction_On_Deaths_Door' }]
	},
	{
		id: 'dragonborn_draconic_ward',
		name: 'Draconic Ward',
		description:
			'Once per Combat when you enter Death’s Door, you gain 2 Temp HP. Whenever you’re Hit by a Melee Attack while you have this Temp HP, your Attacker takes 1 Draconic damage.',
		cost: 1,
		effects: [
			{ type: 'GRANT_TEMP_HP_ONCE_PER_COMBAT_ON_DEATHS_DOOR', value: 2 },
			{ type: 'GRANT_DAMAGE_ON_MELEE_HIT_WHILE_TEMP_HP', target: 'Draconic_damage_type', value: 1 }
		]
	},
	{
		id: 'dragonborn_draconic_protection',
		name: 'Draconic Protection',
		description:
			'Once per Combat, when an ally within 20 Spaces is on Death’s Door, you begin to surge with an ancient power. While they remain on Death’s Door their PD and AD increases by 5 until Combat ends.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Increase_PD_AD_Ally_On_Deaths_Door' }]
	},
	{
		id: 'dragonborn_glide_speed',
		name: 'Glide Speed',
		description:
			'You have a set of wings that you can use to horizontally glide and slow your descent. Provided you aren’t Incapacitated, you gain the following benefits while in the air: Controlled Falling: You suffer no damage from Controlled Falling. Altitude Drop: If you end your turn midair, you Controlled Fall 4 Spaces. Glide Speed: You can use your movement to glide horizontally.',
		cost: 2,
		effects: [{ type: 'GRANT_GLIDE_SPEED' }]
	},
	{
		id: 'dragonborn_guardians_bond',
		name: 'Guardian’s Bond',
		description:
			'Once per Combat when an ally enters Death’s Door within 20 Spaces of you, you take an amount of True damage equal to your Prime Modifier.',
		cost: -1,
		isNegative: true,
		effects: [
			{ type: 'TAKE_TRUE_DAMAGE_ONCE_PER_COMBAT_WHEN_ALLY_DEATHS_DOOR', value: 'Prime_Modifier' }
		]
	},

	// Giantborn Traits (p. 112)
	{
		id: 'giantborn_tough',
		name: 'Tough',
		description: 'Your HP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_HP_MAX_STATIC', value: 1 }]
	},
	{
		id: 'giantborn_powerful_build',
		name: 'Powerful Build',
		description: 'You increase by 1 Size, but you occupy the Space of a creature 1 Size smaller.',
		cost: 2,
		effects: [
			{ type: 'MODIFY_SIZE', target: 'Large' },
			{ type: 'MODIFY_SPACE_OCCUPIED', target: '1_Size_Smaller' }
		]
	},
	{
		id: 'giantborn_unstoppable',
		name: 'Unstoppable',
		description: 'You have ADV on Saves against being Slowed or Stunned.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Slowed' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Stunned' }
		]
	},
	{
		id: 'giantborn_giants_resolve',
		name: 'Giant’s Resolve',
		description: 'While on Death’s Door, you reduce all damage taken by 1.',
		cost: 1,
		effects: [{ type: 'REDUCE_DAMAGE_TAKEN', value: 1, condition: 'deaths_door' }]
	},
	{
		id: 'giantborn_unyielding_movement',
		name: 'Unyielding Movement',
		description: 'You’re immune to being Slowed 2 (or higher).',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'IMMUNE_TO_SLOWED_2_OR_HIGHER' }]
	},
	{
		id: 'giantborn_giants_fortitude',
		name: 'Giant’s Fortitude',
		description: 'You also gain the benefits of your Giant’s Resolve Trait while Well-Bloodied.',
		cost: 2,
		prerequisites: ['giantborn_giants_resolve'],
		effects: [{ type: 'GRANT_BENEFIT_WHILE_WELL_BLOODIED', target: 'giantborn_giants_resolve' }]
	},
	{
		id: 'giantborn_strong_body',
		name: 'Strong Body',
		description:
			'Once per Combat when you take damage from an Attack, you can reduce the damage taken by an amount equal to your Might or Agility (your choice).',
		cost: 2,
		effects: [{ type: 'REDUCE_DAMAGE_TAKEN_ONCE_PER_COMBAT', value: 'Might_or_Agility' }]
	},
	{
		id: 'giantborn_mighty_hurl',
		name: 'Mighty Hurl',
		description:
			'You throw creatures 1 Space farther than normal, and objects (including Weapons) 5 Spaces farther than normal.',
		cost: 1,
		effects: [
			{ type: 'MODIFY_THROW_DISTANCE_CREATURES', value: 1 },
			{ type: 'MODIFY_THROW_DISTANCE_OBJECTS', value: 5 }
		]
	},
	{
		id: 'giantborn_titanic_toss',
		name: 'Titanic Toss',
		description:
			'You have ADV on Checks made to throw creatures. Additionally, you don’t have DisADV as a result of making an Attack with a Weapon with the Toss or Thrown Property at Long Range.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_CHECKS', target: 'Throw_Creatures' },
			{ type: 'IGNORE_DISADV_ON_RANGED_ATTACK_WITH_TOSS_THROWN_AT_LONG_RANGE' }
		]
	},
	{
		id: 'giantborn_mighty_leap',
		name: 'Mighty Leap',
		description:
			'You can use your Might instead of Agility to determine your Jump Distance and the damage you take from Falling.',
		cost: 1,
		effects: [{ type: 'USE_ATTRIBUTE_FOR_JUMP_DISTANCE_FALLING_DAMAGE', target: 'Might' }]
	},
	{
		id: 'giantborn_brute',
		name: 'Brute',
		description: 'Once per Combat, you can take the Shove or Grapple Action as a Minor Action.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Shove_or_Grapple_As_Minor_Action_OncePerCombat' }]
	},
	{
		id: 'giantborn_heavy_riser',
		name: 'Heavy Riser',
		description: 'You have to spend 4 Spaces of movement to stand up from Prone.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_MOVEMENT_TO_STAND_UP', value: 4 }]
	},
	{
		id: 'giantborn_clumsiness',
		name: 'Clumsiness',
		description: 'You have DisADV on Agility Checks.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_DISADV_ON_CHECKS', target: 'Agility_Checks' }]
	},
	{
		id: 'giantborn_intelligence_attribute_decrease',
		name: 'Intelligence Decrease',
		description: 'You decrease your Intelligence by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'intelligence', value: -1 }]
	},

	// Angelborn Traits (p. 113)
	{
		id: 'angelborn_radiant_resistance',
		name: 'Radiant Resistance',
		description: 'You have Resistance (Half) to Radiant damage.',
		cost: 1,
		effects: [{ type: 'GRANT_RESISTANCE_HALF', target: 'Radiant' }]
	},
	{
		id: 'angelborn_celestial_magic',
		name: 'Celestial Magic',
		description:
			'You learn 1 Spell of your choice from the Divine Spell List (Holy & Restoration during the Beta). Once per Long Rest, you can cast the chosen Spell spending 1 less MP than normal (minimum of 0 MP). The Spells total MP cost (before all reductions) still can’t exceed your Mana Spend Limit.',
		cost: 2,
		effects: [
			{ type: 'GRANT_SPELL_FROM_LIST', target: 'Divine_Spell_List' },
			{ type: 'REDUCE_MP_COST_ONCE_PER_LONG_REST', value: 1 }
		]
	},
	{
		id: 'angelborn_healing_touch',
		name: 'Healing Touch',
		description:
			'Once per Combat, you can spend 1 AP to touch a creature and Heal it. Make a DC 10 Spell Check. Success: You can restore up to 2 HP to the target. Success (each 5): +1 HP. Failure: You only restore 2 HP.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', value: 'Healing_Touch_OncePerCombat_1AP' }]
	},
	{
		id: 'angelborn_divine_glow',
		name: 'Divine Glow',
		description: 'Your body can emit a Bright Light in a 5 Space radius around you at will.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ABILITY', value: 'Emit_Bright_Light_5Space_Radius_AtWill' }]
	},
	{
		id: 'angelborn_mana_increase',
		name: 'Mana Increase',
		description: 'Your MP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_MP_MAX', value: 1 }]
	},
	{
		id: 'angelborn_celestial_clarity',
		name: 'Celestial Clarity',
		description: 'You have ADV on Saves against being Blinded or Deafened.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Blinded' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Deafened' }
		]
	},
	{
		id: 'angelborn_angelic_insight',
		name: 'Angelic Insight',
		description:
			'Once per Long Rest you can grant yourself ADV on an Insight Check to see if someone is lying.',
		cost: 1,
		effects: [{ type: 'GRANT_ADV_ON_INSIGHT_CHECK_ONCE_PER_LONG_REST', condition: 'see_if_lying' }]
	},
	{
		id: 'angelborn_gift_of_the_angels',
		name: 'Gift of the Angels',
		description:
			'Once per Combat you can spend 1 AP and 1 MP and touch a creature to heal them over time. The creature recovers 1 HP at the start of each of their turns for 1 minute (5 Rounds).',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', value: 'Heal_Over_Time_OncePerCombat_1AP_1MP' }]
	},
	{
		id: 'angelborn_blinding_light',
		name: 'Blinding Light',
		description:
			'Once per Combat, you can spend 1 AP to choose a creature within 5 Spaces and make a Spell Check contested by its Physical Save. Success: The target is Blinded until the end of your next turn.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Blind_Target_OncePerCombat_1AP' }]
	},
	{
		id: 'angelborn_glide_speed',
		name: 'Glide Speed',
		description:
			'You have a set of wings that you can use to horizontally glide and slow your descent. Provided you aren’t Incapacitated, you gain the following benefits while in the air: Controlled Falling: You suffer no damage from Controlled Falling. Altitude Drop: If you end your turn midair, you Controlled Fall 4 Spaces. Glide Speed: You can use your movement to glide horizontally.',
		cost: 2,
		effects: [{ type: 'GRANT_GLIDE_SPEED' }]
	},
	{
		id: 'angelborn_pacifist',
		name: 'Pacifist',
		description:
			'Your divine call is to put others before yourself and resist doing harm. You suffer a -1 penalty to all Checks and Saves made during the first round of Combat.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'PENALTY_ON_CHECKS_SAVES_FIRST_ROUND_OF_COMBAT', value: -1 }]
	},
	{
		id: 'angelborn_umbral_weakness',
		name: 'Umbral Weakness',
		description: 'You have Umbral Vulnerability (1).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_VULNERABILITY_STATIC', target: 'Umbral', value: 1 }]
	},

	// Fiendborn Traits (p. 114)
	{
		id: 'fiendborn_fiendish_resistance',
		name: 'Fiendish Resistance',
		description: 'You gain Resistance (Half) to your Fiendish damage type.',
		cost: 2,
		effects: [{ type: 'GRANT_RESISTANCE_HALF', target: 'Fiendish_damage_type' }]
	},
	{
		id: 'fiendborn_fiendish_magic',
		name: 'Fiendish Magic',
		description:
			'You learn 1 Spell of your choice from the Arcane Spell List from the Destruction or Enchantment Spell Schools. If the Spell deals damage, it must be the same damage type as your Fiendish damage. Once per Long Rest, you can cast the chosen Spell spending 1 less MP than normal (minimum of 0 MP). The Spells total MP cost (before all reductions) still can’t exceed your Mana Spend Limit.',
		cost: 2,
		effects: [
			{
				type: 'GRANT_SPELL_FROM_LIST_SCHOOLS',
				target: 'Arcane_Spell_List',
				schools: ['Destruction', 'Enchantment']
			},
			{
				type: 'REDUCE_MP_COST_ONCE_PER_LONG_REST',
				value: 1,
				condition: 'spell_damage_type_matches_fiendish'
			}
		]
	},
	{
		id: 'fiendborn_darkvision',
		name: 'Darkvision',
		description: 'You have a Darkvision of 10 Spaces.',
		cost: 1,
		effects: [{ type: 'GRANT_DARKVISION', value: 10 }]
	},
	{
		id: 'fiendborn_lights_bane',
		name: 'Light’s Bane',
		description: 'You can spend 1 AP to snuff out a mundane light source within 5 Spaces of you.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ABILITY', value: 'Snuff_Out_Mundane_Light_Source_1AP' }]
	},
	{
		id: 'fiendborn_mana_increase',
		name: 'Mana Increase',
		description: 'Your MP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_MP_MAX', value: 1 }]
	},
	{
		id: 'fiendborn_silver_tongued',
		name: 'Silver-Tongued',
		description:
			'Once per Long Rest you can grant yourself ADV on an Influence Check when trying to deceive someone.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_INFLUENCE_CHECK_ONCE_PER_LONG_REST', condition: 'trying_to_deceive' }
		]
	},
	{
		id: 'fiendborn_fiendish_aura',
		name: 'Fiendish Aura',
		description:
			'You learn the Sorcery Cantrip, but you must choose the type of energy that’s the same as your Fiendish Origin.',
		cost: 1,
		effects: [
			{ type: 'GRANT_SPELL_KNOWN', value: 'Sorcery_Cantrip' },
			{ type: 'SET_SORCERY_ENERGY_TYPE', target: 'Fiendish_Origin' }
		]
	},
	{
		id: 'fiendborn_superior_darkvision',
		name: 'Superior Darkvision',
		description: 'Your Darkvision increases to 20 Spaces.',
		cost: 1,
		prerequisites: ['fiendborn_darkvision'],
		effects: [{ type: 'MODIFY_DARKVISION', value: 20 }]
	},
	{
		id: 'fiendborn_infernal_bravery',
		name: 'Infernal Bravery',
		description: 'You have ADV on Saves against being Intimidated.',
		cost: 1,
		effects: [{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Intimidated' }]
	},
	{
		id: 'fiendborn_intimidator',
		name: 'Intimidator',
		description: 'Once per Combat you can take the Intimidate Action as a Minor Action.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Intimidate_As_Minor_Action_OncePerCombat' }]
	},
	{
		id: 'fiendborn_charming_gaze',
		name: 'Charming Gaze',
		description:
			'You can spend 1 AP to gaze upon a creature you can see within 10 Spaces that can also see you. Make a Spell Check contested by the target’s Repeated Charisma Save. Success: The creature becomes Charmed by you for 1 minute. You can use this ability once per Long Rest, and when you roll for Initiative, or meet some other unique criteria at the GM’s discretion, this ability recharges.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Charm_Target_OncePerLongRest_1AP' }]
	},
	{
		id: 'fiendborn_glide_speed',
		name: 'Glide Speed',
		description:
			'You have a set of wings that you can use to horizontally glide and slow your descent. Provided you aren’t Incapacitated, you gain the following benefits while in the air: Controlled Falling: You suffer no damage from Controlled Falling. Altitude Drop: If you end your turn midair, you Controlled Fall 4 Spaces. Glide Speed: You can use your movement to glide horizontally.',
		cost: 2,
		effects: [{ type: 'GRANT_GLIDE_SPEED' }]
	},
	{
		id: 'fiendborn_radiant_weakness',
		name: 'Radiant Weakness',
		description: 'You have Radiant Vulnerability (1).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_VULNERABILITY_STATIC', target: 'Radiant', value: 1 }]
	},
	{
		id: 'fiendborn_divine_dampening',
		name: 'Divine Dampening',
		description: 'You recover 1 less HP when healed from divine sources.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'REDUCE_HP_REGAINED_FROM_DIVINE_SOURCES', value: 1 }]
	},

	// Beastborn Traits (p. 115-116)
	{
		id: 'beastborn_darkvision',
		name: 'Darkvision',
		description: 'You have Darkvision 10 Spaces.',
		cost: 1,
		effects: [{ type: 'GRANT_DARKVISION', value: 10 }]
	},
	{
		id: 'beastborn_echolocation',
		name: 'Echolocation',
		description:
			'You can spend 1 AP to roar, scream, or screech to gain Blindsight in a 10 Spaces radius that lasts until the start of your next turn. The sound can be heard from up to 100 Spaces away. You gain no benefit from this Trait in an area of Silence.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Echolocation_1AP_10Space_1Round' }]
	},
	{
		id: 'beastborn_keen_sense',
		name: 'Keen Sense',
		description:
			'Choose 1 of the following senses: hearing, sight, or smell. You make Awareness Checks with ADV using the chosen sense.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_ADV_ON_AWARENESS_CHECKS_USING_SENSE',
				target: 'chosen_sense',
				userChoiceRequired: { prompt: 'Choose a sense: hearing, sight, or smell' }
			}
		]
		// This trait can be chosen multiple times, but the interface doesn't directly support that.
		// The logic for handling multiple selections will need to be in the application.
	},
	{
		id: 'beastborn_sunlight_sensitivity',
		name: 'Sunlight Sensitivity',
		description:
			'While you or your target is in sunlight, you have DisADV on Attacks and Awareness Checks that rely on sight.',
		cost: -2,
		isNegative: true,
		effects: [{ type: 'GRANT_DISADV_ON_ATTACKS_AWARENESS_CHECKS_IN_SUNLIGHT' }]
	},
	{
		id: 'beastborn_quick_reactions',
		name: 'Quick Reactions',
		description: 'While you aren’t wearing Armor, you gain +1 PD.',
		cost: 1,
		effects: [{ type: 'MODIFY_PD', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'beastborn_climb_speed',
		name: 'Climb Speed',
		description: 'You gain a Climb Speed equal to your Ground Speed.',
		cost: 1,
		effects: [{ type: 'GRANT_CLIMB_SPEED_EQUAL_TO_SPEED' }]
	},
	{
		id: 'beastborn_spider_climb',
		name: 'Spider Climb',
		description:
			'You can walk without falling on the ceiling and vertical surfaces normally without needing to Climb.',
		cost: 1,
		prerequisites: ['beastborn_climb_speed'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Walk_On_Vertical_Surfaces_Ceilings' }]
	},
	{
		id: 'beastborn_web_walk',
		name: 'Web Walk',
		description:
			'You can walk along and through webs unimpeded. Additionally, you know the location of any creature that’s in contact with the same web.',
		cost: 1,
		effects: [
			{ type: 'IGNORE_DIFFICULT_TERRAIN_FROM_WEBS' },
			{ type: 'KNOW_LOCATION_OF_CREATURES_IN_CONTACT_WITH_WEB' }
		]
	},
	{
		id: 'beastborn_water_breathing',
		name: 'Water Breathing',
		description: 'You can breathe underwater.',
		cost: 1,
		effects: [{ type: 'GRANT_WATER_BREATHING' }]
	},
	{
		id: 'beastborn_swim_speed',
		name: 'Swim Speed',
		description:
			'You gain a Swim Speed equal to your Ground Speed. Additionally, your Breath Duration increases by 3.',
		cost: 1,
		effects: [
			{ type: 'GRANT_SWIM_SPEED_EQUAL_TO_SPEED' },
			{ type: 'MODIFY_BREATH_DURATION', value: 3 }
		]
	},
	{
		id: 'beastborn_speed_increase',
		name: 'Speed Increase',
		description: 'Your Speed increases by 1 Space.',
		cost: 2,
		effects: [{ type: 'MODIFY_SPEED', value: 5 }]
		// This trait can be chosen up to 5 times, but the interface doesn't directly support that.
		// The logic for handling multiple selections will need to be in the application.
	},
	{
		id: 'beastborn_sprint',
		name: 'Sprint',
		description:
			'You can use your Minor Action to take the Move Action. Once you use this Trait, you can’t use it again until you take a turn without taking the Move Action.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', value: 'Move_As_Minor_Action_OncePerTurn_NoMoveAction' }]
	},
	{
		id: 'beastborn_charge',
		name: 'Charge',
		description:
			'If you move at least 2 Spaces in a straight line before making a Melee Attack, the damage of the Attack increases by 1.',
		cost: 2,
		effects: [
			{
				type: 'MODIFY_DAMAGE_ON_MELEE_ATTACK',
				value: 1,
				condition: 'move_2_spaces_straight_before'
			}
		]
	},
	{
		id: 'beastborn_burrow_speed',
		name: 'Burrow Speed',
		description: 'You gain a Burrow Speed equal to half your Movement Speed.',
		cost: 2,
		effects: [{ type: 'GRANT_BURROW_SPEED_HALF_SPEED' }]
	},
	{
		id: 'beastborn_jumper',
		name: 'Jumper',
		description:
			'Your Jump Distance increases by 2, and you can take the Jump Action as a Minor Action.',
		cost: 1,
		effects: [
			{ type: 'MODIFY_JUMP_DISTANCE', value: 2 },
			{ type: 'GRANT_ABILITY', value: 'Jump_As_Minor_Action' }
		]
	},
	{
		id: 'beastborn_strong_jumper',
		name: 'Strong Jumper',
		description:
			'You no longer need to move 2 Spaces before performing a Running Jump, and you take 0 damage from Controlled Falling 5 Spaces or less.',
		cost: 1,
		effects: [
			{ type: 'IGNORE_2_SPACES_MOVEMENT_FOR_RUNNING_JUMP' },
			{ type: 'IGNORE_FALLING_DAMAGE_5_SPACES_OR_LESS' }
		]
	},
	{
		id: 'beastborn_glide_speed',
		name: 'Glide Speed',
		description:
			'You have a set of wings that you can use to horizontally glide and slow your descent. Provided you aren’t Incapacitated, you gain the following benefits while in the air: Controlled Falling: You suffer no damage from Controlled Falling. Altitude Drop: If you end your turn midair, you Controlled Fall 4 Spaces. Glide Speed: You can use your movement to glide horizontally.',
		cost: 2,
		effects: [{ type: 'GRANT_GLIDE_SPEED' }]
	},
	{
		id: 'beastborn_limited_flight',
		name: 'Limited Flight',
		description:
			'You have a set of wings that grant you limited flight. Provided you aren’t Incapacitated, you gain the following benefits: Vertical Ascent: You can spend 2 Spaces of movement to ascend 1 Space vertically. Hover: When you end your turn in the air, you maintain your altitude.',
		cost: 2,
		prerequisites: ['beastborn_glide_speed'],
		effects: [{ type: 'GRANT_LIMITED_FLIGHT' }]
	},
	{
		id: 'beastborn_full_flight',
		name: 'Full Flight',
		description: 'You have a Fly Speed equal to your Ground Speed.',
		cost: 2,
		prerequisites: ['beastborn_limited_flight'],
		effects: [{ type: 'GRANT_FLY_SPEED_EQUAL_TO_SPEED' }]
	},
	{
		id: 'beastborn_flyby',
		name: 'Flyby',
		description: 'You don’t provoke Opportunity Attacks when you Fly out of an enemy’s reach.',
		cost: 1,
		prerequisites: ['beastborn_limited_flight'],
		effects: [{ type: 'IGNORE_OPPORTUNITY_ATTACKS_WHEN_FLY_OUT_OF_REACH' }]
	},
	{
		id: 'beastborn_stealth_feathers',
		name: 'Stealth Feathers',
		description: 'You have ADV on Stealth Checks while Flying.',
		cost: 2,
		prerequisites: ['beastborn_limited_flight'],
		effects: [{ type: 'GRANT_ADV_ON_STEALTH_CHECKS_WHILE_FLYING' }]
	},
	{
		id: 'beastborn_winged_arms',
		name: 'Winged Arms',
		description:
			'Your arms are also your wings. Anytime you use a Glide Speed or Flying Speed, you can’t hold anything in your hands.',
		cost: -1,
		isNegative: true,
		prerequisites: ['beastborn_limited_flight'], // Assuming Limited Flight or Full Flight
		effects: [{ type: 'PENALTY_CANT_HOLD_WHILE_FLYING' }]
	},
	{
		id: 'beastborn_tough',
		name: 'Tough',
		description: 'Your HP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_HP_MAX_STATIC', value: 1 }]
	},
	{
		id: 'beastborn_thick_skinned',
		name: 'Thick-Skinned',
		description: 'While you aren’t wearing Armor, you gain +1 AD.',
		cost: 1,
		effects: [{ type: 'MODIFY_AD', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'beastborn_powerful_build',
		name: 'Powerful Build',
		description: 'You increase by 1 Size, but you occupy the Space of a creature 1 Size smaller.',
		cost: 2,
		effects: [
			{ type: 'MODIFY_SIZE', target: 'Large' },
			{ type: 'MODIFY_SPACE_OCCUPIED', target: '1_Size_Smaller' }
		]
	},
	{
		id: 'beastborn_long_limbed',
		name: 'Long-Limbed',
		description: 'When you make a Melee Martial Attack, your reach is 1 Space greater than normal.',
		cost: 3,
		effects: [{ type: 'MODIFY_MELEE_REACH', value: 1 }]
	},
	{
		id: 'beastborn_secondary_arms',
		name: 'Secondary Arms',
		description:
			'You have 2 slightly smaller secondary arms below your primary pair of arms. They function just like your primary arms, but they can’t wield Weapons with the Heavy Property or Shields.',
		cost: 1,
		effects: [{ type: 'GRANT_SECONDARY_ARMS' }]
	},
	{
		id: 'beastborn_prehensile_appendage',
		name: 'Prehensile Appendage',
		description:
			'You have a prehensile tail or trunk that has a reach of 1 Space and can lift up an amount of pounds equal to your Might times 5 (or half as many kilograms). You can use it to lift, hold, or drop objects, and to push, pull, or grapple creatures. It can’t wield Weapons or Shields, you can’t use tools with it that require manual precision, and you can’t use it in place of Somatic Components for Spells.',
		cost: 1,
		effects: [{ type: 'GRANT_PREHENSILE_APPENDAGE' }]
	},
	{
		id: 'beastborn_hazardous_hide',
		name: 'Hazardous Hide',
		description:
			'You have spikes, retractable barbs, poisonous skin, or some other form of defense mechanism to keep creatures from touching you. Choose 1 of the following damage types: Corrosion, Piercing, or Poison. While you are physically Grappled, your Grappler takes 1 damage of the chosen type at the start of each of its turns. Creatures that start their turn Grappled by you also take this damage.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_DAMAGE_TO_GRAPPLER',
				target: 'chosen_damage_type',
				value: 1,
				userChoiceRequired: { prompt: 'Choose a damage type: Corrosion, Piercing, or Poison' }
			}
		]
	},
	{
		id: 'beastborn_natural_armor',
		name: 'Natural Armor',
		description: 'While not wearing Armor, you gain PDR.',
		cost: 2,
		prerequisites: ['beastborn_thick_skinned'],
		effects: [{ type: 'GRANT_PDR', condition: 'not_wearing_armor' }]
	},
	{
		id: 'beastborn_hard_shell',
		name: 'Hard Shell',
		description:
			'You have a large shell around your body for protection. Your AD increases by 1 (while you’re not wearing Armor), your Movement Speed decreases by 1, and you’re immune to being Flanked.',
		cost: 1,
		prerequisites: ['beastborn_thick_skinned'],
		effects: [
			{ type: 'MODIFY_AD', value: 1, condition: 'not_wearing_armor' },
			{ type: 'MODIFY_SPEED', value: -5 },
			{ type: 'IMMUNE_TO_FLANKING' }
		]
	},
	{
		id: 'beastborn_shell_retreat',
		name: 'Shell Retreat',
		description:
			'Your body has a shell that you can retreat into. You can spend 1 AP to retreat into or come back out of your shell. You gain +5 PD and AD, PDR, EDR and ADV on Might Saves. While in your shell, you’re Prone, you can’t move, you have DisADV on Agility Saves, and you can’t take Reactions.',
		cost: 1,
		prerequisites: ['beastborn_hard_shell'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Retreat_Into_Shell_1AP' }]
	},
	{
		id: 'beastborn_camouflage',
		name: 'Camouflage',
		description:
			'You can change the color and pattern of your body. You have ADV on Stealth Checks while motionless.',
		cost: 2,
		effects: [{ type: 'GRANT_ADV_ON_STEALTH_CHECKS_WHILE_MOTIONLESS' }]
	},
	{
		id: 'beastborn_prowler',
		name: 'Prowler',
		description: 'You have ADV on Stealth Checks while in Darkness.',
		cost: 1,
		effects: [{ type: 'GRANT_ADV_ON_STEALTH_CHECKS_WHILE_IN_DARKNESS' }]
	},
	{
		id: 'beastborn_cold_resistance',
		name: 'Cold Resistance',
		description:
			'You have Cold Resistance (Half) and Resistance to Exhaustion from cold temperatures.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE_HALF', target: 'Cold' },
			{ type: 'GRANT_RESISTANCE_TO_EXHAUSTION', condition: 'cold_temperatures' }
		]
	},
	{
		id: 'beastborn_fire_resistance',
		name: 'Fire Resistance',
		description:
			'You have Fire Resistance (Half) and Resistance to Exhaustion from hot temperatures.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE_HALF', target: 'Fire' },
			{ type: 'GRANT_RESISTANCE_TO_EXHAUSTION', condition: 'hot_temperatures' }
		]
	},
	{
		id: 'beastborn_short_legged',
		name: 'Short-Legged',
		description: 'Your Speed decreases by 1 Space.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SPEED', value: -5 }]
	},
	{
		id: 'beastborn_small_sized',
		name: 'Small-Sized',
		description: 'Your Size is considered Small.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SIZE', target: 'Small' }]
	},
	{
		id: 'beastborn_reckless',
		name: 'Reckless',
		description: 'Your PD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_PD', value: -1 }]
	},
	{
		id: 'beastborn_natural_weapon',
		name: 'Natural Weapon',
		description:
			'You have up to 2 Natural Weapons (claws, horns, fangs, tail, etc.) which you can use to make Unarmed Strikes that deal 1 Bludgeoning, Piercing, or Slashing damage (your choice upon gaining this Trait). You can perform Attack Maneuvers with your Natural Weapons.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_NATURAL_WEAPON',
				value: 1,
				userChoiceRequired: { prompt: 'Choose a damage type: Bludgeoning, Piercing, or Slashing' }
			}
		]
		// This trait can be chosen multiple times, but the interface doesn't directly support that.
		// The logic for handling multiple selections will need to be in the application.
	},
	{
		id: 'beastborn_extended_natural_weapon',
		name: 'Extended Natural Weapon',
		description: 'Your Natural Weapon now has the Reach Property.',
		cost: 2,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_PROPERTY_TO_NATURAL_WEAPON', target: 'Reach' }]
	},
	{
		id: 'beastborn_natural_projectile',
		name: 'Natural Projectile',
		description:
			'You can use your Natural Weapon to make a Ranged Martial Attack with a Range of 10 Spaces. The Natural Weapon might produce a spine, barb, fluid, or other harmful projectile (your choice).',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Natural_Projectile_Ranged_Attack' }]
	},
	{
		id: 'beastborn_natural_weapon_passive',
		name: 'Natural Weapon Passive',
		description:
			'You can choose 1 Weapon Style that fits your desired Natural Weapon. You can benefit from the chosen Weapon Style’s passive with your Natural Weapon.',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [
			{
				type: 'GRANT_WEAPON_STYLE_PASSIVE_TO_NATURAL_WEAPON',
				target: 'chosen_weapon_style',
				userChoiceRequired: { prompt: 'Choose a Weapon Style' }
			}
		]
	},
	{
		id: 'beastborn_rend',
		name: 'Rend',
		description:
			'You can spend 1 AP when making an Attack Check with your Natural Weapon to force the target to make a Physical Save. Failure: Target begins Bleeding.',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Rend_Bleeding_1AP' }]
	},
	{
		id: 'beastborn_retractable_natural_weapon',
		name: 'Retractable Natural Weapon',
		description:
			'Your Natural Weapon is able to be concealed or retracted and gains the Concealable Property (gain ADV on the first Attack Check you make in Combat).',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_PROPERTY_TO_NATURAL_WEAPON', target: 'Concealable' }]
	},
	{
		id: 'beastborn_venomous_natural_weapon',
		name: 'Venomous Natural Weapon',
		description:
			'When you Hit a creature with your Natural Weapon, they make a Physical Save against your Save DC. Failure: The target becomes Impaired until the start of your next turn.',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Venomous_Natural_Weapon_Impaired' }]
	},
	{
		id: 'beastborn_fast_reflexes',
		name: 'Fast Reflexes',
		description:
			'You gain ADV on Initiative Checks and on the first Attack Check you make in Combat.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_INITIATIVE_CHECKS' },
			{ type: 'GRANT_ADV_ON_FIRST_ATTACK_CHECK_IN_COMBAT' }
		]
	},
	{
		id: 'beastborn_mimicry',
		name: 'Mimicry',
		description:
			'You can mimic simple sounds that you’ve heard (such as a baby’s crying, the creak of a door, or single words) and repeat short 3 word phrases that sound identical to what you heard. A creature can make an Insight Check contested by your Trickery Check to determine if this sound is real.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Mimic_Simple_Sounds_Short_Phrases' }]
	},
	{
		id: 'beastborn_intimidating_shout',
		name: 'Intimidating Shout',
		description:
			'Once per Combat, you can spend 1 AP to let out an Intimidating Shout. All creatures within 5 Spaces that can hear you must make a Charisma Save contested by your Attack Check. Failure: A target is Hindered on the next Attack Check or Spell Attack it makes before the start of your next turn.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', value: 'Intimidating_Shout_OncePerCombat_1AP' }]
	},
	{
		id: 'beastborn_toxic_fortitude',
		name: 'Toxic Fortitude',
		description: 'You have Poison Resistance (Half) and ADV on Saves against being Poisoned.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE_HALF', target: 'Poison' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Poisoned' }
		]
	},
	{
		id: 'beastborn_shoot_webs',
		name: 'Shoot Webs',
		description:
			'You can spend 1 AP to shoot web at a target within 5 Spaces. Make an Attack Check contested by the target’s Physical Save. Success: The target is Restrained by webbing and can spend 1 AP on their turn to attempt to escape (Martial Check vs your Save DC). The webbing can also be attacked and destroyed (PD 5, AD 10, 2 HP; Immunity to Bludgeoning, Poison, and Psychic damage).',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', value: 'Shoot_Webs_1AP' }]
	}
];
````

## File: src/lib/rulesdata/_backup_original/types.ts
````typescript
// src/lib/rulesdata/types.ts

// Interface for Attribute Data
export interface IAttributeData {
	id: 'might' | 'agility' | 'charisma' | 'intelligence';
	name: string;
	description: string;
	derivedStats?: Array<{ statName: string; formula: string }>;
}

// Interface for Trait Effects
export interface ITraitEffect {
	type: string; // e.g., 'MODIFY_ATTRIBUTE', 'GRANT_SKILL_EXPERTISE', 'GRANT_FEATURE'
	target?: string; // e.g., attribute ID ('might'), skill ID ('athletics'), feature ID ('rage')
	value?: any; // e.g., number for attribute modification, object for skill expertise details
	condition?: string; // Optional condition for the effect to apply
	userChoiceRequired?: {
		// Details if the user needs to make a choice for this effect
		prompt: string; // Prompt shown to the user
		options?: string[]; // Optional list of specific options (e.g., skill IDs, attribute IDs)
	};
	descriptionOverride?: string; // Optional override for how this effect is described
	subFeature?: string; // Optional sub-feature identifier for complex effects
	schools?: string[]; // Optional list of spell schools associated with the effect
}

// Interface for Traits
export interface ITrait {
	id: string;
	name: string;
	description: string;
	cost: number; // Ancestry points cost
	isMinor?: boolean; // True if this is a Minor Trait
	isNegative?: boolean; // True if this is a Negative Trait (grants points)
	effects?: ITraitEffect[]; // Array of effects the trait grants
	prerequisites?: any[]; // Optional prerequisites for taking this trait
	sourceAncestryId?: string; // ID of the ancestry this trait belongs to (for combined lists)
}

// Interface for Ancestries
export interface IAncestry {
	id: string;
	name: string;
	description: string;
	defaultTraitIds?: string[]; // Traits automatically granted
	expandedTraitIds: string[]; // Traits available for selection
	origin?: {
		// Optional origin property for ancestries with specific origins (e.g., Dragonborn, Fiendborn, Beastborn)
		prompt: string; // Prompt shown to the user for choosing an origin
		options?: string[]; // Optional list of specific options for the origin
	};
	variantTraits?: ITrait[]; // Optional list of variant traits (e.g., Fallen Angelborn, Redeemed Fiendborn)
}

// Interface for Class Feature Choice Options
export interface IClassFeatureChoiceOption {
	value: string; // Internal value for the choice
	label: string; // Display label for the choice
	description?: string; // Optional description for the choice
	effectsOnChoice?: ITraitEffect[]; // Effects granted if this option is chosen
}

// Interface for Class Feature Choices
export interface IClassFeatureChoice {
	id: string; // Internal ID for the choice (e.g., 'sorcerousOrigin')
	prompt: string; // Prompt shown to the user
	type: 'select_one' | 'select_multiple'; // Type of selection
	maxSelections?: number; // Max number of options if type is 'select_multiple'
	options: IClassFeatureChoiceOption[]; // Available options for the choice
}

// Interface for Class Features
export interface IClassFeature {
	id: string;
	name: string;
	description: string;
	level: number; // Level at which the feature is gained
	effects?: ITraitEffect[]; // Effects granted by the feature
}

// Interface for Class Definitions
export interface IClassDefinition {
	id: string;
	name: string;
	description: string;
	// Base stats granted by the class at Level 1
	baseHpContribution: number;
	startingSP: number;
	startingMP: number;
	skillPointGrantLvl1?: number; // Additional skill points granted at Lvl 1 (beyond Int mod)
	tradePointGrantLvl1?: number; // Additional trade points granted at Lvl 1 (beyond Int mod)
	combatTraining?: string[]; // Array of combat training proficiencies (e.g., 'Weapons', 'All Armor')
	maneuversKnownLvl1?: string | number; // Maneuvers known at Level 1 (can be 'All Attack' or a number)
	techniquesKnownLvl1?: number; // Techniques known at Level 1
	saveDCBase: number;
	deathThresholdBase: number;
	moveSpeedBase: number;
	restPointsBase: number;
	gritPointsBase: number; // Base grit points (before Charisma mod)
	initiativeBonusBase: number; // Base initiative bonus (before Agility mod)
	// Add cantripsKnownLvl1, spellsKnownLvl1 if applicable (not for Barbarian L1)
	cantripsKnownLvl1?: number;
	spellsKnownLvl1?: number;

	level1Features: IClassFeature[]; // Features gained at Level 1
	featureChoicesLvl1?: IClassFeatureChoice[]; // Choices available for features at Level 1
	// ... other level-specific data to be added later
}

// Interface for Skill Data
export interface ISkillData {
	id: string;
	name: string;
	attributeAssociation: 'might' | 'agility' | 'charisma' | 'intelligence' | 'prime'; // Associated attribute
	description: string;
}

// Interface for Trade Data
export interface ITradeData {
	id: string;
	name: string;
	attributeAssociation: 'might' | 'agility' | 'charisma' | 'intelligence'; // Associated attribute
	description: string;
	tools?: string; // Required tools for the trade
}

// Interface for Language Data
export interface ILanguageData {
	id: string;
	name: string;
	type: 'standard' | 'exotic'; // Type of language
	description: string;
}
````

## File: src/lib/rulesdata/_backup_original/warlock_features.json
````json
{
	"className": "Warlock",
	"startingEquipment": {
		"weaponsOrShields": ["1 Weapon"],
		"armor": "1 set of Light Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"spellcastingPath": {
		"combatTraining": {
			"armor": ["Light Armor"]
		},
		"spellList": {
			"type": "all_schools",
			"schoolCount": 4,
			"description": "You choose 4 Spell Schools. When you learn a new Spell, you can choose any Spell from the chosen Spell Schools.",
			"betaNote": "The Warlock works in a unique way with Spell Schools, so until more Spells are released in future updates you just get access to any of the \"Premade Lists\" that have been released. You could pick 4 Spell Schools and then grab Spells from across all the Prepared Lists if you want to, but it will be difficult without with the current number of Spells."
		},
		"cantrips": {
			"knownIncreasesBy": "Cantrips Known column of the Warlock Class Table",
			"description": "Cantrips are Spells with the Cantrip Spell Tag."
		},
		"spells": {
			"knownIncreasesBy": "Spells Known column of the Warlock Class Table",
			"description": "These can be Spells with or without the Cantrip Spell Tag."
		},
		"manaPoints": {
			"maximumIncreasesBy": "Mana Points column of the Warlock Class Table"
		}
	},
	"coreFeatures": [
		{
			"featureName": "Warlock Contract",
			"levelGained": 1,
			"description": "You have a binding agreement with your patron that allows you to make sacrifices in exchange for boons.",
			"benefits": [
				{
					"name": "Hasty Bargain",
					"description": "Once per turn when you make a Check, you can spend 1 HP to gain ADV on the Check."
				},
				{
					"name": "Desperate Bargain",
					"description": "Once per Combat, you can spend 1 AP to regain an amount of HP equal to your Prime Modifier. When you do, you become Exposed until the end of your next turn."
				}
			]
		},
		{
			"featureName": "Pact Boon",
			"levelGained": 1,
			"description": "You gain a Pact Boon from your Patron. Choose 1 of the following options: Weapon, Armor, Cantrip, or Familiar.",
			"choices": [
				{
					"prompt": "Choose your Pact Boon.",
					"count": 1,
					"options": [
						{
							"name": "Pact Weapon",
							"description": "You can choose a Weapon in your possession and bond with it, making it your Pact Weapon. You can only have 1 Pact Weapon at a time. If the Weapon has the Ammo property, it manifests its own Ammo when you load it, which immediately vanishes once the Attack is resolved. You gain the following benefits while wielding the Weapon:\n• Weapon Mastery: You're considered to have Training with your Pact Weapon.\n• Maneuvers: You gain access to Attack Maneuvers, and learn 2 additional Save Maneuvers of your choice.\n• Weapon Style Passive: While wielding your Pact Weapon, you benefit from that Weapon Style Passive.\n• Pocket Dimension: Using a Minor Action, you can dismiss the Weapon into a pocket dimension, summon it from that pocket dimension, or summon it from anywhere on the same plane of existence. If you don't have a free hand when you summon it, or you choose not to grab it, it appears in your Space at your feet.\n• New Pact Weapon: Over the course of a Quick Rest, you can touch a Weapon in your possession, bond with it, and make it your new Pact Weapon, ending your bond with your previous Pact Weapon."
						},
						{
							"name": "Pact Armor",
							"description": "You can choose an Armor in your possession and bond with it, making it your Pact Armor. You can only have 1 Pact Armor at a time. You gain the following benefits while wearing the Armor:\n• Armor Mastery: You're considered to have Training with your Pact Armor.\n• Maneuvers: You learn 3 Defensive Maneuvers of your choice.\n• Mystical Armor: You gain MDR.\n• Pocket Dimension: Using a Minor Action, you can dismiss the Armor into a pocket dimension, summon it from that pocket dimension, or summon it from anywhere on the same plane of existence. If you aren't able to wear the Armor when you summon it, or you choose not to wear it, it appears in your Space at your feet.\n• New Pact Armor: Over the course of a Quick Rest, you can touch an Armor in your possession, bond with it, and make it your new Pact Armor, ending your bond with your previous Pact Armor."
						},
						{
							"name": "Pact Cantrip",
							"description": "Choose a Spell you know with the Cantrip Spell Tag. The chosen Spell becomes your Pact Cantrip. When you cast your Pact Cantrip, you gain the following benefits:\n• If the Spell deals damage, it deals an extra +1 damage to Bloodied targets.\n• If the Spell's range is Touch, it becomes 3 Spaces. Otherwise it increases by 5 Spaces.\n• Once per Round, when you cast your Pact Cantrip you can grant your self ADV on the Spell Check.\nChoosing a New Pact Cantrip: When you complete a Long Rest, you can choose a different Spell following the same restrictions. When you do, the new Spell becomes your new Pact Cantrip. You can only have 1 Pact Cantrip at a time."
						},
						{
							"name": "Pact Familiar",
							"description": "You learn the Find Familiar Spell. When you cast the Spell, your Familiar gains 3 additional Familiar Traits of your choice for free."
						}
					]
				}
			]
		},
		{
			"featureName": "Beseech Patron (Flavor Feature)",
			"levelGained": 1,
			"description": "During a Long Rest, while sleeping or meditating, you can access an Inner Sanctum within your mind. Its appearance is influenced by your psyche and is subject to change. While inside your Inner Sanctum, you can attempt to contact your Patron. If they choose to respond, they enter your mind and you might possibly be able to see or hear them. While connected to your Patron in this way, you're aware of your surroundings but you can't take actions or move. Your Patron chooses when to end the connection, or you can make a Mental Save against your own Save DC to force the connection to end.",
			"isFlavor": true
		},
		{
			"featureName": "Life Tap",
			"levelGained": 2,
			"description": "When you produce an MP Effect, you can spend HP in place of MP. The total amount of HP and MP spent can't exceed your Mana Spend Limit. You can use this Feature once per Long Rest, and regain the ability to use it again when you roll for Initiative."
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Eldritch",
			"features": [
				{
					"featureName": "Otherworldly Gift",
					"levelGained": 3,
					"description": "Your patron grants you the following benefits:\n• Psychic Spellcasting: You learn 1 Spell of your choice with the Psychic Spell Tag. When you learn a new Spell, you can choose any Spell that has the Psychic Spell Tag.\n• Forbidden Knowledge: When you complete a Short or Long Rest, you temporarily learn any Spell of your choice. When you cast that Spell, its MP cost is reduced by 1 (minimum of 0). Its total MP cost before the reduction can't exceed your Mana Spend Limit. You forget the Spell immediately after you cast it or complete a Short or Long Rest.\nYou gain the following Warlock Contract option:\n• Eldritch Bargain: When you make an Attack against the PD or AD of a creature, you can spend 1 HP to target its other Defense instead."
				},
				{
					"featureName": "Alien Comprehension (Flavor Feature)",
					"levelGained": 3,
					"description": "You become Fluent in Deep Speech, and you understand the writings and ramblings of lunatics.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Fey",
			"features": [
				{
					"featureName": "Fey Aspect",
					"levelGained": 3,
					"description": "Choose 1 of the following Conditions: Charmed or Intimidated. The chosen Condition becomes your Fey Aspect Condition. You gain the following Benefits:\n• Can't Trick a Trickster: You have ADV on Saves against your Fey Aspect Condition.\n• Fey Step: When you're Hit by an Attack, you can spend 1 AP as a Reaction to teleport up to 3 Spaces to an unoccupied Space you can see. When you do so, you become Invisible until the start of your next turn. You can use this Feature once per Long Rest, and regain the ability to use it again when you roll for Initiative.\nYou gain the following Warlock Contract option:\n• Beguiling Bargain: Once on each of your turns when you cast a Spell or make an Attack that targets at least 1 creature, you can spend 1 HP to force 1 target of your choice to make a Charisma Save against your Save DC. Failure: You subject the target to your Fey Aspect Condition until the end of your next turn."
				},
				{
					"featureName": "Dream Walker (Flavor Feature)",
					"levelGained": 3,
					"description": "While sleeping, you are lucid and can manipulate what appears in your dreams. Additionally, while you're in contact with a sleeping creature you can make a Spell Check against the target's Intelligence Save. Success: You can witness their dream. You choose if the creature notices that you're watching their dream or not. Failure: You can't use this Feature again on that creature until it wakes up.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/warlock_table.json
````json
{
	"className": "Warlock",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 6,
			"cantripsKnown": 2,
			"spellsKnown": 3,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/wizard_features.json
````json
{
	"className": "Wizard",
	"startingEquipment": {
		"weaponsOrShields": ["1 Weapon"],
		"armor": "1 set of Light Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"spellcastingPath": {
		"combatTraining": {
			"armor": ["Light Armor"]
		},
		"spellList": {
			"type": "specific",
			"listName": "Arcane Spell List",
			"betaNote": "You get access to the following \"Premade List\" that have had their Spells pre-selected for you: Fire & Flames, Ice & Illusions, Lightning & Teleportation, or Psychic & Enchantment"
		},
		"cantrips": {
			"knownIncreasesBy": "Cantrips Known column of the Wizard Class Table",
			"description": "Cantrips are Spells with the Cantrip Spell Tag."
		},
		"spells": {
			"knownIncreasesBy": "Spells Known column of the Wizard Class Table",
			"description": "These can be Spells with or without the Cantrip Spell Tag."
		},
		"manaPoints": {
			"maximumIncreasesBy": "Mana Points column of the Wizard Class Table"
		}
	},
	"coreFeatures": [
		{
			"featureName": "Spell School Initiate",
			"levelGained": 1,
			"description": "You've completed training in a specialized School of Magic. Choose a Spell School. You gain the following benefits:",
			"benefits": [
				{
					"name": "School Magic",
					"description": "You learn 1 Arcane Cantrip and 1 Arcane Spell from this Spell School."
				},
				{
					"name": "Signature School",
					"description": "When you cast a Spell from the chosen School, you can reduce its MP cost by 1. Its total MP cost before the reduction still can't exceed your Mana Spend Limit. You can use this Feature once per Long Rest, but regain the ability to use it again when you roll for Initiative."
				}
			]
		},
		{
			"featureName": "Arcane Sigil",
			"levelGained": 1,
			"description": "You can spend 1 AP and 1 MP to create a 1 Space diameter Arcane Sigil on the ground beneath you that lasts for 1 minute. When you create an Arcane Sigil choose 1 Spell School (Enchantment, Necromancy, Protection, etc.) or 1 Spell Tag (Fire, Cold, Teleportation, etc.). The Arcane Sigil radiates magic of the chosen type.\nUsing a Sigil: While a creature is within the area of your Arcane Sigil, it has ADV on Spell Checks to cast or produce the effects of Spells with the chosen Spell School or Spell Tag.\nMoving a Sigil: You can spend 1 AP to teleport one of your Sigils within 10 spaces to your current space, but multiple Sigils can't coexist in the same Space."
		},
		{
			"featureName": "Ritual Caster (Flavor Feature)",
			"levelGained": 1,
			"description": "You learn 1 Arcane Spell with the Ritual Spell Tag each time you gain a Wizard Class Feature (including this one). You can only gain this benefit once per Level. Additionally, when you encounter an Arcane Spell with the Ritual Spell Tag in a form you can study (such as a spellbook, a spell scroll, or from an instructor), you can spend a number of hours equal to the Spell's base MP cost to learn it. You can only cast Spells you learn with this feature as Rituals, unless you learned it from another source.",
			"isFlavor": true
		},
		{
			"featureName": "Prepared Spell",
			"levelGained": 2,
			"description": "When you complete a Long Rest, choose 1 Spell you know. The chosen Spell becomes your Prepared Spell until your next Long Rest. Your Prepared Spell gains the following benefits:",
			"benefits": [
				{
					"name": "Mana Limit Break",
					"description": "When you cast this Spell, you can increase your Mana Spend Limit by 1. You can use this Feature once per Long Rest, but you regain the ability to use it when you roll for Initiative."
				},
				{
					"name": "Rehearsed Casting",
					"description": "During a Spell Duel, Challengers have DisADV on Spell Checks to stop your Spell."
				}
			]
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Portal Mage",
			"features": [
				{
					"featureName": "Portal Magic",
					"levelGained": 3,
					"description": "When you use your Arcane Sigil Feature, you can spend 1 additional MP to create 1 intangible Arcane Portal in a Space you can see within 10 Spaces that is linked to the Sigil. The Portal disappears when its linked Arcane Sigil ends. It grants the following benefits:\n• Arcane Portal: Creatures of your choice within 1 Space of the Sigil or Portal can spend 1 Space of Movement to teleport to an unoccupied Space within 1 Space of the linked Sigil or Portal.\n• Linked Magic: While within 1 Space of the Sigil or Portal, you can cast a Spell or make an Attack as if you were standing in the Space of the linked Sigil or Portal. When you do, you gain the benefits of the Arcane Sigil, regardless of where you're standing.\n• Teleportation Expert: When you learn a new Spell, you can choose any Spell with the Teleportation Spell Tag."
				},
				{
					"featureName": "Portal Sage (Flavor Feature)",
					"levelGained": 3,
					"description": "You have ADV on Checks to learn about the Astromancy Spell School (such as Teleportation magic or Portals). Additionally, if you spend 1 minute observing a portal or teleportation runes, you can make a DC 10 Spell Check to try to understand the inner mechanism of a Portal within 5 Spaces. Success: You learn where it leads to and for how long it has been open. Success (5): You learn how to activate and deactivate it (such as its passphrase, procedures, or any required special item).",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Witch",
			"features": [
				{
					"featureName": "Coven's Gift",
					"levelGained": 3,
					"description": "You learn 1 Spell of your choice with the Curse Spell Tag. When you learn a new Spell, you can choose any Spell with the Curse Spell Tag. Spells with the Curse Spell Tag count as being part of your chosen Spell School for the purposes of your Spell School Initiate Feature.\nBeta Note: DC20 will receive an overhaul of its Spellcasting (and Maneuvers/Techniques) systems in Beta 0.10. Until then, the following Spells are considered to have the Curse Spell Tag: Bane, Befriend, Death Bolt, and Poison Bolt."
				},
				{
					"featureName": "Hex Enhancements",
					"levelGained": 3,
					"description": "You gain the Spell Enhancements listed below, which you can add to any Spell you cast. You can only use 1 of these Spell Enhancements per Spell you cast. MP spent on these Spell Enhancements doesn't count against your Mana Spend Limit. When you use one of these Spell Enhancements, 1 creature of your choice that's targeted by the Spell must make a Repeated Charisma Save against your Spell Check. If the Spell doesn't normally require a Spell Check, you must make one when using one of these Spell Enhancements. Save Failure: The target is subjected to the chosen Hex effects for 1 minute:",
					"choices": [
						{
							"prompt": "Choose a Hex Enhancement to add to a spell.",
							"count": 1,
							"options": [
								{
									"name": "Bewitching Hex (1 MP)",
									"description": "The target becomes Charmed by you for the duration."
								},
								{
									"name": "Reaping/Life Hex (1 MP)",
									"description": "The target takes 1 True damage and you regain 1 HP. This effect repeats at the end of each of its turns for the duration."
								},
								{
									"name": "Vermin Hex (1 MP)",
									"description": "The target can't speak and if its Size is Large or smaller its Size decreases by 1. Its Size decreases by 1 again at the end of each of its turns for the duration until it's tiny."
								}
							]
						}
					]
				},
				{
					"featureName": "Curse Expert (Flavor Feature)",
					"levelGained": 3,
					"description": "You can spend 1 minute focusing your mind to detect the presence of Curses within 20 Spaces. You learn the location of any Cursed creature or Cursed object within range. If you spend 10 minutes in contact with a Cursed creature or object, you learn the nature of the Curse but not the knowledge of how to remove it.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/_backup_original/wizard_table.json
````json
{
	"className": "Wizard",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 8,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 6,
			"cantripsKnown": 2,
			"spellsKnown": 3,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/_new_schema/ancestries.ts
````typescript
import type { Ancestry } from '../schemas/character.schema';

export const ancestriesData: Ancestry[] = [
	{
		id: 'human',
		name: 'Human',
		description:
			'Humans are the most common ancestry in the world, known for their adaptability and resilience.',
		defaultTraitIds: [
			'human_attribute_increase',
			'human_skill_expertise',
			'human_resolve',
			'human_undying'
		],
		expandedTraitIds: [
			'human_trade_expertise',
			'human_determination',
			'human_unbreakable',
			'human_attribute_decrease'
		]
	},
	{
		id: 'elf',
		name: 'Elf',
		description: 'Elves are graceful and long-lived beings with a deep connection to nature.',
		defaultTraitIds: ['elf_elven_will', 'elf_nimble', 'elf_agile_explorer', 'elf_discerning_sight'],
		expandedTraitIds: [
			'elf_quick_reactions',
			'elf_peerless_sight',
			'elf_climb_speed',
			'elf_speed_increase',
			'elf_trade_expertise_elf',
			'elf_plant_knowledge',
			'elf_brittle',
			'elf_frail',
			'elf_might_decrease'
		]
	},
	{
		id: 'dwarf',
		name: 'Dwarf',
		description:
			'Dwarves are a stout and resilient folk, known for their craftsmanship and deep connection to the earth.',
		defaultTraitIds: [
			'dwarf_tough',
			'dwarf_toxic_fortitude',
			'dwarf_physically_sturdy',
			'dwarf_iron_stomach'
		],
		expandedTraitIds: [
			'dwarf_thick_skinned',
			'dwarf_natural_combatant',
			'dwarf_stone_blood',
			'dwarf_minor_tremorsense',
			'dwarf_stubborn',
			'dwarf_earthen_knowledge',
			'dwarf_charisma_attribute_decrease',
			'dwarf_short_legged'
		]
	},
	{
		id: 'halfling',
		name: 'Halfling',
		description: 'Halflings are small, cheerful people with an affinity for nature and simple pleasures.',
		defaultTraitIds: [
			'halfling_small_sized',
			'halfling_elusive',
			'halfling_bravery',
			'halfling_endurance'
		],
		expandedTraitIds: [
			'halfling_deft_footwork',
			'halfling_beast_whisperer',
			'halfling_beast_insight',
			'halfling_burst_of_bravery',
			'halfling_trade_expertise',
			'halfling_critter_knowledge',
			'halfling_brittle',
			'halfling_intelligence_attribute_decrease',
			'halfling_short_legged'
		]
	},
	{
		id: 'gnome',
		name: 'Gnome',
		description: 'Gnomes are small, curious beings with a natural affinity for magic and technology.',
		defaultTraitIds: [
			'gnome_small_sized',
			'gnome_escape_artist',
			'gnome_magnified_vision',
			'gnome_mental_clarity'
		],
		expandedTraitIds: [
			'gnome_strong_minded',
			'gnome_predict_weather',
			'gnome_mana_increase',
			'gnome_trapper',
			'gnome_lightning_insulation',
			'gnome_trade_expertise'
		]
	},
	{
		id: 'orc',
		name: 'Orc',
		description: 'Orcs are fierce warriors with a strong tribal culture and savage fighting instincts.',
		defaultTraitIds: [
			'orc_cursed_mind',
			'orc_rush',
			'orc_brutal_strikes',
			'orc_tough'
		],
		expandedTraitIds: [
			'orc_reckless'
		]
	},
	{
		id: 'dragonborn',
		name: 'Dragonborn',
		description: 'Dragonborn are draconic humanoids with breath weapons and draconic heritage.',
		defaultTraitIds: [
			'dragonborn_darkvision',
			'dragonborn_draconic_resistance',
			'dragonborn_draconic_breath_weapon',
			'dragonborn_thick_skinned'
		],
		expandedTraitIds: []
	},
	{
		id: 'giantborn',
		name: 'Giantborn',
		description: 'Giantborn are descendants of giants, large and strong but sometimes clumsy.',
		defaultTraitIds: [
			'giantborn_giant_blood',
			'giantborn_tough',
			'giantborn_throw_ally',
			'giantborn_clumsy'
		],
		expandedTraitIds: []
	},
	{
		id: 'angelborn',
		name: 'Angelborn',
		description: 'Angelborn have celestial heritage, bringing light and healing but sensitive to darkness.',
		defaultTraitIds: [
			'angelborn_divine_resistance',
			'angelborn_healing_hands',
			'angelborn_light_sensitivity'
		],
		expandedTraitIds: []
	},
	{
		id: 'fiendborn',
		name: 'Fiendborn',
		description: 'Fiendborn have infernal heritage, with dark powers but weakness to holy energy.',
		defaultTraitIds: [
			'fiendborn_darkvision',
			'fiendborn_hellish_resistance',
			'fiendborn_infernal_legacy',
			'fiendborn_holy_vulnerability'
		],
		expandedTraitIds: []
	},
	{
		id: 'beastborn',
		name: 'Beastborn',
		description: 'Beastborn have animal traits, with enhanced senses and natural weapons but wild instincts.',
		defaultTraitIds: [
			'beastborn_keen_senses',
			'beastborn_natural_weapons',
			'beastborn_thick_hide',
			'beastborn_wild_mind'
		],
		expandedTraitIds: []
	}
];

// Helper functions for accessing ancestry data
export const getAncestryData = (id: string): Ancestry | undefined => {
	return ancestriesData.find(ancestry => ancestry.id === id);
};
````

## File: src/lib/rulesdata/_new_schema/barbarian_features.ts
````typescript
import type { ClassDefinition } from '../schemas/character.schema';

export const barbarianClass: ClassDefinition = {
	className: "Barbarian",
	startingStats: {
		hp: 10, // From barbarian_table.json
		sp: 6,
		mp: 0,
		skillPoints: 4,
		tradePoints: 3,
		languagePoints: 2,
		maneuversKnown: 0, // All Attack maneuvers + additional from table
		techniquesKnown: 1,
		cantripsKnown: 0,
		spellsKnown: 0
	},
	coreFeatures: [
		{
			featureName: "Martial Path",
			levelGained: 1,
			description: "You gain combat training and martial prowess.",
			effects: [
				{ type: 'GRANT_COMBAT_TRAINING', target: 'Weapons', value: true },
				{ type: 'GRANT_COMBAT_TRAINING', target: 'All_Armor', value: true },
				{ type: 'GRANT_COMBAT_TRAINING', target: 'All_Shields', value: true },
				{ type: 'GRANT_MANEUVERS', target: 'all_attack', value: true }
			],
			benefits: [
				{
					name: "Combat Training",
					description: "You gain proficiency with Weapons, All Armor, and All Shields.",
					effects: [
						{ type: 'GRANT_COMBAT_TRAINING', target: 'Weapons', value: true },
						{ type: 'GRANT_COMBAT_TRAINING', target: 'All_Armor', value: true },
						{ type: 'GRANT_COMBAT_TRAINING', target: 'All_Shields', value: true }
					]
				},
				{
					name: "Maneuver Knowledge",
					description: "You learn all Attack maneuvers plus additional maneuvers as shown on the Barbarian Class Table.",
					effects: [
						{ type: 'GRANT_MANEUVERS', target: 'all_attack', value: true }
					]
				},
				{
					name: "Stamina Regeneration", 
					description: "Once per round, you can regain up to half your maximum SP when you score a Heavy or Critical Hit against a creature, or when a Heavy or Critical Hit is scored against you.",
					effects: [
						{ type: 'GRANT_ABILITY', target: 'stamina_regen', value: 'Once per round, regain up to half maximum SP when you score or take a Heavy/Critical Hit.' }
					]
				}
			]
		},
		{
			featureName: "Rage",
			levelGained: 1,
			description: "During Combat, you can spend 1 AP and 1 SP to enter a Rage for 1 minute.",
			effects: [
				{ type: 'GRANT_ABILITY', target: 'rage', value: 'Spend 1 AP and 1 SP to Rage for 1 minute: +1 melee damage, ADV on Might Saves, -5 PD, Resistance (Half) to Elemental and Physical damage.' }
			]
		},
		{
			featureName: "Berserker",
			levelGained: 1,
			description: "Your primal savagery grants you the following benefits:",
			benefits: [
				{
					name: "Charge",
					description: "When you make a Melee Martial Attack on your turn, you can move up to 2 Spaces immediately before making the Attack.",
					effects: [
						{ type: 'GRANT_ABILITY', target: 'charge', value: 'Move up to 2 Spaces before making a Melee Martial Attack on your turn.' }
					]
				},
				{
					name: "Berserker Defense",
					description: "While you aren't wearing Armor you gain +2 AD.",
					effects: [
						{ type: 'MODIFY_STAT', target: 'ad', value: 2, condition: 'not_wearing_armor' }
					]
				},
				{
					name: "Fast Movement", 
					description: "You gain +1 Speed while not wearing Armor.",
					effects: [
						{ type: 'MODIFY_STAT', target: 'moveSpeed', value: 1, condition: 'not_wearing_armor' }
					]
				},
				{
					name: "Mighty Leap",
					description: "You can use your Might instead of Agility to determine your Jump Distance and the damage you take from Falling.",
					effects: [
						{ type: 'SET_VALUE', target: 'jumpCalculationAttribute', value: 'might' }
					]
				}
			]
		},
		{
			featureName: "Shattering Force",
			levelGained: 1,
			description: "When you Hit a structure or mundane object with a Melee Attack, it's considered a Critical Hit.",
			isFlavor: true,
			effects: [
				{ type: 'GRANT_ABILITY', target: 'shattering_force', value: 'Melee Attacks against structures and mundane objects are Critical Hits.' }
			]
		},
		{
			featureName: "Battlecry",
			levelGained: 2,
			description: "You can spend 1 AP and 1 SP to release a shout of your choice.",
			effects: [
				{ type: 'GRANT_ABILITY', target: 'battlecry', value: 'Spend 1 AP and 1 SP to release a shout affecting allies within 10 Spaces until start of your next turn.' }
			],
			choices: [
				{
					id: "barbarian_battlecry_choice",
					prompt: "Choose a shout to learn.",
					count: 3, // Learn all three shout options
					options: [
						{
							name: "Fortitude Shout",
							description: "Each creature gains Resistance (1) against the next source of Physical or Elemental damage.",
							effects: [
								{ type: 'GRANT_ABILITY', target: 'fortitude_shout', value: 'Grant allies Resistance (1) against next Physical or Elemental damage.' }
							]
						},
						{
							name: "Fury Shout", 
							description: "Each creature deals +1 damage on their next Attack against 1 target.",
							effects: [
								{ type: 'GRANT_ABILITY', target: 'fury_shout', value: 'Grant allies +1 damage on their next Attack.' }
							]
						},
						{
							name: "Urgent Shout",
							description: "Each creature gains +1 Speed until the start of your next turn.",
							effects: [
								{ type: 'GRANT_ABILITY', target: 'urgent_shout', value: 'Grant allies +1 Speed until start of your next turn.' }
							]
						}
					]
				}
			]
		},
		{
			featureName: "Talent",
			levelGained: 2,
			description: "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent.",
			effects: [
				{ type: 'GRANT_CHOICE', target: 'talent', value: 1 }
			]
		}
	],
	subclasses: [
		{
			subclassName: "Elemental Fury",
			description: "Harness the power of the elements in your rage.",
			features: [
				{
					featureName: "Raging Elements",
					levelGained: 3,
					description: "You can surround yourself with the elements while raging.",
					choices: [
						{
							id: "barbarian_elemental_rage_damage_type",
							prompt: "Choose your Elemental Rage damage type.",
							count: 1,
							options: [
								{
									name: "Cold",
									description: "Your Elemental Rage damage is Cold.",
									effects: [
										{ type: 'GRANT_ABILITY', target: 'elemental_rage_cold', value: 'Elemental Rage damage is Cold. Gain 2 Space Aura while Raging with elemental effects.' }
									]
								},
								{
									name: "Fire",
									description: "Your Elemental Rage damage is Fire.",
									effects: [
										{ type: 'GRANT_ABILITY', target: 'elemental_rage_fire', value: 'Elemental Rage damage is Fire. Gain 2 Space Aura while Raging with elemental effects.' }
									]
								},
								{
									name: "Lightning", 
									description: "Your Elemental Rage damage is Lightning.",
									effects: [
										{ type: 'GRANT_ABILITY', target: 'elemental_rage_lightning', value: 'Elemental Rage damage is Lightning. Gain 2 Space Aura while Raging with elemental effects.' }
									]
								},
								{
									name: "Physical",
									description: "Your Elemental Rage damage is Physical (choose type each Rage).",
									effects: [
										{ type: 'GRANT_ABILITY', target: 'elemental_rage_physical', value: 'Elemental Rage damage is Physical (choose Bludgeoning/Piercing/Slashing each Rage). Gain 2 Space Aura while Raging with elemental effects.' }
									]
								}
							]
						},
						{
							id: "barbarian_aura_type",
							prompt: "Choose 1 additional benefit for your Aura Type.",
							count: 1,
							options: [
								{
									name: "Slowing Aura",
									description: "Spaces within your Aura count as Difficult Terrain for creatures of your choice.",
									effects: [
										{ type: 'GRANT_ABILITY', target: 'slowing_aura', value: 'Aura creates Difficult Terrain for chosen creatures. Failed saves also cause Slowed until end of their next turn.' }
									]
								},
								{
									name: "Splashing Aura",
									description: "Once per Turn when you deal Elemental Rage damage to a creature, you can automatically deal 1 Elemental Rage damage to a creature within 1 Space of it.",
									effects: [
										{ type: 'GRANT_ABILITY', target: 'splashing_aura', value: 'Once per turn, Elemental Rage damage splashes to a creature within 1 Space for 1 damage.' }
									]
								},
								{
									name: "Stunning Aura",
									description: "Once per Turn when a creature within your Aura fails a Save you force it to make, it also can't spend AP on Reactions until the start of its next turn.",
									effects: [
										{ type: 'GRANT_ABILITY', target: 'stunning_aura', value: 'Once per turn, creatures that fail saves in your Aura cannot spend AP on Reactions until start of their next turn.' }
									]
								},
								{
									name: "Pushing Aura",
									description: "When you use your Elemental Blast, creatures affected must make a Physical Save.",
									effects: [
										{ type: 'GRANT_ABILITY', target: 'pushing_aura', value: 'Elemental Blast forces Physical Save; failure moves targets 2 Spaces toward or away from you.' }
									]
								}
							]
						}
					]
				},
				{
					featureName: "Elemental Affinity",
					levelGained: 3,
					description: "You are infused with the power of your Element.",
					isFlavor: true,
					effects: [
						{ type: 'GRANT_ABILITY', target: 'elemental_affinity', value: 'Voice can boom 3x louder, create elemental visual displays, Resistance to environmental Exhaustion.' }
					]
				}
			]
		},
		{
			subclassName: "Spirit Guardian",
			description: "Call upon ancestral spirits to aid you in battle.",
			features: [
				{
					featureName: "Ancestral Guardian", 
					levelGained: 3,
					description: "Bestowed Protection and Spiritual Aura while Raging.",
					effects: [
						{ type: 'GRANT_CHOICE', target: 'guardian_maneuver', value: 1 },
						{ type: 'GRANT_RESISTANCE', target: 'Mystical', value: 1, condition: 'raging' },
						{ type: 'GRANT_ABILITY', target: 'spiritual_aura', value: 'While Raging: 5 Space Aura allows Shove on any creature, use Parry/Protect/Raise Shield on any creature in Aura.' }
					],
					choices: [
						{
							id: "barbarian_guardian_maneuver",
							prompt: "Learn 1 of the following Maneuvers (or any Maneuver if you know all 3).",
							count: 1,
							options: [
								{
									name: "Parry",
									description: "Learn the Parry maneuver.",
									effects: [
										{ type: 'GRANT_CHOICE', target: 'maneuver', value: 'Parry' }
									]
								},
								{
									name: "Protect",
									description: "Learn the Protect maneuver.", 
									effects: [
										{ type: 'GRANT_CHOICE', target: 'maneuver', value: 'Protect' }
									]
								},
								{
									name: "Raise Shield",
									description: "Learn the Raise Shield maneuver.",
									effects: [
										{ type: 'GRANT_CHOICE', target: 'maneuver', value: 'Raise Shield' }
									]
								}
							]
						}
					]
				},
				{
					featureName: "Ancestral Knowledge",
					levelGained: 3,
					description: "You have ADV on Checks to recall information about the history of your Ancestries.",
					isFlavor: true,
					effects: [
						{ type: 'GRANT_ABILITY', target: 'ancestral_knowledge', value: 'ADV on Checks about your Ancestries\' history. Once per Long Rest: ADV on a Trade or Language Check.' }
					]
				}
			]
		}
	]
};
````

## File: src/lib/rulesdata/_new_schema/champion_features.ts
````typescript
/**
 * Champion Class Definition - New Effect Schema
 * Based on DC20 Champion features
 */

import type { ClassDefinition } from '../schemas/character.schema';

export const championClass: ClassDefinition = {
  className: 'Champion',
  startingStats: {
    hp: 10,
    sp: 6,
    mp: 0,
    skillPoints: 3,
    tradePoints: 3,
    languagePoints: 2,
    maneuversKnown: 4,
    techniquesKnown: 1,
    cantripsKnown: 0,
    spellsKnown: 0
  },
  coreFeatures: [
    {
      featureName: 'Martial Path',
      levelGained: 1,
      description: 'You gain extensive combat training.',
      effects: [
        { type: 'GRANT_COMBAT_TRAINING', target: 'Weapons', value: true },
        { type: 'GRANT_COMBAT_TRAINING', target: 'All_Armors', value: true },
        { type: 'GRANT_COMBAT_TRAINING', target: 'All_Shields', value: true },
        { type: 'GRANT_ABILITY', target: 'learns_all_attack_maneuvers', value: 'You learn all Attack Maneuvers.' },
        { type: 'GRANT_ABILITY', target: 'stamina_regen', value: 'Once per round, regain up to half maximum SP when you perform a Maneuver.' }
      ]
    },
    {
      featureName: 'Master-at-Arms',
      levelGained: 1,
      description: 'Your training in warfare has granted you extensive weapon mastery.',
      benefits: [
        {
          name: 'Weapon Master',
          description: 'At the start of each of your turns, you can freely swap any Weapon you are currently wielding in each hand for any other Weapon without provoking Opportunity Attacks.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'weapon_master', value: 'Free weapon swapping at start of turn without provoking Opportunity Attacks.' }
          ]
        },
        {
          name: 'Maneuver Master',
          description: 'You learn 2 Maneuvers of your choice.',
          effects: [
            { type: 'GRANT_CHOICE', target: 'maneuver', value: 2 }
          ]
        },
        {
          name: 'Technique Master',
          description: 'You learn 1 Technique of your choice. Once per Combat, when you perform a Technique you can reduce its SP cost by 1.',
          effects: [
            { type: 'GRANT_CHOICE', target: 'technique', value: 1 },
            { type: 'GRANT_ABILITY', target: 'technique_master', value: 'Once per Combat: reduce a Technique\'s SP cost by 1.' }
          ]
        }
      ]
    },
    {
      featureName: 'Fighting Spirit',
      levelGained: 1,
      description: 'You stand ready for Combat at any moment.',
      benefits: [
        {
          name: 'Combat Readiness',
          description: 'At the start of your first turn in Combat, you gain one of the following benefits: Brace (Dodge Action + ADV on next Save) or Advance (Move Action + ADV on next Physical Check).',
          effects: [
            { type: 'GRANT_ABILITY', target: 'combat_readiness', value: 'First turn in Combat: choose Brace (Dodge + ADV on Save) or Advance (Move + ADV on Physical Check).' }
          ]
        },
        {
          name: 'Second Wind',
          description: 'Once per Combat when you start your turn Bloodied, you can regain 2 HP and 1 SP.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'second_wind', value: 'Once per Combat when Bloodied at turn start: regain 2 HP and 1 SP.' }
          ]
        }
      ]
    },
    {
      featureName: 'Know Your Enemy',
      levelGained: 1,
      description: 'You can spend 1 minute observing or interacting with a creature out of Combat (or spend 1 AP in Combat) to learn information about its physical capabilities compared to your own.',
      isFlavor: true,
      effects: [
        { type: 'GRANT_ABILITY', target: 'know_your_enemy', value: 'Spend 1 minute (or 1 AP in Combat) to assess creature\'s Might, Agility, PD, AD, or HP vs. yours (DC 10 Knowledge/Insight).' }
      ]
    },
    {
      featureName: 'Adaptive Tactics',
      levelGained: 2,
      description: 'When you roll for Initiative, and at the end of each of your turns, you gain a d8 Tactical Die if you don\'t already have one.',
      effects: [
        { type: 'GRANT_ABILITY', target: 'adaptive_tactics', value: 'Gain d8 Tactical Die at Initiative and end of turns. Spend for: Assault (+die to Attack), Defense (+die to PD/AD), or Mobility (+die to Move/Jump).' }
      ]
    }
  ],
  subclasses: []
};
````

## File: src/lib/rulesdata/_new_schema/cleric_features.ts
````typescript
/**
 * Cleric Class Definition - New Effect Schema
 * Based on the DC20 rule analysis from classAndAncestryAndCalcRefactor.md
 */

import type { ClassDefinition } from '../schemas/character.schema';

export const clericClass: ClassDefinition = {
  className: 'Cleric',
  startingStats: {
    hp: 8,
    sp: 0,
    mp: 6,
    skillPoints: 3,
    tradePoints: 3,
    languagePoints: 2,
    maneuversKnown: 0,
    techniquesKnown: 0,
    cantripsKnown: 2,
    spellsKnown: 3
  },
  coreFeatures: [
    {
      featureName: 'Spellcasting Path',
      levelGained: 1,
      description: 'You gain the ability to cast spells and use divine magic.',
      effects: [
        { type: 'GRANT_COMBAT_TRAINING', target: 'Light_Armor', value: true },
        { type: 'GRANT_COMBAT_TRAINING', target: 'Light_Shields', value: true }
      ]
    },
    {
      featureName: 'Cleric Order',
      levelGained: 1,
      description: 'Your connection to your deity grants you divine powers.',
      choices: [
        {
          id: 'cleric_divine_damage',
          prompt: 'Choose your Divine Damage type',
          count: 1,
          options: [
            {
              name: 'Cold',
              description: 'Your divine damage is Cold.',
              effects: [{ type: 'GRANT_ABILITY', target: 'divine_damage_cold', value: 'Your Divine Damage type is Cold.' }]
            },
            {
              name: 'Fire',
              description: 'Your divine damage is Fire.',
              effects: [{ type: 'GRANT_ABILITY', target: 'divine_damage_fire', value: 'Your Divine Damage type is Fire.' }]
            },
            {
              name: 'Lightning',
              description: 'Your divine damage is Lightning.',
              effects: [{ type: 'GRANT_ABILITY', target: 'divine_damage_lightning', value: 'Your Divine Damage type is Lightning.' }]
            },
            {
              name: 'Acid',
              description: 'Your divine damage is Acid.',
              effects: [{ type: 'GRANT_ABILITY', target: 'divine_damage_acid', value: 'Your Divine Damage type is Acid.' }]
            },
            {
              name: 'Poison',
              description: 'Your divine damage is Poison.',
              effects: [{ type: 'GRANT_ABILITY', target: 'divine_damage_poison', value: 'Your Divine Damage type is Poison.' }]
            },
            {
              name: 'Psychic',
              description: 'Your divine damage is Psychic.',
              effects: [{ type: 'GRANT_ABILITY', target: 'divine_damage_psychic', value: 'Your Divine Damage type is Psychic.' }]
            }
          ]
        },
        {
          id: 'cleric_divine_domain',
          prompt: 'Choose 2 Divine Domains',
          count: 2,
          options: [
            {
              name: 'Magic',
              description: 'Your Maximum MP increases by 1. You also learn 1 additional Spell with the Restoration Spell Tag.',
              effects: [
                { type: 'MODIFY_STAT', target: 'mpMax', value: 1 },
                { type: 'GRANT_SPELL', target: 'restoration_tag', value: 1 }
              ]
            },
            {
              name: 'Peace',
              description: 'You gain Combat Training with Heavy Armor, Heavy Shields, and Weapons. Additionally, you learn 2 Defensive Maneuvers of your choice.',
              effects: [
                { type: 'GRANT_COMBAT_TRAINING', target: 'Heavy_Armor', value: true },
                { type: 'GRANT_COMBAT_TRAINING', target: 'Heavy_Shields', value: true },
                { type: 'GRANT_COMBAT_TRAINING', target: 'Weapons', value: true },
                { type: 'GRANT_CHOICE', target: 'defensive_maneuver', value: 2 }
              ]
            },
            {
              name: 'War',
              description: 'You gain Combat Training with Heavy Armor, Heavy Shields, and Weapons. Additionally, you learn 2 Attack Maneuvers of your choice.',
              effects: [
                { type: 'GRANT_COMBAT_TRAINING', target: 'Heavy_Armor', value: true },
                { type: 'GRANT_COMBAT_TRAINING', target: 'Heavy_Shields', value: true },
                { type: 'GRANT_COMBAT_TRAINING', target: 'Weapons', value: true },
                { type: 'GRANT_CHOICE', target: 'attack_maneuver', value: 2 }
              ]
            },
            {
              name: 'Life',
              description: 'Your Maximum HP increases by 1. You also learn 1 additional Spell with the Restoration Spell Tag.',
              effects: [
                { type: 'MODIFY_STAT', target: 'hpMax', value: 1 },
                { type: 'GRANT_SPELL', target: 'restoration_tag', value: 1 }
              ]
            },
            {
              name: 'Death',
              description: 'You gain 1 Skill Point. You also learn 1 additional Cantrip with the Restoration Spell Tag.',
              effects: [
                { type: 'MODIFY_STAT', target: 'skillPoints', value: 1 },
                { type: 'GRANT_CANTRIP', target: 'restoration_tag', value: 1 }
              ]
            },
            {
              name: 'Nature',
              description: 'You learn 1 additional Spell with the Elemental Spell Tag. You also gain 1 Trade Point.',
              effects: [
                { type: 'GRANT_SPELL', target: 'elemental_tag', value: 1 },
                { type: 'MODIFY_STAT', target: 'tradePoints', value: 1 }
              ]
            },
            {
              name: 'Ancestral',
              description: 'You gain 2 Ancestry Points, which you can spend on Traits for your chosen Ancestry.',
              effects: [
                { type: 'MODIFY_STAT', target: 'ancestryPoints', value: 2 }
              ]
            },
            {
              name: 'Knowledge',
              description: 'Your Mastery Limit increases by 1 for all Knowledge Trades. You also gain 2 Skill Points.',
              effects: [
                { type: 'MODIFY_STAT', target: 'knowledgeMasteryLimit', value: 1 },
                { type: 'MODIFY_STAT', target: 'skillPoints', value: 2 }
              ]
            },
            {
              name: 'Trickery',
              description: 'You learn 1 additional Cantrip with the Illusion Spell Tag. Your Mastery Limit for one Skill of your choice increases by 1.',
              effects: [
                { type: 'GRANT_CANTRIP', target: 'illusion_tag', value: 1 },
                { type: 'GRANT_SKILL_EXPERTISE', target: 'any_skill', value: { capIncrease: 1, levelIncrease: 0 }, userChoice: { prompt: 'Choose a Skill for increased Mastery Limit' } }
              ]
            },
            {
              name: 'Light',
              description: 'You learn 1 additional Cantrip with the Holy Spell Tag. Additionally, you learn the Light Cantrip.',
              effects: [
                { type: 'GRANT_CANTRIP', target: 'holy_tag', value: 1 },
                { type: 'GRANT_CANTRIP', target: 'light_cantrip', value: 1 }
              ]
            }
          ]
        }
      ]
    },
    {
      featureName: 'Knowledge',
      levelGained: 1,
      description: 'Your divine connection enhances your understanding.',
      effects: [
        { type: 'MODIFY_STAT', target: 'knowledgeMasteryLimit', value: 1 },
        { type: 'MODIFY_STAT', target: 'skillPoints', value: 2 }
      ]
    },
    {
      featureName: 'Divine Blessing',
      levelGained: 2,
      description: 'You can spend 2 AP to grant a creature within 5 Spaces a d8 Help Die for any d20 Check, Attack, or Save. You can do this a number of times equal to your Charisma (minimum 1), and you regain all uses when you finish a Long Rest.',
      effects: [
        { type: 'GRANT_ABILITY', target: 'divine_blessing', value: 'Spend 2 AP to grant d8 Help Die within 5 Spaces, uses = Charisma (min 1) per Long Rest.' }
      ]
    }
  ],
  subclasses: []
};
````

## File: src/lib/rulesdata/_new_schema/hunter_features.ts
````typescript
/**
 * Hunter Class Definition - New Effect Schema
 * Based on the DC20 rule analysis from classAndAncestryAndCalcRefactor.md
 */

import type { ClassDefinition } from '../schemas/character.schema';

export const hunterClass: ClassDefinition = {
  className: 'Hunter',
  startingStats: {
    hp: 9,
    sp: 6,
    mp: 0,
    skillPoints: 5,
    tradePoints: 4,
    languagePoints: 2,
    maneuversKnown: 4,
    techniquesKnown: 1,
    cantripsKnown: 0,
    spellsKnown: 0
  },
  coreFeatures: [
    {
      featureName: 'Martial Path',
      levelGained: 1,
      description: 'You gain training in martial combat.',
      effects: [
        { type: 'GRANT_COMBAT_TRAINING', target: 'Weapons', value: true },
        { type: 'GRANT_COMBAT_TRAINING', target: 'Light_Armor', value: true },
        { type: 'GRANT_COMBAT_TRAINING', target: 'Light_Shields', value: true },
        { type: 'GRANT_ABILITY', target: 'learns_all_attack_maneuvers', value: 'You learn all Attack Maneuvers.' }
      ]
    },
    {
      featureName: "Hunter's Mark",
      levelGained: 1,
      description: 'You can spend 1 AP and 1 SP to focus on and mark a creature you can see within 15 Spaces as your quarry. While marked, you gain ADV on Awareness and Survival Checks to find the target, the first Martial Attack against your target on your turn has ADV and ignores PDR, and Heavy/Critical Hits grant a d8 Help Die to the next Attack against the target. The mark lasts until the target is on a different Plane, you Long Rest, fall Unconscious, or mark another creature.',
      effects: [
        { type: 'GRANT_ABILITY', target: 'hunters_mark', value: "Mark a creature (1 AP + 1 SP): ADV on Awareness/Survival to find, first Martial Attack has ADV and ignores PDR, Heavy/Critical Hits grant d8 Help Die." }
      ]
    },
    {
      featureName: 'Favored Terrain',
      levelGained: 1,
      description: 'You are particularly familiar with specific environments. While in your Favored Terrains, you have ADV on Stealth and Survival Checks and cannot be Surprised.',
      choices: [
        {
          id: 'hunter_favored_terrain',
          prompt: 'Choose 2 types of Favored Terrain',
          count: 2,
          options: [
            {
              name: 'Grassland',
              description: 'Your Speed and Jump Distance increases by 1.',
              effects: [
                { type: 'MODIFY_STAT', target: 'moveSpeed', value: 1 },
                { type: 'MODIFY_STAT', target: 'jumpDistance', value: 1 },
                { type: 'GRANT_ABILITY', target: 'favored_terrain_grassland', value: 'In grassland: ADV on Stealth and Survival, cannot be Surprised.' }
              ]
            },
            {
              name: 'Forest',
              description: 'You have ADV on Stealth Checks when you take the Hide Action.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'favored_terrain_forest', value: 'In forest: ADV on Stealth and Survival, cannot be Surprised, ADV on Stealth when Hiding.' }
              ]
            },
            {
              name: 'Desert',
              description: 'You have Fire Resistance (Half) and are not affected by Exhaustion from hot temperatures.',
              effects: [
                { type: 'GRANT_RESISTANCE', target: 'Fire', value: 'half' },
                { type: 'GRANT_ABILITY', target: 'favored_terrain_desert', value: 'In desert: ADV on Stealth and Survival, cannot be Surprised, immune to hot temperature Exhaustion.' }
              ]
            },
            {
              name: 'Mountain',
              description: 'You gain a Climb Speed equal to your Movement Speed.',
              effects: [
                { type: 'GRANT_MOVEMENT', target: 'climb', value: 'equal_to_speed' },
                { type: 'GRANT_ABILITY', target: 'favored_terrain_mountain', value: 'In mountains: ADV on Stealth and Survival, cannot be Surprised.' }
              ]
            },
            {
              name: 'Swamp',
              description: 'You have Poison Resistance (Half) and are not affected by Difficult Terrain.',
              effects: [
                { type: 'GRANT_RESISTANCE', target: 'Poison', value: 'half' },
                { type: 'GRANT_ABILITY', target: 'favored_terrain_swamp', value: 'In swamp: ADV on Stealth and Survival, cannot be Surprised, ignore Difficult Terrain.' }
              ]
            },
            {
              name: 'Coast',
              description: 'You gain a Swim Speed equal to your Movement Speed.',
              effects: [
                { type: 'GRANT_MOVEMENT', target: 'swim', value: 'equal_to_speed' },
                { type: 'GRANT_ABILITY', target: 'favored_terrain_coast', value: 'In coastal areas: ADV on Stealth and Survival, cannot be Surprised.' }
              ]
            },
            {
              name: 'Arctic',
              description: 'You have Cold Resistance (Half) and are not affected by Exhaustion from cold temperatures.',
              effects: [
                { type: 'GRANT_RESISTANCE', target: 'Cold', value: 'half' },
                { type: 'GRANT_ABILITY', target: 'favored_terrain_arctic', value: 'In arctic: ADV on Stealth and Survival, cannot be Surprised, immune to cold temperature Exhaustion.' }
              ]
            },
            {
              name: 'Subterranean',
              description: 'You have Darkvision 10 Spaces and Tremorsense 3 Spaces.',
              effects: [
                { type: 'GRANT_SENSE', target: 'darkvision', value: 10 },
                { type: 'GRANT_SENSE', target: 'tremorsense', value: 3 },
                { type: 'GRANT_ABILITY', target: 'favored_terrain_subterranean', value: 'Underground: ADV on Stealth and Survival, cannot be Surprised.' }
              ]
            },
            {
              name: 'Urban',
              description: 'Your Mastery Limit for Social Skills increases by 1.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'favored_terrain_urban', value: 'In urban areas: ADV on Stealth and Survival, cannot be Surprised, +1 Social Skills Mastery Limit.' }
              ]
            }
          ]
        }
      ]
    },
    {
      featureName: "Hunter's Strike",
      levelGained: 2,
      description: 'When you make a Martial Attack against the target of your Hunter\'s Mark, you can spend 1 SP to deal +1d8 damage of the Weapon\'s damage type. If the Attack was a Heavy Hit, the damage becomes +2d8. If the Attack was a Critical Hit, the damage becomes +3d8.',
      effects: [
        { type: 'GRANT_ABILITY', target: 'hunters_strike', value: "Against Hunter's Mark target: spend 1 SP for +1d8 damage (+2d8 Heavy Hit, +3d8 Critical Hit)." }
      ]
    },
    {
      featureName: 'Bestiary',
      levelGained: 3,
      description: 'Your knowledge of creatures grants you tactical advantages when facing them.',
      effects: [
        { type: 'GRANT_ABILITY', target: 'bestiary', value: 'You have extensive knowledge of creature weaknesses and behaviors for tactical advantage.' }
      ]
    }
  ],
  subclasses: []
};
````

## File: src/lib/rulesdata/_new_schema/monk_features.ts
````typescript
import type { ClassDefinition } from '../schemas/character.schema';

export const monkClass: ClassDefinition = {
	id: 'monk',
	name: 'Monk',
	startingEquipment: {
		weaponsOrShields: ['2 Weapons', '3 Weapons with the Toss or Thrown Property'],
		armor: '1 set of Light Armor',
		packs: 'X or Y Packs (Adventuring Packs Coming Soon)'
	},
	martialPath: {
		combatTraining: {
			weapons: ['Weapons'],
			armor: ['Light Armor']
		},
		maneuvers: {
			learnsAllAttack: true,
			additionalKnown: 'Maneuvers Known column of the Monk Class Table'
		},
		techniques: {
			additionalKnown: 'Techniques Known column of the Monk Class Table'
		},
		staminaPoints: {
			maximumIncreasesBy: 'Stamina Points column of the Monk Class Table'
		},
		staminaRegen: {
			description: 'Once per round, you can regain up to half your maximum SP when you succeed on an Attack Check, Athletics Check, or Acrobatics Check.',
			conditions: []
		}
	},
	coreFeatures: [
		{
			id: 'monk_training',
			featureName: 'Monk Training',
			levelGained: 1,
			description: 'Your martial arts training grants you greater offense, defense, and movement.',
			effects: [
				{
					type: 'GRANT_ABILITY',
					target: 'iron_palm',
					value: 'Your limbs are considered Natural Weapons with the Impact Property that deal 1 Bludgeoning damage.'
				},
				{
					type: 'MODIFY_STAT',
					target: 'pd',
					value: 2,
					condition: 'not_wearing_armor'
				},
				{
					type: 'MODIFY_STAT',
					target: 'moveSpeed',
					value: 1,
					condition: 'not_wearing_armor'
				},
				{
					type: 'MODIFY_STAT',
					target: 'jumpDistance',
					value: 1,
					condition: 'not_wearing_armor'
				},
				{
					type: 'GRANT_ABILITY',
					target: 'step_of_wind',
					value: 'While not wearing Armor: move on vertical surfaces and across liquids, use Prime Modifier for Jump Distance and Fall damage.'
				}
			]
		},
		{
			id: 'monk_stance',
			featureName: 'Monk Stance',
			levelGained: 1,
			description: 'You learn 2 Monk Stances. You can enter/swap stances at the start of your turn or spend 1 SP to swap during your turn.',
			effects: [
				{
					type: 'GRANT_CHOICE',
					target: 'monk_stances',
					value: {
						prompt: 'Learn 2 Monk Stances',
						count: 2,
						options: [
							'bear_stance',
							'bull_stance', 
							'cobra_stance',
							'gazelle_stance',
							'tiger_stance',
							'turtle_stance'
						]
					},
					userChoice: {
						prompt: 'Choose 2 Monk Stances to learn',
						options: [
							'Bear Stance (Big Hits)',
							'Bull Stance (Knockback)',
							'Cobra Stance (Counter)',
							'Gazelle Stance (Nimble)',
							'Tiger Stance (Mobility)',
							'Turtle Stance (Defense)'
						]
					}
				}
			]
		},
		{
			id: 'mastery_progression',
			featureName: 'Mastery Progression',
			levelGained: 1,
			description: 'You gain Combat Mastery progression as shown on the class table.',
			effects: [
				{
					type: 'MODIFY_STAT',
					target: 'combatMastery',
					value: 'level_based'
				}
			]
		}
	]
};
````

## File: src/lib/rulesdata/_new_schema/rogue_features.ts
````typescript
import type { ClassDefinition } from '../schemas/character.schema';

export const rogueClass: ClassDefinition = {
	id: 'rogue',
	name: 'Rogue',
	startingEquipment: {
		weaponsOrShields: ['3 Weapons', '1 Shield'],
		armor: '1 set of Light Armor',
		packs: 'X or Y Packs (Adventuring Packs Coming Soon)'
	},
	martialPath: {
		combatTraining: {
			weapons: ['Weapons'],
			armor: ['Light Armor']
		},
		maneuvers: {
			learnsAllAttack: true,
			additionalKnown: 'Maneuvers Known column of the Rogue Class Table'
		},
		techniques: {
			additionalKnown: 'Techniques Known column of the Rogue Class Table'
		},
		staminaPoints: {
			maximumIncreasesBy: 'Stamina Points column of the Rogue Class Table'
		}
	},
	coreFeatures: [
		{
			id: 'rogue_expertise',
			featureName: 'Expertise',
			levelGained: 1,
			description: 'Choose 2 Skills. Your Mastery Cap and Mastery Level in those Skills both increase by 1.',
			effects: [
				{
					type: 'GRANT_SKILL_EXPERTISE',
					target: 'any_skill',
					value: { capIncrease: 1, levelIncrease: 1 },
					userChoice: {
						prompt: 'Choose 2 Skills for Expertise',
						count: 2
					}
				}
			]
		},
		{
			id: 'sneak_attack',
			featureName: 'Sneak Attack',
			levelGained: 1,
			description: 'Once per turn, you can deal extra damage when you have ADV on an Attack Check or when you Flank the target.',
			effects: [
				{
					type: 'GRANT_ABILITY',
					target: 'sneak_attack',
					value: 'Once per turn: extra damage on attacks with ADV or when Flanking.'
				}
			]
		},
		{
			id: 'thieves_cant',
			featureName: 'Thieves\' Cant',
			levelGained: 1,
			description: 'You know a secret mix of dialect, jargon, and code that allows you to hide messages in seemingly normal conversation.',
			effects: [
				{
					type: 'GRANT_ABILITY',
					target: 'thieves_cant',
					value: 'Secret language for hiding messages in normal conversation.'
				}
			]
		},
		{
			id: 'cunning_action',
			featureName: 'Cunning Action',
			levelGained: 2,
			description: 'You can use your Minor Action to take the Disengage, Hide, or Dash action.',
			effects: [
				{
					type: 'GRANT_ABILITY',
					target: 'cunning_action',
					value: 'Use Minor Action for Disengage, Hide, or Dash.'
				}
			]
		}
	]
};
````

## File: src/lib/rulesdata/_new_schema/sorcerer_features.ts
````typescript
import type { ClassDefinition } from '../schemas/character.schema';

export const sorcererClass: ClassDefinition = {
	id: 'sorcerer',
	name: 'Sorcerer',
	startingEquipment: {
		weaponsOrShields: ['2 Weapons'],
		armor: '1 set of Light Armor',
		packs: 'X or Y Packs (Adventuring Packs Coming Soon)'
	},
	spellcasterPath: {
		spellcastingProgression: 'full',
		spellcastingAttribute: 'charisma',
		spellsKnown: {
			description: 'Spells Known column of the Sorcerer Class Table'
		},
		ritualCasting: false,
		spellPreparation: false
	},
	coreFeatures: [
		{
			id: 'draconic_bloodline',
			featureName: 'Draconic Bloodline',
			levelGained: 1,
			description: 'Choose a draconic ancestor. You gain resistance to the associated damage type and bonus spells.',
			effects: [
				{
					type: 'GRANT_CHOICE',
					target: 'draconic_bloodline',
					value: {
						prompt: 'Choose your Draconic Bloodline',
						options: ['red', 'blue', 'green', 'black', 'white', 'gold', 'silver', 'bronze', 'copper', 'brass']
					},
					userChoice: {
						prompt: 'Choose your Draconic Ancestor',
						options: [
							'Red Dragon (Fire)',
							'Blue Dragon (Lightning)', 
							'Green Dragon (Poison)',
							'Black Dragon (Acid)',
							'White Dragon (Cold)',
							'Gold Dragon (Fire)',
							'Silver Dragon (Cold)',
							'Bronze Dragon (Lightning)',
							'Copper Dragon (Acid)',
							'Brass Dragon (Fire)'
						]
					}
				}
			]
		},
		{
			id: 'draconic_resilience',
			featureName: 'Draconic Resilience',
			levelGained: 1,
			description: 'Your hit point maximum increases by 1, and it increases by 1 again whenever you gain a level in this class.',
			effects: [
				{
					type: 'MODIFY_STAT',
					target: 'hpMax',
					value: 1
				}
			]
		},
		{
			id: 'sorcery_points',
			featureName: 'Sorcery Points',
			levelGained: 2,
			description: 'You have sorcery points equal to your sorcerer level. You can use these to cast additional spells or enhance your magic.',
			effects: [
				{
					type: 'GRANT_RESOURCE',
					target: 'sorcery_points',
					value: 'level'
				}
			]
		},
		{
			id: 'metamagic',
			featureName: 'Metamagic',
			levelGained: 3,
			description: 'You gain the ability to twist your spells to suit your needs. You learn metamagic options that you can use with sorcery points.',
			effects: [
				{
					type: 'GRANT_CHOICE',
					target: 'metamagic_options',
					value: {
						prompt: 'Choose 2 Metamagic options',
						count: 2,
						options: ['careful_spell', 'distant_spell', 'empowered_spell', 'extended_spell', 'heightened_spell', 'quickened_spell', 'subtle_spell', 'twinned_spell']
					},
					userChoice: {
						prompt: 'Choose 2 Metamagic options',
						options: [
							'Careful Spell',
							'Distant Spell',
							'Empowered Spell',
							'Extended Spell',
							'Heightened Spell',
							'Quickened Spell',
							'Subtle Spell',
							'Twinned Spell'
						]
					}
				}
			]
		}
	]
};
````

## File: src/lib/rulesdata/_new_schema/spellblade_features.ts
````typescript
import type { ClassDefinition } from '../schemas/character.schema';

export const spellbladeClass: ClassDefinition = {
	id: 'spellblade',
	name: 'Spellblade',
	startingEquipment: {
		weaponsOrShields: ['3 Weapons', '1 Shield'],
		armor: '1 set of Light Armor',
		packs: 'X or Y Packs (Adventuring Packs Coming Soon)'
	},
	hybridPath: {
		martialAspect: {
			combatTraining: {
				weapons: ['Weapons'],
				armor: ['Light Armor', 'Heavy Armor'],
				shields: ['All Shields']
			},
			maneuvers: {
				learnsAllAttack: true,
				additionalKnown: 'Maneuvers Known column of the Spellblade Class Table'
			},
			techniques: {
				additionalKnown: 'Techniques Known column of the Spellblade Class Table'
			},
			staminaPoints: {
				maximumIncreasesBy: 'Stamina Points column of the Spellblade Class Table'
			}
		},
		spellcastingAspect: {
			spellcastingProgression: 'half',
			spellcastingAttribute: 'intelligence',
			spellsKnown: {
				description: 'Spells Known column of the Spellblade Class Table'
			},
			ritualCasting: true,
			spellPreparation: true
		}
	},
	coreFeatures: [
		{
			id: 'fighting_style',
			featureName: 'Fighting Style',
			levelGained: 1,
			description: 'You adopt a particular style of fighting as your specialty. Choose one Fighting Style.',
			effects: [
				{
					type: 'GRANT_CHOICE',
					target: 'fighting_style',
					value: {
						prompt: 'Choose a Fighting Style',
						options: ['defense', 'dueling', 'great_weapon_fighting', 'protection', 'two_weapon_fighting']
					},
					userChoice: {
						prompt: 'Choose your Fighting Style',
						options: [
							'Defense (+1 AD while wearing armor)',
							'Dueling (+2 damage with one-handed weapons)',
							'Great Weapon Fighting (reroll 1s and 2s on damage)',
							'Protection (use reaction to impose DisADV)',
							'Two-Weapon Fighting (add ability modifier to off-hand damage)'
						]
					}
				}
			]
		},
		{
			id: 'spellstrike',
			featureName: 'Spellstrike',
			levelGained: 2,
			description: 'When you cast a spell that requires a Spell Attack, you can deliver the spell through a weapon attack.',
			effects: [
				{
					type: 'GRANT_ABILITY',
					target: 'spellstrike',
					value: 'Deliver touch spells through weapon attacks.'
				}
			]
		},
		{
			id: 'arcane_weapon',
			featureName: 'Arcane Weapon',
			levelGained: 2,
			description: 'You can use a bonus action to imbue a weapon you\'re holding with magical energy.',
			effects: [
				{
					type: 'GRANT_ABILITY',
					target: 'arcane_weapon',
					value: 'Imbue weapons with magical energy for enhanced damage.'
				}
			]
		}
	]
};
````

## File: src/lib/rulesdata/_new_schema/traits.ts
````typescript
import type { Trait } from '../schemas/character.schema';

export const traitsData: Trait[] = [
	// Human Traits (p. 108)
	{
		id: 'human_attribute_increase',
		name: 'Attribute Increase',
		description:
			'Choose an Attribute. The chosen Attribute increases by 1 (up to the Attribute Limit).',
		cost: 2,
		effects: [
			{
				type: 'MODIFY_ATTRIBUTE',
				target: 'any_attribute',
				value: 1,
				userChoice: { prompt: 'Choose an Attribute to increase by 1', options: ['might', 'agility', 'charisma', 'intelligence'] }
			}
		]
	},
	{
		id: 'human_skill_expertise',
		name: 'Skill Expertise',
		description:
			'Choose a Skill. Your Mastery Cap and Mastery Level in the chosen Skill both increase by 1. You can only benefit from 1 Feature that increases your Skill Mastery Limit at a time.',
		cost: 2,
		effects: [
			{
				type: 'GRANT_SKILL_EXPERTISE',
				target: 'any_skill',
				value: { capIncrease: 1, levelIncrease: 1 },
				userChoice: { prompt: 'Choose a skill for Expertise' }
			}
		]
	},
	{
		id: 'human_resolve',
		name: 'Human Resolve',
		description: 'Your Deaths Door Threshold value is expanded by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'deathThresholdModifier', value: 1 }]
	},
	{
		id: 'human_undying',
		name: 'Undying',
		description: 'You have ADV on Saves against the Doomed Condition.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_SAVE', target: 'Doomed', value: 'ADV' }]
	},
	{
		id: 'human_trade_expertise',
		name: 'Trade Expertise',
		description:
			'Choose a Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1. You can only benefit from 1 Feature that increases your Trade Mastery Limit at a time.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				target: 'any_trade',
				value: { capIncrease: 1, levelIncrease: 1 },
				userChoice: { prompt: 'Choose a Trade for Expertise' }
			}
		]
	},
	{
		id: 'human_determination',
		name: 'Human Determination',
		description:
			'Once per Combat, you can give yourself ADV on an Attack Check or Spell Check while Bloodied.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_ABILITY',
				target: 'determination',
				value: 'Once per Combat, you can give yourself ADV on an Attack Check or Spell Check while Bloodied.'
			}
		]
	},
	{
		id: 'human_unbreakable',
		name: 'Unbreakable',
		description: 'You have ADV on Death Saves.',
		cost: 1,
		effects: [{ type: 'GRANT_ADV_ON_SAVE', target: 'Death_Save', value: 'ADV' }]
	},
	{
		id: 'human_attribute_decrease',
		name: 'Attribute Decrease',
		description:
			'Choose an Attribute. You decrease the chosen Attribute by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [
			{
				type: 'MODIFY_ATTRIBUTE',
				target: 'any_attribute',
				value: -1,
				userChoice: { prompt: 'Choose an Attribute to decrease by 1', options: ['might', 'agility', 'charisma', 'intelligence'] }
			}
		]
	},

	// Elf Traits (p. 108)
	{
		id: 'elf_elven_will',
		name: 'Elven Will',
		description: 'You have ADV on Checks and Saves against being Charmed and put to Sleep.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Charmed', value: 'ADV' },
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Sleep_Magic', value: 'ADV' }
		]
	},
	{
		id: 'elf_nimble',
		name: 'Nimble',
		description:
			'When you take the Dodge Action, you instead gain the benefits of the Full Dodge Action.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ABILITY', target: 'nimble', value: 'When you take the Dodge Action, you gain the benefits of the Full Dodge Action.' }
		]
	},
	{
		id: 'elf_agile_explorer',
		name: 'Agile Explorer',
		description: 'You are not affected by Difficult Terrain.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'agile_explorer', value: 'You are not affected by Difficult Terrain.' }]
	},
	{
		id: 'elf_discerning_sight',
		name: 'Discerning Sight',
		description: 'You have ADV on Checks and Saves made to discern through visual illusions.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_CHECK', target: 'Discern Visual Illusions', value: 'ADV' }]
	},
	{
		id: 'elf_quick_reactions',
		name: 'Quick Reactions',
		description: 'While you are not wearing Armor, you gain +1 PD.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'pd', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'elf_peerless_sight',
		name: 'Peerless Sight',
		description:
			'You do not have DisADV as a result of making an Attack with a Weapon at Long Range',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'peerless_sight', value: 'You do not have DisADV on Ranged Weapon Attacks at Long Range.' }]
	},
	{
		id: 'elf_climb_speed',
		name: 'Climb Speed',
		description: 'You gain a Climb Speed equal to your Movement Speed.',
		cost: 1,
		effects: [{ type: 'GRANT_MOVEMENT', target: 'climb', value: 'equal_to_speed' }]
	},
	{
		id: 'elf_speed_increase',
		name: 'Speed Increase',
		description: 'Your Speed increases by 1 Space.',
		cost: 2,
		effects: [{ type: 'MODIFY_STAT', target: 'moveSpeed', value: 1 }]
	},
	{
		id: 'elf_trade_expertise_elf',
		name: 'Trade Expertise (Elf)',
		description:
			'Choose a Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1. You can only benefit from 1 Feature that increases your Trade Mastery Limit at a time.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				target: 'any_trade',
				value: { capIncrease: 1, levelIncrease: 1 },
				userChoice: { prompt: 'Choose a Trade for Expertise' }
			}
		]
	},
	{
		id: 'elf_plant_knowledge',
		name: 'Plant Knowledge',
		description:
			'While within forests, jungles, and swamps, you have ADV on Survival Checks. Additionally, you have ADV on Nature Checks made to recall information about plants.',
		cost: 0,
		isMinor: true,
		effects: [
			{ type: 'GRANT_ABILITY', target: 'plant_knowledge', value: 'You have ADV on Survival Checks in forests, jungles, and swamps, and ADV on Nature Checks about plants.' }
		]
	},
	{
		id: 'elf_brittle',
		name: 'Brittle',
		description: 'Your AD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_STAT', target: 'ad', value: -1 }]
	},
	{
		id: 'elf_frail',
		name: 'Frail',
		description: 'Your HP maximum decreases by 2.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_STAT', target: 'hpMax', value: -2 }]
	},
	{
		id: 'elf_might_decrease',
		name: 'Might Decrease',
		description: 'Your Might decreases by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'might', value: -1 }]
	},

	// Dwarf Traits (p. 109)
	{
		id: 'dwarf_tough',
		name: 'Tough',
		description: 'Your HP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'hpMax', value: 1 }]
	},
	{
		id: 'dwarf_toxic_fortitude',
		name: 'Toxic Fortitude',
		description: 'You have Poison Resistance (Half) and ADV on Saves against being Poisoned.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE', target: 'Poison', value: 'half' },
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Poisoned', value: 'ADV' }
		]
	},
	{
		id: 'dwarf_physically_sturdy',
		name: 'Physically Sturdy',
		description: 'You have ADV on Saves against being Impaired, Deafened, or Petrified.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Impaired', value: 'ADV' },
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Deafened', value: 'ADV' },
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Petrified', value: 'ADV' }
		]
	},
	{
		id: 'dwarf_iron_stomach',
		name: 'Iron Stomach',
		description: 'You have ADV on Saves against effects that come from consuming food or liquids.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'iron_stomach', value: 'You have ADV on Saves against effects from consuming food or liquids.' }]
	},
	{
		id: 'dwarf_thick_skinned',
		name: 'Thick-Skinned',
		description: 'While you are not wearing Armor, you gain +1 AD.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'ad', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'dwarf_natural_combatant',
		name: 'Natural Combatant',
		description: 'You gain Combat Training with Heavy Armor and All Shields.',
		cost: 1,
		effects: [
			{ type: 'GRANT_COMBAT_TRAINING', target: 'Heavy_Armor', value: true },
			{ type: 'GRANT_COMBAT_TRAINING', target: 'All_Shields', value: true }
		]
	},
	{
		id: 'dwarf_stone_blood',
		name: 'Stone Blood',
		description:
			'You have ADV on Saves against Bleeding. Additionally, you can spend 1 AP to end the Bleeding Condition on yourself.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Bleeding', value: 'ADV' },
			{ type: 'GRANT_ABILITY', target: 'stone_blood', value: 'You can spend 1 AP to end the Bleeding Condition on yourself.' }
		]
	},
	{
		id: 'dwarf_minor_tremorsense',
		name: 'Minor Tremorsense',
		description: 'You have Tremorsense 3 Spaces.',
		cost: 1,
		effects: [{ type: 'GRANT_SENSE', target: 'tremorsense', value: 3 }]
	},
	{
		id: 'dwarf_stubborn',
		name: 'Stubborn',
		description: 'You have ADV on Saves against being Taunted and against being forcibly moved.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Taunted', value: 'ADV' },
			{ type: 'GRANT_ABILITY', target: 'stubborn', value: 'You have ADV on Saves against being forcibly moved.' }
		]
	},
	{
		id: 'dwarf_earthen_knowledge',
		name: 'Earthen Knowledge',
		description:
			'While underground, you have ADV on Survival Checks. Additionally, you have ADV on Nature Checks made to recall information about stones, gems, and metals.',
		cost: 0,
		isMinor: true,
		effects: [
			{ type: 'GRANT_ABILITY', target: 'earthen_knowledge', value: 'You have ADV on Survival Checks while underground and ADV on Nature Checks about stones, gems, and metals.' }
		]
	},
	{
		id: 'dwarf_charisma_attribute_decrease',
		name: 'Charisma Decrease',
		description: 'Your Charisma decreases by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'charisma', value: -1 }]
	},
	{
		id: 'dwarf_short_legged',
		name: 'Short-Legged',
		description: 'Your Speed decreases by 1 Space.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_STAT', target: 'moveSpeed', value: -1 }]
	},

	// Halfling Traits (p. 109)
	{
		id: 'halfling_small_sized',
		name: 'Small-Sized',
		description: 'Your Size is considered Small.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'small_size', value: 'Your Size is considered Small.' }]
	},
	{
		id: 'halfling_elusive',
		name: 'Elusive',
		description: 'When you take the Disengage Action, you instead gain the benefits of the Full Disengage Action.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'elusive', value: 'When you take the Disengage Action, you gain the benefits of the Full Disengage Action.' }]
	},
	{
		id: 'halfling_bravery',
		name: 'Halfling Bravery',
		description: 'You have ADV on Saves against being Intimidated, Rattled, or Frightened',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Intimidated', value: 'ADV' },
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Rattled', value: 'ADV' },
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Frightened', value: 'ADV' }
		]
	},
	{
		id: 'halfling_endurance',
		name: 'Halfling Endurance',
		description: 'You have Exhaustion Resistance.',
		cost: 1,
		effects: [{ type: 'GRANT_RESISTANCE', target: 'Exhaustion', value: 'condition' }]
	},
	{
		id: 'halfling_deft_footwork',
		name: 'Deft Footwork',
		description: 'You can move through the space of a hostile creature 1 size larger than you as if it were Difficult Terrain.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'deft_footwork', value: 'You can move through the space of a hostile creature 1 size larger as if it were Difficult Terrain.' }]
	},
	{
		id: 'halfling_beast_whisperer',
		name: 'Beast Whisperer',
		description: 'You can speak to Beasts in a limited manner. They can understand the meanings of simple words, concepts, or states of emotion.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'beast_whisperer', value: 'You can speak to Beasts in a limited manner.' }]
	},
	{
		id: 'halfling_beast_insight',
		name: 'Beast Insight',
		description: 'You can understand Beasts in a limited manner. You can understand the meaning of their noises and behaviors.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'beast_insight', value: 'You can understand Beasts in a limited manner.' }]
	},
	{
		id: 'halfling_burst_of_bravery',
		name: 'Burst of Bravery',
		description: 'Once per Combat, you can end the Intimidated, Rattled, or Frightened Condition on yourself for free at any time.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'burst_of_bravery', value: 'Once per Combat: end Intimidated, Rattled, or Frightened on yourself for free.' }]
	},
	{
		id: 'halfling_trade_expertise',
		name: 'Trade Expertise',
		description: 'Choose a Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				target: 'any_trade',
				value: { capIncrease: 1, levelIncrease: 1 },
				userChoice: { prompt: 'Choose a Trade for Expertise' }
			}
		]
	},
	{
		id: 'halfling_critter_knowledge',
		name: 'Critter Knowledge',
		description: 'You have ADV on Nature, Survival, and Animal Checks involving Small size creatures and smaller.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'critter_knowledge', value: 'You have ADV on Nature, Survival, and Animal Checks involving Small creatures.' }]
	},
	{
		id: 'halfling_brittle',
		name: 'Brittle',
		description: 'Your AD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_STAT', target: 'ad', value: -1 }]
	},
	{
		id: 'halfling_intelligence_attribute_decrease',
		name: 'Intelligence Decrease',
		description: 'Your Intelligence decreases by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'intelligence', value: -1 }]
	},
	{
		id: 'halfling_short_legged',
		name: 'Short-Legged',
		description: 'Your Speed decreases by 1 Space.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_STAT', target: 'moveSpeed', value: -1 }]
	},

	// Gnome Traits (p. 110) 
	{
		id: 'gnome_small_sized',
		name: 'Small-Sized',
		description: 'Your Size is considered Small.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'small_size', value: 'Your Size is considered Small.' }]
	},
	{
		id: 'gnome_escape_artist',
		name: 'Escape Artist',
		description: 'You have ADV on Checks and Saves to avoid or escape being Grappled or Restrained.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'escape_artist', value: 'You have ADV on Checks and Saves to avoid or escape being Grappled or Restrained.' }]
	},
	{
		id: 'gnome_magnified_vision',
		name: 'Magnified Vision',
		description: 'You have ADV on Investigation Checks made on something you are holding or touching.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'magnified_vision', value: 'You have ADV on Investigation Checks on things you are holding or touching.' }]
	},
	{
		id: 'gnome_mental_clarity',
		name: 'Mental Clarity',
		description: 'You have ADV on Saves against being Dazed or Stunned.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Dazed', value: 'ADV' },
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Stunned', value: 'ADV' }
		]
	},
	{
		id: 'gnome_strong_minded',
		name: 'Strong-Minded',
		description: 'You gain Psychic Resistance (1).',
		cost: 1,
		effects: [{ type: 'GRANT_RESISTANCE', target: 'Psychic', value: 1 }]
	},
	{
		id: 'gnome_predict_weather',
		name: 'Predict Weather',
		description: 'You can naturally tell what the weather is going to be in the next hour in the area within 1 mile of you. You do not have DisADV on Checks or Saves as a result of naturally occurring weather.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'predict_weather', value: 'You can predict weather within 1 mile for the next hour and ignore DisADV from natural weather.' }]
	},
	{
		id: 'gnome_mana_increase',
		name: 'Mana Increase',
		description: 'Your MP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'mpMax', value: 1 }]
	},
	{
		id: 'gnome_trapper',
		name: 'Trapper',
		description: 'You have ADV on Investigation Checks to spot Traps and on Trickery Checks to Hide Traps.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'trapper', value: 'You have ADV on Investigation Checks to spot Traps and on Trickery Checks to Hide Traps.' }]
	},
	{
		id: 'gnome_lightning_insulation',
		name: 'Lightning Insulation',
		description: 'You have Lightning Resistance (Half) and cannot be struck by natural lightning.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE', target: 'Lightning', value: 'half' },
			{ type: 'GRANT_ABILITY', target: 'lightning_insulation', value: 'You can\'t be struck by natural lightning.' }
		]
	},
	{
		id: 'gnome_trade_expertise',
		name: 'Trade Expertise',
		description: 'Choose a Crafting or Subterfuge Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				target: 'crafting_or_subterfuge_trade',
				value: { capIncrease: 1, levelIncrease: 1 },
				userChoice: { prompt: 'Choose a Crafting or Subterfuge Trade for Expertise' }
			}
		]
	},

	// Orc Traits (p. 110)
	{
		id: 'orc_cursed_mind',
		name: 'Cursed Mind',
		description: 'You gain Psychic Vulnerability (1).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_VULNERABILITY', target: 'Psychic', value: 1 }]
	},
	{
		id: 'orc_rush',
		name: 'Orc Rush',
		description: 'Once per Combat when you willingly move toward an enemy, you can spend 1 AP to gain Temp HP equal to your Prime Modifier.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'orc_rush', value: 'Once per Combat: spend 1 AP to gain Temp HP equal to Prime Modifier when moving toward enemy.' }]
	},
	{
		id: 'orc_brutal_strikes',
		name: 'Brutal Strikes',
		description: 'You deal +1 damage when you score a Brutal or Critical Hit with a Melee Weapon or Unarmed Strike.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'brutal_strikes', value: '+1 damage on Brutal or Critical Hits with Melee Attacks.' }]
	},
	{
		id: 'orc_tough',
		name: 'Tough',
		description: 'Your HP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'hpMax', value: 1 }]
	},
	{
		id: 'orc_reckless',
		name: 'Reckless',
		description: 'Your PD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_STAT', target: 'pd', value: -1 }]
	},

	// Dragonborn Traits (p. 111)
	{
		id: 'dragonborn_darkvision',
		name: 'Darkvision',
		description: 'You have Darkvision 10 Spaces.',
		cost: 1,
		effects: [{ type: 'GRANT_SENSE', target: 'darkvision', value: 10 }]
	},
	{
		id: 'dragonborn_draconic_resistance',
		name: 'Draconic Resistance',
		description: 'You gain Resistance (Half) to your Draconic damage type.',
		cost: 2,
		effects: [{ type: 'GRANT_RESISTANCE', target: 'Draconic_damage_type', value: 'half' }]
	},
	{
		id: 'dragonborn_draconic_breath_weapon',
		name: 'Draconic Breath Weapon',
		description: 'You gain a Breath Weapon that you can use by spending 2 AP. You can use this ability once per Long Rest, and regain the ability when you roll for Initiative.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'draconic_breath', value: 'Breath Weapon: 2 AP, once per Long Rest, regain on Initiative.' }]
	},
	{
		id: 'dragonborn_thick_skinned',
		name: 'Thick-Skinned',
		description: 'While you aren\'t wearing Armor, you gain +1 AD.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'ad', value: 1, condition: 'not_wearing_armor' }]
	},

	// Giantborn Traits (p. 112)
	{
		id: 'giantborn_giant_blood',
		name: 'Giant Blood',
		description: 'Your Size is considered Large.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'large_size', value: 'Your Size is considered Large.' }]
	},
	{
		id: 'giantborn_tough',
		name: 'Tough',
		description: 'Your HP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'hpMax', value: 1 }]
	},
	{
		id: 'giantborn_throw_ally',
		name: 'Throw Ally',
		description: 'You can throw willing allies as a Combat Action.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'throw_ally', value: 'You can throw willing allies as a Combat Action.' }]
	},
	{
		id: 'giantborn_clumsy',
		name: 'Clumsy',
		description: 'Your PD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_STAT', target: 'pd', value: -1 }]
	},

	// Angelborn Traits (p. 113)
	{
		id: 'angelborn_divine_resistance',
		name: 'Divine Resistance',
		description: 'You have Holy Resistance (Half).',
		cost: 1,
		effects: [{ type: 'GRANT_RESISTANCE', target: 'Holy', value: 'half' }]
	},
	{
		id: 'angelborn_healing_hands',
		name: 'Healing Hands',
		description: 'Once per Long Rest, you can touch a creature to heal them for 1d4 + your Prime Modifier HP.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'healing_hands', value: 'Once per Long Rest: heal 1d4 + Prime Modifier HP by touch.' }]
	},
	{
		id: 'angelborn_light_sensitivity',
		name: 'Light Sensitivity',
		description: 'While in bright light, you have DisADV on Attack Checks.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'light_sensitivity', value: 'DisADV on Attack Checks in bright light.' }]
	},

	// Fiendborn Traits (p. 114)
	{
		id: 'fiendborn_darkvision',
		name: 'Darkvision',
		description: 'You have Darkvision 10 Spaces.',
		cost: 1,
		effects: [{ type: 'GRANT_SENSE', target: 'darkvision', value: 10 }]
	},
	{
		id: 'fiendborn_hellish_resistance',
		name: 'Hellish Resistance',
		description: 'You have Fire Resistance (Half).',
		cost: 1,
		effects: [{ type: 'GRANT_RESISTANCE', target: 'Fire', value: 'half' }]
	},
	{
		id: 'fiendborn_infernal_legacy',
		name: 'Infernal Legacy',
		description: 'You know one Cantrip from the Fiendborn Ancestry Spells.',
		cost: 1,
		effects: [{ type: 'GRANT_SPELL', target: 'fiendborn_cantrip', value: 'One Cantrip from Fiendborn Ancestry Spells.' }]
	},
	{
		id: 'fiendborn_holy_vulnerability',
		name: 'Holy Vulnerability',
		description: 'You have Holy Vulnerability (1).',
		cost: -2,
		isNegative: true,
		effects: [{ type: 'GRANT_VULNERABILITY', target: 'Holy', value: 1 }]
	},

	// Beastborn Traits (p. 115)
	{
		id: 'beastborn_keen_senses',
		name: 'Keen Senses',
		description: 'You have ADV on Awareness Checks that rely on hearing or smell.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'keen_senses', value: 'ADV on Awareness Checks using hearing or smell.' }]
	},
	{
		id: 'beastborn_natural_weapons',
		name: 'Natural Weapons',
		description: 'Your claws and teeth are Natural Weapons that deal 1 Slashing or Piercing damage.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'natural_weapons', value: 'Claws and teeth are Natural Weapons dealing 1 damage.' }]
	},
	{
		id: 'beastborn_thick_hide',
		name: 'Thick Hide',
		description: 'While you aren\'t wearing Armor, you gain +1 AD.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'ad', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'beastborn_wild_mind',
		name: 'Wild Mind',
		description: 'You have DisADV on Intelligence-based Checks.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'wild_mind', value: 'DisADV on Intelligence-based Checks.' }]
	}
];

// Helper functions for accessing trait data
export const getTraitData = (id: string): Trait | undefined => {
	return traitsData.find(trait => trait.id === id);
};

export const getTraitsByAncestry = (ancestryId: string): Trait[] => {
	return traitsData.filter(trait => trait.id.startsWith(ancestryId + '_'));
};
````

## File: src/lib/rulesdata/_new_schema/warlock_features.ts
````typescript
import type { ClassDefinition } from '../schemas/character.schema';

export const warlockClass: ClassDefinition = {
	id: 'warlock',
	name: 'Warlock',
	startingEquipment: {
		weaponsOrShields: ['2 Weapons'],
		armor: '1 set of Light Armor',
		packs: 'X or Y Packs (Adventuring Packs Coming Soon)'
	},
	spellcasterPath: {
		spellcastingProgression: 'warlock',
		spellcastingAttribute: 'charisma',
		spellsKnown: {
			description: 'Spells Known column of the Warlock Class Table'
		},
		ritualCasting: false,
		spellPreparation: false
	},
	coreFeatures: [
		{
			id: 'otherworldly_patron',
			featureName: 'Otherworldly Patron',
			levelGained: 1,
			description: 'You have struck a pact with an otherworldly being. Choose your patron type.',
			effects: [
				{
					type: 'GRANT_CHOICE',
					target: 'warlock_patron',
					value: {
						prompt: 'Choose your Otherworldly Patron',
						options: ['archfey', 'fiend', 'great_old_one', 'celestial', 'hexblade']
					},
					userChoice: {
						prompt: 'Choose your Otherworldly Patron',
						options: [
							'The Archfey',
							'The Fiend',
							'The Great Old One',
							'The Celestial',
							'The Hexblade'
						]
					}
				}
			]
		},
		{
			id: 'pact_magic',
			featureName: 'Pact Magic',
			levelGained: 1,
			description: 'Your arcane research and magic bestowed by your patron have given you facility with spells.',
			effects: [
				{
					type: 'GRANT_SPELLCASTING',
					target: 'warlock_spellcasting',
					value: 'Pact Magic: short rest spell slot recovery'
				}
			]
		},
		{
			id: 'eldritch_invocations',
			featureName: 'Eldritch Invocations',
			levelGained: 2,
			description: 'You learn eldritch invocations, fragments of forbidden knowledge that imbue you with an abiding magical ability.',
			effects: [
				{
					type: 'GRANT_CHOICE',
					target: 'eldritch_invocations',
					value: {
						prompt: 'Choose 2 Eldritch Invocations',
						count: 2,
						options: ['agonizing_blast', 'armor_of_shadows', 'beast_speech', 'beguiling_influence', 'devil_sight', 'eldritch_sight', 'eyes_of_rune_keeper', 'fiendish_vigor']
					},
					userChoice: {
						prompt: 'Choose 2 Eldritch Invocations',
						options: [
							'Agonizing Blast',
							'Armor of Shadows',
							'Beast Speech',
							'Beguiling Influence',
							'Devil\'s Sight',
							'Eldritch Sight',
							'Eyes of the Rune Keeper',
							'Fiendish Vigor'
						]
					}
				}
			]
		},
		{
			id: 'pact_boon',
			featureName: 'Pact Boon',
			levelGained: 3,
			description: 'Your otherworldly patron bestows a gift upon you for your loyal service.',
			effects: [
				{
					type: 'GRANT_CHOICE',
					target: 'pact_boon',
					value: {
						prompt: 'Choose your Pact Boon',
						options: ['chain', 'blade', 'tome']
					},
					userChoice: {
						prompt: 'Choose your Pact Boon',
						options: [
							'Pact of the Chain (familiar)',
							'Pact of the Blade (magical weapon)',
							'Pact of the Tome (ritual spells)'
						]
					}
				}
			]
		}
	]
};
````

## File: src/lib/rulesdata/_new_schema/wizard_features.ts
````typescript
/**
 * Wizard Class Definition - New Effect Schema
 * Based on DC20 Wizard features with spell school specialization
 */

import type { ClassDefinition } from '../schemas/character.schema';

export const wizardClass: ClassDefinition = {
  className: 'Wizard',
  startingStats: {
    hp: 6,
    sp: 0,
    mp: 6,
    skillPoints: 4,
    tradePoints: 3,
    languagePoints: 2,
    maneuversKnown: 0,
    techniquesKnown: 0,
    cantripsKnown: 3,
    spellsKnown: 4
  },
  coreFeatures: [
    {
      featureName: 'Spellcasting Path',
      levelGained: 1,
      description: 'You gain the ability to cast arcane spells.',
      effects: [
        { type: 'GRANT_COMBAT_TRAINING', target: 'Light_Armor', value: true }
      ]
    },
    {
      featureName: 'Spell School Initiate',
      levelGained: 1,
      description: 'You have completed training in a specialized School of Magic.',
      choices: [
        {
          id: 'wizard_spell_school',
          prompt: 'Choose your specialized Spell School',
          count: 1,
          options: [
            {
              name: 'Fire & Flames',
              description: 'Specialize in fire magic and flame manipulation.',
              effects: [
                { type: 'GRANT_CANTRIP', target: 'fire_flames_school', value: 1 },
                { type: 'GRANT_SPELL', target: 'fire_flames_school', value: 1 },
                { type: 'GRANT_ABILITY', target: 'signature_school_fire', value: 'Reduce MP cost by 1 for Fire & Flames spells (once per Long Rest, regain on Initiative).' }
              ]
            },
            {
              name: 'Ice & Illusions',
              description: 'Specialize in ice magic and illusion spells.',
              effects: [
                { type: 'GRANT_CANTRIP', target: 'ice_illusions_school', value: 1 },
                { type: 'GRANT_SPELL', target: 'ice_illusions_school', value: 1 },
                { type: 'GRANT_ABILITY', target: 'signature_school_ice', value: 'Reduce MP cost by 1 for Ice & Illusions spells (once per Long Rest, regain on Initiative).' }
              ]
            },
            {
              name: 'Lightning & Teleportation',
              description: 'Specialize in lightning magic and teleportation spells.',
              effects: [
                { type: 'GRANT_CANTRIP', target: 'lightning_teleportation_school', value: 1 },
                { type: 'GRANT_SPELL', target: 'lightning_teleportation_school', value: 1 },
                { type: 'GRANT_ABILITY', target: 'signature_school_lightning', value: 'Reduce MP cost by 1 for Lightning & Teleportation spells (once per Long Rest, regain on Initiative).' }
              ]
            },
            {
              name: 'Psychic & Enchantment',
              description: 'Specialize in psychic magic and enchantment spells.',
              effects: [
                { type: 'GRANT_CANTRIP', target: 'psychic_enchantment_school', value: 1 },
                { type: 'GRANT_SPELL', target: 'psychic_enchantment_school', value: 1 },
                { type: 'GRANT_ABILITY', target: 'signature_school_psychic', value: 'Reduce MP cost by 1 for Psychic & Enchantment spells (once per Long Rest, regain on Initiative).' }
              ]
            }
          ]
        }
      ]
    },
    {
      featureName: 'Arcane Sigil',
      levelGained: 1,
      description: 'You can spend 1 AP and 1 MP to create a 1 Space diameter Arcane Sigil on the ground beneath you that lasts for 1 minute.',
      effects: [
        { type: 'GRANT_ABILITY', target: 'arcane_sigil', value: 'Create Arcane Sigil (1 AP + 1 MP): 1 Space area, choose School/Tag, creatures within have ADV on Spell Checks for that type. Can teleport sigil 1 AP within 10 spaces.' }
      ]
    },
    {
      featureName: 'Ritual Caster',
      levelGained: 1,
      description: 'You learn Arcane Spells with the Ritual Spell Tag and can cast them as rituals.',
      isFlavor: true,
      effects: [
        { type: 'GRANT_ABILITY', target: 'ritual_caster', value: 'Learn 1 Ritual Spell per Wizard level. Can study and learn Ritual Spells from external sources (hours = MP cost).' }
      ]
    },
    {
      featureName: 'Prepared Spell',
      levelGained: 2,
      description: 'When you complete a Long Rest, choose 1 Spell you know to become your Prepared Spell.',
      effects: [
        { type: 'GRANT_ABILITY', target: 'prepared_spell', value: 'Choose 1 Prepared Spell per Long Rest: Mana Limit Break (+1 to Spend Limit once per Long Rest, regain on Initiative) and Rehearsed Casting (opponents have DisADV in Spell Duels).' }
      ]
    }
  ],
  subclasses: [
    {
      subclassName: 'Portal Mage',
      description: 'Masters of dimensional magic and teleportation.',
      features: [
        {
          featureName: 'Portal Magic',
          levelGained: 3,
          description: 'You gain advanced teleportation abilities.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'portal_magic', value: 'Advanced teleportation and dimensional magic abilities.' }
          ]
        }
      ]
    }
  ]
};
````

## File: src/lib/rulesdata/schemas/character.schema.ts
````typescript
/**
 * @file src/lib/rulesdata/schemas/character.schema.ts
 * @description The definitive schema for all character creation data, designed for robust, machine-readable processing.
 */

// ================================================================= //
// I. CORE EFFECT MODEL - The Heart of the System
// ================================================================= //

/**
 * A universal, machine-readable representation of a single mechanical effect.
 * This can be attached to traits, class features, choices, items, etc.
 */
export interface Effect {
  /** The action to be performed by the calculation engine. */
  type:
    // --- Stat & Attribute Modification ---
    | 'MODIFY_ATTRIBUTE'        // Modifies a core attribute (Might, Agility, etc.).
    | 'MODIFY_STAT'             // Modifies a derived or resource stat (hpMax, pd, moveSpeed, etc.).
    | 'SET_VALUE'               // Overrides a stat with a specific value or another stat's value.

    // --- Grants & Abilities ---
    | 'GRANT_ABILITY'           // Grants a descriptive, in-game ability or feature.
    | 'GRANT_RESISTANCE'        // Grants resistance to damage types or conditions.
    | 'GRANT_VULNERABILITY'     // Grants vulnerability to a damage type.
    | 'GRANT_ADV_ON_SAVE'       // Grants advantage on saves against specific conditions or types.
    | 'GRANT_ADV_ON_CHECK'      // Grants advantage on specific skill/ability checks.
    | 'GRANT_COMBAT_TRAINING'   // Grants proficiency with armor, weapons, or shields.
    | 'GRANT_MOVEMENT'          // Grants a special movement type like Climb or Swim.
    | 'GRANT_SENSE'             // Grants a sense like Darkvision or Tremorsense.

    // --- Choices & Progression ---
    | 'GRANT_CHOICE'            // Grants the player a choice (e.g., learn 2 maneuvers).
    | 'GRANT_SKILL_EXPERTISE'   // A specific effect for Human/Rogue skill expertise.
    | 'GRANT_TRADE_EXPERTISE'   // A specific effect for Human trade expertise.
    | 'GRANT_SPELL'             // Grants a known spell.
    | 'GRANT_CANTRIP'           // Grants a known cantrip.
    | 'GRANT_MANEUVERS'         // Grants knowledge of maneuvers.
    | 'GRANT_TECHNIQUES'        // Grants knowledge of techniques.
    ;

  /** The specific stat, attribute, or item being affected. Standardized for the calculator. */
  target: string; // e.g., 'might', 'hpMax', 'pd', 'ad', 'moveSpeed', 'jumpDistance', 'deathThresholdModifier', 'skillPoints', 'ancestryPoints', 'maneuver', 'technique', 'Poison', 'Charmed', 'Heavy_Armor', 'climb', 'darkvision', 'any_attribute', 'any_skill'

  /** The value of the effect. Can be a number, string, or complex object. */
  value: number | string | boolean | { [key: string]: any }; // e.g., 1, -1, 'half', 'equal_to_speed', true, { capIncrease: 1, levelIncrease: 1 }

  /** An optional condition under which this effect is active. */
  condition?: string; // e.g., 'not_wearing_armor', 'bloodied'

  /** If this effect requires a choice from the player to be resolved. */
  userChoice?: {
    prompt: string;
    options?: string[]; // e.g., ['might', 'agility', 'charisma', 'intelligence']
  };
}


// ================================================================= //
// II. ANCESTRY & TRAIT SCHEMAS
// ================================================================= //

export interface Trait {
  id: string;
  name: string;
  description: string;
  cost: number;
  isMinor?: boolean;
  isNegative?: boolean;
  prerequisites?: string[];
  effects: Effect[]; // Every mechanical benefit is now an Effect.
}

export interface Ancestry {
  id: string;
  name: string;
  description: string;
  defaultTraitIds: string[];
  expandedTraitIds: string[];
  origin?: {
    prompt: string;
    options: string[];
  };
  variantTraits?: Trait[];
}


// ================================================================= //
// III. CLASS & FEATURE SCHEMAS
// ================================================================= //

/** A named benefit within a larger class feature, containing its own effects. */
export interface FeatureBenefit {
  name: string;
  description: string;
  effects: Effect[];
}

/** An option a player can select as part of a feature choice. */
export interface FeatureChoiceOption {
  name: string;      // The value/ID of the option.
  description: string;
  effects: Effect[]; // Effects granted if this specific option is chosen.
}

/** A choice presented to the player by a class feature. */
export interface FeatureChoice {
  id: string; // A unique ID for this choice, e.g., "cleric_divine_domain_choice"
  prompt: string;
  count: number; // Number of options the player must select.
  options: FeatureChoiceOption[];
}

/** A single class feature, either core or from a subclass. */
export interface ClassFeature {
  featureName: string;
  levelGained: number;
  description: string;
  isFlavor?: boolean;
  /** Direct effects of the feature, applied automatically. */
  effects?: Effect[];
  /** Named sub-sections of a feature, each with its own effects. */
  benefits?: FeatureBenefit[];
  /** Choices the player must make to fully define the feature. */
  choices?: FeatureChoice[];
}

/** A subclass option for a given class. */
export interface Subclass {
  subclassName: string;
  description?: string;
  features: ClassFeature[];
}

/** The complete, robust definition for a single class. */
export interface ClassDefinition {
  className: string;
  // This section contains data derived from the level progression table for easy access at Lvl 1.
  startingStats: {
      hp: number;
      sp: number;
      mp: number;
      skillPoints: number;
      tradePoints: number;
      languagePoints: number;
      maneuversKnown: number;
      techniquesKnown: number;
      cantripsKnown: number;
      spellsKnown: number;
  };
  coreFeatures: ClassFeature[];
  subclasses: Subclass[];
}

// ================================================================= //
// IV. CALCULATION DATA STRUCTURES
// ================================================================= //

/** Aggregated stat modifiers from all effects */
export interface StatModifiers {
  // Attributes
  might: number;
  agility: number;
  charisma: number;
  intelligence: number;

  // Core Stats
  hpMax: number;
  spMax: number;
  mpMax: number;
  pd: number;
  ad: number;
  pdr: number;
  
  // Movement & Combat
  moveSpeed: number;
  jumpDistance: number;
  deathThresholdModifier: number;
  saveDC: number;
  initiativeBonus: number;
  
  // Resource Stats
  skillPoints: number;
  tradePoints: number;
  languagePoints: number;
  ancestryPoints: number;
  restPoints: number;
  gritPoints: number;
  
  // Learning Stats
  maneuversKnown: number;
  techniquesKnown: number;
  cantripsKnown: number;
  spellsKnown: number;
  skillMasteryLimit: number;
  tradeMasteryLimit: number;
  knowledgeMasteryLimit: number;
}

/** Conditional modifiers that depend on circumstances */
export interface ConditionalModifier {
  effect: Effect;
  condition: string;
  description: string;
}

/** Abilities granted to the character (displayed as features) */
export interface GrantedAbility {
  name: string;
  description: string;
  source: string; // e.g., "Human Trait: Determination"
  type: 'passive' | 'active' | 'resistance' | 'advantage';
}

/** Result of effect processing */
export interface EffectProcessingResult {
  statModifiers: StatModifiers;
  conditionalModifiers: ConditionalModifier[];
  grantedAbilities: GrantedAbility[];
  combatTraining: string[];
  resistances: Array<{ type: string; value: string }>;
  vulnerabilities: Array<{ type: string; value: string }>;
  senses: Array<{ type: string; range: number }>;
  movements: Array<{ type: string; speed: string }>;
}
````

## File: src/lib/rulesdata/spells-data/spells/additional-spells/index.ts
````typescript
import { druidcraft } from './druidcraft';
import { findFamiliar } from './find-familiar';
import { shield } from './shield';
import { tetheringVines } from './tethering-vines';
import { closeWounds } from './close-wounds';
import { deathBolt } from './death-bolt';

export const additionalSpells = [
	druidcraft,
	findFamiliar,
	shield,
	tetheringVines,
	closeWounds,
	deathBolt
];
````

## File: src/lib/rulesdata/spells-data/spells/fiendborn-ancestry-spells/index.ts
````typescript
import { poisonBolt } from './poison-bolt';
import { acidBolt } from './acid-bolt';

export const fiendbornAncestrySpells = [poisonBolt, acidBolt];
````

## File: src/lib/rulesdata/spells-data/spells/fire-and-flames/index.ts
````typescript
import { fireBolt } from './fire-bolt';
import { minorFlameBlade } from './minor-flame-blade';
import { dancingFlames } from './dancing-flames';
import { burningFlames } from './burning-flames';
import { fogCloud } from './fog-cloud';
import { fireShield } from './fire-shield';
import { grease } from './grease';

export const fireAndFlamesSpells = [
	fireBolt,
	minorFlameBlade,
	dancingFlames,
	burningFlames,
	fogCloud,
	fireShield,
	grease
];
````

## File: src/lib/rulesdata/spells-data/spells/holy-and-restoration/index.ts
````typescript
import { sacredBolt } from './sacred-bolt';
import { guidance } from './guidance';
import { light } from './light';
import { guidingBolt } from './guiding-bolt';
import { bless } from './bless';
import { heal } from './heal';
import { shieldOfFaith } from './shield-of-faith';

export const holyAndRestorationSpells = [
	sacredBolt,
	guidance,
	light,
	guidingBolt,
	bless,
	heal,
	shieldOfFaith
];
````

## File: src/lib/rulesdata/spells-data/spells/ice-and-illusions/index.ts
````typescript
import { frostBolt } from './frost-bolt';
import { minorIllusion } from './minor-illusion';
import { mageHand } from './mage-hand';
import { catapult } from './catapult';
import { magicMissile } from './magic-missile';
import { iceKnife } from './ice-knife';
import { silentImage } from './silent-image';

export const iceAndIllusionsSpells = [
	frostBolt,
	minorIllusion,
	mageHand,
	catapult,
	magicMissile,
	iceKnife,
	silentImage
];
````

## File: src/lib/rulesdata/spells-data/spells/lightning-and-teleportation/index.ts
````typescript
import { lightningBolt } from './lightning-bolt';
import { lightningBlade } from './lightning-blade';
import { shockingGrasp } from './shocking-grasp';
import { gust } from './gust';
import { returningShock } from './returning-shock';
import { mistyStep } from './misty-step';
import { cracklingLightning } from './crackling-lightning';

export const lightningAndTeleportationSpells = [
	lightningBolt,
	lightningBlade,
	shockingGrasp,
	gust,
	returningShock,
	mistyStep,
	cracklingLightning
];
````

## File: src/lib/rulesdata/spells-data/spells/psychic-and-enchantment/index.ts
````typescript
import { psiBolt } from './psi-bolt';
import { message } from './message';
import { befriend } from './befriend';
import { psychicFear } from './psychic-fear';
import { bane } from './bane';
import { command } from './command';
import { sleep } from './sleep';

export const psychicAndEnchantmentSpells = [
	psiBolt,
	message,
	befriend,
	psychicFear,
	bane,
	command,
	sleep
];
````

## File: src/lib/rulesdata/spells-data/spells/special-class-spells/index.ts
````typescript
import { sorcery } from './sorcery';

export const specialClassSpells = [sorcery];
````

## File: src/lib/rulesdata/spells-data/spells/index.ts
````typescript
import { fireAndFlamesSpells } from './fire-and-flames';
import { iceAndIllusionsSpells } from './ice-and-illusions';
import { lightningAndTeleportationSpells } from './lightning-and-teleportation';
import { psychicAndEnchantmentSpells } from './psychic-and-enchantment';
import { holyAndRestorationSpells } from './holy-and-restoration';
import { specialClassSpells } from './special-class-spells';
import { fiendbornAncestrySpells } from './fiendborn-ancestry-spells';
import { additionalSpells } from './additional-spells';

export * from './fire-and-flames';
export * from './ice-and-illusions';
export * from './lightning-and-teleportation';
export * from './psychic-and-enchantment';
export * from './holy-and-restoration';
export * from './special-class-spells';
export * from './fiendborn-ancestry-spells';
export * from './additional-spells';

export const allSpells = [
	...fireAndFlamesSpells,
	...iceAndIllusionsSpells,
	...lightningAndTeleportationSpells,
	...psychicAndEnchantmentSpells,
	...holyAndRestorationSpells,
	...specialClassSpells,
	...fiendbornAncestrySpells,
	...additionalSpells
];
````

## File: src/lib/rulesdata/spells-data/types/spell.types.ts
````typescript
// ./spells-data/types/spell.types.ts

/**
 * @file spell.types.ts
 * @description This file contains the definitive TypeScript schemas and enumerations
 * for modeling all spells in the DC20 system.
 */

export enum SpellSchool {
	Astromancy = 'Astromancy',
	Conjuration = 'Conjuration',
	Destruction = 'Destruction',
	Divination = 'Divination',
	Enchantment = 'Enchantment',
	Illusion = 'Illusion',
	Protection = 'Protection',
	Restoration = 'Restoration',
	Transmutation = 'Transmutation',
	Abjuration = 'Abjuration'
}

export enum SpellList {
	Arcane = 'Arcane',
	Primal = 'Primal',
	Divine = 'Divine'
}

export enum ClassName {
	Wizard = 'Wizard',
	Sorcerer = 'Sorcerer',
	Cleric = 'Cleric',
	Druid = 'Druid'
}

export enum PremadeSpellList {
	FireAndFlames = 'Fire & Flames List',
	IceAndIllusions = 'Ice & Illusions List',
	LightningAndTeleportation = 'Lightning & Teleportation List',
	PsychicAndEnchantment = 'Psychic & Enchantment List',
	HolyAndRestoration = 'Holy & Restoration List',
	SpecialClass = 'Special Class Feature Spells',
	FiendbornAncestry = 'Fiendborn Ancestry Trait Spells',
	Additional = 'Additional Spells'
}

export interface SpellCost {
	ap: number;
	mp?: number;
}

export interface SpellEffect {
	title: string;
	description: string;
}

export interface SpellEnhancement {
	type: 'AP' | 'MP';
	cost: number;
	name: string;
	description: string;
}

export interface Spell {
	name: string;
	premadeList: PremadeSpellList;
	school: SpellSchool;
	isCantrip: boolean;
	isRitual?: boolean;
	cost: SpellCost;
	range: string;
	duration: string;
	spellLists: SpellList[];
	availableClasses: ClassName[];
	effects: SpellEffect[];
	cantripPassive?: string;
	enhancements: SpellEnhancement[];
}
````

## File: src/lib/rulesdata/ancestries.ts
````typescript
// src/lib/rulesdata/ancestries.ts

import type { IAncestry } from './types';

export const ancestriesData: IAncestry[] = [
	{
		id: 'human',
		name: 'Human',
		description:
			'Humans are the most common ancestry in the world, known for their adaptability and resilience.',
		defaultTraitIds: [
			'human_attribute_increase',
			'human_skill_expertise',
			'human_resolve',
			'human_undying'
		],
		expandedTraitIds: [
			'human_trade_expertise',
			'human_determination',
			'human_unbreakable',
			'human_attribute_decrease'
		]
	},
	{
		id: 'elf',
		name: 'Elf',
		description: 'Elves are graceful and long-lived beings with a deep connection to nature.',
		defaultTraitIds: ['elf_elven_will', 'elf_nimble', 'elf_agile_explorer', 'elf_discerning_sight'],
		expandedTraitIds: [
			'elf_quick_reactions',
			'elf_peerless_sight',
			'elf_climb_speed',
			'elf_speed_increase',
			'elf_trade_expertise_elf',
			'elf_plant_knowledge',
			'elf_brittle',
			'elf_frail',
			'elf_might_decrease'
		]
	},
	{
		id: 'dwarf',
		name: 'Dwarf',
		description:
			'Dwarves are a stout and resilient folk, known for their craftsmanship and deep connection to the earth.',
		defaultTraitIds: [
			'dwarf_tough',
			'dwarf_toxic_fortitude',
			'dwarf_physically_sturdy',
			'dwarf_iron_stomach'
		],
		expandedTraitIds: [
			'dwarf_thick_skinned',
			'dwarf_natural_combatant',
			'dwarf_stone_blood',
			'dwarf_minor_tremorsense',
			'dwarf_stubborn',
			'dwarf_trade_expertise',
			'dwarf_earthen_knowledge',
			'dwarf_charisma_attribute_decrease',
			'dwarf_short_legged'
		]
	},
	{
		id: 'halfling',
		name: 'Halfling',
		description:
			'Halflings are a small and nimble folk, known for their bravery and love of comfort.',
		defaultTraitIds: [
			'halfling_small_sized',
			'halfling_elusive',
			'halfling_bravery',
			'halfling_endurance',
			'halfling_deft_footwork',
			'halfling_beast_whisperer'
		],
		expandedTraitIds: [
			'halfling_beast_insight',
			'halfling_burst_of_bravery',
			'halfling_trade_expertise',
			'halfling_critter_knowledge',
			'halfling_brittle',
			'halfling_intelligence_attribute_decrease',
			'halfling_short_legged'
		]
	},
	{
		id: 'gnome',
		name: 'Gnome',
		description:
			'Gnomes are small and energetic folk, known for their inventiveness and connection to the feywild.',
		defaultTraitIds: [
			'gnome_small_sized',
			'gnome_escape_artist',
			'gnome_magnified_vision',
			'gnome_mental_clarity',
			'gnome_strong_minded',
			'gnome_predict_weather'
		],
		expandedTraitIds: [
			'gnome_mana_increase',
			'gnome_trapper',
			'gnome_lightning_insulation',
			'gnome_trade_expertise',
			'gnome_storm_knowledge',
			'gnome_agility_attribute_decrease',
			'gnome_short_legged'
		]
	},
	{
		id: 'orc',
		name: 'Orc',
		description:
			'Orcs are a strong and fierce folk, known for their martial prowess and intimidating presence.',
		defaultTraitIds: [
			'orc_cursed_mind',
			'orc_rush',
			'orc_brutal_strikes',
			'orc_tough',
			'orc_orcish_resolve',
			'orc_already_cursed'
		],
		expandedTraitIds: [
			'orc_intimidating_shout',
			'orc_dash',
			'orc_finishing_blow',
			'orc_imposing_presence',
			'orc_provocation',
			'orc_reckless'
		]
	},
	{
		id: 'dragonborn',
		name: 'Dragonborn',
		description:
			'Dragonborn are a proud and powerful folk, who trace their lineage back to dragons.',
		defaultTraitIds: [
			'dragonborn_darkvision',
			'dragonborn_draconic_resistance',
			'dragonborn_draconic_breath_weapon',
			'dragonborn_reptilian_superiority'
		],
		expandedTraitIds: [
			'dragonborn_mana_increase',
			'dragonborn_thick_skinned',
			'dragonborn_second_breath',
			'dragonborn_concussive_breath',
			'dragonborn_draconic_affinity',
			'dragonborn_dying_breath',
			'dragonborn_draconic_ward',
			'dragonborn_draconic_protection',
			'dragonborn_glide_speed',
			'dragonborn_guardians_bond'
		],
		origin: {
			// Draconic Origin
			prompt: 'Choose a Draconic Origin:',
			options: [
				'cold',
				'corrosion',
				'fire',
				'lightning',
				'poison',
				'sonic',
				'psychic',
				'radiant',
				'umbral'
			]
		}
	},
	{
		id: 'giantborn',
		name: 'Giantborn',
		description: 'Giantborn are a large and powerful folk, who trace their lineage back to giants.',
		defaultTraitIds: [
			'giantborn_tough',
			'giantborn_powerful_build',
			'giantborn_unstoppable',
			'giantborn_giants_resolve',
			'giantborn_unyielding_movement'
		],
		expandedTraitIds: [
			'giantborn_giants_fortitude',
			'giantborn_strong_body',
			'giantborn_mighty_hurl',
			'giantborn_titanic_toss',
			'giantborn_mighty_leap',
			'giantborn_brute',
			'giantborn_heavy_riser',
			'giantborn_clumsiness',
			'giantborn_intelligence_attribute_decrease'
		]
	},
	{
		id: 'angelborn',
		name: 'Angelborn',
		description: 'Angelborn are a celestial folk, known for their grace and divine connection.',
		defaultTraitIds: [
			'angelborn_radiant_resistance',
			'angelborn_celestial_magic',
			'angelborn_healing_touch',
			'angelborn_divine_glow'
		],
		expandedTraitIds: [
			'angelborn_mana_increase',
			'angelborn_celestial_clarity',
			'angelborn_angelic_insight',
			'angelborn_gift_of_the_angels',
			'angelborn_blinding_light',
			'angelborn_glide_speed',
			'angelborn_pacifist',
			'angelborn_umbral_weakness'
		],
		variantTraits: [
			// Fallen Angelborn
			{
				id: 'angelborn_fallen',
				name: 'Fallen',
				cost: 0,
				description: 'You can now spend your Ancestry Points on Fiendborn Traits.'
			}
		]
	},
	{
		id: 'fiendborn',
		name: 'Fiendborn',
		description: 'Fiendborn are a fiendish folk, known for their cunning and infernal connection.',
		defaultTraitIds: [
			'fiendborn_fiendish_resistance',
			'fiendborn_fiendish_magic',
			'fiendborn_darkvision',
			'fiendborn_lights_bane'
		],
		expandedTraitIds: [
			'fiendborn_mana_increase',
			'fiendborn_silver_tongued',
			'fiendborn_fiendish_aura',
			'fiendborn_superior_darkvision',
			'fiendborn_infernal_bravery',
			'fiendborn_intimidator',
			'fiendborn_charming_gaze',
			'fiendborn_glide_speed',
			'fiendborn_radiant_weakness',
			'fiendborn_divine_dampening'
		],
		origin: {
			// Fiendish Origin
			prompt: 'Choose a Fiendish Origin:',
			options: ['cold', 'corrosion', 'fire', 'poison', 'umbral']
		},
		variantTraits: [
			// Fiendborn Redemption
			{
				id: 'fiendborn_redeemed',
				name: 'Redeemed',
				cost: 0,
				description: 'You can now spend your Ancestry Points on Angelborn Traits.'
			}
		]
	},
	{
		id: 'beastborn',
		name: 'Beastborn',
		description: 'Beastborn are a diverse folk, who take on the characteristics of various beasts.',
		defaultTraitIds: [], // Beastborn has no Default Traits
		expandedTraitIds: [
			// Listed under Beast Traits sections in PDF
			// Senses
			'beastborn_darkvision',
			'beastborn_echolocation',
			'beastborn_keen_sense',
			'beastborn_sunlight_sensitivity',
			// Mobility
			'beastborn_quick_reactions',
			'beastborn_climb_speed',
			'beastborn_spider_climb',
			'beastborn_web_walk',
			'beastborn_water_breathing',
			'beastborn_swim_speed',
			'beastborn_speed_increase',
			'beastborn_sprint',
			'beastborn_charge',
			'beastborn_burrow_speed',
			// Jumping
			'beastborn_jumper',
			'beastborn_strong_jumper',
			// Flying
			'beastborn_glide_speed',
			'beastborn_limited_flight',
			'beastborn_full_flight',
			'beastborn_flyby',
			'beastborn_stealth_feathers',
			'beastborn_winged_arms',
			// Body
			'beastborn_tough',
			'beastborn_thick_skinned',
			'beastborn_powerful_build',
			'beastborn_long_limbed',
			'beastborn_secondary_arms',
			'beastborn_prehensile_appendage',
			'beastborn_hazardous_hide',
			'beastborn_natural_armor',
			'beastborn_hard_shell',
			'beastborn_shell_retreat',
			'beastborn_camouflage',
			'beastborn_prowler',
			'beastborn_cold_resistance',
			'beastborn_fire_resistance',
			'beastborn_short_legged',
			'beastborn_small_sized',
			'beastborn_reckless',
			// Natural Weapons
			'beastborn_natural_weapon',
			'beastborn_extended_natural_weapon',
			'beastborn_natural_projectile',
			'beastborn_natural_weapon_passive',
			'beastborn_rend',
			'beastborn_retractable_natural_weapon',
			'beastborn_venomous_natural_weapon',
			// Miscellaneous
			'beastborn_fast_reflexes',
			'beastborn_mimicry',
			'beastborn_intimidating_shout',
			'beastborn_toxic_fortitude',
			'beastborn_shoot_webs'
		],
		origin: {
			// Beastborn Origin
			prompt: 'Choose a type of Beast you are modeled after:',
			options: [] // Options are open-ended, based on GM/player choice
		}
	}
];
````

## File: src/lib/rulesdata/languages.ts
````typescript
import type { ILanguageData } from './types';

export const languagesData: ILanguageData[] = [
	{
		id: 'common',
		name: 'Common',
		type: 'standard', // From DC20 p.18
		description:
			'Common is the most simple and universal language in the world. All Player Characters start Fluent in Common.'
	},
	{
		id: 'elvish',
		name: 'Elvish',
		type: 'standard', // From DC20 p.18
		description: 'Elvish is a fluid and melodic language spoken by Elves. Typical Speakers: Elves.'
	},
	{
		id: 'draconic',
		name: 'Draconic',
		type: 'exotic', // From DC20 p.18
		description:
			'Draconic is a harsh, guttural language spoken by Dragons and Dragonkin. Typical Speakers: Dragons, Dragonkin.'
	},
	{
		id: 'dwarvish',
		name: 'Dwarvish',
		type: 'standard', // From DC20 p.18
		description:
			'Dwarvish is a language of hard consonants and guttural sounds, spoken by Dwarves. Typical Speakers: Dwarves.'
	},
	{
		id: 'gnomish',
		name: 'Gnomish',
		type: 'standard', // From DC20 p.18
		description:
			'Gnomish is a language filled with trills and clicks, spoken by Gnomes. Typical Speakers: Gnomes.'
	},
	{
		id: 'goblin',
		name: 'Goblin',
		type: 'standard', // From DC20 p.18
		description:
			'Goblin is a rough and simple language spoken by Goblins, Hobgoblins, and Bugbears. Typical Speakers: Goblins, Hobgoblins, Bugbears.'
	},
	{
		id: 'halfling',
		name: 'Halfling',
		type: 'standard', // From DC20 p.18
		description:
			'Halfling is a soft and gentle language spoken by Halflings. Typical Speakers: Halflings.'
	},
	{
		id: 'orcish',
		name: 'Orcish',
		type: 'standard', // From DC20 p.18
		description: 'Orcish is a brutal and harsh language spoken by Orcs. Typical Speakers: Orcs.'
	},
	{
		id: 'primordial',
		name: 'Primordial',
		type: 'exotic', // From DC20 p.18
		description: 'Primordial is the language of Elementals. Typical Speakers: Elementals.'
	},
	{
		id: 'celestial',
		name: 'Celestial',
		type: 'exotic', // From DC20 p.18
		description: 'Celestial is the language of Celestials. Typical Speakers: Celestials.'
	},
	{
		id: 'abyssal',
		name: 'Abyssal',
		type: 'exotic', // From DC20 p.18
		description: 'Abyssal is the language of Demons. Typical Speakers: Demons.'
	},
	{
		id: 'infernal',
		name: 'Infernal',
		type: 'exotic', // From DC20 p.18
		description: 'Infernal is the language of Devils. Typical Speakers: Devils.'
	},
	{
		id: 'undercommon',
		name: 'Undercommon',
		type: 'exotic', // From DC20 p.18
		description:
			'Undercommon is a language spoken by inhabitants of the Underdark, such as Drow. Typical Speakers: Drow, Underdark inhabitants.'
	}
];
````

## File: src/lib/rulesdata/maneuvers.ts
````typescript
/**
 * @file maneuvers.ts
 * @description Contains the schemas and a complete list of all Martial Maneuvers
 * from the DC20 Beta 0.9.5 rulebook (pages 48-50).
 */

//==============================================================================
// SCHEMAS / TYPES
//==============================================================================

/**
 * Categorizes maneuvers based on their function as described in the rulebook.
 */
export enum ManeuverType {
	Attack = 'Attack',
	Save = 'Save',
	Grapple = 'Grapple',
	Defense = 'Defense'
}

/**
 * Represents the resource cost of a maneuver, typically in Action Points (AP).
 */
export interface ManeuverCost {
	ap: number;
}

/**
 * The definitive blueprint for a single Maneuver object.
 */
export interface Maneuver {
	name: string;
	type: ManeuverType;
	cost: ManeuverCost;
	description: string;
	isReaction: boolean;
	trigger?: string; // Optional: The condition for using a Reaction maneuver.
	requirement?: string; // Optional: Any prerequisites for using the maneuver.
}

//==============================================================================
// MANEUVER DATA
//==============================================================================

/**
 * A comprehensive list of all martial maneuvers available in the game.
 */
export const maneuvers: Maneuver[] = [
	// --- Attack Maneuvers (Page 48) ---
	{
		name: 'Extend Attack',
		type: ManeuverType.Attack,
		cost: { ap: 1 },
		description:
			'Your Melee Attack Range is increased by 1 Space (or your Ranged Attack Range is increased by 5 Spaces) for the Attack.',
		isReaction: false
	},
	{
		name: 'Power Attack',
		type: ManeuverType.Attack,
		cost: { ap: 1 },
		description: 'You deal +1 damage with the Attack. You can use this Maneuver multiple times.',
		isReaction: false
	},
	{
		name: 'Sweep Attack',
		type: ManeuverType.Attack,
		cost: { ap: 1 },
		description:
			'Choose 1 additional target within 1 Space of the original target that’s within your Attack Range. Make 1 Attack Check against all targets. Attack Hit: The original target takes your Attack’s damage, and each additional target Hit takes 1 damage of the same type. You can use this Maneuver multiple times.',
		isReaction: false
	},

	// --- Save Maneuvers (Page 49) ---
	{
		name: 'Bleed',
		type: ManeuverType.Save,
		cost: { ap: 1 },
		description: 'The target begins Bleeding (1 True damage at the start of their turn).',
		isReaction: false
	},
	{
		name: 'Daze',
		type: ManeuverType.Save,
		cost: { ap: 1 },
		description:
			'The target becomes Dazed (DisADV on Mental Checks) on the next Mental Check it makes before the end of your next turn.',
		isReaction: false
	},
	{
		name: 'Expose',
		type: ManeuverType.Save,
		cost: { ap: 1 },
		description:
			'The target becomes Exposed (Attacks against it have ADV) against the next Attack made against it before the end of your next turn.',
		isReaction: false
	},
	{
		name: 'Hamstring',
		type: ManeuverType.Save,
		cost: { ap: 1 },
		description:
			'The target becomes Slowed (every 1 Space you move costs an extra 1 Space of movement) until the end of your next turn.',
		isReaction: false
	},
	{
		name: 'Hinder',
		type: ManeuverType.Save,
		cost: { ap: 1 },
		description:
			'The target becomes Hindered (DisADV on Attacks) on the next Attack it makes before the end of your next turn.',
		isReaction: false
	},
	{
		name: 'Impair',
		type: ManeuverType.Save,
		cost: { ap: 1 },
		description:
			'The target becomes Impaired (DisADV on Physical Checks) on the next Physical Check it makes before the end of your next turn.',
		isReaction: false
	},
	{
		name: 'Knockback',
		type: ManeuverType.Save,
		cost: { ap: 1 },
		description:
			'The target is pushed 1 Space away + up to 1 additional Space for every 5 it fails its Save by.',
		isReaction: false
	},
	{
		name: 'Trip',
		type: ManeuverType.Save,
		cost: { ap: 1 },
		description: 'The target falls Prone.',
		isReaction: false
	},

	// --- Grapple Maneuvers (Page 49) ---
	{
		name: 'Body Block',
		type: ManeuverType.Grapple,
		cost: { ap: 1 },
		isReaction: true,
		trigger: 'You are targeted by an Attack.',
		description:
			'You reposition a creature Grappled by you to shield yourself from damage. You and the Grappled creature take half the damage dealt by the attack and you can move the Grappled creature to any space adjacent to you immediately afterwards.'
	},
	{
		name: 'Restrain',
		type: ManeuverType.Grapple,
		cost: { ap: 1 },
		description:
			'The target is Restrained until the Grapple ends. On its turn it can spend 1 AP to end being Restrained, but it remains Grappled until the Condition ends.',
		isReaction: false
	},
	{
		name: 'Slam',
		type: ManeuverType.Grapple,
		cost: { ap: 1 },
		description: 'The target takes 1 Bludgeoning damage. Success (each 5): +1 damage.',
		isReaction: false
	},
	{
		name: 'Takedown',
		type: ManeuverType.Grapple,
		cost: { ap: 1 },
		description: 'The target falls Prone. You don’t fall Prone unless you choose to do so.',
		isReaction: false
	},
	{
		name: 'Throw',
		type: ManeuverType.Grapple,
		cost: { ap: 1 },
		requirement: 'The Grappled creature is your Size or smaller.',
		description:
			'The target is thrown up to a number of Spaces away from you equal to 1/2 of your Might (ending the Grappled Condition) + up to 1 additional Space for every 5 they fail the Contest by.',
		isReaction: false
	},

	// --- Defense Maneuvers (Page 50) ---
	{
		name: 'Parry',
		type: ManeuverType.Defense,
		cost: { ap: 1 },
		isReaction: true,
		trigger:
			'When a creature you can see within 1 Space (including yourself) is targeted by an Attack against its PD.',
		description: 'You grant the target a +5 bonus to PD against this Attack.'
	},
	{
		name: 'Protect',
		type: ManeuverType.Defense,
		cost: { ap: 1 },
		isReaction: true,
		trigger: 'A creature you can see within 1 Space is Hit by an Attack.',
		description:
			'The target takes half of the damage and you take the other half. The damage you take bypasses any Damage Reduction.'
	},
	{
		name: 'Raise Shield',
		type: ManeuverType.Defense,
		cost: { ap: 1 },
		isReaction: true,
		trigger:
			'When a creature you can see within 1 Space (including yourself) is targeted by an Attack against its AD.',
		requirement: 'You’re wielding a Shield.',
		description: 'You grant the target a +5 bonus to AD against this Attack.'
	},
	{
		name: 'Side Step',
		type: ManeuverType.Defense,
		cost: { ap: 1 },
		isReaction: true,
		trigger: 'You’re targeted by an Attack against your PD.',
		description:
			'You move 1 Space to a Space that’s still within the Attack’s range. When you do, the Attack has DisADV against you. If you move behind Cover, you don’t gain the benefit of that Cover against the Attack.'
	},
	{
		name: 'Swap',
		type: ManeuverType.Defense,
		cost: { ap: 1 },
		description:
			'You switch Spaces with a willing creature within 1 Space. If this movement would provoke an Opportunity Attack against you or the target creature, any Opportunity Attacks are made against you.',
		isReaction: false // This is a standard action, not a reaction.
	},
	{
		name: 'Taunt',
		type: ManeuverType.Defense,
		cost: { ap: 1 },
		description:
			'Choose an enemy creature that can see or hear you within 5 Spaces. Make an Attack Check, Influence Check, or Intimidation Check (your choice) contested by the target’s Mental Save. Contest Success: The target is Taunted (DisADV on Attacks against creatures other than you) by you on their next Attack.',
		isReaction: false
	}
];

/** A simple alias for the main maneuvers array. */
export const allManeuvers = maneuvers;
````

## File: src/lib/rulesdata/skills.ts
````typescript
import type { ISkillData } from './types';

export const skillsData: ISkillData[] = [
	{
		id: 'athletics',
		name: 'Athletics',
		attributeAssociation: 'might',
		description:
			'Athletics covers activities that involve physical prowess, such as climbing, swimming, and jumping in difficult circumstances, or participating in a Grapple.'
	},
	{
		id: 'intimidation',
		name: 'Intimidation',
		attributeAssociation: 'might',
		description:
			'Intimidation covers attempts to influence a creature’s behavior using threats, hostile actions, and physical violence.'
	},
	{
		id: 'acrobatics',
		name: 'Acrobatics',
		attributeAssociation: 'agility',
		description: 'Acrobatics covers activities that require flexibility, nimbleness, and balance.'
	},
	{
		id: 'trickery',
		name: 'Trickery',
		attributeAssociation: 'agility',
		description:
			'Trickery covers non-verbal means of deceiving others, such as pickpocketing things, concealing an object on your person, or other forms of physical deception.'
	},
	{
		id: 'stealth',
		name: 'Stealth',
		attributeAssociation: 'agility',
		description:
			'Stealth covers attempts to avoid being seen or heard by other creatures, such as sneaking about or hiding behind cover.'
	},
	{
		id: 'animal',
		name: 'Animal',
		attributeAssociation: 'charisma',
		description:
			'Animal covers interactions such as corralling, training, calming, and gauging the intention of Beasts.'
	},
	{
		id: 'insight',
		name: 'Insight',
		attributeAssociation: 'charisma',
		description:
			'Insight governs your ability to discern intentions. This could be from observing a creature’s body language, facial cues, and mannerisms. Alternatively, Insight can represent a gut feeling or intuition about a situation.'
	},
	{
		id: 'influence',
		name: 'Influence',
		attributeAssociation: 'charisma',
		description:
			'Influence covers your attempts to manipulate a creature’s behavior using compelling arguments based on truth, half-truths, lies, or some combination in between.'
	},
	{
		id: 'investigation',
		name: 'Investigation',
		attributeAssociation: 'intelligence',
		description:
			'Investigation covers using your senses to search for and discover things that are not readily observable. You look for clues and then make deductions on those clues to try and discern the locations of things or how they work (finding hidden objects, secret doors, or weak points in structures). It also covers the process of researching information through various texts.'
	},
	{
		id: 'medicine',
		name: 'Medicine',
		attributeAssociation: 'intelligence',
		description:
			'Medicine covers activities that involve medical knowledge and application, such as treating a wounded creature, diagnosing an illness, or identifying a cure to an ailment.'
	},
	{
		id: 'survival',
		name: 'Survival',
		attributeAssociation: 'intelligence',
		description:
			'Survival covers the activities required to survive in the wilderness, such as tracking quarry, foraging for food and water, and navigating through uncharted territory.'
	},
	{
		id: 'awareness',
		name: 'Awareness',
		attributeAssociation: 'prime', // Uses Prime Modifier
		description:
			'Awareness governs your ability to detect the presence of other creatures or objects using your sight, hearing, smell, or other senses.'
	}
];
````

## File: src/lib/rulesdata/techniques.ts
````typescript
/**
 * @file techniques.ts
 * @description Contains the schemas and a complete list of all Martial Techniques
 * from the DC20 Beta 0.9.5 rulebook (pages 51-53).
 */

//==============================================================================
// SCHEMAS / TYPES
//==============================================================================

/**
 * Represents the resource cost of a technique or its enhancement.
 */
export interface MartialAbilityCost {
	ap?: number;
	sp?: number;
}

/**
 * The blueprint for a Technique's optional enhancement.
 */
export interface TechniqueEnhancement {
	name: string;
	cost: {
		ap?: number;
		sp: number;
	};
	description: string;
}

/**
 * The definitive blueprint for a single Technique object.
 */
export interface Technique {
	name: string;
	cost: MartialAbilityCost;
	description: string;
	isReaction: boolean;
	trigger?: string;
	requirement?: string;
	enhancements: TechniqueEnhancement[];
}

//==============================================================================
// TECHNIQUE DATA
//==============================================================================

/**
 * A comprehensive list of all martial techniques available in the game.
 */
export const techniques: Technique[] = [
	{
		name: 'Forbearance',
		cost: { ap: 1, sp: 1 },
		isReaction: true,
		trigger: 'When a creature you can see within 1 Space is targeted by an Attack.',
		description:
			'You become the new target of the Check, and choose to switch places with the original target (if it’s willing). If the Check is accompanied by a Save, you make the Save instead of the original target.',
		enhancements: [
			{
				name: 'Steadfast Forbearance',
				cost: { sp: 1 },
				description:
					'If multiple creatures within 1 Space of you are targeted by the same Check, you can attempt to protect them as well. You can spend 1 SP per additional target to become the new target of its Check as well. You take the collective damage of all protected creatures against the Check.'
			},
			{
				name: 'Immense Defense',
				cost: { sp: 2 },
				description: 'You gain Resistance (Half) against all damage taken using this Technique.'
			}
		]
	},
	{
		name: 'Heroic Bash',
		cost: { ap: 1, sp: 1 },
		isReaction: false,
		requirement: 'Melee Weapon or Unarmed Strike',
		description:
			"Using a Melee Weapon (or Unarmed Strike) you can attempt to send an enemy hurling through the air. Make an Attack Check against the PD of a target within 1 Space of you, and it makes a Physical Save against your Save DC. Attack Hit: It takes your Weapon's (or Unarmed Strike) damage. Save Failure: It gets knockback horizontally up to 3 Spaces + 1 additional Space for every 5 it fails the Save by.",
		enhancements: [
			{
				name: 'Extended Knockback',
				cost: { sp: 1 },
				description:
					'You can spend 1 SP to increase the Knockback distance by 2 Spaces and increase the damage by 1.'
			},
			{
				name: 'Painful Knockback',
				cost: { sp: 1 },
				description: 'You can spend 1 SP to increase the damage by 2.'
			},
			{
				name: 'Bash & Smash',
				cost: { ap: 1, sp: 1 },
				description:
					'You can spend an additional 1 AP and 1 SP to change the Target from one creature to every creature’s PD within 1 Space.'
			}
		]
	},
	{
		name: 'Heroic Leap',
		cost: { ap: 1, sp: 1 },
		isReaction: false,
		requirement: 'Melee Weapon or Unarmed Strike',
		description:
			'You perform an exceptional leap and assault a creature. You gain up to your Speed in Spaces and increase your Jump Distance by 1 on the next Long or Vertical Jump you make. You leap into the air and make an Attack Check against the PD of a target within 1 Space of where you land, and it makes a Physical Save against your Save DC. Attack Hit: It takes your Weapon (or Unarmed Strike) damage. Save Failure: The target falls Prone.',
		enhancements: [
			{
				name: 'Brutal Leap',
				cost: { sp: 1 },
				description:
					'You can spend 1 SP to transfer all of the Falling damage you would usually take into the target instead.'
			},
			{
				name: 'Far Leap',
				cost: { sp: 1 },
				description: 'You can spend 1 SP to increase your damage by 1 and your Jump Distance by 2.'
			},
			{
				name: 'Heroic Slam',
				cost: { ap: 1, sp: 1 },
				description:
					'You can spend 1 AP and 1 SP to compare your Attack Check against the AD of all creatures within 1 Space of where you land (instead of a single target).'
			}
		]
	},
	{
		name: 'Heroic Parry',
		cost: { ap: 1, sp: 1 },
		isReaction: true,
		trigger:
			'You or a creature you can see within 1 Space are targeted by an Attack against its PD.',
		description: 'You grant the target a +5 bonus to its PD until the start of its next turn.',
		enhancements: [
			{
				name: 'Heroic Disengage',
				cost: { sp: 1 },
				description:
					'You can spend 1 SP to allow the target to Disengage and move up to half its Speed after the Attack.'
			}
		]
	},
	{
		name: 'Heroic Taunt',
		cost: { ap: 1, sp: 1 },
		isReaction: false,
		description:
			'You attempt to Taunt all enemies within 5 Spaces. Make an Attack Check or Intimidation Check (your choice) contested by each target’s Mental Save. Contest Success: Each creature you beat is Taunted (DisADV on Attack and Spell Checks against creatures other than you) by you until the end of your next turn.',
		enhancements: [
			{
				name: 'Legendary Taunt',
				cost: { sp: 2 },
				description:
					'You can spend 2 SP to have any damage dealt by Taunted enemies to be halved against any creatures other than you.'
			}
		]
	},
	{
		name: 'Slip Away',
		cost: { ap: 1, sp: 1 },
		isReaction: true,
		trigger: 'A Creature misses you with an Attack.',
		description: 'You take the Full Dodge Action and move up to your Speed.',
		enhancements: [
			{
				name: 'Diving Attack',
				cost: { sp: 1 },
				description:
					'You can spend 1 SP to make an Attack Check against a creature within 1 Space of you as part of Slip Away (you make this attack before the creature makes theirs).'
			}
		]
	},
	{
		name: 'Sunder Armor',
		cost: { ap: 1, sp: 1 },
		isReaction: false,
		description:
			'You make a Martial Attack against a creature’s PD. Hit: Until the start of your next turn, the target gains Vulnerability (1) to a damage type dealt by the Attack.',
		enhancements: []
	},
	{
		name: 'Tumble and Dive',
		cost: { ap: 2, sp: 1 },
		isReaction: true,
		trigger: 'You are the target of an Attack.',
		description:
			'You move up to your Speed and avoid the attack entirely as long as you end your movement outside the range or behind Full Cover of the Attack. Additional Opportunity Attacks are still able to be made against you.',
		enhancements: [
			{
				name: 'Heroic Dive',
				cost: { sp: 2 },
				description:
					'You can spend 2 SP to bring a willing creature within 1 Space along with you as part of Tumble and Dive. They move the same amount of Spaces as you and must also end their movement within 1 Space of you.'
			}
		]
	},
	{
		name: 'Volley',
		cost: { ap: 2, sp: 1 },
		isReaction: false,
		requirement: 'Ranged Weapon',
		description:
			'You launch a volley of projectiles. Choose a point within your Weapon’s range. Make a single Attack Check and compare it against the AD of all creatures of your choice within 1 Space of the chosen point. Attack Hit: You deal 2 damage of the Weapon’s type to each creature.',
		enhancements: [
			{
				name: 'Impairing Volley',
				cost: { sp: 1 },
				description:
					'You can spend 1 SP to cause each creature within the area to make a Physical Save against your Save DC. Failure: They’re Impaired (DisADV on Physical Checks) until the end of your next turn.'
			},
			{
				name: 'Blanket of Arrows',
				cost: { sp: 1 },
				description: 'You can spend 1 SP to increase the area to 3 Spaces from the chosen point.'
			},
			{
				name: 'Line of Arrows',
				cost: { sp: 1 },
				description:
					'You can spend 1 SP to also target each creature occupying a Space in a Line between you and the chosen point.'
			}
		]
	},
	{
		name: 'Whirlwind',
		cost: { ap: 2, sp: 1 },
		isReaction: false,
		requirement: 'Melee Weapon or Unarmed Strike',
		description:
			'You make a single Attack Check against the AD of all creatures of your choice within 1 Space of you. Attack Hit: You deal your Weapon (or Unarmed Strike) damage to each creature.',
		enhancements: [
			{
				name: 'Blood Whirl',
				cost: { sp: 1 },
				description:
					'You can spend 1 SP to force each creature targeted to make a Physical Save against your Save DC. Failure: They begin Bleeding.'
			},
			{
				name: 'Wide Swing',
				cost: { sp: 1 },
				description:
					'You can spend 1 SP to increase the range of Whirlwind by 1 Space, targeting each creature of your choice within 2 Spaces of you.'
			},
			{
				name: 'Throwing Finisher',
				cost: { sp: 1 },
				description:
					'If you’re wielding a Melee Weapon, you can choose to spend an extra 1 SP at the end of the Whirlwind to throw the Weapon at a target within 5 Spaces. Use the same single Attack Check against this target as well. The weapon lands within 1 Space of the target (GM discretion).'
			}
		]
	}
];

/** A simple alias for the main techniques array. */
export const allTechniques = techniques;
````

## File: src/lib/rulesdata/traits.ts
````typescript
import type { ITrait } from './types';

export const traitsData: ITrait[] = [
	// Human Traits (p. 108)
	{
		id: 'human_attribute_increase',
		name: 'Attribute Increase',
		description:
			'Choose an Attribute. The chosen Attribute increases by 1 (up to the Attribute Limit).',
		cost: 2,
		effects: [
			{
				type: 'MODIFY_ATTRIBUTE',
				target: 'any_attribute_choice',
				value: 1,
				userChoiceRequired: { prompt: 'Choose an Attribute to increase by 1' }
			}
		]
	},
	{
		id: 'human_skill_expertise',
		name: 'Skill Expertise',
		description:
			'Choose a Skill. Your Mastery Cap and Mastery Level in the chosen Skill both increase by 1. You can only benefit from 1 Feature that increases your Skill Mastery Limit at a time.',
		cost: 2,
		effects: [
			{
				type: 'GRANT_SKILL_EXPERTISE',
				value: { skillId: 'any_skill_choice', capIncrease: 1, levelIncrease: 1 },
				userChoiceRequired: { prompt: 'Choose a skill for Expertise' }
			}
		]
	},
	{
		id: 'human_resolve',
		name: 'Human Resolve',
		description: 'Your Death’s Door Threshold value is expanded by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_DEATH_THRESHOLD_MODIFIER', value: 1 }]
	},
	{
		id: 'human_undying',
		name: 'Undying',
		description: 'You have ADV on Saves against the Doomed Condition.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Doomed' }]
	},
	{
		id: 'human_trade_expertise',
		name: 'Trade Expertise',
		description:
			'Choose a Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1. You can only benefit from 1 Feature that increases your Trade Mastery Limit at a time.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				value: { tradeId: 'any_trade_choice', capIncrease: 1, levelIncrease: 1 },
				userChoiceRequired: { prompt: 'Choose a Trade for Expertise' }
			}
		]
	},
	{
		id: 'human_determination',
		name: 'Human Determination',
		description:
			'Once per Combat, you can give yourself ADV on an Attack Check or Spell Check while Bloodied.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_ADV_ON_CHECK_WHILE_BLOODIED',
				target: 'Attack_or_Spell_Check',
				condition: 'bloodied'
			}
		]
	},
	{
		id: 'human_unbreakable',
		name: 'Unbreakable',
		description: 'You have ADV on Death Saves.',
		cost: 1,
		effects: [{ type: 'GRANT_ADV_ON_SAVE', target: 'Death_Save' }]
	},
	{
		id: 'human_attribute_decrease',
		name: 'Attribute Decrease',
		description:
			'Choose an Attribute. You decrease the chosen Attribute by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [
			{
				type: 'MODIFY_ATTRIBUTE',
				target: 'any_attribute_choice',
				value: -1,
				userChoiceRequired: { prompt: 'Choose an Attribute to decrease by 1' }
			}
		]
	},

	// Elf Traits (p. 108)
	{
		id: 'elf_elven_will',
		name: 'Elven Will',
		description: 'You have ADV on Checks and Saves against being Charmed and put to Sleep.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Charmed' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Sleep_Magic' }
		]
	},
	{
		id: 'elf_nimble',
		name: 'Nimble',
		description:
			'When you take the Dodge Action, you instead gain the benefits of the Full Dodge Action.',
		cost: 2,
		effects: [
			{ type: 'MODIFY_ACTION_BENEFIT', target: 'Dodge_Action', value: 'Full_Dodge_Benefit' }
		]
	},
	{
		id: 'elf_agile_explorer',
		name: 'Agile Explorer',
		description: 'You’re not affected by Difficult Terrain.',
		cost: 2,
		effects: [{ type: 'IGNORE_DIFFICULT_TERRAIN' }]
	},
	{
		id: 'elf_discerning_sight',
		name: 'Discerning Sight',
		description: 'You have ADV on Checks and Saves made to discern through visual illusions.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_CHECKS_SAVES_VS_ILLUSION_VISUAL' }]
	},
	{
		id: 'elf_quick_reactions',
		name: 'Quick Reactions',
		description: 'While you aren’t wearing Armor, you gain +1 PD.',
		cost: 1,
		effects: [{ type: 'MODIFY_PD', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'elf_peerless_sight',
		name: 'Peerless Sight',
		description:
			'You don’t have DisADV as a result of making an Attack with a Weapon at Long Range',
		cost: 1,
		effects: [{ type: 'IGNORE_DISADV_ON_RANGED_ATTACK_AT_LONG_RANGE' }]
	},
	{
		id: 'elf_climb_speed',
		name: 'Climb Speed',
		description: 'You gain a Climb Speed equal to your Movement Speed.',
		cost: 1,
		effects: [{ type: 'GRANT_CLIMB_SPEED_EQUAL_TO_SPEED' }]
	},
	{
		id: 'elf_speed_increase',
		name: 'Speed Increase',
		description: 'Your Speed increases by 1 Space.',
		cost: 2,
		effects: [{ type: 'MODIFY_SPEED', value: 5 }] // 1 Space = 5 feet
	},
	{
		id: 'elf_trade_expertise_elf',
		name: 'Trade Expertise (Elf)',
		description:
			'Choose a Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1. You can only benefit from 1 Feature that increases your Trade Mastery Limit at a time.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				value: { tradeId: 'any_trade_choice', capIncrease: 1, levelIncrease: 1 },
				userChoiceRequired: { prompt: 'Choose a Trade for Expertise' }
			}
		]
	},
	{
		id: 'elf_plant_knowledge',
		name: 'Plant Knowledge',
		description:
			'While within forests, jungles, and swamps, you have ADV on Survival Checks. Additionally, you have ADV on Nature Checks made to recall information about plants.',
		cost: 0,
		isMinor: true,
		effects: [
			{ type: 'GRANT_ADV_ON_SURVIVAL_CHECKS_IN_ENVIRONMENTS', target: 'forests_jungles_swamps' },
			{ type: 'GRANT_ADV_ON_NATURE_CHECKS_ABOUT_PLANTS' }
		]
	},
	{
		id: 'elf_brittle',
		name: 'Brittle',
		description: 'Your AD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_AD', value: -1 }]
	},
	{
		id: 'elf_frail',
		name: 'Frail',
		description: 'Your HP maximum decreases by 2.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_HP_MAX_STATIC', value: -2 }]
	},
	{
		id: 'elf_might_decrease',
		name: 'Might Decrease',
		description: 'Your Might decreases by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'might', value: -1 }]
	},

	// Dwarf Traits (p. 109)
	{
		id: 'dwarf_tough',
		name: 'Tough',
		description: 'Your HP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_HP_MAX_STATIC', value: 1 }]
	},
	{
		id: 'dwarf_toxic_fortitude',
		name: 'Toxic Fortitude',
		description: 'You have Poison Resistance (Half) and ADV on Saves against being Poisoned.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE_HALF', target: 'Poison' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Poisoned' }
		]
	},
	{
		id: 'dwarf_physically_sturdy',
		name: 'Physically Sturdy',
		description: 'You have ADV on Saves against being Impaired, Deafened, or Petrified.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Impaired' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Deafened' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Petrified' }
		]
	},
	{
		id: 'dwarf_iron_stomach',
		name: 'Iron Stomach',
		description: 'You have ADV on Saves against effects that come from consuming food or liquids.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_SAVE_VS_EFFECT_FROM_CONSUMING' }]
	},
	{
		id: 'dwarf_thick_skinned',
		name: 'Thick-Skinned',
		description: 'While you aren’t wearing Armor, you gain +1 AD.',
		cost: 1,
		effects: [{ type: 'MODIFY_AD', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'dwarf_natural_combatant',
		name: 'Natural Combatant',
		description: 'You gain Combat Training with Heavy Armor and All Shields.',
		cost: 1,
		effects: [
			{ type: 'GRANT_COMBAT_TRAINING', target: 'Heavy_Armor' },
			{ type: 'GRANT_COMBAT_TRAINING', target: 'All_Shields' }
		]
	},
	{
		id: 'dwarf_stone_blood',
		name: 'Stone Blood',
		description:
			'You have ADV on Saves against Bleeding. Additionally, you can spend 1 AP to end the Bleeding Condition on yourself.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Bleeding' },
			{ type: 'GRANT_ABILITY', value: 'End_Bleeding_Self_1AP' }
		]
	},
	{
		id: 'dwarf_minor_tremorsense',
		name: 'Minor Tremorsense',
		description: 'You have Tremorsense 3 Spaces.',
		cost: 1,
		effects: [{ type: 'GRANT_TREMORSENSE', value: 3 }]
	},
	{
		id: 'dwarf_stubborn',
		name: 'Stubborn',
		description: 'You have ADV on Saves against being Taunted and against being forcibly moved.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Taunted' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_FORCED_MOVEMENT' }
		]
	},
	{
		id: 'dwarf_trade_expertise',
		name: 'Trade Expertise',
		description:
			'Choose a Crafting or Services Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				value: {
					tradeId: 'any_crafting_or_services_trade_choice',
					capIncrease: 1,
					levelIncrease: 1
				},
				userChoiceRequired: { prompt: 'Choose a Crafting or Services Trade for Expertise' }
			}
		]
	},
	{
		id: 'dwarf_earthen_knowledge',
		name: 'Earthen Knowledge',
		description:
			'While within mountainous and subterranean environments, you have ADV on Survival Checks. Additionally, you have ADV on Nature Checks made to recall information about rocks, soil, crystals, and gems.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_ADV_ON_SURVIVAL_CHECKS_IN_ENVIRONMENTS',
				target: 'mountainous_and_subterranean'
			},
			{ type: 'GRANT_ADV_ON_NATURE_CHECKS_ABOUT_ROCKS_SOIL_CRYSTALS_GEMS' }
		]
	},
	{
		id: 'dwarf_charisma_attribute_decrease',
		name: 'Charisma Attribute Decrease',
		description: 'You decrease your Charisma by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'charisma', value: -1 }]
	},
	{
		id: 'dwarf_short_legged',
		name: 'Short-Legged',
		description: 'Your Speed decreases by 1 Space.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SPEED', value: -5 }]
	},

	// Halfling Traits (p. 109)
	{
		id: 'halfling_small_sized',
		name: 'Small-Sized',
		description: 'Your Size is considered Small.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SIZE', target: 'Small' }]
	},
	{
		id: 'halfling_elusive',
		name: 'Elusive',
		description:
			'When you take the Disengage Action, you instead gain the benefits of the Full Disengage Action.',
		cost: 2,
		effects: [
			{ type: 'MODIFY_ACTION_BENEFIT', target: 'Disengage_Action', value: 'Full_Disengage_Action' }
		]
	},
	{
		id: 'halfling_bravery',
		name: 'Halfling Bravery',
		description: 'You have ADV on Saves against being Intimidated, Rattled, or Frightened',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Intimidated' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Rattled' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Frightened' }
		]
	},
	{
		id: 'halfling_endurance',
		name: 'Halfling Endurance',
		description: 'You have Exhaustion Resistance.',
		cost: 1,
		effects: [{ type: 'GRANT_CONDITION_RESISTANCE', target: 'Exhaustion' }]
	},
	{
		id: 'halfling_deft_footwork',
		name: 'Deft Footwork',
		description:
			'You can move through the space of a hostile creature 1 size larger than you as if it were Difficult Terrain.',
		cost: 1,
		effects: [{ type: 'IGNORE_DIFFICULT_TERRAIN_WHEN_MOVING_THROUGH_SPACE_OF_LARGER_HOSTILE' }]
	},
	{
		id: 'halfling_beast_whisperer',
		name: 'Beast Whisperer',
		description:
			'You can speak to Beasts in a limited manner. They can understand the meanings of simple words, concepts, or states of emotion. You don’t have a special ability to understand them in return.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_LIMITED_COMMUNICATION_WITH_BEASTS' }]
	},
	{
		id: 'halfling_beast_insight',
		name: 'Beast Insight',
		description:
			'You can understand Beasts in a limited manner. You can understand the meaning of their noises and behaviors, though they have no special ability to understand you in return.',
		cost: 1,
		effects: [{ type: 'GRANT_LIMITED_UNDERSTANDING_OF_BEASTS' }]
	},
	{
		id: 'halfling_burst_of_bravery',
		name: 'Burst of Bravery',
		description:
			'Once per Combat, you can end the Intimidated, Rattled, or Frightened Condition on yourself for free at any time.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ABILITY', value: 'End_Intimidated_Rattled_Frightened_Self_OncePerCombat' }
		]
	},
	{
		id: 'halfling_trade_expertise',
		name: 'Trade Expertise',
		description:
			'Choose a Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				value: { tradeId: 'any_trade_choice', capIncrease: 1, levelIncrease: 1 },
				userChoiceRequired: { prompt: 'Choose a Trade for Expertise' }
			}
		]
	},
	{
		id: 'halfling_critter_knowledge',
		name: 'Critter Knowledge',
		description:
			'You have ADV on Nature, Survival, and Animal Checks involving Small size creatures and smaller.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_ADV_ON_CHECKS_INVOLVING_SMALL_CREATURES',
				target: 'Nature_Survival_Animal_Checks'
			}
		]
	},
	{
		id: 'halfling_brittle',
		name: 'Brittle',
		description: 'Your AD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_AD', value: -1 }]
	},
	{
		id: 'halfling_intelligence_attribute_decrease',
		name: 'Intelligence Attribute Decrease',
		description: 'You decrease your Intelligence by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'intelligence', value: -1 }]
	},
	{
		id: 'halfling_short_legged',
		name: 'Short-Legged',
		description: 'Your Speed decreases by 1 Space.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SPEED', value: -5 }]
	},

	// Gnome Traits (p. 110)
	{
		id: 'gnome_small_sized',
		name: 'Small-Sized',
		description: 'Your Size is considered Small.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SIZE', target: 'Small' }]
	},
	{
		id: 'gnome_escape_artist',
		name: 'Escape Artist',
		description:
			'You have ADV on Checks and Saves to avoid or escape being Grappled or Restrained.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_CHECKS_SAVES_TO_AVOID_ESCAPE', target: 'Grappled_or_Restrained' }
		]
	},
	{
		id: 'gnome_magnified_vision',
		name: 'Magnified Vision',
		description:
			'You have ADV on Investigation Checks made on something you’re holding or touching.',
		cost: 1,
		effects: [{ type: 'GRANT_ADV_ON_INVESTIGATION_CHECKS_ON_HELD_TOUCHED' }]
	},
	{
		id: 'gnome_mental_clarity',
		name: 'Mental Clarity',
		description: 'You have ADV on Saves against being Dazed or Stunned.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Dazed' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Stunned' }
		]
	},
	{
		id: 'gnome_strong_minded',
		name: 'Strong-Minded',
		description: 'You gain Psychic Resistance (1).',
		cost: 1,
		effects: [{ type: 'GRANT_RESISTANCE_STATIC', target: 'Psychic', value: 1 }]
	},
	{
		id: 'gnome_predict_weather',
		name: 'Predict Weather',
		description:
			'You can naturally tell what the weather is going to be in the next hour in the area within 1 mile of you. You don’t have DisADV on Checks or Saves as a result of naturally occurring weather.',
		cost: 0,
		isMinor: true,
		effects: [
			{ type: 'GRANT_ABILITY', value: 'Predict_Weather_1Mile_1Hour' },
			{ type: 'IGNORE_DISADV_FROM_NATURAL_WEATHER' }
		]
	},
	{
		id: 'gnome_mana_increase',
		name: 'Mana Increase',
		description: 'Your MP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_MP_MAX', value: 1 }]
	},
	{
		id: 'gnome_trapper',
		name: 'Trapper',
		description:
			'You have ADV on Investigation Checks to spot Traps and on Trickery Checks to Hide Traps.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_INVESTIGATION_CHECKS_TO_SPOT_TRAPS' },
			{ type: 'GRANT_ADV_ON_TRICKERY_CHECKS_TO_HIDE_TRAPS' }
		]
	},
	{
		id: 'gnome_lightning_insulation',
		name: 'Lightning Insulation',
		description: 'You have Lightning Resistance (Half) and can’t be struck by natural lightning.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE_HALF', target: 'Lightning' },
			{ type: 'IMMUNE_TO_NATURAL_LIGHTNING' }
		]
	},
	{
		id: 'gnome_trade_expertise',
		name: 'Trade Expertise',
		description:
			'Choose a Crafting or Subterfuge Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				value: {
					tradeId: 'any_crafting_or_subterfuge_trade_choice',
					capIncrease: 1,
					levelIncrease: 1
				},
				userChoiceRequired: { prompt: 'Choose a Crafting or Subterfuge Trade for Expertise' }
			}
		]
	},
	{
		id: 'gnome_storm_knowledge',
		name: 'Storm Knowledge',
		description:
			'While within rainy, snowy, or stormy environments, you have ADV on Survival Checks. Additionally, you have ADV on Knowledge Checks made to recall information about rain, snow, and storms.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SURVIVAL_CHECKS_IN_ENVIRONMENTS', target: 'rainy_snowy_stormy' },
			{ type: 'GRANT_ADV_ON_KNOWLEDGE_CHECKS_ABOUT_RAIN_SNOW_STORMS' }
		]
	},
	{
		id: 'gnome_agility_attribute_decrease',
		name: 'Agility Decrease',
		description: 'You decrease your Agility by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'agility', value: -1 }]
	},
	{
		id: 'gnome_short_legged',
		name: 'Short-Legged',
		description: 'Your Speed decreases by 1 Space.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SPEED', value: -5 }]
	},

	// Orc Traits (p. 110)
	{
		id: 'orc_cursed_mind',
		name: 'Cursed Mind',
		description: 'You gain Psychic Vulnerability (1).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_VULNERABILITY_STATIC', target: 'Psychic', value: 1 }]
	},
	{
		id: 'orc_rush',
		name: 'Orc Rush',
		description:
			'Once per Combat when you willingly move toward an enemy, you can spend 1 AP to gain Temp HP equal to your Prime Modifier.',
		cost: 2,
		effects: [
			{ type: 'GRANT_TEMP_HP_ONCE_PER_COMBAT_WHEN_MOVE_TOWARD_ENEMY', value: 'Prime_Modifier' }
		]
	},
	{
		id: 'orc_brutal_strikes',
		name: 'Brutal Strikes',
		description:
			'You deal +1 damage when you score a Brutal or Critical Hit with a Melee Weapon or Unarmed Strike.',
		cost: 2,
		effects: [
			{
				type: 'MODIFY_DAMAGE_ON_HIT',
				target: 'Melee_Martial_Attack',
				value: 1,
				condition: 'Brutal_or_Critical_Hit'
			}
		]
	},
	{
		id: 'orc_tough',
		name: 'Tough',
		description: 'Your HP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_HP_MAX_STATIC', value: 1 }]
	},
	{
		id: 'orc_orcish_resolve',
		name: 'Orcish Resolve',
		description: 'You gain 1 additional AP while on Death’s Door.',
		cost: 1,
		effects: [{ type: 'MODIFY_AP_WHILE_DEATHS_DOOR', value: 1 }]
	},
	{
		id: 'orc_already_cursed',
		name: 'Already Cursed',
		description: 'You have ADV on Saves against Curses.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Curses' }]
	},
	{
		id: 'orc_intimidating_shout',
		name: 'Intimidating Shout',
		description:
			'Once per Combat, you can spend 1 AP to let out an Intimidating Shout. All creatures within 5 Spaces that can hear you must make a Charisma Save contested by your Attack Check. Failure: A target is Hindered on the next Attack Check or Spell Attack it makes before the start of your next turn.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', value: 'Intimidating_Shout_OncePerCombat_1AP' }]
	},
	{
		id: 'orc_dash',
		name: 'Orc Dash',
		description:
			'Once per Combat you can use your Minor Action to move, as long as that movement is towards an enemy.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Move_As_Minor_Action_OncePerCombat_Toward_Enemy' }]
	},
	{
		id: 'orc_finishing_blow',
		name: 'Finishing Blow',
		description: 'You deal +1 damage to creatures who are Well-Bloodied.',
		cost: 1,
		effects: [
			{
				type: 'MODIFY_DAMAGE_ON_HIT',
				target: 'Martial_Attacks',
				value: 1,
				condition: 'Well_Bloodied'
			}
		]
	},
	{
		id: 'orc_imposing_presence',
		name: 'Imposing Presence',
		description:
			'Once per Combat when a creature makes an Attack against you, you can force them to make a Charisma Save. Save Failure: They must choose a new target for the Attack. If there are no other targets, then the Attack is wasted.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Force_New_Target_OncePerCombat_Reaction' }]
	},
	{
		id: 'orc_provocation',
		name: 'Provocation',
		description: 'You have DisADV on Checks and Saves against being Taunted.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_DISADV_ON_CHECKS_SAVES_VS_CONDITION', target: 'Taunted' }]
	},
	{
		id: 'orc_reckless',
		name: 'Reckless',
		description: 'Your PD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_PD', value: -1 }]
	},

	// Dragonborn Traits (p. 111)
	{
		id: 'dragonborn_darkvision',
		name: 'Darkvision',
		description: 'You have Darkvision 10 Spaces.',
		cost: 1,
		effects: [{ type: 'GRANT_DARKVISION', value: 10 }]
	},
	{
		id: 'dragonborn_draconic_resistance',
		name: 'Draconic Resistance',
		description: 'You gain Resistance (Half) to your Draconic damage type.',
		cost: 2,
		effects: [{ type: 'GRANT_RESISTANCE_HALF', target: 'Draconic_damage_type' }]
	},
	{
		id: 'dragonborn_draconic_breath_weapon',
		name: 'Draconic Breath Weapon',
		description:
			'You gain a Breath Weapon that you can use by spending 2 AP to exhale destructive power in an Area or Focused against a specific target. You can use this ability once per Long Rest, and regain the ability to use it again when you roll for Initiative.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ABILITY', value: 'Draconic_Breath_Weapon_OncePerLongRest_RegainOnInitiative' }
		]
	},
	{
		id: 'dragonborn_reptilian_superiority',
		name: 'Reptilian Superiority',
		description:
			'You have ADV on Intimidation Checks against reptilian creatures of Medium Size and smaller (not including other Dragonborn).',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_INTIMIDATION_CHECKS_VS_REPTILIAN_MEDIUM_SMALL' }]
	},
	{
		id: 'dragonborn_mana_increase',
		name: 'Mana Increase',
		description: 'Your MP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_MP_MAX', value: 1 }]
	},
	{
		id: 'dragonborn_thick_skinned',
		name: 'Thick-Skinned',
		description: 'While you aren’t wearing Armor, you gain +1 AD.',
		cost: 1,
		effects: [{ type: 'MODIFY_AD', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'dragonborn_second_breath',
		name: 'Second Breath',
		description:
			'You can now use your Draconic Breath Weapon twice per Combat. Additionally, whenever you use your Draconic Breath Weapon, you can spend 2 uses to increase the damage by 2 if its an Area, or by 4 if its Focused.',
		cost: 1,
		prerequisites: ['dragonborn_draconic_breath_weapon'],
		effects: [
			{ type: 'GRANT_ABILITY', value: 'Draconic_Breath_Weapon_TwicePerCombat' },
			{ type: 'GRANT_ABILITY', value: 'Draconic_Breath_Weapon_Enhanced_Damage_Spend_Uses' }
		]
	},
	{
		id: 'dragonborn_concussive_breath',
		name: 'Concussive Breath',
		description:
			'When you use your Draconic Breath Weapon, you can force all targets to make a Physical Save. Save Failure: The target is pushed 1 Space away +1 additional Space for every 5 it fails its Save by.',
		cost: 1,
		prerequisites: ['dragonborn_draconic_breath_weapon'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Draconic_Breath_Weapon_Concussive_Push' }]
	},
	{
		id: 'dragonborn_draconic_affinity',
		name: 'Draconic Affinity',
		description:
			'When you take damage of the same type as your Draconic damage, your next Draconic Breath Weapon deals +1 bonus damage.',
		cost: 1,
		effects: [
			{
				type: 'MODIFY_DAMAGE_ON_NEXT_DRACONIC_BREATH_WEAPON',
				value: 1,
				condition: 'take_same_type_damage'
			}
		]
	},
	{
		id: 'dragonborn_dying_breath',
		name: 'Dying Breath',
		description:
			'Once per Combat when you enter Death’s Door, you regain a use of your Draconic Breath Weapon and can immediately use it as a Reaction for free (0 AP).',
		cost: 1,
		prerequisites: ['dragonborn_draconic_breath_weapon'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Draconic_Breath_Weapon_Reaction_On_Deaths_Door' }]
	},
	{
		id: 'dragonborn_draconic_ward',
		name: 'Draconic Ward',
		description:
			'Once per Combat when you enter Death’s Door, you gain 2 Temp HP. Whenever you’re Hit by a Melee Attack while you have this Temp HP, your Attacker takes 1 Draconic damage.',
		cost: 1,
		effects: [
			{ type: 'GRANT_TEMP_HP_ONCE_PER_COMBAT_ON_DEATHS_DOOR', value: 2 },
			{ type: 'GRANT_DAMAGE_ON_MELEE_HIT_WHILE_TEMP_HP', target: 'Draconic_damage_type', value: 1 }
		]
	},
	{
		id: 'dragonborn_draconic_protection',
		name: 'Draconic Protection',
		description:
			'Once per Combat, when an ally within 20 Spaces is on Death’s Door, you begin to surge with an ancient power. While they remain on Death’s Door their PD and AD increases by 5 until Combat ends.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Increase_PD_AD_Ally_On_Deaths_Door' }]
	},
	{
		id: 'dragonborn_glide_speed',
		name: 'Glide Speed',
		description:
			'You have a set of wings that you can use to horizontally glide and slow your descent. Provided you aren’t Incapacitated, you gain the following benefits while in the air: Controlled Falling: You suffer no damage from Controlled Falling. Altitude Drop: If you end your turn midair, you Controlled Fall 4 Spaces. Glide Speed: You can use your movement to glide horizontally.',
		cost: 2,
		effects: [{ type: 'GRANT_GLIDE_SPEED' }]
	},
	{
		id: 'dragonborn_guardians_bond',
		name: 'Guardian’s Bond',
		description:
			'Once per Combat when an ally enters Death’s Door within 20 Spaces of you, you take an amount of True damage equal to your Prime Modifier.',
		cost: -1,
		isNegative: true,
		effects: [
			{ type: 'TAKE_TRUE_DAMAGE_ONCE_PER_COMBAT_WHEN_ALLY_DEATHS_DOOR', value: 'Prime_Modifier' }
		]
	},

	// Giantborn Traits (p. 112)
	{
		id: 'giantborn_tough',
		name: 'Tough',
		description: 'Your HP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_HP_MAX_STATIC', value: 1 }]
	},
	{
		id: 'giantborn_powerful_build',
		name: 'Powerful Build',
		description: 'You increase by 1 Size, but you occupy the Space of a creature 1 Size smaller.',
		cost: 2,
		effects: [
			{ type: 'MODIFY_SIZE', target: 'Large' },
			{ type: 'MODIFY_SPACE_OCCUPIED', target: '1_Size_Smaller' }
		]
	},
	{
		id: 'giantborn_unstoppable',
		name: 'Unstoppable',
		description: 'You have ADV on Saves against being Slowed or Stunned.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Slowed' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Stunned' }
		]
	},
	{
		id: 'giantborn_giants_resolve',
		name: 'Giant’s Resolve',
		description: 'While on Death’s Door, you reduce all damage taken by 1.',
		cost: 1,
		effects: [{ type: 'REDUCE_DAMAGE_TAKEN', value: 1, condition: 'deaths_door' }]
	},
	{
		id: 'giantborn_unyielding_movement',
		name: 'Unyielding Movement',
		description: 'You’re immune to being Slowed 2 (or higher).',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'IMMUNE_TO_SLOWED_2_OR_HIGHER' }]
	},
	{
		id: 'giantborn_giants_fortitude',
		name: 'Giant’s Fortitude',
		description: 'You also gain the benefits of your Giant’s Resolve Trait while Well-Bloodied.',
		cost: 2,
		prerequisites: ['giantborn_giants_resolve'],
		effects: [{ type: 'GRANT_BENEFIT_WHILE_WELL_BLOODIED', target: 'giantborn_giants_resolve' }]
	},
	{
		id: 'giantborn_strong_body',
		name: 'Strong Body',
		description:
			'Once per Combat when you take damage from an Attack, you can reduce the damage taken by an amount equal to your Might or Agility (your choice).',
		cost: 2,
		effects: [{ type: 'REDUCE_DAMAGE_TAKEN_ONCE_PER_COMBAT', value: 'Might_or_Agility' }]
	},
	{
		id: 'giantborn_mighty_hurl',
		name: 'Mighty Hurl',
		description:
			'You throw creatures 1 Space farther than normal, and objects (including Weapons) 5 Spaces farther than normal.',
		cost: 1,
		effects: [
			{ type: 'MODIFY_THROW_DISTANCE_CREATURES', value: 1 },
			{ type: 'MODIFY_THROW_DISTANCE_OBJECTS', value: 5 }
		]
	},
	{
		id: 'giantborn_titanic_toss',
		name: 'Titanic Toss',
		description:
			'You have ADV on Checks made to throw creatures. Additionally, you don’t have DisADV as a result of making an Attack with a Weapon with the Toss or Thrown Property at Long Range.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_CHECKS', target: 'Throw_Creatures' },
			{ type: 'IGNORE_DISADV_ON_RANGED_ATTACK_WITH_TOSS_THROWN_AT_LONG_RANGE' }
		]
	},
	{
		id: 'giantborn_mighty_leap',
		name: 'Mighty Leap',
		description:
			'You can use your Might instead of Agility to determine your Jump Distance and the damage you take from Falling.',
		cost: 1,
		effects: [{ type: 'USE_ATTRIBUTE_FOR_JUMP_DISTANCE_FALLING_DAMAGE', target: 'Might' }]
	},
	{
		id: 'giantborn_brute',
		name: 'Brute',
		description: 'Once per Combat, you can take the Shove or Grapple Action as a Minor Action.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Shove_or_Grapple_As_Minor_Action_OncePerCombat' }]
	},
	{
		id: 'giantborn_heavy_riser',
		name: 'Heavy Riser',
		description: 'You have to spend 4 Spaces of movement to stand up from Prone.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_MOVEMENT_TO_STAND_UP', value: 4 }]
	},
	{
		id: 'giantborn_clumsiness',
		name: 'Clumsiness',
		description: 'You have DisADV on Agility Checks.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_DISADV_ON_CHECKS', target: 'Agility_Checks' }]
	},
	{
		id: 'giantborn_intelligence_attribute_decrease',
		name: 'Intelligence Decrease',
		description: 'You decrease your Intelligence by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'intelligence', value: -1 }]
	},

	// Angelborn Traits (p. 113)
	{
		id: 'angelborn_radiant_resistance',
		name: 'Radiant Resistance',
		description: 'You have Resistance (Half) to Radiant damage.',
		cost: 1,
		effects: [{ type: 'GRANT_RESISTANCE_HALF', target: 'Radiant' }]
	},
	{
		id: 'angelborn_celestial_magic',
		name: 'Celestial Magic',
		description:
			'You learn 1 Spell of your choice from the Divine Spell List (Holy & Restoration during the Beta). Once per Long Rest, you can cast the chosen Spell spending 1 less MP than normal (minimum of 0 MP). The Spells total MP cost (before all reductions) still can’t exceed your Mana Spend Limit.',
		cost: 2,
		effects: [
			{ type: 'GRANT_SPELL_FROM_LIST', target: 'Divine_Spell_List' },
			{ type: 'REDUCE_MP_COST_ONCE_PER_LONG_REST', value: 1 }
		]
	},
	{
		id: 'angelborn_healing_touch',
		name: 'Healing Touch',
		description:
			'Once per Combat, you can spend 1 AP to touch a creature and Heal it. Make a DC 10 Spell Check. Success: You can restore up to 2 HP to the target. Success (each 5): +1 HP. Failure: You only restore 2 HP.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', value: 'Healing_Touch_OncePerCombat_1AP' }]
	},
	{
		id: 'angelborn_divine_glow',
		name: 'Divine Glow',
		description: 'Your body can emit a Bright Light in a 5 Space radius around you at will.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ABILITY', value: 'Emit_Bright_Light_5Space_Radius_AtWill' }]
	},
	{
		id: 'angelborn_mana_increase',
		name: 'Mana Increase',
		description: 'Your MP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_MP_MAX', value: 1 }]
	},
	{
		id: 'angelborn_celestial_clarity',
		name: 'Celestial Clarity',
		description: 'You have ADV on Saves against being Blinded or Deafened.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Blinded' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Deafened' }
		]
	},
	{
		id: 'angelborn_angelic_insight',
		name: 'Angelic Insight',
		description:
			'Once per Long Rest you can grant yourself ADV on an Insight Check to see if someone is lying.',
		cost: 1,
		effects: [{ type: 'GRANT_ADV_ON_INSIGHT_CHECK_ONCE_PER_LONG_REST', condition: 'see_if_lying' }]
	},
	{
		id: 'angelborn_gift_of_the_angels',
		name: 'Gift of the Angels',
		description:
			'Once per Combat you can spend 1 AP and 1 MP and touch a creature to heal them over time. The creature recovers 1 HP at the start of each of their turns for 1 minute (5 Rounds).',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', value: 'Heal_Over_Time_OncePerCombat_1AP_1MP' }]
	},
	{
		id: 'angelborn_blinding_light',
		name: 'Blinding Light',
		description:
			'Once per Combat, you can spend 1 AP to choose a creature within 5 Spaces and make a Spell Check contested by its Physical Save. Success: The target is Blinded until the end of your next turn.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Blind_Target_OncePerCombat_1AP' }]
	},
	{
		id: 'angelborn_glide_speed',
		name: 'Glide Speed',
		description:
			'You have a set of wings that you can use to horizontally glide and slow your descent. Provided you aren’t Incapacitated, you gain the following benefits while in the air: Controlled Falling: You suffer no damage from Controlled Falling. Altitude Drop: If you end your turn midair, you Controlled Fall 4 Spaces. Glide Speed: You can use your movement to glide horizontally.',
		cost: 2,
		effects: [{ type: 'GRANT_GLIDE_SPEED' }]
	},
	{
		id: 'angelborn_pacifist',
		name: 'Pacifist',
		description:
			'Your divine call is to put others before yourself and resist doing harm. You suffer a -1 penalty to all Checks and Saves made during the first round of Combat.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'PENALTY_ON_CHECKS_SAVES_FIRST_ROUND_OF_COMBAT', value: -1 }]
	},
	{
		id: 'angelborn_umbral_weakness',
		name: 'Umbral Weakness',
		description: 'You have Umbral Vulnerability (1).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_VULNERABILITY_STATIC', target: 'Umbral', value: 1 }]
	},

	// Fiendborn Traits (p. 114)
	{
		id: 'fiendborn_fiendish_resistance',
		name: 'Fiendish Resistance',
		description: 'You gain Resistance (Half) to your Fiendish damage type.',
		cost: 2,
		effects: [{ type: 'GRANT_RESISTANCE_HALF', target: 'Fiendish_damage_type' }]
	},
	{
		id: 'fiendborn_fiendish_magic',
		name: 'Fiendish Magic',
		description:
			'You learn 1 Spell of your choice from the Arcane Spell List from the Destruction or Enchantment Spell Schools. If the Spell deals damage, it must be the same damage type as your Fiendish damage. Once per Long Rest, you can cast the chosen Spell spending 1 less MP than normal (minimum of 0 MP). The Spells total MP cost (before all reductions) still can’t exceed your Mana Spend Limit.',
		cost: 2,
		effects: [
			{
				type: 'GRANT_SPELL_FROM_LIST_SCHOOLS',
				target: 'Arcane_Spell_List',
				schools: ['Destruction', 'Enchantment']
			},
			{
				type: 'REDUCE_MP_COST_ONCE_PER_LONG_REST',
				value: 1,
				condition: 'spell_damage_type_matches_fiendish'
			}
		]
	},
	{
		id: 'fiendborn_darkvision',
		name: 'Darkvision',
		description: 'You have a Darkvision of 10 Spaces.',
		cost: 1,
		effects: [{ type: 'GRANT_DARKVISION', value: 10 }]
	},
	{
		id: 'fiendborn_lights_bane',
		name: 'Light’s Bane',
		description: 'You can spend 1 AP to snuff out a mundane light source within 5 Spaces of you.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ABILITY', value: 'Snuff_Out_Mundane_Light_Source_1AP' }]
	},
	{
		id: 'fiendborn_mana_increase',
		name: 'Mana Increase',
		description: 'Your MP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_MP_MAX', value: 1 }]
	},
	{
		id: 'fiendborn_silver_tongued',
		name: 'Silver-Tongued',
		description:
			'Once per Long Rest you can grant yourself ADV on an Influence Check when trying to deceive someone.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_INFLUENCE_CHECK_ONCE_PER_LONG_REST', condition: 'trying_to_deceive' }
		]
	},
	{
		id: 'fiendborn_fiendish_aura',
		name: 'Fiendish Aura',
		description:
			'You learn the Sorcery Cantrip, but you must choose the type of energy that’s the same as your Fiendish Origin.',
		cost: 1,
		effects: [
			{ type: 'GRANT_SPELL_KNOWN', value: 'Sorcery_Cantrip' },
			{ type: 'SET_SORCERY_ENERGY_TYPE', target: 'Fiendish_Origin' }
		]
	},
	{
		id: 'fiendborn_superior_darkvision',
		name: 'Superior Darkvision',
		description: 'Your Darkvision increases to 20 Spaces.',
		cost: 1,
		prerequisites: ['fiendborn_darkvision'],
		effects: [{ type: 'MODIFY_DARKVISION', value: 20 }]
	},
	{
		id: 'fiendborn_infernal_bravery',
		name: 'Infernal Bravery',
		description: 'You have ADV on Saves against being Intimidated.',
		cost: 1,
		effects: [{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Intimidated' }]
	},
	{
		id: 'fiendborn_intimidator',
		name: 'Intimidator',
		description: 'Once per Combat you can take the Intimidate Action as a Minor Action.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Intimidate_As_Minor_Action_OncePerCombat' }]
	},
	{
		id: 'fiendborn_charming_gaze',
		name: 'Charming Gaze',
		description:
			'You can spend 1 AP to gaze upon a creature you can see within 10 Spaces that can also see you. Make a Spell Check contested by the target’s Repeated Charisma Save. Success: The creature becomes Charmed by you for 1 minute. You can use this ability once per Long Rest, and when you roll for Initiative, or meet some other unique criteria at the GM’s discretion, this ability recharges.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Charm_Target_OncePerLongRest_1AP' }]
	},
	{
		id: 'fiendborn_glide_speed',
		name: 'Glide Speed',
		description:
			'You have a set of wings that you can use to horizontally glide and slow your descent. Provided you aren’t Incapacitated, you gain the following benefits while in the air: Controlled Falling: You suffer no damage from Controlled Falling. Altitude Drop: If you end your turn midair, you Controlled Fall 4 Spaces. Glide Speed: You can use your movement to glide horizontally.',
		cost: 2,
		effects: [{ type: 'GRANT_GLIDE_SPEED' }]
	},
	{
		id: 'fiendborn_radiant_weakness',
		name: 'Radiant Weakness',
		description: 'You have Radiant Vulnerability (1).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_VULNERABILITY_STATIC', target: 'Radiant', value: 1 }]
	},
	{
		id: 'fiendborn_divine_dampening',
		name: 'Divine Dampening',
		description: 'You recover 1 less HP when healed from divine sources.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'REDUCE_HP_REGAINED_FROM_DIVINE_SOURCES', value: 1 }]
	},

	// Beastborn Traits (p. 115-116)
	{
		id: 'beastborn_darkvision',
		name: 'Darkvision',
		description: 'You have Darkvision 10 Spaces.',
		cost: 1,
		effects: [{ type: 'GRANT_DARKVISION', value: 10 }]
	},
	{
		id: 'beastborn_echolocation',
		name: 'Echolocation',
		description:
			'You can spend 1 AP to roar, scream, or screech to gain Blindsight in a 10 Spaces radius that lasts until the start of your next turn. The sound can be heard from up to 100 Spaces away. You gain no benefit from this Trait in an area of Silence.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Echolocation_1AP_10Space_1Round' }]
	},
	{
		id: 'beastborn_keen_sense',
		name: 'Keen Sense',
		description:
			'Choose 1 of the following senses: hearing, sight, or smell. You make Awareness Checks with ADV using the chosen sense.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_ADV_ON_AWARENESS_CHECKS_USING_SENSE',
				target: 'chosen_sense',
				userChoiceRequired: { prompt: 'Choose a sense: hearing, sight, or smell' }
			}
		]
		// This trait can be chosen multiple times, but the interface doesn't directly support that.
		// The logic for handling multiple selections will need to be in the application.
	},
	{
		id: 'beastborn_sunlight_sensitivity',
		name: 'Sunlight Sensitivity',
		description:
			'While you or your target is in sunlight, you have DisADV on Attacks and Awareness Checks that rely on sight.',
		cost: -2,
		isNegative: true,
		effects: [{ type: 'GRANT_DISADV_ON_ATTACKS_AWARENESS_CHECKS_IN_SUNLIGHT' }]
	},
	{
		id: 'beastborn_quick_reactions',
		name: 'Quick Reactions',
		description: 'While you aren’t wearing Armor, you gain +1 PD.',
		cost: 1,
		effects: [{ type: 'MODIFY_PD', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'beastborn_climb_speed',
		name: 'Climb Speed',
		description: 'You gain a Climb Speed equal to your Ground Speed.',
		cost: 1,
		effects: [{ type: 'GRANT_CLIMB_SPEED_EQUAL_TO_SPEED' }]
	},
	{
		id: 'beastborn_spider_climb',
		name: 'Spider Climb',
		description:
			'You can walk without falling on the ceiling and vertical surfaces normally without needing to Climb.',
		cost: 1,
		prerequisites: ['beastborn_climb_speed'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Walk_On_Vertical_Surfaces_Ceilings' }]
	},
	{
		id: 'beastborn_web_walk',
		name: 'Web Walk',
		description:
			'You can walk along and through webs unimpeded. Additionally, you know the location of any creature that’s in contact with the same web.',
		cost: 1,
		effects: [
			{ type: 'IGNORE_DIFFICULT_TERRAIN_FROM_WEBS' },
			{ type: 'KNOW_LOCATION_OF_CREATURES_IN_CONTACT_WITH_WEB' }
		]
	},
	{
		id: 'beastborn_water_breathing',
		name: 'Water Breathing',
		description: 'You can breathe underwater.',
		cost: 1,
		effects: [{ type: 'GRANT_WATER_BREATHING' }]
	},
	{
		id: 'beastborn_swim_speed',
		name: 'Swim Speed',
		description:
			'You gain a Swim Speed equal to your Ground Speed. Additionally, your Breath Duration increases by 3.',
		cost: 1,
		effects: [
			{ type: 'GRANT_SWIM_SPEED_EQUAL_TO_SPEED' },
			{ type: 'MODIFY_BREATH_DURATION', value: 3 }
		]
	},
	{
		id: 'beastborn_speed_increase',
		name: 'Speed Increase',
		description: 'Your Speed increases by 1 Space.',
		cost: 2,
		effects: [{ type: 'MODIFY_SPEED', value: 5 }]
		// This trait can be chosen up to 5 times, but the interface doesn't directly support that.
		// The logic for handling multiple selections will need to be in the application.
	},
	{
		id: 'beastborn_sprint',
		name: 'Sprint',
		description:
			'You can use your Minor Action to take the Move Action. Once you use this Trait, you can’t use it again until you take a turn without taking the Move Action.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', value: 'Move_As_Minor_Action_OncePerTurn_NoMoveAction' }]
	},
	{
		id: 'beastborn_charge',
		name: 'Charge',
		description:
			'If you move at least 2 Spaces in a straight line before making a Melee Attack, the damage of the Attack increases by 1.',
		cost: 2,
		effects: [
			{
				type: 'MODIFY_DAMAGE_ON_MELEE_ATTACK',
				value: 1,
				condition: 'move_2_spaces_straight_before'
			}
		]
	},
	{
		id: 'beastborn_burrow_speed',
		name: 'Burrow Speed',
		description: 'You gain a Burrow Speed equal to half your Movement Speed.',
		cost: 2,
		effects: [{ type: 'GRANT_BURROW_SPEED_HALF_SPEED' }]
	},
	{
		id: 'beastborn_jumper',
		name: 'Jumper',
		description:
			'Your Jump Distance increases by 2, and you can take the Jump Action as a Minor Action.',
		cost: 1,
		effects: [
			{ type: 'MODIFY_JUMP_DISTANCE', value: 2 },
			{ type: 'GRANT_ABILITY', value: 'Jump_As_Minor_Action' }
		]
	},
	{
		id: 'beastborn_strong_jumper',
		name: 'Strong Jumper',
		description:
			'You no longer need to move 2 Spaces before performing a Running Jump, and you take 0 damage from Controlled Falling 5 Spaces or less.',
		cost: 1,
		effects: [
			{ type: 'IGNORE_2_SPACES_MOVEMENT_FOR_RUNNING_JUMP' },
			{ type: 'IGNORE_FALLING_DAMAGE_5_SPACES_OR_LESS' }
		]
	},
	{
		id: 'beastborn_glide_speed',
		name: 'Glide Speed',
		description:
			'You have a set of wings that you can use to horizontally glide and slow your descent. Provided you aren’t Incapacitated, you gain the following benefits while in the air: Controlled Falling: You suffer no damage from Controlled Falling. Altitude Drop: If you end your turn midair, you Controlled Fall 4 Spaces. Glide Speed: You can use your movement to glide horizontally.',
		cost: 2,
		effects: [{ type: 'GRANT_GLIDE_SPEED' }]
	},
	{
		id: 'beastborn_limited_flight',
		name: 'Limited Flight',
		description:
			'You have a set of wings that grant you limited flight. Provided you aren’t Incapacitated, you gain the following benefits: Vertical Ascent: You can spend 2 Spaces of movement to ascend 1 Space vertically. Hover: When you end your turn in the air, you maintain your altitude.',
		cost: 2,
		prerequisites: ['beastborn_glide_speed'],
		effects: [{ type: 'GRANT_LIMITED_FLIGHT' }]
	},
	{
		id: 'beastborn_full_flight',
		name: 'Full Flight',
		description: 'You have a Fly Speed equal to your Ground Speed.',
		cost: 2,
		prerequisites: ['beastborn_limited_flight'],
		effects: [{ type: 'GRANT_FLY_SPEED_EQUAL_TO_SPEED' }]
	},
	{
		id: 'beastborn_flyby',
		name: 'Flyby',
		description: 'You don’t provoke Opportunity Attacks when you Fly out of an enemy’s reach.',
		cost: 1,
		prerequisites: ['beastborn_limited_flight'],
		effects: [{ type: 'IGNORE_OPPORTUNITY_ATTACKS_WHEN_FLY_OUT_OF_REACH' }]
	},
	{
		id: 'beastborn_stealth_feathers',
		name: 'Stealth Feathers',
		description: 'You have ADV on Stealth Checks while Flying.',
		cost: 2,
		prerequisites: ['beastborn_limited_flight'],
		effects: [{ type: 'GRANT_ADV_ON_STEALTH_CHECKS_WHILE_FLYING' }]
	},
	{
		id: 'beastborn_winged_arms',
		name: 'Winged Arms',
		description:
			'Your arms are also your wings. Anytime you use a Glide Speed or Flying Speed, you can’t hold anything in your hands.',
		cost: -1,
		isNegative: true,
		prerequisites: ['beastborn_limited_flight'], // Assuming Limited Flight or Full Flight
		effects: [{ type: 'PENALTY_CANT_HOLD_WHILE_FLYING' }]
	},
	{
		id: 'beastborn_tough',
		name: 'Tough',
		description: 'Your HP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_HP_MAX_STATIC', value: 1 }]
	},
	{
		id: 'beastborn_thick_skinned',
		name: 'Thick-Skinned',
		description: 'While you aren’t wearing Armor, you gain +1 AD.',
		cost: 1,
		effects: [{ type: 'MODIFY_AD', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'beastborn_powerful_build',
		name: 'Powerful Build',
		description: 'You increase by 1 Size, but you occupy the Space of a creature 1 Size smaller.',
		cost: 2,
		effects: [
			{ type: 'MODIFY_SIZE', target: 'Large' },
			{ type: 'MODIFY_SPACE_OCCUPIED', target: '1_Size_Smaller' }
		]
	},
	{
		id: 'beastborn_long_limbed',
		name: 'Long-Limbed',
		description: 'When you make a Melee Martial Attack, your reach is 1 Space greater than normal.',
		cost: 3,
		effects: [{ type: 'MODIFY_MELEE_REACH', value: 1 }]
	},
	{
		id: 'beastborn_secondary_arms',
		name: 'Secondary Arms',
		description:
			'You have 2 slightly smaller secondary arms below your primary pair of arms. They function just like your primary arms, but they can’t wield Weapons with the Heavy Property or Shields.',
		cost: 1,
		effects: [{ type: 'GRANT_SECONDARY_ARMS' }]
	},
	{
		id: 'beastborn_prehensile_appendage',
		name: 'Prehensile Appendage',
		description:
			'You have a prehensile tail or trunk that has a reach of 1 Space and can lift up an amount of pounds equal to your Might times 5 (or half as many kilograms). You can use it to lift, hold, or drop objects, and to push, pull, or grapple creatures. It can’t wield Weapons or Shields, you can’t use tools with it that require manual precision, and you can’t use it in place of Somatic Components for Spells.',
		cost: 1,
		effects: [{ type: 'GRANT_PREHENSILE_APPENDAGE' }]
	},
	{
		id: 'beastborn_hazardous_hide',
		name: 'Hazardous Hide',
		description:
			'You have spikes, retractable barbs, poisonous skin, or some other form of defense mechanism to keep creatures from touching you. Choose 1 of the following damage types: Corrosion, Piercing, or Poison. While you are physically Grappled, your Grappler takes 1 damage of the chosen type at the start of each of its turns. Creatures that start their turn Grappled by you also take this damage.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_DAMAGE_TO_GRAPPLER',
				target: 'chosen_damage_type',
				value: 1,
				userChoiceRequired: { prompt: 'Choose a damage type: Corrosion, Piercing, or Poison' }
			}
		]
	},
	{
		id: 'beastborn_natural_armor',
		name: 'Natural Armor',
		description: 'While not wearing Armor, you gain PDR.',
		cost: 2,
		prerequisites: ['beastborn_thick_skinned'],
		effects: [{ type: 'GRANT_PDR', condition: 'not_wearing_armor' }]
	},
	{
		id: 'beastborn_hard_shell',
		name: 'Hard Shell',
		description:
			'You have a large shell around your body for protection. Your AD increases by 1 (while you’re not wearing Armor), your Movement Speed decreases by 1, and you’re immune to being Flanked.',
		cost: 1,
		prerequisites: ['beastborn_thick_skinned'],
		effects: [
			{ type: 'MODIFY_AD', value: 1, condition: 'not_wearing_armor' },
			{ type: 'MODIFY_SPEED', value: -5 },
			{ type: 'IMMUNE_TO_FLANKING' }
		]
	},
	{
		id: 'beastborn_shell_retreat',
		name: 'Shell Retreat',
		description:
			'Your body has a shell that you can retreat into. You can spend 1 AP to retreat into or come back out of your shell. You gain +5 PD and AD, PDR, EDR and ADV on Might Saves. While in your shell, you’re Prone, you can’t move, you have DisADV on Agility Saves, and you can’t take Reactions.',
		cost: 1,
		prerequisites: ['beastborn_hard_shell'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Retreat_Into_Shell_1AP' }]
	},
	{
		id: 'beastborn_camouflage',
		name: 'Camouflage',
		description:
			'You can change the color and pattern of your body. You have ADV on Stealth Checks while motionless.',
		cost: 2,
		effects: [{ type: 'GRANT_ADV_ON_STEALTH_CHECKS_WHILE_MOTIONLESS' }]
	},
	{
		id: 'beastborn_prowler',
		name: 'Prowler',
		description: 'You have ADV on Stealth Checks while in Darkness.',
		cost: 1,
		effects: [{ type: 'GRANT_ADV_ON_STEALTH_CHECKS_WHILE_IN_DARKNESS' }]
	},
	{
		id: 'beastborn_cold_resistance',
		name: 'Cold Resistance',
		description:
			'You have Cold Resistance (Half) and Resistance to Exhaustion from cold temperatures.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE_HALF', target: 'Cold' },
			{ type: 'GRANT_RESISTANCE_TO_EXHAUSTION', condition: 'cold_temperatures' }
		]
	},
	{
		id: 'beastborn_fire_resistance',
		name: 'Fire Resistance',
		description:
			'You have Fire Resistance (Half) and Resistance to Exhaustion from hot temperatures.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE_HALF', target: 'Fire' },
			{ type: 'GRANT_RESISTANCE_TO_EXHAUSTION', condition: 'hot_temperatures' }
		]
	},
	{
		id: 'beastborn_short_legged',
		name: 'Short-Legged',
		description: 'Your Speed decreases by 1 Space.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SPEED', value: -5 }]
	},
	{
		id: 'beastborn_small_sized',
		name: 'Small-Sized',
		description: 'Your Size is considered Small.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SIZE', target: 'Small' }]
	},
	{
		id: 'beastborn_reckless',
		name: 'Reckless',
		description: 'Your PD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_PD', value: -1 }]
	},
	{
		id: 'beastborn_natural_weapon',
		name: 'Natural Weapon',
		description:
			'You have up to 2 Natural Weapons (claws, horns, fangs, tail, etc.) which you can use to make Unarmed Strikes that deal 1 Bludgeoning, Piercing, or Slashing damage (your choice upon gaining this Trait). You can perform Attack Maneuvers with your Natural Weapons.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_NATURAL_WEAPON',
				value: 1,
				userChoiceRequired: { prompt: 'Choose a damage type: Bludgeoning, Piercing, or Slashing' }
			}
		]
		// This trait can be chosen multiple times, but the interface doesn't directly support that.
		// The logic for handling multiple selections will need to be in the application.
	},
	{
		id: 'beastborn_extended_natural_weapon',
		name: 'Extended Natural Weapon',
		description: 'Your Natural Weapon now has the Reach Property.',
		cost: 2,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_PROPERTY_TO_NATURAL_WEAPON', target: 'Reach' }]
	},
	{
		id: 'beastborn_natural_projectile',
		name: 'Natural Projectile',
		description:
			'You can use your Natural Weapon to make a Ranged Martial Attack with a Range of 10 Spaces. The Natural Weapon might produce a spine, barb, fluid, or other harmful projectile (your choice).',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Natural_Projectile_Ranged_Attack' }]
	},
	{
		id: 'beastborn_natural_weapon_passive',
		name: 'Natural Weapon Passive',
		description:
			'You can choose 1 Weapon Style that fits your desired Natural Weapon. You can benefit from the chosen Weapon Style’s passive with your Natural Weapon.',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [
			{
				type: 'GRANT_WEAPON_STYLE_PASSIVE_TO_NATURAL_WEAPON',
				target: 'chosen_weapon_style',
				userChoiceRequired: { prompt: 'Choose a Weapon Style' }
			}
		]
	},
	{
		id: 'beastborn_rend',
		name: 'Rend',
		description:
			'You can spend 1 AP when making an Attack Check with your Natural Weapon to force the target to make a Physical Save. Failure: Target begins Bleeding.',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Rend_Bleeding_1AP' }]
	},
	{
		id: 'beastborn_retractable_natural_weapon',
		name: 'Retractable Natural Weapon',
		description:
			'Your Natural Weapon is able to be concealed or retracted and gains the Concealable Property (gain ADV on the first Attack Check you make in Combat).',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_PROPERTY_TO_NATURAL_WEAPON', target: 'Concealable' }]
	},
	{
		id: 'beastborn_venomous_natural_weapon',
		name: 'Venomous Natural Weapon',
		description:
			'When you Hit a creature with your Natural Weapon, they make a Physical Save against your Save DC. Failure: The target becomes Impaired until the start of your next turn.',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Venomous_Natural_Weapon_Impaired' }]
	},
	{
		id: 'beastborn_fast_reflexes',
		name: 'Fast Reflexes',
		description:
			'You gain ADV on Initiative Checks and on the first Attack Check you make in Combat.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_INITIATIVE_CHECKS' },
			{ type: 'GRANT_ADV_ON_FIRST_ATTACK_CHECK_IN_COMBAT' }
		]
	},
	{
		id: 'beastborn_mimicry',
		name: 'Mimicry',
		description:
			'You can mimic simple sounds that you’ve heard (such as a baby’s crying, the creak of a door, or single words) and repeat short 3 word phrases that sound identical to what you heard. A creature can make an Insight Check contested by your Trickery Check to determine if this sound is real.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Mimic_Simple_Sounds_Short_Phrases' }]
	},
	{
		id: 'beastborn_intimidating_shout',
		name: 'Intimidating Shout',
		description:
			'Once per Combat, you can spend 1 AP to let out an Intimidating Shout. All creatures within 5 Spaces that can hear you must make a Charisma Save contested by your Attack Check. Failure: A target is Hindered on the next Attack Check or Spell Attack it makes before the start of your next turn.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', value: 'Intimidating_Shout_OncePerCombat_1AP' }]
	},
	{
		id: 'beastborn_toxic_fortitude',
		name: 'Toxic Fortitude',
		description: 'You have Poison Resistance (Half) and ADV on Saves against being Poisoned.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE_HALF', target: 'Poison' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Poisoned' }
		]
	},
	{
		id: 'beastborn_shoot_webs',
		name: 'Shoot Webs',
		description:
			'You can spend 1 AP to shoot web at a target within 5 Spaces. Make an Attack Check contested by the target’s Physical Save. Success: The target is Restrained by webbing and can spend 1 AP on their turn to attempt to escape (Martial Check vs your Save DC). The webbing can also be attacked and destroyed (PD 5, AD 10, 2 HP; Immunity to Bludgeoning, Poison, and Psychic damage).',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', value: 'Shoot_Webs_1AP' }]
	}
];
````

## File: src/lib/rulesdata/types.ts
````typescript
// src/lib/rulesdata/types.ts

// Interface for Attribute Data
export interface IAttributeData {
	id: 'might' | 'agility' | 'charisma' | 'intelligence';
	name: string;
	description: string;
	derivedStats?: Array<{ statName: string; formula: string }>;
}

// Interface for Trait Effects
export interface ITraitEffect {
	type: string; // e.g., 'MODIFY_ATTRIBUTE', 'GRANT_SKILL_EXPERTISE', 'GRANT_FEATURE'
	target?: string; // e.g., attribute ID ('might'), skill ID ('athletics'), feature ID ('rage')
	value?: any; // e.g., number for attribute modification, object for skill expertise details
	condition?: string; // Optional condition for the effect to apply
	userChoiceRequired?: {
		// Details if the user needs to make a choice for this effect
		prompt: string; // Prompt shown to the user
		options?: string[]; // Optional list of specific options (e.g., skill IDs, attribute IDs)
	};
	descriptionOverride?: string; // Optional override for how this effect is described
	subFeature?: string; // Optional sub-feature identifier for complex effects
	schools?: string[]; // Optional list of spell schools associated with the effect
}

// Interface for Traits
export interface ITrait {
	id: string;
	name: string;
	description: string;
	cost: number; // Ancestry points cost
	isMinor?: boolean; // True if this is a Minor Trait
	isNegative?: boolean; // True if this is a Negative Trait (grants points)
	effects?: ITraitEffect[]; // Array of effects the trait grants
	prerequisites?: any[]; // Optional prerequisites for taking this trait
	sourceAncestryId?: string; // ID of the ancestry this trait belongs to (for combined lists)
}

// Interface for Ancestries
export interface IAncestry {
	id: string;
	name: string;
	description: string;
	defaultTraitIds?: string[]; // Traits automatically granted
	expandedTraitIds: string[]; // Traits available for selection
	origin?: {
		// Optional origin property for ancestries with specific origins (e.g., Dragonborn, Fiendborn, Beastborn)
		prompt: string; // Prompt shown to the user for choosing an origin
		options?: string[]; // Optional list of specific options for the origin
	};
	variantTraits?: ITrait[]; // Optional list of variant traits (e.g., Fallen Angelborn, Redeemed Fiendborn)
}

// Interface for Class Feature Choice Options
export interface IClassFeatureChoiceOption {
	value: string; // Internal value for the choice
	label: string; // Display label for the choice
	description?: string; // Optional description for the choice
	effectsOnChoice?: ITraitEffect[]; // Effects granted if this option is chosen
}

// Interface for Class Feature Choices
export interface IClassFeatureChoice {
	id: string; // Internal ID for the choice (e.g., 'sorcerousOrigin')
	prompt: string; // Prompt shown to the user
	type: 'select_one' | 'select_multiple'; // Type of selection
	maxSelections?: number; // Max number of options if type is 'select_multiple'
	options: IClassFeatureChoiceOption[]; // Available options for the choice
}

// Interface for Class Features
export interface IClassFeature {
	id: string;
	name: string;
	description: string;
	level: number; // Level at which the feature is gained
	effects?: ITraitEffect[]; // Effects granted by the feature
}

// Interface for Class Definitions
export interface IClassDefinition {
	id: string;
	name: string;
	description: string;
	// Base stats granted by the class at Level 1
	baseHpContribution: number;
	startingSP: number;
	startingMP: number;
	skillPointGrantLvl1?: number; // Additional skill points granted at Lvl 1 (beyond Int mod)
	tradePointGrantLvl1?: number; // Additional trade points granted at Lvl 1 (beyond Int mod)
	combatTraining?: string[]; // Array of combat training proficiencies (e.g., 'Weapons', 'All Armor')
	maneuversKnownLvl1?: string | number; // Maneuvers known at Level 1 (can be 'All Attack' or a number)
	techniquesKnownLvl1?: number; // Techniques known at Level 1
	saveDCBase: number;
	deathThresholdBase: number;
	moveSpeedBase: number;
	restPointsBase: number;
	gritPointsBase: number; // Base grit points (before Charisma mod)
	initiativeBonusBase: number; // Base initiative bonus (before Agility mod)
	// Add cantripsKnownLvl1, spellsKnownLvl1 if applicable (not for Barbarian L1)
	cantripsKnownLvl1?: number;
	spellsKnownLvl1?: number;

	level1Features: IClassFeature[]; // Features gained at Level 1
	featureChoicesLvl1?: IClassFeatureChoice[]; // Choices available for features at Level 1
	// ... other level-specific data to be added later
}

// Interface for Skill Data
export interface ISkillData {
	id: string;
	name: string;
	attributeAssociation: 'might' | 'agility' | 'charisma' | 'intelligence' | 'prime'; // Associated attribute
	description: string;
}

// Interface for Trade Data
export interface ITradeData {
	id: string;
	name: string;
	attributeAssociation: 'might' | 'agility' | 'charisma' | 'intelligence'; // Associated attribute
	description: string;
	tools?: string; // Required tools for the trade
}

// Interface for Language Data
export interface ILanguageData {
	id: string;
	name: string;
	type: 'standard' | 'exotic'; // Type of language
	description: string;
}
````

## File: src/lib/services/_backup/characterCalculator.ts
````typescript
// DC20 Character Calculator Service
// Handles calculation of derived stats based on DC20 rules

import { skillsData } from '../rulesdata/skills';
import { ancestriesData } from '../rulesdata/ancestries';
import { findClassByName } from '../rulesdata/loaders/class-features.loader';
import type { IClassDefinition } from '../rulesdata/schemas/class.schema';
import { processTraitEffects, type ProcessedTraitEffects } from './traitEffectProcessor';

export interface CharacterInProgressData {
	id: string;
	// Attributes
	attribute_might: number;
	attribute_agility: number;
	attribute_charisma: number;
	attribute_intelligence: number;

	// Progression
	level: number;
	combatMastery: number;

	// Class & Ancestry
	classId: string | null;
	ancestry1Id: string | null;
	ancestry2Id: string | null;
	selectedTraitIds: string;
	selectedFeatureChoices: string;

	// Character Details
	finalName: string | null;
	finalPlayerName: string | null;

	// Skills (if implemented)
	skillsJson?: string;
	tradesJson?: string;
	languagesJson?: string;

	// Manual Defense Overrides
	manualPD?: number;
	manualAD?: number;
	manualPDR?: number;

	// Timestamps
	createdAt: Date;
	updatedAt?: Date;
	completedAt?: string;
}

export interface CalculatedCharacterStats {
	// Basic Info
	id: string;
	finalName: string;
	finalPlayerName?: string;
	finalLevel: number;

	// Timestamps
	createdAt: Date;
	updatedAt?: Date;
	completedAt?: string;

	// Attributes
	finalMight: number;
	finalAgility: number;
	finalCharisma: number;
	finalIntelligence: number;

	// Calculated Stats
	finalPrimeModifierValue: number;
	finalPrimeModifierAttribute: string;
	finalCombatMastery: number;

	// Saves (Attribute + Combat Mastery)
	finalSaveMight: number;
	finalSaveAgility: number;
	finalSaveCharisma: number;
	finalSaveIntelligence: number;

	// Health & Resources
	finalHPMax: number;
	finalSPMax: number;
	finalMPMax: number;

	// Defenses
	finalPD: number; // Precision Defense
	finalAD: number; // Area Defense

	// Other Stats
	finalSaveDC: number;
	finalDeathThreshold: number;
	finalMoveSpeed: number;
	finalJumpDistance: number;
	finalRestPoints: number;
	finalGritPoints: number;
	finalInitiativeBonus: number;

	// PDR (Precision Damage Reduction)
	finalPDR: number;

	// Class & Ancestry Info
	classId: string | null;
	className: string;
	ancestry1Id: string | null;
	ancestry1Name?: string;
	ancestry2Id: string | null;
	ancestry2Name?: string;
	selectedFeatureChoices?: string;
	selectedTraitIds?: string;

	// JSON data fields
	skillsJson?: string;
	tradesJson?: string;
	languagesJson?: string;
	
	// Calculated bonus data
	skillsWithBonuses?: any[];
	tradesWithBonuses?: any[];
}

// Import class data (we need to create this import based on what's available)
const getClassData = async (classId: string): Promise<IClassDefinition | null> => {
	try {
		// Dynamic import of class data
		const { classesData } = await import('../rulesdata/loaders/class.loader');

		const classData = classesData.find((c) => c.id === classId);
		return classData || null;
	} catch (error) {
		console.warn('Could not load class data:', error);
		return null;
	}
};

// Get ancestry data by ID
const getAncestryData = (ancestryId: string | null): { 
	id: string; 
	name: string; 
	defaultTraitIds: string[];
	expandedTraitIds: string[];
} | null => {
	if (!ancestryId) return null;

	const ancestry = ancestriesData.find((a) => a.id === ancestryId);
	return ancestry ? { 
		id: ancestry.id, 
		name: ancestry.name,
		defaultTraitIds: ancestry.defaultTraitIds || [],
		expandedTraitIds: ancestry.expandedTraitIds
	} : null;
};

const calculatePrimeModifier = (attributes: {
	might: number;
	agility: number;
	charisma: number;
	intelligence: number;
}): { value: number; attribute: string } => {
	// Find the highest attribute
	const { might, agility, charisma, intelligence } = attributes;
	const attrArray = [
		{ value: might, name: 'MIG' },
		{ value: agility, name: 'AGI' },
		{ value: charisma, name: 'CHA' },
		{ value: intelligence, name: 'INT' }
	];

	const highest = attrArray.reduce((prev, curr) => (curr.value > prev.value ? curr : prev));

	return {
		value: highest.value,
		attribute: highest.name
	};
};

export const calculateCharacterStats = async (
	characterData: CharacterInProgressData
): Promise<CalculatedCharacterStats> => {
	console.log('calculateCharacterStats called with:', characterData);

	// Get class data
	const classData = characterData.classId ? await getClassData(characterData.classId) : null;
	console.log('Class data loaded:', classData);

	// Get class features data
	const classFeatures = classData ? findClassByName(classData.name) : null;

	// Get ancestry data
	const ancestry1Data = getAncestryData(characterData.ancestry1Id);
	const ancestry2Data = getAncestryData(characterData.ancestry2Id);
	console.log('Ancestry data loaded:', { ancestry1Data, ancestry2Data });

	// Process trait effects EARLY to get attribute modifiers
	let processedTraitEffects: ProcessedTraitEffects;
	try {
		const selectedTraitIds = characterData.selectedTraitIds ? JSON.parse(characterData.selectedTraitIds) : [];
		processedTraitEffects = processTraitEffects(
			selectedTraitIds, 
			characterData.ancestry1Id, 
			characterData.ancestry2Id
		);
		console.log('Trait effects processed:', processedTraitEffects);
	} catch (error) {
		console.warn('Error processing trait effects:', error);
		// Initialize empty effects if parsing fails
		processedTraitEffects = {
			attributeModifiers: { might: 0, agility: 0, charisma: 0, intelligence: 0 },
			staticBonuses: { hpMax: 0, mpMax: 0, spMax: 0, pd: 0, ad: 0, moveSpeed: 0, deathThreshold: 0, jumpDistance: 0, initiativeBonus: 0 },
			resistances: [],
			vulnerabilities: [],
			abilities: [],
			conditionalEffects: [],
			userChoicesRequired: []
		};
	}

	// Apply attribute modifiers from traits BEFORE other calculations
	const finalMight = characterData.attribute_might + processedTraitEffects.attributeModifiers.might;
	const finalAgility = characterData.attribute_agility + processedTraitEffects.attributeModifiers.agility;
	const finalCharisma = characterData.attribute_charisma + processedTraitEffects.attributeModifiers.charisma;
	const finalIntelligence = characterData.attribute_intelligence + processedTraitEffects.attributeModifiers.intelligence;

	// Combat Mastery (half level rounded up)
	const finalCombatMastery = Math.ceil(characterData.level / 2);

	// Prime Modifier
	const primeModifier = calculatePrimeModifier({
		might: finalMight,
		agility: finalAgility,
		charisma: finalCharisma,
		intelligence: finalIntelligence
	});

	// Defenses (DC20 formulas)
	// PD (Precision Defense) = 8 + CM + Agility + Intelligence + Bonuses from traits/items
	let calculatedPD = 8 + finalCombatMastery + finalAgility + finalIntelligence;
	

	// AD (Area Defense) = 8 + CM + Might + Charisma + Bonuses from traits/items
	let calculatedAD = 8 + finalCombatMastery + finalMight + finalCharisma;
	

	// Health & Resources
	let finalHPMax = finalMight; // Base from Might
	let finalSPMax = 0;
	let finalMPMax = 0;
	let finalSaveDC = 10; // Base (correct DC20 base)
	let finalDeathThreshold = 10; // Base
	let finalMoveSpeed = 5; // Default base, will be set by class data
	let finalRestPoints = 4; // Will be set to finalHPMax later
	let finalInitiativeBonus = 0; // Base

	// Add class contributions
	if (classData) {
		finalHPMax += classData.baseHpContribution;
		finalSPMax = classData.startingSP;
		finalMPMax = classData.startingMP;
		// Note: saveDCBase is not used in correct formula, keeping base at 10
		finalDeathThreshold = classData.deathThresholdBase;
		finalMoveSpeed = classData.moveSpeedBase;
		// finalRestPoints will be set to finalHPMax after all calculations
		finalInitiativeBonus = classData.initiativeBonusBase;

		// Apply effects from class features using the new class features structure
		if (classFeatures) {
			// Get level 1 features
			const level1Features = classFeatures.coreFeatures.filter(
				(feature) => feature.levelGained === 1
			);

			level1Features.forEach((feature) => {
				if (feature.benefits) {
					feature.benefits.forEach((benefit) => {
						if (benefit.effects) {
							benefit.effects.forEach((effect) => {
								if (effect.type === 'MODIFIER') {
									// For now, we'll assume the condition is met.
									// A more robust solution would parse and evaluate the condition string.
									if (effect.target === 'defenses.ad') {
										calculatedAD += effect.value;
									} else if (effect.target === 'defenses.pd') {
										calculatedPD += effect.value;
									} else if (effect.target === 'coreStats.moveSpeed') {
										finalMoveSpeed += effect.value;
									} else if (effect.target === 'resources.mpMax') {
										finalMPMax += effect.value;
									} else if (effect.target === 'coreStats.jumpDistance') {
										finalJumpDistance += effect.value;
									}
									// Add more target cases here as needed
								} else if (effect.type === 'OVERRIDE') {
									if (effect.target === 'coreStats.jumpDistance') {
										// A more robust solution would parse the value string
										finalJumpDistance = finalMight;
									}
								} else if (effect.type === 'GRANT_SKILL_POINTS') {
									// This is a placeholder. A real implementation would need to
									// modify the character's skill points data.
									console.log(`Granting ${effect.value} skill points.`);
								} else if (effect.type === 'GRANT_SPELLS') {
									// This is a placeholder. A real implementation would need to
									// add the spells to the character's spell list.
									console.log(`Granting ${effect.value} spells.`);
								} else if (effect.type === 'GRANT_CANTRIPS') {
									// This is a placeholder. A real implementation would need to
									// add the cantrips to the character's spell list.
									console.log(`Granting ${effect.value} cantrips.`);
								} else if (effect.type === 'GRANT_COMBAT_TRAINING') {
									// This is a placeholder. A real implementation would need to
									// add the combat training to the character's data.
									console.log(`Granting combat training: ${effect.value}`);
								} else if (effect.type === 'GRANT_MANEUVERS') {
									// This is a placeholder. A real implementation would need to
									// add the maneuvers to the character's data.
									console.log(`Granting ${effect.value} maneuvers.`);
								} else if (effect.type === 'GRANT_ANCESTRY_POINTS') {
									// This is a placeholder. A real implementation would need to
									// add the ancestry points to the character's data.
									console.log(`Granting ${effect.value} ancestry points.`);
								} else if (effect.type === 'GRANT_PASSIVE') {
									// This is a placeholder. A real implementation would need to
									// add the passive to the character's data.
									console.log(`Granting passive: ${effect.value}`);
								}
							});
						}
					});
				}
			});
		}
	}

	// Process selected feature choices (robust parsing approach)
	if (characterData.selectedFeatureChoices && classFeatures) {
		try {
			const selectedChoices: { [key: string]: string } = JSON.parse(
				characterData.selectedFeatureChoices
			);

			// Find all level 1 features with choices
			const level1Features = classFeatures.coreFeatures.filter(
				(feature) => feature.levelGained === 1
			);

			level1Features.forEach((feature) => {
				if (feature.choices) {
					feature.choices.forEach((choice, choiceIndex) => {
						const choiceId = `${classFeatures.className.toLowerCase()}_${feature.featureName.toLowerCase().replace(/\s+/g, '_')}_${choiceIndex}`;
						const selectedOptions = selectedChoices[choiceId];

						if (selectedOptions) {
							let optionsToProcess: string[] = [];

							// Handle both single selection and multiple selection
							try {
								optionsToProcess = JSON.parse(selectedOptions);
								if (!Array.isArray(optionsToProcess)) {
									optionsToProcess = [selectedOptions];
								}
							} catch {
								optionsToProcess = [selectedOptions];
							}

							// Process each selected option
							optionsToProcess.forEach((optionName) => {
								const selectedOption = choice.options?.find((opt) => opt.name === optionName);
								if (selectedOption) {
									const description = selectedOption.description.toLowerCase();

									// Parse stat bonuses from descriptions using regex patterns

									// MP bonuses: "your maximum mp increases by X", "mp increases by X", "+X mp"
									const mpMatch =
										description.match(
											/(?:your maximum mp increases by|mp increases by|\+)\s*(\d+)\s*mp/i
										) || description.match(/maximum mp increases by\s*(\d+)/i);
									if (mpMatch) {
										finalMPMax += parseInt(mpMatch[1]);
									}

									// Ancestry Points: "you get X ancestry points", "X ancestry points"
									const ancestryMatch = description.match(
										/(?:you get|gain)\s*(\d+)\s*ancestry points?/i
									);
									if (ancestryMatch) {
										// Note: This would need to be handled in character creation logic, not just stats
										console.log(
											`Feature choice grants ${ancestryMatch[1]} ancestry points: ${optionName}`
										);
									}

									// SP bonuses: "your maximum sp increases by X", "+X sp"
									const spMatch = description.match(
										/(?:your maximum sp increases by|sp increases by|\+)\s*(\d+)\s*sp/i
									);
									if (spMatch) {
										finalSPMax += parseInt(spMatch[1]);
									}

									// HP bonuses: "your maximum hp increases by X", "+X hp"
									const hpMatch = description.match(
										/(?:your maximum hp increases by|hp increases by|\+)\s*(\d+)\s*hp/i
									);
									if (hpMatch) {
										finalHPMax += parseInt(hpMatch[1]);
									}

									// Maneuver learning: "you learn X maneuvers", "learn X defensive maneuvers"
									const maneuverMatch = description.match(
										/you learn\s*(\d+)\s*(?:defensive\s+)?maneuvers?/i
									);
									if (maneuverMatch) {
										// Note: This would be handled in maneuver tracking, not base stats
										console.log(
											`Feature choice grants ${maneuverMatch[1]} maneuvers: ${optionName}`
										);
									}

									// Spell learning: "you learn X additional spell", "you learn X spell"
									const spellMatch = description.match(
										/you learn\s*(\d+)\s*(?:additional\s+)?spells?/i
									);
									if (spellMatch) {
										// Note: This would be handled in spell tracking, not base stats
										console.log(`Feature choice grants ${spellMatch[1]} spells: ${optionName}`);
									}

									// Save DC bonuses: "save dc increases by X", "+X to save dc"
									const saveDCMatch = description.match(
										/(?:save dc increases by|\+)\s*(\d+)(?:\s*to save dc)?/i
									);
									if (saveDCMatch) {
										finalSaveDC += parseInt(saveDCMatch[1]);
									}

									// Movement speed: "move speed increases by X", "+X movement"
									const speedMatch = description.match(
										/(?:move speed increases by|movement.*increases by|\+)\s*(\d+)(?:\s*(?:feet|ft|spaces?))?.*(?:movement|speed)/i
									);
									if (speedMatch) {
										finalMoveSpeed += parseInt(speedMatch[1]);
									}

									// Jump distance: "jump distance increases by X", "+X jump distance"
									const jumpDistanceMatch = description.match(
										/(?:jump distance increases by|jump.*increases by|\+)\s*(\d+)(?:\s*(?:feet|ft|spaces?))?.*(?:jump|distance)/i
									);
									if (jumpDistanceMatch) {
										finalJumpDistance += parseInt(jumpDistanceMatch[1]);
									}
								}
							});
						}
					});
				}
			});
		} catch (error) {
			console.warn('Error processing feature choices:', error);
		}
	}

	// Apply static bonuses from trait effects (after class effects, before manual overrides)
	finalHPMax += processedTraitEffects.staticBonuses.hpMax;
	finalMPMax += processedTraitEffects.staticBonuses.mpMax;
	finalSPMax += processedTraitEffects.staticBonuses.spMax;
	finalMoveSpeed += processedTraitEffects.staticBonuses.moveSpeed;
	finalDeathThreshold += processedTraitEffects.staticBonuses.deathThreshold;
	finalInitiativeBonus += processedTraitEffects.staticBonuses.initiativeBonus;

	// Apply trait bonuses to defenses AFTER class effects
	calculatedPD += processedTraitEffects.staticBonuses.pd;
	calculatedAD += processedTraitEffects.staticBonuses.ad;

	// Apply manual overrides LAST
	const finalPD = characterData.manualPD !== undefined ? characterData.manualPD : calculatedPD;
	const finalAD = characterData.manualAD !== undefined ? characterData.manualAD : calculatedAD;

		// Add attribute bonuses
	finalSaveDC += primeModifier.value + finalCombatMastery; // Save DC = 10 + Prime + Combat Mastery
	finalInitiativeBonus += finalCombatMastery + finalAgility; // Initiative = CM + Agility

	// Calculate Save Values (Updated Formula)
	// Save = Attribute Modifier + Combat Mastery (always)
	const finalSaveMight = finalMight + finalCombatMastery;
	const finalSaveAgility = finalAgility + finalCombatMastery;
	const finalSaveCharisma = finalCharisma + finalCombatMastery;
	const finalSaveIntelligence = finalIntelligence + finalCombatMastery;

	console.log('Save calculations:', {
		combatMastery: finalCombatMastery,
		attributes: {
			might: finalMight,
			agility: finalAgility,
			charisma: finalCharisma,
			intelligence: finalIntelligence
		},
		results: {
			might: finalSaveMight,
			agility: finalSaveAgility,
			charisma: finalSaveCharisma,
			intelligence: finalSaveIntelligence
		}
	});

	// Jump Distance = Agility (min 1)
	let finalJumpDistance = Math.max(1, finalAgility);

	// Grit Points = 2 + Charisma (from class base)
	const baseGritPoints = classData?.gritPointsBase || 2;
	const finalGritPoints = baseGritPoints + finalCharisma;

	// Calculate PDR (Precision Damage Reduction) with manual override
	const calculatedPDR = calculatePDR(characterData, classData);
	const finalPDR = characterData.manualPDR !== undefined ? characterData.manualPDR : calculatedPDR;

	// Process skills with calculated bonuses
	let skillsJson = characterData.skillsJson;
	if (!skillsJson) {
		// Create default skills with 0 proficiency
		const defaultSkills: Record<string, number> = {};
		skillsData.forEach((skill) => {
			defaultSkills[skill.id] = 0;
		});
		skillsJson = JSON.stringify(defaultSkills);
	}

	// Calculate skill bonuses: Attribute + Mastery*2
	const skillsWithBonuses: any[] = [];
	try {
		const skillProficiencies = JSON.parse(skillsJson);
		skillsData.forEach((skill) => {
			const proficiency = skillProficiencies[skill.id] || 0;
			const masteryBonus = proficiency * 2;
			
			// Get attribute modifier based on skill's attribute association
			let attributeModifier = 0;
			switch (skill.attributeAssociation.toLowerCase()) {
				case 'might':
					attributeModifier = finalMight;
					break;
				case 'agility':
					attributeModifier = finalAgility;
					break;
				case 'charisma':
					attributeModifier = finalCharisma;
					break;
				case 'intelligence':
					attributeModifier = finalIntelligence;
					break;
				default:
					attributeModifier = 0;
			}
			
			const totalBonus = attributeModifier + masteryBonus;
			
			skillsWithBonuses.push({
				id: skill.id,
				name: skill.name,
				attribute: skill.attributeAssociation,
				proficiency,
				bonus: totalBonus
			});
		});
	} catch (error) {
		console.warn('Error calculating skill bonuses:', error);
	}

	// Process trades with calculated bonuses
	const tradesWithBonuses: any[] = [];
	try {
		const tradeProficiencies = JSON.parse(characterData.tradesJson || '{}');
		// Import trades data
		const { tradesData } = await import('../rulesdata/trades');
		const { knowledgeData } = await import('../rulesdata/knowledge');
		const allTradesAndKnowledge = [...tradesData, ...knowledgeData];
		
		allTradesAndKnowledge.forEach((trade) => {
			const proficiency = tradeProficiencies[trade.id] || 0;
			const masteryBonus = proficiency * 2;
			
			// Get attribute modifier based on trade's attribute association
			let attributeModifier = 0;
			switch (trade.attributeAssociation.toLowerCase()) {
				case 'might':
					attributeModifier = finalMight;
					break;
				case 'agility':
					attributeModifier = finalAgility;
					break;
				case 'charisma':
					attributeModifier = finalCharisma;
					break;
				case 'intelligence':
					attributeModifier = finalIntelligence;
					break;
				default:
					attributeModifier = 0;
			}
			
			const totalBonus = attributeModifier + masteryBonus;
			
			tradesWithBonuses.push({
				id: trade.id,
				name: trade.name,
				proficiency,
				bonus: totalBonus
			});
		});
	} catch (error) {
		console.warn('Error calculating trade bonuses:', error);
	}

	// DC20 Rule: Rest Points = HP
	finalRestPoints = finalHPMax;

	return {
		// Basic Info
		id: characterData.id,
		finalName: characterData.finalName || 'Unnamed Character',
		finalPlayerName: characterData.finalPlayerName || undefined,
		finalLevel: characterData.level,

		// Timestamps
		createdAt: characterData.createdAt,
		updatedAt: characterData.updatedAt,
		completedAt: characterData.completedAt,

		// Attributes
		finalMight,
		finalAgility,
		finalCharisma,
		finalIntelligence,

		// Calculated Stats
		finalPrimeModifierValue: primeModifier.value,
		finalPrimeModifierAttribute: primeModifier.attribute,
		finalCombatMastery,

		// Saves (Attribute + Combat Mastery)
		finalSaveMight,
		finalSaveAgility,
		finalSaveCharisma,
		finalSaveIntelligence,

		// Health & Resources
		finalHPMax,
		finalSPMax,
		finalMPMax,

		// Defenses
		finalPD,
		finalAD,

		// Other Stats
		finalSaveDC,
		finalDeathThreshold,
		finalMoveSpeed,
		finalJumpDistance,
		finalRestPoints,
		finalGritPoints,
		finalInitiativeBonus,

		// PDR (Precision Damage Reduction)
		finalPDR,

		// Class & Ancestry Info
		classId: characterData.classId,
		className: classData?.name || 'Unknown',
		ancestry1Id: characterData.ancestry1Id,
		ancestry1Name: ancestry1Data?.name,
		ancestry2Id: characterData.ancestry2Id,
		ancestry2Name: ancestry2Data?.name,
		selectedFeatureChoices: characterData.selectedFeatureChoices,
		selectedTraitIds: characterData.selectedTraitIds,

		// JSON data fields
		skillsJson,
		tradesJson: characterData.tradesJson || '{}',
		languagesJson: characterData.languagesJson || '{"common": {"fluency": "fluent"}}',
		
		// Calculated skill and trade bonuses
		skillsWithBonuses,
		tradesWithBonuses
	};
};

// Helper function to calculate PDR (Precision Damage Reduction)
const calculatePDR = (
	characterData: CharacterInProgressData,
	classData: IClassDefinition | null
): number => {
	let pdr = 0;

	// Check for Beastborn Natural Armor trait
	if (characterData.selectedTraitIds) {
		try {
			const selectedTraits = JSON.parse(characterData.selectedTraitIds);
			if (selectedTraits.includes('beastborn_natural_armor')) {
				// Natural Armor grants PDR when not wearing armor
				// According to DC20 rules, this grants PDR (Precision Damage Reduction)
				pdr += 1;
			}
		} catch (error) {
			console.warn('Error parsing selectedTraitIds for PDR calculation:', error);
		}
	}

	// Check for Barbarian Rage ability
	if (classData?.id === 'barbarian') {
		// Barbarian Rage grants Resistance (Half) to Precision damage
		// This is effectively PDR, but it's a different mechanic
		// For now, we'll note this but not add to base PDR since Rage is conditional
		// TODO: Could add a note or separate field for conditional PDR
	}

	// TODO: Add additional PDR sources:
	// - Heavy Armor with PDR property (requires armor system integration)
	// - Shell Retreat ability (conditional)
	// - Magic items or other class features
	// - Equipment-based PDR calculation

	return pdr;
};
````

## File: src/lib/services/_backup/traitEffectProcessor.ts
````typescript
import { traitsData } from '../rulesdata/traits';
import { ancestriesData } from '../rulesdata/ancestries';
import type { ITrait, ITraitEffect } from '../rulesdata/types';

export interface ProcessedTraitEffects {
	attributeModifiers: {
		might: number;
		agility: number;
		charisma: number;
		intelligence: number;
	};
	staticBonuses: {
		hpMax: number;
		mpMax: number;
		spMax: number;
		pd: number;
		ad: number;
		moveSpeed: number; // in spaces
		deathThreshold: number;
		jumpDistance: number;
		initiativeBonus: number;
	};
	resistances: Array<{
		type: string;
		value: number | string;
	}>;
	vulnerabilities: Array<{
		type: string;
		value: number;
	}>;
	abilities: string[];
	conditionalEffects: Array<{
		type: string;
		condition: string;
		target: string;
		value: any;
	}>;
	sizeModification?: string;
	userChoicesRequired: Array<{
		traitId: string;
		effect: ITraitEffect;
		prompt: string;
		options?: string[];
	}>;
}

// Initialize empty processed effects
function createEmptyEffects(): ProcessedTraitEffects {
	return {
		attributeModifiers: {
			might: 0,
			agility: 0,
			charisma: 0,
			intelligence: 0
		},
		staticBonuses: {
			hpMax: 0,
			mpMax: 0,
			spMax: 0,
			pd: 0,
			ad: 0,
			moveSpeed: 0,
			deathThreshold: 0,
			jumpDistance: 0,
			initiativeBonus: 0
		},
		resistances: [],
		vulnerabilities: [],
		abilities: [],
		conditionalEffects: [],
		userChoicesRequired: []
	};
}

// Get default traits for an ancestry
function getDefaultTraitsForAncestry(ancestryId: string | null): string[] {
	if (!ancestryId) return [];
	
	const ancestry = ancestriesData.find(a => a.id === ancestryId);
	return ancestry?.defaultTraitIds || [];
}

// Effect processors for different trait effect types
const EFFECT_PROCESSORS: Record<string, (effect: ITraitEffect, results: ProcessedTraitEffects, traitId: string) => void> = {
	MODIFY_ATTRIBUTE: (effect, results, traitId) => {
		if (effect.target && typeof effect.value === 'number') {
			// Handle user choice required
			if (effect.userChoiceRequired) {
				results.userChoicesRequired.push({
					traitId,
					effect,
					prompt: effect.userChoiceRequired.prompt,
					options: effect.userChoiceRequired.options
				});
				return;
			}
			
			// Apply direct attribute modification
			const attrKey = effect.target as keyof typeof results.attributeModifiers;
			if (attrKey in results.attributeModifiers) {
				results.attributeModifiers[attrKey] += effect.value;
			}
		}
	},

	MODIFY_HP_MAX_STATIC: (effect, results) => {
		if (typeof effect.value === 'number') {
			results.staticBonuses.hpMax += effect.value;
		}
	},

	MODIFY_MP_MAX: (effect, results) => {
		if (typeof effect.value === 'number') {
			results.staticBonuses.mpMax += effect.value;
		}
	},

	MODIFY_PD: (effect, results) => {
		if (typeof effect.value === 'number') {
			if (effect.condition) {
				// Handle conditional PD bonuses
				results.conditionalEffects.push({
					type: 'PD_BONUS',
					condition: effect.condition,
					target: 'pd',
					value: effect.value
				});
			} else {
				results.staticBonuses.pd += effect.value;
			}
		}
	},

	MODIFY_AD: (effect, results) => {
		if (typeof effect.value === 'number') {
			if (effect.condition) {
				// Handle conditional AD bonuses
				results.conditionalEffects.push({
					type: 'AD_BONUS',
					condition: effect.condition,
					target: 'ad',
					value: effect.value
				});
			} else {
				results.staticBonuses.ad += effect.value;
			}
		}
	},

	MODIFY_SPEED: (effect, results) => {
		if (typeof effect.value === 'number') {
			// Convert from internal units (5 = 1 space) to spaces
			results.staticBonuses.moveSpeed += effect.value / 5;
		}
	},

	MODIFY_DEATH_THRESHOLD_MODIFIER: (effect, results) => {
		if (typeof effect.value === 'number') {
			results.staticBonuses.deathThreshold += effect.value;
		}
	},

	MODIFY_JUMP_DISTANCE: (effect, results) => {
		if (typeof effect.value === 'number') {
			results.staticBonuses.jumpDistance += effect.value;
		}
	},

	GRANT_RESISTANCE_HALF: (effect, results) => {
		if (effect.target) {
			results.resistances.push({
				type: effect.target,
				value: 'half'
			});
		}
	},

	GRANT_RESISTANCE_STATIC: (effect, results) => {
		if (effect.target && typeof effect.value === 'number') {
			results.resistances.push({
				type: effect.target,
				value: effect.value
			});
		}
	},

	GRANT_VULNERABILITY_STATIC: (effect, results) => {
		if (effect.target && typeof effect.value === 'number') {
			results.vulnerabilities.push({
				type: effect.target,
				value: effect.value
			});
		}
	},

	MODIFY_SIZE: (effect, results) => {
		if (effect.target) {
			results.sizeModification = effect.target;
		}
	},

	GRANT_ABILITY: (effect, results) => {
		if (effect.value && typeof effect.value === 'string') {
			results.abilities.push(effect.value);
		}
	},

	GRANT_DARKVISION: (effect, results) => {
		if (typeof effect.value === 'number') {
			results.abilities.push(`Darkvision ${effect.value} Spaces`);
		}
	},

	GRANT_CLIMB_SPEED_EQUAL_TO_SPEED: (effect, results) => {
		results.abilities.push('Climb Speed equal to Movement Speed');
	},

	GRANT_SWIM_SPEED_EQUAL_TO_SPEED: (effect, results) => {
		results.abilities.push('Swim Speed equal to Movement Speed');
	},

	GRANT_GLIDE_SPEED: (effect, results) => {
		results.abilities.push('Glide Speed');
	},

	GRANT_ADV_ON_SAVE_VS_CONDITION: (effect, results) => {
		if (effect.target) {
			results.abilities.push(`ADV on Saves vs ${effect.target}`);
		}
	},

	GRANT_ADV_ON_CHECKS: (effect, results) => {
		if (effect.target) {
			results.abilities.push(`ADV on ${effect.target}`);
		}
	},

	IGNORE_DIFFICULT_TERRAIN: (effect, results) => {
		results.abilities.push('Ignore Difficult Terrain');
	},

	GRANT_SKILL_EXPERTISE: (effect, results, traitId) => {
		if (effect.userChoiceRequired) {
			results.userChoicesRequired.push({
				traitId,
				effect,
				prompt: effect.userChoiceRequired.prompt,
				options: effect.userChoiceRequired.options
			});
		} else if (effect.value && typeof effect.value === 'object') {
			results.abilities.push(`Skill Expertise: ${effect.value.skillId || 'Selected Skill'}`);
		}
	},

	GRANT_TRADE_EXPERTISE: (effect, results, traitId) => {
		if (effect.userChoiceRequired) {
			results.userChoicesRequired.push({
				traitId,
				effect,
				prompt: effect.userChoiceRequired.prompt,
				options: effect.userChoiceRequired.options
			});
		} else if (effect.value && typeof effect.value === 'object') {
			results.abilities.push(`Trade Expertise: ${effect.value.tradeId || 'Selected Trade'}`);
		}
	}
};

/**
 * Process trait effects from selected and default traits
 * @param selectedTraitIds Array of manually selected trait IDs
 * @param ancestry1Id First ancestry ID (for default traits)
 * @param ancestry2Id Second ancestry ID (for default traits)
 * @returns Processed trait effects ready for application
 */
export function processTraitEffects(
	selectedTraitIds: string[] = [],
	ancestry1Id: string | null = null,
	ancestry2Id: string | null = null
): ProcessedTraitEffects {
	const results = createEmptyEffects();
	
	// Get all default traits from both ancestries
	const defaultTraits = [
		...getDefaultTraitsForAncestry(ancestry1Id),
		...getDefaultTraitsForAncestry(ancestry2Id)
	];
	
	// Combine all traits (default + selected)
	const allTraitIds = [...new Set([...defaultTraits, ...selectedTraitIds])];
	
	console.log('Processing traits:', {
		defaultTraits,
		selectedTraitIds,
		allTraitIds
	});
	
	// Process each trait
	allTraitIds.forEach(traitId => {
		const trait = traitsData.find(t => t.id === traitId);
		if (!trait || !trait.effects) {
			console.warn(`Trait not found or has no effects: ${traitId}`);
			return;
		}
		
		// Process each effect of the trait
		trait.effects.forEach(effect => {
			const processor = EFFECT_PROCESSORS[effect.type];
			if (processor) {
				try {
					processor(effect, results, traitId);
				} catch (error) {
					console.error(`Error processing effect ${effect.type} for trait ${traitId}:`, error);
				}
			} else {
				console.warn(`No processor found for effect type: ${effect.type} in trait ${traitId}`);
			}
		});
	});
	
	console.log('Processed trait effects:', results);
	
	return results;
}

/**
 * Calculate the total ancestry points cost for given traits
 * @param traitIds Array of trait IDs
 * @returns Total point cost (can be negative for negative traits)
 */
export function calculateTraitCosts(traitIds: string[]): number {
	return traitIds.reduce((total, traitId) => {
		const trait = traitsData.find(t => t.id === traitId);
		return total + (trait?.cost || 0);
	}, 0);
}

/**
 * Get all traits available for selection based on ancestries
 * @param ancestry1Id First ancestry ID
 * @param ancestry2Id Second ancestry ID (optional)
 * @returns Array of available trait objects
 */
export function getAvailableTraits(ancestry1Id: string | null, ancestry2Id: string | null = null): ITrait[] {
	const availableTraitIds = new Set<string>();
	
	// Add traits from first ancestry
	if (ancestry1Id) {
		const ancestry1 = ancestriesData.find(a => a.id === ancestry1Id);
		if (ancestry1) {
			ancestry1.expandedTraitIds.forEach(id => availableTraitIds.add(id));
		}
	}
	
	// Add traits from second ancestry
	if (ancestry2Id) {
		const ancestry2 = ancestriesData.find(a => a.id === ancestry2Id);
		if (ancestry2) {
			ancestry2.expandedTraitIds.forEach(id => availableTraitIds.add(id));
		}
	}
	
	// Convert IDs to trait objects
	return Array.from(availableTraitIds)
		.map(id => traitsData.find(t => t.id === id))
		.filter((trait): trait is ITrait => trait !== undefined);
}
````

## File: src/lib/services/_new_schema/characterCalculator.ts
````typescript
/**
 * New Character Calculator using the unified Effect system
 * 
 * This is a complete rewrite of the character calculator that eliminates
 * text parsing and instead processes structured Effect objects.
 */

import { processEffects, aggregateEffectsFromSources } from './effectProcessor';
import { traitsData } from '../../rulesdata/_new_schema/traits';
import { ancestriesData } from '../../rulesdata/_new_schema/ancestries';
import { barbarianClass } from '../../rulesdata/_new_schema/barbarian_features';
import type { 
	Effect, 
	EffectProcessingResult,
	ClassDefinition 
} from '../../rulesdata/schemas/character.schema';

export interface CharacterBuildData {
	// Core Info
	id: string;
	finalName: string;
	finalPlayerName?: string;
	level: number;

	// Attributes (from point buy)
	attribute_might: number;
	attribute_agility: number;
	attribute_charisma: number;
	attribute_intelligence: number;

	// Progression
	combatMastery: number;

	// Class & Ancestry
	classId: string;
	ancestry1Id?: string;
	ancestry2Id?: string;

	// Selections
	selectedTraitIds: string[];
	featureChoices: Record<string, any>; // User choices for effects that require them
	
	// Manual Overrides
	manualPD?: number;
	manualAD?: number;
	manualPDR?: number;
}

export interface CalculatedCharacterStats {
	// Basic Info
	id: string;
	finalName: string;
	finalPlayerName?: string;
	finalLevel: number;

	// Final Attributes (base + modifiers)
	finalMight: number;
	finalAgility: number;
	finalCharisma: number;
	finalIntelligence: number;

	// Calculated Stats
	finalPrimeModifierValue: number;
	finalPrimeModifierAttribute: string;
	finalCombatMastery: number;

	// Saves (Attribute + Combat Mastery)
	finalSaveMight: number;
	finalSaveAgility: number;
	finalSaveCharisma: number;
	finalSaveIntelligence: number;

	// Health & Resources
	finalHPMax: number;
	finalSPMax: number;
	finalMPMax: number;

	// Defenses
	finalPD: number;
	finalAD: number;
	finalPDR: number;

	// Other Stats
	finalSaveDC: number;
	finalDeathThreshold: number;
	finalMoveSpeed: number;
	finalJumpDistance: number;
	finalRestPoints: number;
	finalGritPoints: number;
	finalInitiativeBonus: number;

	// Class & Ancestry Info
	classId: string;
	ancestry1Name?: string;
	ancestry2Name?: string;

	// Features and Abilities (for display)
	grantedAbilities: Array<{
		name: string;
		description: string;
		source: string;
		type: 'passive' | 'active' | 'resistance' | 'advantage';
	}>;

	// Conditional effects for UI to handle
	conditionalModifiers: Array<{
		effect: Effect;
		condition: string;
		description: string;
	}>;

	// Combat training
	combatTraining: string[];
}

/**
 * Step 1: Data Aggregation - Collect all Effect objects
 */
function aggregateAllEffects(buildData: CharacterBuildData): Effect[] {
	const allEffects: Effect[] = [];

	// Collect effects from selected traits
	for (const traitId of buildData.selectedTraitIds) {
		const trait = traitsData.find(t => t.id === traitId);
		if (trait?.effects) {
			allEffects.push(...trait.effects);
		}
	}

	// Collect effects from ancestry default traits
	if (buildData.ancestry1Id) {
		const ancestry = ancestriesData.find(a => a.id === buildData.ancestry1Id);
		if (ancestry?.defaultTraitIds) {
			for (const traitId of ancestry.defaultTraitIds) {
				const trait = traitsData.find(t => t.id === traitId);
				if (trait?.effects) {
					allEffects.push(...trait.effects);
				}
			}
		}
	}

	// Collect effects from class features
	const classData = getClassData(buildData.classId);
	if (classData) {
		for (const feature of classData.coreFeatures) {
			// Direct feature effects
			if (feature.effects) {
				allEffects.push(...feature.effects);
			}

			// Benefits within features
			if (feature.benefits) {
				for (const benefit of feature.benefits) {
					if (benefit.effects) {
						allEffects.push(...benefit.effects);
					}
				}
			}

			// Chosen options from feature choices
			if (feature.choices) {
				for (const choice of feature.choices) {
					const userChoice = buildData.featureChoices[choice.id];
					if (userChoice) {
						// Find the selected option(s) and add their effects
						for (const option of choice.options) {
							if (userChoice === option.name || 
								(Array.isArray(userChoice) && userChoice.includes(option.name))) {
								if (option.effects) {
									allEffects.push(...option.effects);
								}
							}
						}
					}
				}
			}
		}
	}

	return allEffects;
}

/**
 * Step 2: Get class data (simplified for demo - would be more robust in production)
 */
function getClassData(classId: string): ClassDefinition | null {
	if (classId === 'barbarian') {
		return barbarianClass;
	}
	// Add other classes as they are migrated
	return null;
}

/**
 * Step 3: Calculate final character stats
 */
export function calculateCharacterStats(buildData: CharacterBuildData): CalculatedCharacterStats {
	
	// Step 1: Aggregate all effects
	const allEffects = aggregateAllEffects(buildData);
	
	// Step 2: Process effects through the engine
	const processed = processEffects(allEffects, buildData.featureChoices);
	
	// Step 3: Calculate final attributes (base + modifiers)
	const finalMight = buildData.attribute_might + processed.statModifiers.might;
	const finalAgility = buildData.attribute_agility + processed.statModifiers.agility;
	const finalCharisma = buildData.attribute_charisma + processed.statModifiers.charisma;
	const finalIntelligence = buildData.attribute_intelligence + processed.statModifiers.intelligence;
	
	// Step 4: Calculate prime modifier
	const attributeValues = { finalMight, finalAgility, finalCharisma, finalIntelligence };
	const maxValue = Math.max(...Object.values(attributeValues));
	const primeAttribute = Object.keys(attributeValues).find(
		key => attributeValues[key as keyof typeof attributeValues] === maxValue
	)!.replace('final', '').toLowerCase();
	
	// Step 5: Get class base stats
	const classData = getClassData(buildData.classId);
	const baseHP = classData?.startingStats.hp || 0;
	const baseSP = classData?.startingStats.sp || 0;
	const baseMP = classData?.startingStats.mp || 0;
	
	// Step 6: Calculate derived stats using DC20 formulas
	const combatMastery = buildData.combatMastery;
	
	// Health & Resources
	const finalHPMax = baseHP + finalMight + (buildData.level - 1) + processed.statModifiers.hpMax;
	const finalSPMax = baseSP + finalAgility + processed.statModifiers.spMax;
	const finalMPMax = baseMP + finalIntelligence + processed.statModifiers.mpMax;
	
	// Defenses
	const basePD = 8 + combatMastery + finalAgility + finalIntelligence;
	const baseAD = 8 + combatMastery + finalMight + finalCharisma;
	const finalPD = buildData.manualPD ?? (basePD + processed.statModifiers.pd);
	const finalAD = buildData.manualAD ?? (baseAD + processed.statModifiers.ad);
	const finalPDR = buildData.manualPDR ?? processed.statModifiers.pdr;
	
	// Saves
	const finalSaveMight = finalMight + combatMastery;
	const finalSaveAgility = finalAgility + combatMastery;
	const finalSaveCharisma = finalCharisma + combatMastery;
	const finalSaveIntelligence = finalIntelligence + combatMastery;
	
	// Other derived stats
	const finalSaveDC = 8 + combatMastery + maxValue + processed.statModifiers.saveDC;
	const finalDeathThreshold = 10 + processed.statModifiers.deathThresholdModifier;
	const finalMoveSpeed = 5 + processed.statModifiers.moveSpeed; // Base 5 spaces in DC20
	const finalJumpDistance = Math.floor(finalAgility / 2) + processed.statModifiers.jumpDistance;
	const finalRestPoints = 4 + processed.statModifiers.restPoints;
	const finalGritPoints = 2 + Math.floor(finalCharisma / 2) + processed.statModifiers.gritPoints;
	const finalInitiativeBonus = finalAgility + processed.statModifiers.initiativeBonus;

	// Get ancestry names for display
	const ancestry1Name = buildData.ancestry1Id ? 
		ancestriesData.find(a => a.id === buildData.ancestry1Id)?.name : undefined;
	const ancestry2Name = buildData.ancestry2Id ? 
		ancestriesData.find(a => a.id === buildData.ancestry2Id)?.name : undefined;

	return {
		// Basic Info
		id: buildData.id,
		finalName: buildData.finalName,
		finalPlayerName: buildData.finalPlayerName,
		finalLevel: buildData.level,

		// Final Attributes
		finalMight,
		finalAgility,
		finalCharisma,
		finalIntelligence,

		// Calculated Stats
		finalPrimeModifierValue: maxValue,
		finalPrimeModifierAttribute: primeAttribute,
		finalCombatMastery: combatMastery,

		// Saves
		finalSaveMight,
		finalSaveAgility,
		finalSaveCharisma,
		finalSaveIntelligence,

		// Health & Resources
		finalHPMax,
		finalSPMax,
		finalMPMax,

		// Defenses
		finalPD,
		finalAD,
		finalPDR,

		// Other Stats
		finalSaveDC,
		finalDeathThreshold,
		finalMoveSpeed,
		finalJumpDistance,
		finalRestPoints,
		finalGritPoints,
		finalInitiativeBonus,

		// Class & Ancestry Info
		classId: buildData.classId,
		ancestry1Name,
		ancestry2Name,

		// Features and Abilities
		grantedAbilities: processed.grantedAbilities,
		conditionalModifiers: processed.conditionalModifiers,
		combatTraining: processed.combatTraining
	};
}
````

## File: src/lib/services/_new_schema/demo.ts
````typescript
/**
 * Demonstration of the New Effect System
 * 
 * This shows how the new unified Effect system works to calculate
 * character stats without any text parsing or brittle regex logic.
 */

import { calculateCharacterStats, type CharacterBuildData } from './characterCalculator';

// Example: Level 1 Human Barbarian
const humanBarbarianBuild: CharacterBuildData = {
	id: 'demo-char-1',
	finalName: 'Thorgar the Mighty',
	finalPlayerName: 'Demo Player',
	level: 1,

	// Attributes from point buy
	attribute_might: 4,      // 16 total (prime)
	attribute_agility: 2,    // 14 total
	attribute_charisma: 1,   // 13 total  
	attribute_intelligence: 0, // 12 total

	// Progression
	combatMastery: 1, // Level 1

	// Class & Ancestry
	classId: 'barbarian',
	ancestry1Id: 'human',

	// Selected traits (beyond defaults)
	selectedTraitIds: ['human_determination'], // From expanded list

	// Feature choices
	featureChoices: {
		'human_attribute_increase_choice': 'might', // +1 to Might from Human trait
		'human_skill_expertise_choice': 'athletics', // Skill expertise choice
		'barbarian_battlecry_choice': ['Fortitude Shout', 'Fury Shout', 'Urgent Shout'] // All battlecry options
	}
};

// Calculate the character
console.log('='.repeat(60));
console.log('🎲 NEW EFFECT SYSTEM DEMONSTRATION');
console.log('='.repeat(60));

console.log('\n📋 Character Build Data:');
console.log('- Name:', humanBarbarianBuild.finalName);
console.log('- Class:', humanBarbarianBuild.classId);
console.log('- Ancestry:', humanBarbarianBuild.ancestry1Id);
console.log('- Level:', humanBarbarianBuild.level);
console.log('- Base Attributes: M', humanBarbarianBuild.attribute_might, 
	'A', humanBarbarianBuild.attribute_agility,
	'C', humanBarbarianBuild.attribute_charisma, 
	'I', humanBarbarianBuild.attribute_intelligence);

console.log('\n⚙️  Processing Effects...');
const calculatedStats = calculateCharacterStats(humanBarbarianBuild);

console.log('\n📊 CALCULATED RESULTS:');
console.log('='.repeat(40));

console.log('\n🏋️  Final Attributes:');
console.log(`- Might: ${calculatedStats.finalMight} (${humanBarbarianBuild.attribute_might} base + modifiers)`);
console.log(`- Agility: ${calculatedStats.finalAgility}`);
console.log(`- Charisma: ${calculatedStats.finalCharisma}`);
console.log(`- Intelligence: ${calculatedStats.finalIntelligence}`);

console.log('\n💝 Health & Resources:');
console.log(`- HP Max: ${calculatedStats.finalHPMax}`);
console.log(`- SP Max: ${calculatedStats.finalSPMax}`);
console.log(`- MP Max: ${calculatedStats.finalMPMax}`);

console.log('\n🛡️  Defenses:');
console.log(`- PD: ${calculatedStats.finalPD}`);
console.log(`- AD: ${calculatedStats.finalAD}`);
console.log(`- PDR: ${calculatedStats.finalPDR}`);

console.log('\n🎯 Saves:');
console.log(`- Might Save: ${calculatedStats.finalSaveMight}`);
console.log(`- Agility Save: ${calculatedStats.finalSaveAgility}`);
console.log(`- Charisma Save: ${calculatedStats.finalSaveCharisma}`);
console.log(`- Intelligence Save: ${calculatedStats.finalSaveIntelligence}`);

console.log('\n🏃 Movement & Combat:');
console.log(`- Move Speed: ${calculatedStats.finalMoveSpeed} spaces`);
console.log(`- Jump Distance: ${calculatedStats.finalJumpDistance}`);
console.log(`- Initiative Bonus: ${calculatedStats.finalInitiativeBonus}`);
console.log(`- Death Threshold: ${calculatedStats.finalDeathThreshold}`);

console.log('\n⚔️  Combat Training:');
calculatedStats.combatTraining.forEach(training => {
	console.log(`- ${training}`);
});

console.log('\n🌟 Granted Abilities:');
calculatedStats.grantedAbilities.forEach(ability => {
	console.log(`- ${ability.name}: ${ability.description}`);
});

console.log('\n⚠️  Conditional Modifiers:');
calculatedStats.conditionalModifiers.forEach(modifier => {
	console.log(`- ${modifier.description}`);
});

console.log('\n' + '='.repeat(60));
console.log('✅ DEMONSTRATION COMPLETE');
console.log('The new system successfully processed all effects without any text parsing!');
console.log('='.repeat(60));

export { humanBarbarianBuild, calculatedStats };
````

## File: src/lib/services/_new_schema/effectProcessor.ts
````typescript
import type { 
	Effect, 
	StatModifiers, 
	ConditionalModifier, 
	GrantedAbility, 
	EffectProcessingResult 
} from '../../rulesdata/schemas/character.schema';

/**
 * Universal Effect Processing Engine
 * 
 * This is the core of the new data-driven character system.
 * It takes a list of Effect objects from any source (traits, class features, etc.)
 * and processes them into a standardized result format that the calculator can use.
 */

// Initialize empty stat modifiers
function createEmptyStatModifiers(): StatModifiers {
	return {
		// Attributes
		might: 0,
		agility: 0,
		charisma: 0,
		intelligence: 0,

		// Core Stats
		hpMax: 0,
		spMax: 0,
		mpMax: 0,
		pd: 0,
		ad: 0,
		pdr: 0,
		
		// Movement & Combat
		moveSpeed: 0,
		jumpDistance: 0,
		deathThresholdModifier: 0,
		saveDC: 0,
		initiativeBonus: 0,
		
		// Resource Stats
		skillPoints: 0,
		tradePoints: 0,
		languagePoints: 0,
		ancestryPoints: 0,
		restPoints: 0,
		gritPoints: 0,
		
		// Learning Stats
		maneuversKnown: 0,
		techniquesKnown: 0,
		cantripsKnown: 0,
		spellsKnown: 0,
		skillMasteryLimit: 0,
		tradeMasteryLimit: 0,
		knowledgeMasteryLimit: 0
	};
}

// Effect processors for each effect type
const EFFECT_PROCESSORS: Record<string, (effect: Effect, result: EffectProcessingResult) => void> = {
	
	MODIFY_ATTRIBUTE: (effect, result) => {
		if (typeof effect.value === 'number') {
			const attrKey = effect.target as keyof StatModifiers;
			if (attrKey in result.statModifiers) {
				result.statModifiers[attrKey] += effect.value;
			}
		}
	},

	MODIFY_STAT: (effect, result) => {
		if (typeof effect.value === 'number') {
			if (effect.condition) {
				// Conditional modifier - handle by UI
				result.conditionalModifiers.push({
					effect,
					condition: effect.condition,
					description: `${effect.target} ${effect.value > 0 ? '+' : ''}${effect.value} while ${effect.condition}`
				});
			} else {
				// Direct stat modifier
				const statKey = effect.target as keyof StatModifiers;
				if (statKey in result.statModifiers) {
					result.statModifiers[statKey] += effect.value;
				}
			}
		}
	},

	SET_VALUE: (effect, result) => {
		// Handle special value overrides
		if (effect.target === 'jumpCalculationAttribute' && typeof effect.value === 'string') {
			result.grantedAbilities.push({
				name: 'Alternative Jump Calculation',
				description: `Use ${effect.value} instead of Agility for Jump Distance calculation`,
				source: 'Effect',
				type: 'passive'
			});
		}
	},

	GRANT_ABILITY: (effect, result) => {
		if (typeof effect.value === 'string') {
			result.grantedAbilities.push({
				name: effect.target,
				description: effect.value,
				source: 'Effect',
				type: 'active'
			});
		}
	},

	GRANT_RESISTANCE: (effect, result) => {
		result.resistances.push({
			type: effect.target,
			value: effect.value as string
		});
	},

	GRANT_VULNERABILITY: (effect, result) => {
		result.vulnerabilities.push({
			type: effect.target,
			value: effect.value as string
		});
	},

	GRANT_ADV_ON_SAVE: (effect, result) => {
		result.grantedAbilities.push({
			name: `Advantage on ${effect.target} Saves`,
			description: `You have advantage on saves against ${effect.target}`,
			source: 'Effect',
			type: 'passive'
		});
	},

	GRANT_ADV_ON_CHECK: (effect, result) => {
		result.grantedAbilities.push({
			name: `Advantage on ${effect.target} Checks`,
			description: `You have advantage on ${effect.target} checks`,
			source: 'Effect',
			type: 'passive'
		});
	},

	GRANT_COMBAT_TRAINING: (effect, result) => {
		if (typeof effect.target === 'string') {
			result.combatTraining.push(effect.target);
		}
	},

	GRANT_MOVEMENT: (effect, result) => {
		result.movements.push({
			type: effect.target,
			speed: effect.value as string
		});
	},

	GRANT_SENSE: (effect, result) => {
		if (typeof effect.value === 'number') {
			result.senses.push({
				type: effect.target,
				range: effect.value
			});
		}
	},

	GRANT_CHOICE: (effect, result) => {
		// Choices are handled at a higher level - this is just for tracking
		result.grantedAbilities.push({
			name: `Choice: ${effect.target}`,
			description: `You gain a choice for ${effect.target} (value: ${effect.value})`,
			source: 'Effect',
			type: 'passive'
		});
	},

	GRANT_SKILL_EXPERTISE: (effect, result) => {
		if (typeof effect.value === 'object' && effect.value.capIncrease && effect.value.levelIncrease) {
			result.statModifiers.skillMasteryLimit += effect.value.capIncrease;
			result.grantedAbilities.push({
				name: 'Skill Expertise',
				description: `Skill mastery cap and level increased by ${effect.value.capIncrease}`,
				source: 'Effect',
				type: 'passive'
			});
		}
	},

	GRANT_TRADE_EXPERTISE: (effect, result) => {
		if (typeof effect.value === 'object' && effect.value.capIncrease && effect.value.levelIncrease) {
			result.statModifiers.tradeMasteryLimit += effect.value.capIncrease;
			result.grantedAbilities.push({
				name: 'Trade Expertise',
				description: `Trade mastery cap and level increased by ${effect.value.capIncrease}`,
				source: 'Effect',
				type: 'passive'
			});
		}
	},

	GRANT_SPELL: (effect, result) => {
		if (typeof effect.value === 'number') {
			result.statModifiers.spellsKnown += effect.value;
		} else if (typeof effect.value === 'string') {
			result.grantedAbilities.push({
				name: 'Spell Known',
				description: `You know the spell: ${effect.value}`,
				source: 'Effect',
				type: 'passive'
			});
		}
	},

	GRANT_CANTRIP: (effect, result) => {
		if (typeof effect.value === 'number') {
			result.statModifiers.cantripsKnown += effect.value;
		} else if (typeof effect.value === 'string') {
			result.grantedAbilities.push({
				name: 'Cantrip Known',
				description: `You know the cantrip: ${effect.value}`,
				source: 'Effect',
				type: 'passive'
			});
		}
	},

	GRANT_MANEUVERS: (effect, result) => {
		if (effect.value === true || effect.value === 'all_attack') {
			result.grantedAbilities.push({
				name: 'All Attack Maneuvers',
				description: 'You know all Attack maneuvers',
				source: 'Effect',
				type: 'passive'
			});
		} else if (typeof effect.value === 'number') {
			result.statModifiers.maneuversKnown += effect.value;
		}
	},

	GRANT_TECHNIQUES: (effect, result) => {
		if (typeof effect.value === 'number') {
			result.statModifiers.techniquesKnown += effect.value;
		}
	}
};

/**
 * Process a list of effects and return aggregated results
 */
export function processEffects(
	effects: Effect[], 
	userChoices: Record<string, any> = {}
): EffectProcessingResult {
	
	const result: EffectProcessingResult = {
		statModifiers: createEmptyStatModifiers(),
		conditionalModifiers: [],
		grantedAbilities: [],
		combatTraining: [],
		resistances: [],
		vulnerabilities: [],
		senses: [],
		movements: []
	};

	// Process each effect
	for (const effect of effects) {
		// Resolve user choices if needed
		let resolvedEffect = effect;
		if (effect.userChoice && effect.target === 'any_attribute') {
			// Look up the user's choice for this effect
			const choiceKey = `${effect.target}_choice`; // This would need to be more sophisticated
			const userSelection = userChoices[choiceKey];
			if (userSelection) {
				resolvedEffect = {
					...effect,
					target: userSelection,
					userChoice: undefined // Remove the choice requirement
				};
			} else {
				// Choice not yet made - skip processing for now
				continue;
			}
		}

		// Process the effect using the appropriate processor
		const processor = EFFECT_PROCESSORS[resolvedEffect.type];
		if (processor) {
			processor(resolvedEffect, result);
		} else {
			console.warn(`Unknown effect type: ${resolvedEffect.type}`);
		}
	}

	return result;
}

/**
 * Aggregate effects from multiple sources (traits, class features, etc.)
 */
export function aggregateEffectsFromSources(sources: {
	traits: Effect[],
	classFeatures: Effect[],
	choices: Effect[]
}): Effect[] {
	return [
		...sources.traits,
		...sources.classFeatures, 
		...sources.choices
	];
}

/**
 * Get effects that require user choices
 */
export function getUnresolvedChoices(effects: Effect[]): Array<{
	effect: Effect,
	prompt: string,
	options?: string[]
}> {
	return effects
		.filter(effect => effect.userChoice)
		.map(effect => ({
			effect,
			prompt: effect.userChoice!.prompt,
			options: effect.userChoice!.options
		}));
}
````

## File: src/lib/services/characterCalculator.ts.backup
````
// DC20 Character Calculator Service
// Handles calculation of derived stats based on DC20 rules

import { skillsData } from '../rulesdata/skills';
import { ancestriesData } from '../rulesdata/ancestries';
import { findClassByName } from '../rulesdata/loaders/class-features.loader';
import type { IClassDefinition } from '../rulesdata/schemas/class.schema';
import { processTraitEffects, type ProcessedTraitEffects } from './traitEffectProcessor';

export interface CharacterInProgressData {
	id: string;
	// Attributes
	attribute_might: number;
	attribute_agility: number;
	attribute_charisma: number;
	attribute_intelligence: number;

	// Progression
	level: number;
	combatMastery: number;

	// Class & Ancestry
	classId: string | null;
	ancestry1Id: string | null;
	ancestry2Id: string | null;
	selectedTraitIds: string;
	selectedFeatureChoices: string;

	// Character Details
	finalName: string | null;
	finalPlayerName: string | null;

	// Skills (if implemented)
	skillsJson?: string;
	tradesJson?: string;
	languagesJson?: string;

	// Manual Defense Overrides
	manualPD?: number;
	manualAD?: number;
	manualPDR?: number;

	// Timestamps
	createdAt: Date;
	updatedAt?: Date;
	completedAt?: string;
}

export interface CalculatedCharacterStats {
	// Basic Info
	id: string;
	finalName: string;
	finalPlayerName?: string;
	finalLevel: number;

	// Timestamps
	createdAt: Date;
	updatedAt?: Date;
	completedAt?: string;

	// Attributes
	finalMight: number;
	finalAgility: number;
	finalCharisma: number;
	finalIntelligence: number;

	// Calculated Stats
	finalPrimeModifierValue: number;
	finalPrimeModifierAttribute: string;
	finalCombatMastery: number;

	// Saves (Attribute + Combat Mastery)
	finalSaveMight: number;
	finalSaveAgility: number;
	finalSaveCharisma: number;
	finalSaveIntelligence: number;

	// Health & Resources
	finalHPMax: number;
	finalSPMax: number;
	finalMPMax: number;

	// Defenses
	finalPD: number; // Precision Defense
	finalAD: number; // Area Defense

	// Other Stats
	finalSaveDC: number;
	finalDeathThreshold: number;
	finalMoveSpeed: number;
	finalJumpDistance: number;
	finalRestPoints: number;
	finalGritPoints: number;
	finalInitiativeBonus: number;

	// PDR (Precision Damage Reduction)
	finalPDR: number;

	// Class & Ancestry Info
	classId: string | null;
	className: string;
	ancestry1Id: string | null;
	ancestry1Name?: string;
	ancestry2Id: string | null;
	ancestry2Name?: string;
	selectedFeatureChoices?: string;
	selectedTraitIds?: string;

	// JSON data fields
	skillsJson?: string;
	tradesJson?: string;
	languagesJson?: string;
	
	// Calculated bonus data
	skillsWithBonuses?: any[];
	tradesWithBonuses?: any[];
}

// Import class data (we need to create this import based on what's available)
const getClassData = async (classId: string): Promise<IClassDefinition | null> => {
	try {
		// Dynamic import of class data
		const { classesData } = await import('../rulesdata/loaders/class.loader');

		const classData = classesData.find((c) => c.id === classId);
		return classData || null;
	} catch (error) {
		console.warn('Could not load class data:', error);
		return null;
	}
};

// Get ancestry data by ID
const getAncestryData = (ancestryId: string | null): { 
	id: string; 
	name: string; 
	defaultTraitIds: string[];
	expandedTraitIds: string[];
} | null => {
	if (!ancestryId) return null;

	const ancestry = ancestriesData.find((a) => a.id === ancestryId);
	return ancestry ? { 
		id: ancestry.id, 
		name: ancestry.name,
		defaultTraitIds: ancestry.defaultTraitIds || [],
		expandedTraitIds: ancestry.expandedTraitIds
	} : null;
};

const calculatePrimeModifier = (attributes: {
	might: number;
	agility: number;
	charisma: number;
	intelligence: number;
}): { value: number; attribute: string } => {
	// Find the highest attribute
	const { might, agility, charisma, intelligence } = attributes;
	const attrArray = [
		{ value: might, name: 'MIG' },
		{ value: agility, name: 'AGI' },
		{ value: charisma, name: 'CHA' },
		{ value: intelligence, name: 'INT' }
	];

	const highest = attrArray.reduce((prev, curr) => (curr.value > prev.value ? curr : prev));

	return {
		value: highest.value,
		attribute: highest.name
	};
};

export const calculateCharacterStats = async (
	characterData: CharacterInProgressData
): Promise<CalculatedCharacterStats> => {
	console.log('calculateCharacterStats called with:', characterData);

	// Get class data
	const classData = characterData.classId ? await getClassData(characterData.classId) : null;
	console.log('Class data loaded:', classData);

	// Get class features data
	const classFeatures = classData ? findClassByName(classData.name) : null;

	// Get ancestry data
	const ancestry1Data = getAncestryData(characterData.ancestry1Id);
	const ancestry2Data = getAncestryData(characterData.ancestry2Id);
	console.log('Ancestry data loaded:', { ancestry1Data, ancestry2Data });

	// Process trait effects EARLY to get attribute modifiers
	let processedTraitEffects: ProcessedTraitEffects;
	try {
		const selectedTraitIds = characterData.selectedTraitIds ? JSON.parse(characterData.selectedTraitIds) : [];
		processedTraitEffects = processTraitEffects(
			selectedTraitIds, 
			characterData.ancestry1Id, 
			characterData.ancestry2Id
		);
		console.log('Trait effects processed:', processedTraitEffects);
	} catch (error) {
		console.warn('Error processing trait effects:', error);
		// Initialize empty effects if parsing fails
		processedTraitEffects = {
			attributeModifiers: { might: 0, agility: 0, charisma: 0, intelligence: 0 },
			staticBonuses: { hpMax: 0, mpMax: 0, spMax: 0, pd: 0, ad: 0, moveSpeed: 0, deathThreshold: 0, jumpDistance: 0, initiativeBonus: 0 },
			resistances: [],
			vulnerabilities: [],
			abilities: [],
			conditionalEffects: [],
			userChoicesRequired: []
		};
	}

	// Apply attribute modifiers from traits BEFORE other calculations
	const finalMight = characterData.attribute_might + processedTraitEffects.attributeModifiers.might;
	const finalAgility = characterData.attribute_agility + processedTraitEffects.attributeModifiers.agility;
	const finalCharisma = characterData.attribute_charisma + processedTraitEffects.attributeModifiers.charisma;
	const finalIntelligence = characterData.attribute_intelligence + processedTraitEffects.attributeModifiers.intelligence;

	// Combat Mastery (half level rounded up)
	const finalCombatMastery = Math.ceil(characterData.level / 2);

	// Prime Modifier
	const primeModifier = calculatePrimeModifier({
		might: finalMight,
		agility: finalAgility,
		charisma: finalCharisma,
		intelligence: finalIntelligence
	});

	// Defenses (DC20 formulas)
	// PD (Precision Defense) = 8 + CM + Agility + Intelligence + Bonuses from traits/items
	const calculatedPD = 8 + finalCombatMastery + finalAgility + finalIntelligence + processedTraitEffects.staticBonuses.pd;
	const finalPD = characterData.manualPD !== undefined ? characterData.manualPD : calculatedPD;

	// AD (Area Defense) = 8 + CM + Might + Charisma + Bonuses from traits/items
	const calculatedAD = 8 + finalCombatMastery + finalMight + finalCharisma + processedTraitEffects.staticBonuses.ad;
	let finalAD = characterData.manualAD !== undefined ? characterData.manualAD : calculatedAD;

	// Health & Resources
	let finalHPMax = finalMight; // Base from Might
	let finalSPMax = 0;
	let finalMPMax = 0;
	let finalSaveDC = 10; // Base (correct DC20 base)
	let finalDeathThreshold = 10; // Base
	let finalMoveSpeed = 5; // Default base, will be set by class data
	let finalRestPoints = 4; // Will be set to finalHPMax later
	let finalInitiativeBonus = 0; // Base

	// Add class contributions
	if (classData) {
		finalHPMax += classData.baseHpContribution;
		finalSPMax = classData.startingSP;
		finalMPMax = classData.startingMP;
		// Note: saveDCBase is not used in correct formula, keeping base at 10
		finalDeathThreshold = classData.deathThresholdBase;
		finalMoveSpeed = classData.moveSpeedBase;
		// finalRestPoints will be set to finalHPMax after all calculations
		finalInitiativeBonus = classData.initiativeBonusBase;

		// Apply effects from class features using the new class features structure
		if (classFeatures) {
			// Get level 1 features
			const level1Features = classFeatures.coreFeatures.filter(
				(feature) => feature.levelGained === 1
			);

			level1Features.forEach((feature) => {
				if (feature.benefits) {
					feature.benefits.forEach((benefit) => {
						if (benefit.effects) {
							benefit.effects.forEach((effect) => {
								if (effect.type === 'MODIFIER') {
									// For now, we'll assume the condition is met.
									// A more robust solution would parse and evaluate the condition string.
									if (effect.target === 'defenses.ad') {
										finalAD += effect.value;
									} else if (effect.target === 'coreStats.moveSpeed') {
										finalMoveSpeed += effect.value;
									} else if (effect.target === 'resources.mpMax') {
										finalMPMax += effect.value;
									} else if (effect.target === 'coreStats.jumpDistance') {
										finalJumpDistance += effect.value;
									}
									// Add more target cases here as needed
								} else if (effect.type === 'OVERRIDE') {
									if (effect.target === 'coreStats.jumpDistance') {
										// A more robust solution would parse the value string
										finalJumpDistance = finalMight;
									}
								} else if (effect.type === 'GRANT_SKILL_POINTS') {
									// This is a placeholder. A real implementation would need to
									// modify the character's skill points data.
									console.log(`Granting ${effect.value} skill points.`);
								} else if (effect.type === 'GRANT_SPELLS') {
									// This is a placeholder. A real implementation would need to
									// add the spells to the character's spell list.
									console.log(`Granting ${effect.value} spells.`);
								} else if (effect.type === 'GRANT_CANTRIPS') {
									// This is a placeholder. A real implementation would need to
									// add the cantrips to the character's spell list.
									console.log(`Granting ${effect.value} cantrips.`);
								} else if (effect.type === 'GRANT_COMBAT_TRAINING') {
									// This is a placeholder. A real implementation would need to
									// add the combat training to the character's data.
									console.log(`Granting combat training: ${effect.value}`);
								} else if (effect.type === 'GRANT_MANEUVERS') {
									// This is a placeholder. A real implementation would need to
									// add the maneuvers to the character's data.
									console.log(`Granting ${effect.value} maneuvers.`);
								} else if (effect.type === 'GRANT_ANCESTRY_POINTS') {
									// This is a placeholder. A real implementation would need to
									// add the ancestry points to the character's data.
									console.log(`Granting ${effect.value} ancestry points.`);
								} else if (effect.type === 'GRANT_PASSIVE') {
									// This is a placeholder. A real implementation would need to
									// add the passive to the character's data.
									console.log(`Granting passive: ${effect.value}`);
								}
							});
						}
					});
				}
			});
		}
	}

	// Process selected feature choices (robust parsing approach)
	if (characterData.selectedFeatureChoices && classFeatures) {
		try {
			const selectedChoices: { [key: string]: string } = JSON.parse(
				characterData.selectedFeatureChoices
			);

			// Find all level 1 features with choices
			const level1Features = classFeatures.coreFeatures.filter(
				(feature) => feature.levelGained === 1
			);

			level1Features.forEach((feature) => {
				if (feature.choices) {
					feature.choices.forEach((choice, choiceIndex) => {
						const choiceId = `${classFeatures.className.toLowerCase()}_${feature.featureName.toLowerCase().replace(/\s+/g, '_')}_${choiceIndex}`;
						const selectedOptions = selectedChoices[choiceId];

						if (selectedOptions) {
							let optionsToProcess: string[] = [];

							// Handle both single selection and multiple selection
							try {
								optionsToProcess = JSON.parse(selectedOptions);
								if (!Array.isArray(optionsToProcess)) {
									optionsToProcess = [selectedOptions];
								}
							} catch {
								optionsToProcess = [selectedOptions];
							}

							// Process each selected option
							optionsToProcess.forEach((optionName) => {
								const selectedOption = choice.options?.find((opt) => opt.name === optionName);
								if (selectedOption) {
									const description = selectedOption.description.toLowerCase();

									// Parse stat bonuses from descriptions using regex patterns

									// MP bonuses: "your maximum mp increases by X", "mp increases by X", "+X mp"
									const mpMatch =
										description.match(
											/(?:your maximum mp increases by|mp increases by|\+)\s*(\d+)\s*mp/i
										) || description.match(/maximum mp increases by\s*(\d+)/i);
									if (mpMatch) {
										finalMPMax += parseInt(mpMatch[1]);
									}

									// Ancestry Points: "you get X ancestry points", "X ancestry points"
									const ancestryMatch = description.match(
										/(?:you get|gain)\s*(\d+)\s*ancestry points?/i
									);
									if (ancestryMatch) {
										// Note: This would need to be handled in character creation logic, not just stats
										console.log(
											`Feature choice grants ${ancestryMatch[1]} ancestry points: ${optionName}`
										);
									}

									// SP bonuses: "your maximum sp increases by X", "+X sp"
									const spMatch = description.match(
										/(?:your maximum sp increases by|sp increases by|\+)\s*(\d+)\s*sp/i
									);
									if (spMatch) {
										finalSPMax += parseInt(spMatch[1]);
									}

									// HP bonuses: "your maximum hp increases by X", "+X hp"
									const hpMatch = description.match(
										/(?:your maximum hp increases by|hp increases by|\+)\s*(\d+)\s*hp/i
									);
									if (hpMatch) {
										finalHPMax += parseInt(hpMatch[1]);
									}

									// Maneuver learning: "you learn X maneuvers", "learn X defensive maneuvers"
									const maneuverMatch = description.match(
										/you learn\s*(\d+)\s*(?:defensive\s+)?maneuvers?/i
									);
									if (maneuverMatch) {
										// Note: This would be handled in maneuver tracking, not base stats
										console.log(
											`Feature choice grants ${maneuverMatch[1]} maneuvers: ${optionName}`
										);
									}

									// Spell learning: "you learn X additional spell", "you learn X spell"
									const spellMatch = description.match(
										/you learn\s*(\d+)\s*(?:additional\s+)?spells?/i
									);
									if (spellMatch) {
										// Note: This would be handled in spell tracking, not base stats
										console.log(`Feature choice grants ${spellMatch[1]} spells: ${optionName}`);
									}

									// Save DC bonuses: "save dc increases by X", "+X to save dc"
									const saveDCMatch = description.match(
										/(?:save dc increases by|\+)\s*(\d+)(?:\s*to save dc)?/i
									);
									if (saveDCMatch) {
										finalSaveDC += parseInt(saveDCMatch[1]);
									}

									// Movement speed: "move speed increases by X", "+X movement"
									const speedMatch = description.match(
										/(?:move speed increases by|movement.*increases by|\+)\s*(\d+)(?:\s*(?:feet|ft|spaces?))?.*(?:movement|speed)/i
									);
									if (speedMatch) {
										finalMoveSpeed += parseInt(speedMatch[1]);
									}
								}
							});
						}
					});
				}
			});
		} catch (error) {
			console.warn('Error processing feature choices:', error);
		}
	}

	// Apply static bonuses from trait effects (after class effects, before manual overrides)
	finalHPMax += processedTraitEffects.staticBonuses.hpMax;
	finalMPMax += processedTraitEffects.staticBonuses.mpMax;
	finalSPMax += processedTraitEffects.staticBonuses.spMax;
	finalMoveSpeed += processedTraitEffects.staticBonuses.moveSpeed;
	finalDeathThreshold += processedTraitEffects.staticBonuses.deathThreshold;
	finalInitiativeBonus += processedTraitEffects.staticBonuses.initiativeBonus;

	// Add attribute bonuses
	finalSaveDC += primeModifier.value + finalCombatMastery; // Save DC = 10 + Prime + Combat Mastery
	finalInitiativeBonus += finalCombatMastery + finalAgility; // Initiative = CM + Agility

	// Calculate Save Values (Updated Formula)
	// Save = Attribute Modifier + Combat Mastery (always)
	const finalSaveMight = finalMight + finalCombatMastery;
	const finalSaveAgility = finalAgility + finalCombatMastery;
	const finalSaveCharisma = finalCharisma + finalCombatMastery;
	const finalSaveIntelligence = finalIntelligence + finalCombatMastery;

	console.log('Save calculations:', {
		combatMastery: finalCombatMastery,
		attributes: {
			might: finalMight,
			agility: finalAgility,
			charisma: finalCharisma,
			intelligence: finalIntelligence
		},
		results: {
			might: finalSaveMight,
			agility: finalSaveAgility,
			charisma: finalSaveCharisma,
			intelligence: finalSaveIntelligence
		}
	});

	// Jump Distance = Agility (min 1)
	let finalJumpDistance = Math.max(1, finalAgility);

	// Grit Points = 2 + Charisma (from class base)
	const baseGritPoints = classData?.gritPointsBase || 2;
	const finalGritPoints = baseGritPoints + finalCharisma;

	// Calculate PDR (Precision Damage Reduction) with manual override
	const calculatedPDR = calculatePDR(characterData, classData);
	const finalPDR = characterData.manualPDR !== undefined ? characterData.manualPDR : calculatedPDR;

	// Process skills with calculated bonuses
	let skillsJson = characterData.skillsJson;
	if (!skillsJson) {
		// Create default skills with 0 proficiency
		const defaultSkills: Record<string, number> = {};
		skillsData.forEach((skill) => {
			defaultSkills[skill.id] = 0;
		});
		skillsJson = JSON.stringify(defaultSkills);
	}

	// Calculate skill bonuses: Attribute + Mastery*2
	const skillsWithBonuses: any[] = [];
	try {
		const skillProficiencies = JSON.parse(skillsJson);
		skillsData.forEach((skill) => {
			const proficiency = skillProficiencies[skill.id] || 0;
			const masteryBonus = proficiency * 2;
			
			// Get attribute modifier based on skill's attribute association
			let attributeModifier = 0;
			switch (skill.attributeAssociation.toLowerCase()) {
				case 'might':
					attributeModifier = finalMight;
					break;
				case 'agility':
					attributeModifier = finalAgility;
					break;
				case 'charisma':
					attributeModifier = finalCharisma;
					break;
				case 'intelligence':
					attributeModifier = finalIntelligence;
					break;
				default:
					attributeModifier = 0;
			}
			
			const totalBonus = attributeModifier + masteryBonus;
			
			skillsWithBonuses.push({
				id: skill.id,
				name: skill.name,
				attribute: skill.attributeAssociation,
				proficiency,
				bonus: totalBonus
			});
		});
	} catch (error) {
		console.warn('Error calculating skill bonuses:', error);
	}

	// Process trades with calculated bonuses
	const tradesWithBonuses: any[] = [];
	try {
		const tradeProficiencies = JSON.parse(characterData.tradesJson || '{}');
		// Import trades data
		const { tradesData } = await import('../rulesdata/trades');
		const { knowledgeData } = await import('../rulesdata/knowledge');
		const allTradesAndKnowledge = [...tradesData, ...knowledgeData];
		
		allTradesAndKnowledge.forEach((trade) => {
			const proficiency = tradeProficiencies[trade.id] || 0;
			const masteryBonus = proficiency * 2;
			
			// Get attribute modifier based on trade's attribute association
			let attributeModifier = 0;
			switch (trade.attributeAssociation.toLowerCase()) {
				case 'might':
					attributeModifier = finalMight;
					break;
				case 'agility':
					attributeModifier = finalAgility;
					break;
				case 'charisma':
					attributeModifier = finalCharisma;
					break;
				case 'intelligence':
					attributeModifier = finalIntelligence;
					break;
				default:
					attributeModifier = 0;
			}
			
			const totalBonus = attributeModifier + masteryBonus;
			
			tradesWithBonuses.push({
				id: trade.id,
				name: trade.name,
				proficiency,
				bonus: totalBonus
			});
		});
	} catch (error) {
		console.warn('Error calculating trade bonuses:', error);
	}

	// DC20 Rule: Rest Points = HP
	finalRestPoints = finalHPMax;

	return {
		// Basic Info
		id: characterData.id,
		finalName: characterData.finalName || 'Unnamed Character',
		finalPlayerName: characterData.finalPlayerName || undefined,
		finalLevel: characterData.level,

		// Timestamps
		createdAt: characterData.createdAt,
		updatedAt: characterData.updatedAt,
		completedAt: characterData.completedAt,

		// Attributes
		finalMight,
		finalAgility,
		finalCharisma,
		finalIntelligence,

		// Calculated Stats
		finalPrimeModifierValue: primeModifier.value,
		finalPrimeModifierAttribute: primeModifier.attribute,
		finalCombatMastery,

		// Saves (Attribute + Combat Mastery)
		finalSaveMight,
		finalSaveAgility,
		finalSaveCharisma,
		finalSaveIntelligence,

		// Health & Resources
		finalHPMax,
		finalSPMax,
		finalMPMax,

		// Defenses
		finalPD,
		finalAD,

		// Other Stats
		finalSaveDC,
		finalDeathThreshold,
		finalMoveSpeed,
		finalJumpDistance,
		finalRestPoints,
		finalGritPoints,
		finalInitiativeBonus,

		// PDR (Precision Damage Reduction)
		finalPDR,

		// Class & Ancestry Info
		classId: characterData.classId,
		className: classData?.name || 'Unknown',
		ancestry1Id: characterData.ancestry1Id,
		ancestry1Name: ancestry1Data?.name,
		ancestry2Id: characterData.ancestry2Id,
		ancestry2Name: ancestry2Data?.name,
		selectedFeatureChoices: characterData.selectedFeatureChoices,
		selectedTraitIds: characterData.selectedTraitIds,

		// JSON data fields
		skillsJson,
		tradesJson: characterData.tradesJson || '{}',
		languagesJson: characterData.languagesJson || '{"common": {"fluency": "fluent"}}',
		
		// Calculated skill and trade bonuses
		skillsWithBonuses,
		tradesWithBonuses
	};
};

// Helper function to calculate PDR (Precision Damage Reduction)
const calculatePDR = (
	characterData: CharacterInProgressData,
	classData: IClassDefinition | null
): number => {
	let pdr = 0;

	// Check for Beastborn Natural Armor trait
	if (characterData.selectedTraitIds) {
		try {
			const selectedTraits = JSON.parse(characterData.selectedTraitIds);
			if (selectedTraits.includes('beastborn_natural_armor')) {
				// Natural Armor grants PDR when not wearing armor
				// According to DC20 rules, this grants PDR (Precision Damage Reduction)
				pdr += 1;
			}
		} catch (error) {
			console.warn('Error parsing selectedTraitIds for PDR calculation:', error);
		}
	}

	// Check for Barbarian Rage ability
	if (classData?.id === 'barbarian') {
		// Barbarian Rage grants Resistance (Half) to Precision damage
		// This is effectively PDR, but it's a different mechanic
		// For now, we'll note this but not add to base PDR since Rage is conditional
		// TODO: Could add a note or separate field for conditional PDR
	}

	// TODO: Add additional PDR sources:
	// - Heavy Armor with PDR property (requires armor system integration)
	// - Shell Retreat ability (conditional)
	// - Magic items or other class features
	// - Equipment-based PDR calculation

	return pdr;
};
````

## File: src/lib/services/traitEffectProcessor.ts
````typescript
import { traitsData } from '../rulesdata/traits';
import { ancestriesData } from '../rulesdata/ancestries';
import type { ITrait, ITraitEffect } from '../rulesdata/types';

export interface ProcessedTraitEffects {
	attributeModifiers: {
		might: number;
		agility: number;
		charisma: number;
		intelligence: number;
	};
	staticBonuses: {
		hpMax: number;
		mpMax: number;
		spMax: number;
		pd: number;
		ad: number;
		moveSpeed: number; // in spaces
		deathThreshold: number;
		jumpDistance: number;
		initiativeBonus: number;
	};
	resistances: Array<{
		type: string;
		value: number | string;
	}>;
	vulnerabilities: Array<{
		type: string;
		value: number;
	}>;
	abilities: string[];
	conditionalEffects: Array<{
		type: string;
		condition: string;
		target: string;
		value: any;
	}>;
	sizeModification?: string;
	userChoicesRequired: Array<{
		traitId: string;
		effect: ITraitEffect;
		prompt: string;
		options?: string[];
	}>;
}

// Initialize empty processed effects
function createEmptyEffects(): ProcessedTraitEffects {
	return {
		attributeModifiers: {
			might: 0,
			agility: 0,
			charisma: 0,
			intelligence: 0
		},
		staticBonuses: {
			hpMax: 0,
			mpMax: 0,
			spMax: 0,
			pd: 0,
			ad: 0,
			moveSpeed: 0,
			deathThreshold: 0,
			jumpDistance: 0,
			initiativeBonus: 0
		},
		resistances: [],
		vulnerabilities: [],
		abilities: [],
		conditionalEffects: [],
		userChoicesRequired: []
	};
}

// Get default traits for an ancestry
function getDefaultTraitsForAncestry(ancestryId: string | null): string[] {
	if (!ancestryId) return [];
	
	const ancestry = ancestriesData.find(a => a.id === ancestryId);
	return ancestry?.defaultTraitIds || [];
}

// Effect processors for different trait effect types
const EFFECT_PROCESSORS: Record<string, (effect: ITraitEffect, results: ProcessedTraitEffects, traitId: string) => void> = {
	MODIFY_ATTRIBUTE: (effect, results, traitId) => {
		if (effect.target && typeof effect.value === 'number') {
			// Handle user choice required
			if (effect.userChoiceRequired) {
				results.userChoicesRequired.push({
					traitId,
					effect,
					prompt: effect.userChoiceRequired.prompt,
					options: effect.userChoiceRequired.options
				});
				return;
			}
			
			// Apply direct attribute modification
			const attrKey = effect.target as keyof typeof results.attributeModifiers;
			if (attrKey in results.attributeModifiers) {
				results.attributeModifiers[attrKey] += effect.value;
			}
		}
	},

	MODIFY_HP_MAX_STATIC: (effect, results) => {
		if (typeof effect.value === 'number') {
			results.staticBonuses.hpMax += effect.value;
		}
	},

	MODIFY_MP_MAX: (effect, results) => {
		if (typeof effect.value === 'number') {
			results.staticBonuses.mpMax += effect.value;
		}
	},

	MODIFY_PD: (effect, results) => {
		if (typeof effect.value === 'number') {
			if (effect.condition) {
				// Handle conditional PD bonuses
				results.conditionalEffects.push({
					type: 'PD_BONUS',
					condition: effect.condition,
					target: 'pd',
					value: effect.value
				});
			} else {
				results.staticBonuses.pd += effect.value;
			}
		}
	},

	MODIFY_AD: (effect, results) => {
		if (typeof effect.value === 'number') {
			if (effect.condition) {
				// Handle conditional AD bonuses
				results.conditionalEffects.push({
					type: 'AD_BONUS',
					condition: effect.condition,
					target: 'ad',
					value: effect.value
				});
			} else {
				results.staticBonuses.ad += effect.value;
			}
		}
	},

	MODIFY_SPEED: (effect, results) => {
		if (typeof effect.value === 'number') {
			// Convert from internal units (5 = 1 space) to spaces
			results.staticBonuses.moveSpeed += effect.value / 5;
		}
	},

	MODIFY_DEATH_THRESHOLD_MODIFIER: (effect, results) => {
		if (typeof effect.value === 'number') {
			results.staticBonuses.deathThreshold += effect.value;
		}
	},

	MODIFY_JUMP_DISTANCE: (effect, results) => {
		if (typeof effect.value === 'number') {
			results.staticBonuses.jumpDistance += effect.value;
		}
	},

	GRANT_RESISTANCE_HALF: (effect, results) => {
		if (effect.target) {
			results.resistances.push({
				type: effect.target,
				value: 'half'
			});
		}
	},

	GRANT_RESISTANCE_STATIC: (effect, results) => {
		if (effect.target && typeof effect.value === 'number') {
			results.resistances.push({
				type: effect.target,
				value: effect.value
			});
		}
	},

	GRANT_VULNERABILITY_STATIC: (effect, results) => {
		if (effect.target && typeof effect.value === 'number') {
			results.vulnerabilities.push({
				type: effect.target,
				value: effect.value
			});
		}
	},

	MODIFY_SIZE: (effect, results) => {
		if (effect.target) {
			results.sizeModification = effect.target;
		}
	},

	GRANT_ABILITY: (effect, results) => {
		if (effect.value && typeof effect.value === 'string') {
			results.abilities.push(effect.value);
		}
	},

	GRANT_DARKVISION: (effect, results) => {
		if (typeof effect.value === 'number') {
			results.abilities.push(`Darkvision ${effect.value} Spaces`);
		}
	},

	GRANT_CLIMB_SPEED_EQUAL_TO_SPEED: (effect, results) => {
		results.abilities.push('Climb Speed equal to Movement Speed');
	},

	GRANT_SWIM_SPEED_EQUAL_TO_SPEED: (effect, results) => {
		results.abilities.push('Swim Speed equal to Movement Speed');
	},

	GRANT_GLIDE_SPEED: (effect, results) => {
		results.abilities.push('Glide Speed');
	},

	GRANT_ADV_ON_SAVE_VS_CONDITION: (effect, results) => {
		if (effect.target) {
			results.abilities.push(`ADV on Saves vs ${effect.target}`);
		}
	},

	GRANT_ADV_ON_CHECKS: (effect, results) => {
		if (effect.target) {
			results.abilities.push(`ADV on ${effect.target}`);
		}
	},

	IGNORE_DIFFICULT_TERRAIN: (effect, results) => {
		results.abilities.push('Ignore Difficult Terrain');
	},

	GRANT_SKILL_EXPERTISE: (effect, results, traitId) => {
		if (effect.userChoiceRequired) {
			results.userChoicesRequired.push({
				traitId,
				effect,
				prompt: effect.userChoiceRequired.prompt,
				options: effect.userChoiceRequired.options
			});
		} else if (effect.value && typeof effect.value === 'object') {
			results.abilities.push(`Skill Expertise: ${effect.value.skillId || 'Selected Skill'}`);
		}
	},

	GRANT_TRADE_EXPERTISE: (effect, results, traitId) => {
		if (effect.userChoiceRequired) {
			results.userChoicesRequired.push({
				traitId,
				effect,
				prompt: effect.userChoiceRequired.prompt,
				options: effect.userChoiceRequired.options
			});
		} else if (effect.value && typeof effect.value === 'object') {
			results.abilities.push(`Trade Expertise: ${effect.value.tradeId || 'Selected Trade'}`);
		}
	}
};

/**
 * Process trait effects from selected and default traits
 * @param selectedTraitIds Array of manually selected trait IDs
 * @param ancestry1Id First ancestry ID (for default traits)
 * @param ancestry2Id Second ancestry ID (for default traits)
 * @returns Processed trait effects ready for application
 */
export function processTraitEffects(
	selectedTraitIds: string[] = [],
	ancestry1Id: string | null = null,
	ancestry2Id: string | null = null
): ProcessedTraitEffects {
	const results = createEmptyEffects();
	
	// Get all default traits from both ancestries
	const defaultTraits = [
		...getDefaultTraitsForAncestry(ancestry1Id),
		...getDefaultTraitsForAncestry(ancestry2Id)
	];
	
	// Combine all traits (default + selected)
	const allTraitIds = [...new Set([...defaultTraits, ...selectedTraitIds])];
	
	console.log('Processing traits:', {
		defaultTraits,
		selectedTraitIds,
		allTraitIds
	});
	
	// Process each trait
	allTraitIds.forEach(traitId => {
		const trait = traitsData.find(t => t.id === traitId);
		if (!trait || !trait.effects) {
			console.warn(`Trait not found or has no effects: ${traitId}`);
			return;
		}
		
		// Process each effect of the trait
		trait.effects.forEach(effect => {
			const processor = EFFECT_PROCESSORS[effect.type];
			if (processor) {
				try {
					processor(effect, results, traitId);
				} catch (error) {
					console.error(`Error processing effect ${effect.type} for trait ${traitId}:`, error);
				}
			} else {
				console.warn(`No processor found for effect type: ${effect.type} in trait ${traitId}`);
			}
		});
	});
	
	console.log('Processed trait effects:', results);
	
	return results;
}

/**
 * Calculate the total ancestry points cost for given traits
 * @param traitIds Array of trait IDs
 * @returns Total point cost (can be negative for negative traits)
 */
export function calculateTraitCosts(traitIds: string[]): number {
	return traitIds.reduce((total, traitId) => {
		const trait = traitsData.find(t => t.id === traitId);
		return total + (trait?.cost || 0);
	}, 0);
}

/**
 * Get all traits available for selection based on ancestries
 * @param ancestry1Id First ancestry ID
 * @param ancestry2Id Second ancestry ID (optional)
 * @returns Array of available trait objects
 */
export function getAvailableTraits(ancestry1Id: string | null, ancestry2Id: string | null = null): ITrait[] {
	const availableTraitIds = new Set<string>();
	
	// Add traits from first ancestry
	if (ancestry1Id) {
		const ancestry1 = ancestriesData.find(a => a.id === ancestry1Id);
		if (ancestry1) {
			ancestry1.expandedTraitIds.forEach(id => availableTraitIds.add(id));
		}
	}
	
	// Add traits from second ancestry
	if (ancestry2Id) {
		const ancestry2 = ancestriesData.find(a => a.id === ancestry2Id);
		if (ancestry2) {
			ancestry2.expandedTraitIds.forEach(id => availableTraitIds.add(id));
		}
	}
	
	// Convert IDs to trait objects
	return Array.from(availableTraitIds)
		.map(id => traitsData.find(t => t.id === id))
		.filter((trait): trait is ITrait => trait !== undefined);
}
````

## File: src/lib/types/effectSystem.ts
````typescript
/**
 * Enhanced Effect System Types
 * 
 * These types support the comprehensive UI enhancements by providing
 * detailed attribution, validation, and breakdown information.
 */

import type { Effect } from '../rulesdata/schemas/character.schema';

// Source attribution for effects
export interface EffectSource {
  type: 'trait' | 'class_feature' | 'choice' | 'base' | 'ancestry_default';
  id: string;
  name: string;
  description?: string;
  category?: string; // e.g., "Human Trait", "Barbarian Level 1"
}

// Effect with source attribution and resolution status
export interface AttributedEffect extends Effect {
  source: EffectSource;
  resolved: boolean; // Whether user choices are resolved
  resolvedValue?: any; // Final resolved value after choices
  dependsOnChoice?: string; // Which choice this effect depends on
}

// Detailed stat breakdown for tooltips
export interface EnhancedStatBreakdown {
  statName: string;
  base: number;
  effects: Array<{
    source: EffectSource;
    value: number;
    condition?: string;
    description: string;
    isActive: boolean; // Whether this effect is currently active
  }>;
  total: number;
  conditionalTotal?: number; // Total if all conditional effects were active
}

// Validation result for real-time feedback
export interface ValidationResult {
  isValid: boolean;
  errors: ValidationError[];
  warnings: ValidationWarning[];
  attributeLimits: Record<string, AttributeLimit>;
  masteryLimits: MasteryLimitStatus;
}

export interface ValidationError {
  type: 'attribute_limit' | 'points_exceeded' | 'required_choice' | 'mastery_limit';
  field: string;
  message: string;
  currentValue: number;
  maxValue: number;
}

export interface ValidationWarning {
  type: 'approaching_limit' | 'inefficient_choice' | 'missing_optional';
  field: string;
  message: string;
}

export interface AttributeLimit {
  current: number;
  base: number;
  traitBonuses: number;
  max: number;
  exceeded: boolean;
  canIncrease: boolean;
  canDecrease: boolean;
}

export interface MasteryLimitStatus {
  maxSkillMastery: number;
  maxTradeMastery: number;
  currentAdeptCount: number;
  maxAdeptCount: number;
  canSelectAdept: boolean;
}

// Unresolved choice for character creation UI
export interface UnresolvedChoice {
  traitId: string;
  traitName: string;
  effectIndex: number;
  effect: Effect;
  prompt: string;
  options: ChoiceOption[];
  isRequired: boolean;
}

export interface ChoiceOption {
  value: string;
  displayName: string;
  description?: string;
  isValid: boolean;
  validationMessage?: string;
  preview?: EffectPreview;
}

// Effect preview for showing impact of choices
export interface EffectPreview {
  type: 'attribute' | 'skill' | 'stat' | 'ability';
  target: string;
  currentValue: any;
  newValue: any;
  description: string;
}

// Comprehensive calculation result
export interface EnhancedCalculationResult {
  stats: {
    // Final calculated values
    finalMight: number;
    finalAgility: number;
    finalCharisma: number;
    finalIntelligence: number;
    finalHPMax: number;
    finalSPMax: number;
    finalMPMax: number;
    finalPD: number;
    finalAD: number;
    finalPDR: number;
    finalMoveSpeed: number;
    finalJumpDistance: number;
    finalDeathThreshold: number;
    finalSaveDC: number;
    finalInitiativeBonus: number;
    finalRestPoints: number;
    finalGritPoints: number;
  };
  
  // Detailed breakdowns for tooltips
  breakdowns: Record<string, EnhancedStatBreakdown>;
  
  // Abilities and features
  grantedAbilities: Array<{
    name: string;
    description: string;
    source: EffectSource;
    type: 'passive' | 'active' | 'resistance' | 'advantage';
    isConditional: boolean;
    condition?: string;
  }>;
  
  // Conditional modifiers
  conditionalModifiers: Array<{
    effect: AttributedEffect;
    condition: string;
    description: string;
    affectedStats: string[];
  }>;
  
  // Combat training
  combatTraining: Array<{
    type: string;
    source: EffectSource;
  }>;
  
  // Resistances and vulnerabilities
  resistances: Array<{
    type: string;
    value: string;
    source: EffectSource;
  }>;
  
  vulnerabilities: Array<{
    type: string;
    value: string;
    source: EffectSource;
  }>;
  
  // Senses and movement
  senses: Array<{
    type: string;
    range: number;
    source: EffectSource;
  }>;
  
  movements: Array<{
    type: string;
    speed: string;
    source: EffectSource;
  }>;
  
  // Validation results
  validation: ValidationResult;
  
  // Unresolved choices (for character creation)
  unresolvedChoices: UnresolvedChoice[];
  
  // Cache info
  cacheTimestamp: number;
  isFromCache: boolean;
}

// Trait choice storage format
export interface TraitChoiceStorage {
  [key: string]: string; // Format: "trait_id-effect_index" -> "chosen_value"
}

// Character build data for enhanced calculator
export interface EnhancedCharacterBuildData {
  // Core Info
  id: string;
  finalName: string;
  finalPlayerName?: string;
  level: number;

  // Attributes (from point buy)
  attribute_might: number;
  attribute_agility: number;
  attribute_charisma: number;
  attribute_intelligence: number;

  // Progression
  combatMastery: number;

  // Class & Ancestry
  classId: string;
  ancestry1Id?: string;
  ancestry2Id?: string;

  // Selections
  selectedTraitIds: string[]; // Array of trait IDs
  selectedTraitChoices: TraitChoiceStorage; // User choices for traits
  featureChoices: Record<string, any>; // User choices for class features
  
  // Skills/Trades/Languages
  skillsJson: string;
  tradesJson: string;
  languagesJson: string;
  
  // Manual Overrides
  manualPD?: number;
  manualAD?: number;
  manualPDR?: number;
  
  // Timestamps for caching
  lastModified: number;
}

// Hook result for character calculation
export interface CharacterCalculationHook {
  calculationResult: EnhancedCalculationResult;
  isLoading: boolean;
  error?: string;
  
  // Helper functions
  getStatBreakdown: (statName: string) => EnhancedStatBreakdown | undefined;
  getAttributeLimit: (attributeId: string) => AttributeLimit;
  canIncreaseAttribute: (attributeId: string) => boolean;
  canDecreaseAttribute: (attributeId: string) => boolean;
  getEffectPreview: (traitId: string, effectIndex: number, choice: string) => EffectPreview | undefined;
  
  // Validation helpers
  validateTraitChoice: (traitId: string, effectIndex: number, choice: string) => { isValid: boolean; message?: string };
  validateAttributeChange: (attributeId: string, newValue: number) => { isValid: boolean; message?: string };
  
  // Cache control
  invalidateCache: () => void;
  refreshCalculation: () => Promise<void>;
}
````

## File: src/lib/utils/characterEdit.ts
````typescript
// Character edit mode utilities
// Handles converting saved characters back to editable format while preserving manual modifications

import type { CharacterInProgressStoreData } from '../stores/characterContext';
import { getCharacterState, updateCharacterState } from './characterState';

export interface SavedCharacter {
	id: string;
	finalName: string;
	finalPlayerName: string;
	classId: string;
	ancestry1Id: string;
	ancestry2Id?: string;
	// The saved character uses finalMight, finalAgility, etc.
	finalMight: number;
	finalAgility: number;
	finalCharisma: number;
	finalIntelligence: number;
	// But also check for the attribute_ format for backwards compatibility
	attribute_might?: number;
	attribute_agility?: number;
	attribute_charisma?: number;
	attribute_intelligence?: number;
	level: number;
	combatMastery: number;
	selectedTraitIds: string;
	selectedFeatureChoices: string;
	skillsJson: string;
	tradesJson: string;
	languagesJson: string;
	completedAt: string;
	[key: string]: any;
}

// Convert a saved character back to character-in-progress format for editing
export const convertCharacterToInProgress = (
	savedCharacter: SavedCharacter
): CharacterInProgressStoreData => {
	// Get attribute values from the correct property names (finalMight, etc. or attribute_might, etc.)
	const getAttribute = (
		finalName: keyof SavedCharacter,
		attributeName: keyof SavedCharacter
	): number => {
		// Try final* first (current format), then attribute_* (legacy format), then default to -2
		if (savedCharacter[finalName] !== undefined) {
			return savedCharacter[finalName] as number;
		}
		if (savedCharacter[attributeName] !== undefined) {
			return savedCharacter[attributeName] as number;
		}
		return -2;
	};

	return {
		id: savedCharacter.id,
		// Basic character build data (what we want to edit)
		attribute_might: getAttribute('finalMight', 'attribute_might'),
		attribute_agility: getAttribute('finalAgility', 'attribute_agility'),
		attribute_charisma: getAttribute('finalCharisma', 'attribute_charisma'),
		attribute_intelligence: getAttribute('finalIntelligence', 'attribute_intelligence'),
		pointsSpent: calculatePointsSpent(savedCharacter),
		level: savedCharacter.level || 1,
		combatMastery: savedCharacter.combatMastery || 1,
		ancestry1Id: savedCharacter.ancestry1Id,
		ancestry2Id: savedCharacter.ancestry2Id || null,
		selectedTraitIds: savedCharacter.selectedTraitIds || '',
		ancestryPointsSpent: calculateAncestryPointsSpent(savedCharacter),
		classId: savedCharacter.classId,
		selectedFeatureChoices: savedCharacter.selectedFeatureChoices || '',
		// Save masteries (default to false, but try to get from saved character if available)
		saveMasteryMight:
			savedCharacter.saveMasteryMight !== undefined ? savedCharacter.saveMasteryMight : false,
		saveMasteryAgility:
			savedCharacter.saveMasteryAgility !== undefined ? savedCharacter.saveMasteryAgility : false,
		saveMasteryCharisma:
			savedCharacter.saveMasteryCharisma !== undefined ? savedCharacter.saveMasteryCharisma : false,
		saveMasteryIntelligence:
			savedCharacter.saveMasteryIntelligence !== undefined
				? savedCharacter.saveMasteryIntelligence
				: false,
		finalName: savedCharacter.finalName,
		finalPlayerName: savedCharacter.finalPlayerName,
		createdAt: new Date(savedCharacter.completedAt),
		updatedAt: new Date(),
		currentStep: 1, // Start from the beginning when editing
		overflowTraitId: null,
		overflowAttributeName: null,
		// Background selections
		skillsJson: savedCharacter.skillsJson || '{}',
		tradesJson: savedCharacter.tradesJson || '{}',
		languagesJson: savedCharacter.languagesJson || '{"common": {"fluency": "fluent"}}'
	};
};

// Calculate how many attribute points were spent
const calculatePointsSpent = (character: SavedCharacter): number => {
	const baseCost = 4; // Each attribute starts at -2, costs 4 points to get to 0

	// Helper to get attribute values from either format
	const getAttribute = (
		finalName: keyof SavedCharacter,
		attributeName: keyof SavedCharacter
	): number => {
		if (character[finalName] !== undefined) {
			return character[finalName] as number;
		}
		if (character[attributeName] !== undefined) {
			return character[attributeName] as number;
		}
		return -2;
	};

	const attributes = [
		getAttribute('finalMight', 'attribute_might'),
		getAttribute('finalAgility', 'attribute_agility'),
		getAttribute('finalCharisma', 'attribute_charisma'),
		getAttribute('finalIntelligence', 'attribute_intelligence')
	];

	let totalSpent = 0;
	attributes.forEach((value) => {
		if (value > -2) {
			totalSpent += baseCost + Math.max(0, value * 2); // Each point above 0 costs 2
		}
	});

	return totalSpent;
};

// Calculate how many ancestry points were spent (based on selected traits)
const calculateAncestryPointsSpent = (character: SavedCharacter): number => {
	if (!character.selectedTraitIds) return 0;

	try {
		// Import traits data to calculate costs
		const { traitsData } = require('../rulesdata/traits');
		const selectedTraitIds: string[] = JSON.parse(character.selectedTraitIds);
		let totalCost = 0;

		selectedTraitIds.forEach((traitId) => {
			const trait = traitsData.find((t: any) => t.id === traitId);
			if (trait) {
				totalCost += trait.cost;
			}
		});

		return totalCost;
	} catch (error) {
		console.warn('Error calculating ancestry points for edit mode:', error);
		return 0;
	}
};

// Enhanced character completion that preserves manual modifications
export const completeCharacterEdit = async (
	originalCharacterId: string,
	newCharacterState: any,
	characterCalculationFn: (data: any) => Promise<any>
): Promise<void> => {
	try {
		// Get the existing character state (manual modifications)
		const existingState = getCharacterState(originalCharacterId);

		// Calculate new stats based on the edited character build
		const newCalculatedCharacter = await characterCalculationFn({
			id: originalCharacterId, // Keep the same ID
			attribute_might: newCharacterState.attribute_might,
			attribute_agility: newCharacterState.attribute_agility,
			attribute_charisma: newCharacterState.attribute_charisma,
			attribute_intelligence: newCharacterState.attribute_intelligence,
			level: newCharacterState.level || 1,
			combatMastery: newCharacterState.combatMastery || 1,
			classId: newCharacterState.classId,
			ancestry1Id: newCharacterState.ancestry1Id,
			ancestry2Id: newCharacterState.ancestry2Id,
			selectedTraitIds: newCharacterState.selectedTraitIds || '',
			selectedFeatureChoices: newCharacterState.selectedFeatureChoices || '',
			finalName: newCharacterState.finalName,
			finalPlayerName: newCharacterState.finalPlayerName,
			skillsJson: newCharacterState.skillsJson || '',
			tradesJson: newCharacterState.tradesJson || '',
			languagesJson: newCharacterState.languagesJson || '',
			lastModified: new Date().toISOString()
		});

		// Update the saved character in localStorage with NEW CALCULATED VALUES
		const savedCharacters = JSON.parse(localStorage.getItem('savedCharacters') || '[]');
		const characterIndex = savedCharacters.findIndex(
			(char: any) => char.id === originalCharacterId
		);

		if (characterIndex !== -1) {
			// Update the character with new calculated values, preserving manual modifications
			savedCharacters[characterIndex] = {
				...savedCharacters[characterIndex],
				...newCalculatedCharacter,
				lastModified: new Date().toISOString()
			};

			localStorage.setItem('savedCharacters', JSON.stringify(savedCharacters));
		}

		// Update the character state to reflect new original values while preserving current (manual) values
		if (existingState) {
			updateCharacterState(originalCharacterId, {
				resources: {
					// Update original values with new calculated maximums
					original: {
						maxHP: newCalculatedCharacter.finalHPMax || 0,
						maxSP: newCalculatedCharacter.finalSPMax || 0,
						maxMP: newCalculatedCharacter.finalMPMax || 0,
						maxGritPoints: newCalculatedCharacter.finalGritPoints || 0,
						maxRestPoints: newCalculatedCharacter.finalRestPoints || 0
					},
					// Keep existing current values (manual modifications)
					current: existingState.resources.current
				},
				// Currency and other data types keep their existing state
				currency: existingState.currency,
				attacks: existingState.attacks,
				inventory: existingState.inventory,
				defenseNotes: existingState.defenseNotes
			});
		}
	} catch (error) {
		console.error('Error completing character edit:', error);
		throw error;
	}
};
````

## File: src/lib/utils/defenseNotes.ts
````typescript
import { DefenseNote } from '../../types/defenseNotes';

// Get character from localStorage
const getCharacterFromStorage = (characterId: string) => {
	const savedCharacters = JSON.parse(localStorage.getItem('savedCharacters') || '[]');
	return savedCharacters.find((char: any) => char.id === characterId);
};

// Save character back to localStorage
const saveCharacterToStorage = (characterId: string, updates: any) => {
	const savedCharacters = JSON.parse(localStorage.getItem('savedCharacters') || '[]');
	const characterIndex = savedCharacters.findIndex((char: any) => char.id === characterId);

	if (characterIndex !== -1) {
		savedCharacters[characterIndex] = {
			...savedCharacters[characterIndex],
			...updates,
			lastModified: new Date().toISOString()
		};
		localStorage.setItem('savedCharacters', JSON.stringify(savedCharacters));
	}
};

// Get all defense notes for a character
export const getDefenseNotes = (characterId: string): DefenseNote[] => {
	try {
		const character = getCharacterFromStorage(characterId);
		if (!character || !character.defenseNotes) return [];

		return character.defenseNotes.map((note: any) => ({
			...note,
			timestamp: new Date(note.timestamp)
		}));
	} catch (error) {
		console.error('Error loading defense notes:', error);
		return [];
	}
};

// Get notes for a specific defense field
export const getDefenseNotesForField = (
	characterId: string,
	field: 'manualPD' | 'manualPDR' | 'manualAD'
): DefenseNote[] => {
	const allNotes = getDefenseNotes(characterId);
	return allNotes
		.filter((note) => note.field === field)
		.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
};

// Add a new defense note
export const addDefenseNote = (
	characterId: string,
	field: 'manualPD' | 'manualPDR' | 'manualAD',
	oldValue: number,
	newValue: number,
	reason: string
): void => {
	try {
		const character = getCharacterFromStorage(characterId);
		if (!character) return;

		const newNote: DefenseNote = {
			id: `${characterId}_${field}_${Date.now()}`,
			timestamp: new Date(),
			reason,
			oldValue,
			newValue,
			field
		};

		const existingNotes = character.defenseNotes || [];
		const updatedNotes = [...existingNotes, newNote];

		saveCharacterToStorage(characterId, { defenseNotes: updatedNotes });

		console.log(`Defense note added for ${characterId} - ${field}: ${reason}`);
	} catch (error) {
		console.error('Error saving defense note:', error);
	}
};

// Remove all defense notes for a specific field (when reverting to auto)
export const clearDefenseNotesForField = (
	characterId: string,
	field: 'manualPD' | 'manualPDR' | 'manualAD'
): void => {
	try {
		const character = getCharacterFromStorage(characterId);
		if (!character || !character.defenseNotes) return;

		const filteredNotes = character.defenseNotes.filter(
			(note: DefenseNote) => note.field !== field
		);

		saveCharacterToStorage(characterId, { defenseNotes: filteredNotes });

		console.log(`Defense notes cleared for ${characterId} - ${field}`);
	} catch (error) {
		console.error('Error clearing defense notes:', error);
	}
};

// Get formatted tooltip text for a defense field
export const getDefenseTooltipWithNotes = (
	characterId: string,
	field: 'manualPD' | 'manualPDR' | 'manualAD',
	baseTooltip: string
): string => {
	const notes = getDefenseNotesForField(characterId, field);

	if (notes.length === 0) {
		return baseTooltip;
	}

	const recentNotes = notes.slice(0, 3); // Show last 3 changes
	const notesText = recentNotes
		.map((note) => {
			const date = note.timestamp.toLocaleDateString();
			const time = note.timestamp.toLocaleTimeString('en-US', {
				hour: '2-digit',
				minute: '2-digit'
			});
			return `• ${date} ${time}: ${note.oldValue} → ${note.newValue} (${note.reason})`;
		})
		.join('\n');

	const moreText = notes.length > 3 ? `\n... and ${notes.length - 3} more changes` : '';

	return `${baseTooltip}\n\nRecent Changes:\n${notesText}${moreText}`;
};

// Get defense field display name
export const getDefenseDisplayName = (field: 'manualPD' | 'manualPDR' | 'manualAD'): string => {
	switch (field) {
		case 'manualPD':
			return 'Precision Defense';
		case 'manualPDR':
			return 'Precision Damage Reduction';
		case 'manualAD':
			return 'Area Defense';
		default:
			return field;
	}
};
````

## File: src/lib/utils/weaponUtils.ts
````typescript
// weaponUtils.ts
// Utility functions for working with inventory weapons in the attack system

import { Weapon, WeaponType, WeaponProperty } from '../rulesdata/inventoryItems';

export interface ParsedDamage {
	amount: number;
	type: 'S' | 'P' | 'B' | 'S/P' | 'B/P';
	typeDisplay:
		| 'slashing'
		| 'piercing'
		| 'bludgeoning'
		| 'slashing/piercing'
		| 'bludgeoning/piercing';
}

/**
 * Parse damage string like "1 S", "2 B", "1 S/P" into structured data
 */
export function parseDamage(damageStr: string): ParsedDamage {
	const match = damageStr.trim().match(/^(\d+)\s+([SPBG\/]+)$/);
	if (!match) {
		// Fallback for malformed damage strings
		return { amount: 0, type: 'B', typeDisplay: 'bludgeoning' };
	}

	const amount = parseInt(match[1]);
	const type = match[2] as ParsedDamage['type'];

	let typeDisplay: ParsedDamage['typeDisplay'];
	switch (type) {
		case 'S':
			typeDisplay = 'slashing';
			break;
		case 'P':
			typeDisplay = 'piercing';
			break;
		case 'B':
			typeDisplay = 'bludgeoning';
			break;
		case 'S/P':
			typeDisplay = 'slashing/piercing';
			break;
		case 'B/P':
			typeDisplay = 'bludgeoning/piercing';
			break;
		default:
			typeDisplay = 'bludgeoning';
			break;
	}

	return { amount, type, typeDisplay };
}

/**
 * Get primary damage type for simple string representation
 */
export function getDamageType(damageStr: string): string {
	const parsed = parseDamage(damageStr);
	return parsed.typeDisplay;
}

/**
 * Check if weapon is ranged
 */
export function isRangedWeapon(weapon: Weapon): boolean {
	return weapon.type === WeaponType.Ranged;
}

/**
 * Get range from weapon properties (parse "Range (15/45)")
 */
export function getWeaponRange(weapon: Weapon): { short: number; long: number } | null {
	const rangeProp = weapon.properties.find((prop) => prop.includes('Range'));
	if (rangeProp) {
		const match = rangeProp.match(/Range \((\d+)\/(\d+)\)/);
		if (match) {
			return {
				short: parseInt(match[1]),
				long: parseInt(match[2])
			};
		}
	}
	return null;
}

/**
 * Get reload value from properties
 */
export function getReloadValue(weapon: Weapon): number | null {
	const reloadProp = weapon.properties.find((prop) => prop === 'Reload');
	// For now, return a default reload value if property exists
	// Could be enhanced to parse specific reload numbers if they exist in properties
	return reloadProp ? 1 : null;
}

/**
 * Calculate attack bonus based on weapon type and character stats
 */
export function calculateAttackBonus(
	weapon: Weapon,
	combatMastery: number,
	mightMod: number,
	agilityMod: number
): number {
	const statMod = isRangedWeapon(weapon) ? agilityMod : mightMod;
	return combatMastery + statMod;
}

/**
 * Calculate damage for different hit types
 */
export function calculateDamage(weapon: Weapon, hitType: 'normal' | 'heavy' | 'brutal'): string {
	const baseDamage = parseDamage(weapon.damage);
	const hasImpact = weapon.properties.includes('Impact');

	let totalDamage = baseDamage.amount;

	switch (hitType) {
		case 'heavy':
			totalDamage += 1;
			if (hasImpact) totalDamage += 1;
			break;
		case 'brutal':
			totalDamage += 2;
			if (hasImpact) totalDamage += 1;
			break;
		default:
			// normal hit, no bonus
			break;
	}

	return `${totalDamage} ${baseDamage.type}`;
}

/**
 * Get versatile damage options for versatile weapons
 */
export function getVersatileDamage(
	weapon: Weapon
): { oneHanded: string; twoHanded: string } | null {
	if (weapon.handedness === 'Versatile') {
		const baseDamage = parseDamage(weapon.damage);
		const twoHandedAmount = baseDamage.amount + 1;

		return {
			oneHanded: weapon.damage,
			twoHanded: `${twoHandedAmount} ${baseDamage.type}`
		};
	}
	return null;
}

/**
 * Get weapon features based on properties
 */
export function getWeaponFeatures(weapon: Weapon): string[] {
	const features: string[] = [];

	weapon.properties.forEach((prop) => {
		switch (prop) {
			case 'Impact':
				features.push('+1 damage on Heavy Hit');
				break;
			case 'Guard':
				features.push('Defensive bonus');
				break;
			case 'Reach':
				features.push('Extended reach');
				break;
			case 'Versatile':
				features.push('Can be used one or two-handed');
				break;
			case 'Heavy':
				features.push('Heavy weapon');
				break;
			case 'Two-Handed':
				features.push('Requires two hands');
				break;
			case 'Concealable':
				features.push('Easy to hide');
				break;
			case 'Silent':
				features.push('Silent attacks');
				break;
			case 'Unwieldy':
				features.push('Difficult to use effectively');
				break;
			default:
				if (prop.includes('Toss') || prop.includes('Thrown')) {
					features.push('Can be thrown');
				} else if (prop.includes('Range')) {
					const range = getWeaponRange(weapon);
					if (range) {
						features.push(`Range: ${range.short}/${range.long}`);
					}
				} else if (prop.includes('Capture')) {
					features.push('Can capture/entangle');
				} else if (prop === 'Ammo') {
					features.push('Requires ammunition');
				} else if (prop === 'Reload') {
					features.push('Must be reloaded');
				}
				break;
		}
	});

	return features;
}

/**
 * Create empty attack data for fallback cases
 */
export function createEmptyAttackData(weaponName?: string): any {
	return {
		id: '',
		weaponName: weaponName || 'unknown',
		name: weaponName || 'Unknown Weapon',
		attackBonus: 0,
		damage: '0 B',
		damageType: 'bludgeoning',
		critRange: '20',
		critDamage: '0 B',
		brutalDamage: '0 B',
		heavyHitEffect: ''
	};
}
````

## File: src/routes/api/character/progress/_backup_merge_stages_20250621/stageA+server.ts
````typescript
import { json, error } from '@sveltejs/kit';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Constants for validation (should ideally be shared or sourced from rules data)
const ATTRIBUTE_MIN = -2;
const ATTRIBUTE_MAX_L1 = 3;
const POINT_BUY_BUDGET = 12;

export async function POST({ request }) {
	try {
		const {
			characterId,
			finalName,
			attribute_might,
			attribute_agility,
			attribute_charisma,
			attribute_intelligence
		} = await request.json();

		// Backend Validation
		if (!finalName || typeof finalName !== 'string' || finalName.trim().length === 0) {
			return error(400, { message: 'Character name is required.' });
		}
		// Optional: Add length constraints or character restrictions for finalName

		const attributes = {
			might: attribute_might,
			agility: attribute_agility,
			charisma: attribute_charisma,
			intelligence: attribute_intelligence
		};

		// Validate attribute ranges
		for (const [name, value] of Object.entries(attributes)) {
			if (value < ATTRIBUTE_MIN || value > ATTRIBUTE_MAX_L1) {
				return error(400, { message: `Attribute ${name} is out of the allowed range (-2 to +3).` });
			}
		}

		// Validate total points spent
		const pointsSpent =
			attributes.might -
			ATTRIBUTE_MIN +
			(attributes.agility - ATTRIBUTE_MIN) +
			(attributes.charisma - ATTRIBUTE_MIN) +
			(attributes.intelligence - ATTRIBUTE_MIN);

		if (pointsSpent !== POINT_BUY_BUDGET) {
			return error(400, {
				message: `Total points allocated must be exactly ${POINT_BUY_BUDGET}. You allocated ${pointsSpent}.`
			});
		}

		let updatedCharacter;

		if (characterId) {
			// Update existing character progress
			updatedCharacter = await prisma.characterInProgress.update({
				where: { id: characterId },
				data: {
					finalName: finalName.trim(), // Save character name
					attribute_might,
					attribute_agility,
					attribute_charisma,
					attribute_intelligence,
					pointsSpent, // Store points spent for consistency, though backend validates
					level: 1, // Hardcoded to 1 for MVP
					combatMastery: 1, // Calculated as half level rounded up (1 for Level 1)
					selectedTraitIds: JSON.stringify([]), // Initialize selected traits for Stage B
					selectedFeatureChoices: JSON.stringify([]), // Initialize selected feature choices
					currentStep: 1 // Mark Stage A as complete
				}
			});
		} else {
			// Create new character progress (handles TD-002 for the first save)
			updatedCharacter = await prisma.characterInProgress.create({
				data: {
					finalName: finalName.trim(), // Save character name
					attribute_might,
					attribute_agility,
					attribute_charisma,
					attribute_intelligence,
					pointsSpent,
					level: 1, // Hardcoded to 1 for MVP
					combatMastery: 1, // Calculated as half level rounded up (1 for Level 1)
					selectedTraitIds: JSON.stringify([]), // Initialize selected traits for Stage B
					selectedFeatureChoices: JSON.stringify([]), // Initialize selected feature choices
					currentStep: 1 // Mark Stage A as complete
				}
			});
			// Note: The frontend will need to update its store with this new ID
		}

		// Return success response with the character ID
		return json({ success: true, characterId: updatedCharacter.id });
	} catch (e) {
		console.error('Backend error saving Stage A data:', e);
		// Handle Prisma errors or other exceptions
		if (e instanceof Error) {
			return error(500, { message: `Internal server error: ${e.message}` });
		}
		return error(500, { message: 'An unknown error occurred while saving attributes.' });
	} finally {
		await prisma.$disconnect();
	}
}
````

## File: src/routes/api/character/progress/_backup_merge_stages_20250621/stageB+server.ts
````typescript
import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { PrismaClient } from '@prisma/client';
import type { ITrait } from '$lib/rulesdata/types'; // Import ITrait type
import { ancestriesData as ancestries } from '$lib/rulesdata/ancestries';
import { traitsData as traits } from '$lib/rulesdata/traits';

const prisma = new PrismaClient();

export const POST: RequestHandler = async ({ request }) => {
	const data = await request.json();

	// Assuming data contains:
	// characterId: string;
	// selectedAncestries: string[]; // Array of ancestry IDs (max 2)
	// selectedTraits: string[]; // Array of trait IDs
	// attributes: { [key: string]: number }; // Attributes after potential reallocation

	// 1. Validate characterId exists and corresponds to an in-progress character
	if (!data.characterId) {
		return json({ success: false, message: 'Character ID is required.' }, { status: 400 });
	}

	// 2. Validate selected ancestries (max 2)
	if (
		!Array.isArray(data.selectedAncestries) ||
		data.selectedAncestries.length === 0 ||
		data.selectedAncestries.length > 2
	) {
		return json(
			{ success: false, message: 'You must select between 1 and 2 ancestries.' },
			{ status: 400 }
		);
	}
	// Validate ancestry IDs
	for (const ancestryId of data.selectedAncestries) {
		const validAncestry = ancestries.find((a) => a.id === ancestryId);
		if (!validAncestry) {
			return json(
				{ success: false, message: `Invalid ancestry ID: ${ancestryId}` },
				{ status: 400 }
			);
		}
	}

	// 3. Validate selected traits
	if (!Array.isArray(data.selectedTraits)) {
		return json({ success: false, message: 'Selected traits data is invalid.' }, { status: 400 });
	}
	// Validate trait IDs and rules
	if (data.selectedTraits.length > 0) {
		// Validate trait IDs exist
		for (const traitId of data.selectedTraits) {
			const validTrait = traits.find((t) => t.id === traitId);
			if (!validTrait) {
				return json({ success: false, message: `Invalid trait ID: ${traitId}` }, { status: 400 });
			}
		}

		// Get full trait objects
		const selectedTraitObjects: ITrait[] = data.selectedTraits
			.map((id: string) => traits.find((t) => t.id === id))
			.filter((t: ITrait | undefined): t is ITrait => t !== undefined);

		// Validate ancestry points budget
		const totalCost = selectedTraitObjects.reduce(
			(sum: number, trait: ITrait) => sum + trait.cost,
			0
		);
		if (totalCost !== 5) {
			return json(
				{ success: false, message: `Total ancestry points must equal 5, got: ${totalCost}` },
				{ status: 400 }
			);
		}

		// Validate minor trait limit
		const minorTraits = selectedTraitObjects.filter((t: ITrait) => t.isMinor);
		if (minorTraits.length > 1) {
			return json(
				{ success: false, message: `Maximum of 1 minor trait allowed, got: ${minorTraits.length}` },
				{ status: 400 }
			);
		}

		// Validate negative trait point gain limit
		const pointsFromNegative = selectedTraitObjects
			.filter((t: ITrait) => t.cost < 0)
			.reduce((sum: number, t: ITrait) => sum + Math.abs(t.cost), 0);
		if (pointsFromNegative > 2) {
			return json(
				{
					success: false,
					message: `Maximum of +2 points from negative traits allowed, got: ${pointsFromNegative}`
				},
				{ status: 400 }
			);
		}
	}

	// 4. Validate attribute values after trait bonuses (within -2 and +3)
	// Assuming data.attributes is an object like { attribute_might: 1, ... }
	if (!data.attributes || typeof data.attributes !== 'object') {
		return json(
			{ success: false, message: 'Attribute data is missing or invalid.' },
			{ status: 400 }
		);
	}
	// Corrected attribute name to match schema
	const attributeNames = [
		'attribute_might',
		'attribute_agility',
		'attribute_charisma',
		'attribute_intelligence'
	];
	for (const attrName of attributeNames) {
		const attrValue = data.attributes[attrName];
		if (typeof attrValue !== 'number' || attrValue < -2 || attrValue > 3) {
			return json(
				{
					success: false,
					message: `Invalid value for attribute ${attrName}: ${attrValue}. Must be between -2 and +3.`
				},
				{ status: 400 }
			);
		}
	}

	// 5. Validate total attribute points (should still be 12 from Stage A base -2)
	// This check assumes the attributes passed in `data.attributes` are the final values after reallocation.
	// The base value for each attribute is -2, so 4 attributes have a base total of -8.
	// The total points allocated in Stage A is 20 (from 12 points + 8 base).
	// If attributes were reallocated in the helper panel, the sum should still reflect the original points + base.
	// Sum of (attributeValue - baseValue) should equal total points allocated.
	const baseAttributeValue = -2;
	const expectedTotalPoints = 12; // Total points allocated in Stage A
	const actualTotalPoints = attributeNames.reduce(
		(sum, attrName) => sum + (data.attributes[attrName] - baseAttributeValue),
		0
	);

	if (actualTotalPoints !== expectedTotalPoints) {
		return json(
			{
				success: false,
				message: `Total attribute points mismatch. Expected ${expectedTotalPoints}, got ${actualTotalPoints}.`
			},
			{ status: 400 }
		);
	}

	try {
		// Fetch the existing character to ensure it's in the correct state (Stage A complete)
		const character = await prisma.characterInProgress.findUnique({
			where: { id: data.characterId },
			select: {
				currentStep: true
				// Select other fields if needed for validation against previous stage data
			}
		});

		if (!character) {
			return json({ success: false, message: 'Character not found.' }, { status: 404 });
		}

		// Optional: Validate that the character is currently at the correct step (Stage A complete)
		// if (character.currentStep !== 1) { // Check against integer 1 for Stage A
		//      return json({ success: false, message: `Character is not in the correct stage. Current stage: ${character.currentStep}` }, { status: 400 });
		// }

		// Update the CharacterInProgress table with Stage B data
		const updatedCharacter = await prisma.characterInProgress.update({
			where: { id: data.characterId },
			data: {
				ancestry1Id: data.selectedAncestries[0] || null, // Store first ancestry ID
				ancestry2Id: data.selectedAncestries[1] || null, // Store second ancestry ID (if exists)
				selectedTraitIds: JSON.stringify(data.selectedTraits), // Store trait IDs as JSON string
				// Update attributes if they were potentially modified in the helper panel
				attribute_might: data.attributes.attribute_might,
				attribute_agility: data.attributes.attribute_agility,
				attribute_charisma: data.attributes.attribute_charisma,
				attribute_intelligence: data.attributes.attribute_intelligence, // Corrected attribute name
				currentStep: 2 // Mark Stage B as complete (using integer 2)
			}
		});

		// Return success response
		return json({ success: true, character: updatedCharacter });
	} catch (error) {
		console.error('Error processing Stage B data:', error);
		// Return appropriate error response
		return json({ success: false, message: 'Failed to save Stage B data.' }, { status: 500 });
	}
};

// TODO: Consider implementing a GET handler to fetch existing Stage B data if needed for resuming progress
// export const GET: RequestHandler = async ({ url }) => {
//     const characterId = url.searchParams.get('characterId');
//     if (!characterId) {
//         return json({ success: false, message: 'Character ID is required.' }, { status: 400 });
//     }
//     try {
//         const character = await prisma.characterInProgress.findUnique({
//             where: { id: characterId },
//             select: {
//                 selectedAncestries: true,
//                 selectedTraits: true,
//                 // Select other relevant fields
//             },
//         });
//         if (!character) {
//             return json({ success: false, message: 'Character not found.' }, { status: 404 });
//         }
//         return json({ success: true, character });
//     } catch (error) {
//         console.error('Error fetching Stage B data:', error);
//         return json({ success: false, message: 'Failed to fetch Stage B data.' }, { status: 500 });
//     }
// };
````

## File: src/routes/character-creation/components/TraitChoiceSelector.tsx
````typescript
/**
 * Trait Choice Selector Component
 * 
 * This component handles user choices for traits that require input,
 * such as Human Attribute Increase or Skill Expertise.
 */

import React from 'react';
import styled from '@emotion/styled';
import { useCharacter } from '../../../lib/stores/characterContext';
import { useEnhancedCharacterCalculation } from '../../../lib/hooks/useEnhancedCharacterCalculation';
import { attributesData } from '../../../lib/rulesdata/attributes';
import { skillsData } from '../../../lib/rulesdata/skills';
import { tradesData } from '../../../lib/rulesdata/trades';
import type { ITrait, ITraitEffect } from '../../../lib/rulesdata/types';

// Styled components
const ChoiceContainer = styled.div`
  margin-top: 1rem;
  padding: 1rem;
  background-color: #f8fafc;
  border: 1px solid #e2e8f0;
  border-radius: 8px;
  border-left: 4px solid #3b82f6;
`;

const ChoiceTitle = styled.h4`
  margin: 0 0 0.75rem 0;
  color: #1e40af;
  font-size: 0.9rem;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  
  &:before {
    content: '🎯';
    font-size: 1rem;
  }
`;

const ChoiceGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: 0.75rem;
  margin-top: 0.75rem;
`;

const ChoiceButton = styled.button<{ $selected: boolean; $invalid: boolean }>`
  padding: 0.75rem;
  border: 2px solid ${props => 
    props.$invalid ? '#ef4444' : 
    props.$selected ? '#3b82f6' : '#d1d5db'
  };
  border-radius: 8px;
  background-color: ${props => 
    props.$invalid ? '#fef2f2' :
    props.$selected ? '#dbeafe' : '#ffffff'
  };
  color: ${props => 
    props.$invalid ? '#dc2626' :
    props.$selected ? '#1e40af' : '#374151'
  };
  font-size: 0.875rem;
  font-weight: 500;
  cursor: ${props => props.$invalid ? 'not-allowed' : 'pointer'};
  opacity: ${props => props.$invalid ? 0.6 : 1};
  transition: all 0.2s ease;
  text-align: left;
  position: relative;

  &:hover:not(:disabled) {
    transform: ${props => props.$invalid ? 'none' : 'translateY(-1px)'};
    box-shadow: ${props => props.$invalid ? 'none' : '0 4px 8px rgba(0, 0, 0, 0.1)'};
    border-color: ${props => props.$invalid ? '#ef4444' : '#3b82f6'};
  }
  
  &:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }
`;

const ChoiceButtonTitle = styled.div`
  font-weight: 600;
  margin-bottom: 0.25rem;
`;

const ChoiceButtonSubtitle = styled.div`
  font-size: 0.75rem;
  opacity: 0.7;
  line-height: 1.3;
`;

const ValidationMessage = styled.div`
  color: #dc2626;
  font-size: 0.75rem;
  margin-top: 0.5rem;
  padding: 0.5rem;
  background-color: #fef2f2;
  border: 1px solid #fecaca;
  border-radius: 4px;
  font-style: italic;
`;

const PreviewBox = styled.div`
  margin-top: 0.75rem;
  padding: 0.75rem;
  background-color: #f0f9ff;
  border: 1px solid #bae6fd;
  border-radius: 6px;
  font-size: 0.875rem;
  
  &:before {
    content: '✅ ';
    color: #059669;
    font-weight: bold;
  }
`;

const ClearButton = styled.button`
  margin-top: 0.5rem;
  padding: 0.5rem 1rem;
  background-color: #6b7280;
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 0.75rem;
  cursor: pointer;
  transition: background-color 0.2s ease;
  
  &:hover {
    background-color: #4b5563;
  }
`;

interface TraitChoiceSelectorProps {
  trait: ITrait;
  effect: ITraitEffect;
  effectIndex: number;
}

const TraitChoiceSelector: React.FC<TraitChoiceSelectorProps> = ({
  trait,
  effect,
  effectIndex
}) => {
  const { state, dispatch } = useCharacter();
  const { 
    validateTraitChoice, 
    getEffectPreview,
    calculationResult 
  } = useEnhancedCharacterCalculation();
  
  // Get current choice from state
  const currentChoices = JSON.parse(state.selectedTraitChoices || '{}');
  const choiceKey = `${trait.id}-${effectIndex}`;
  const currentChoice = currentChoices[choiceKey] || '';
  
  // Handle choice selection
  const handleChoiceChange = (choice: string) => {
    dispatch({
      type: 'UPDATE_TRAIT_CHOICE',
      traitId: trait.id,
      effectIndex,
      choice: currentChoice === choice ? '' : choice // Toggle selection
    });
  };
  
  // Get options for this effect type
  const getOptions = () => {
    if (effect.userChoiceRequired?.options) {
      return effect.userChoiceRequired.options.map(option => ({
        value: option,
        displayName: option,
        description: ''
      }));
    }
    
    switch (effect.type) {
      case 'MODIFY_ATTRIBUTE':
        return attributesData.map(attr => ({
          value: attr.id,
          displayName: attr.name,
          description: attr.description
        }));
        
      case 'GRANT_SKILL_EXPERTISE':
        return skillsData.map(skill => ({
          value: skill.id,
          displayName: skill.name,
          description: `${skill.attributeAssociation.toUpperCase()} - ${skill.description}`
        }));
        
      case 'GRANT_TRADE_EXPERTISE':
        return tradesData.map(trade => ({
          value: trade.id,
          displayName: trade.name,
          description: `${trade.attributeAssociation.toUpperCase()} - ${trade.description}`
        }));
        
      default:
        return [];
    }
  };
  
  const options = getOptions();
  const prompt = effect.userChoiceRequired?.prompt || `Choose option for ${trait.name}`;
  
  // Get preview for current choice
  const preview = currentChoice ? getEffectPreview(trait.id, effectIndex, currentChoice) : undefined;
  
  return (
    <ChoiceContainer>
      <ChoiceTitle>{prompt}</ChoiceTitle>
      
      <ChoiceGrid>
        {options.map(option => {
          const validation = validateTraitChoice(trait.id, effectIndex, option.value);
          const isSelected = currentChoice === option.value;
          const isInvalid = !validation.isValid && !isSelected;
          
          return (
            <div key={option.value}>
              <ChoiceButton
                $selected={isSelected}
                $invalid={isInvalid}
                onClick={() => {
                  if (validation.isValid || isSelected) {
                    handleChoiceChange(option.value);
                  }
                }}
                disabled={isInvalid}
              >
                <ChoiceButtonTitle>{option.displayName}</ChoiceButtonTitle>
                {option.description && (
                  <ChoiceButtonSubtitle>{option.description}</ChoiceButtonSubtitle>
                )}
              </ChoiceButton>
              
              {isInvalid && validation.message && (
                <ValidationMessage>
                  ⚠️ {validation.message}
                </ValidationMessage>
              )}
            </div>
          );
        })}
      </ChoiceGrid>
      
      {/* Show preview of the selected choice */}
      {preview && (
        <PreviewBox>
          <strong>Preview:</strong> {preview.description}
        </PreviewBox>
      )}
      
      {/* Clear selection button */}
      {currentChoice && (
        <ClearButton onClick={() => handleChoiceChange('')}>
          Clear Selection
        </ClearButton>
      )}
    </ChoiceContainer>
  );
};

export default TraitChoiceSelector;
````

## File: src/routes/character-sheet/components/AttributesSections.tsx
````typescript
import React from 'react';
import type { SkillData, TradeData, LanguageData, CharacterSheetData } from '../../../types';
import {
	StyledAttributesSectionsContainer,
	StyledPrimeSection,
	StyledPrimeBox,
	StyledPrimeLabel,
	StyledPrimeValue,
	StyledSkillRow,
	StyledSkillName,
	StyledAttributeSection,
	StyledAttributeHeader,
	StyledAttributeBox,
	StyledAttributeAbbr,
	StyledAttributeValue,
	StyledAttributeInfo,
	StyledAttributeName,
	StyledAttributeSave,
	StyledAttributeSkillRow,
	StyledKnowledgeTradesSection,
	StyledSectionTitle,
	StyledSectionSubtitle,
	StyledLanguageRow,
	StyledLanguageName,
	StyledFluencyControls,
	StyledFluencyBox,
	StyledFluencyLabel,
	StyledNoItemsMessage
} from '../styles/AttributesSections.styles';
import { StyledProficiencyDots, StyledDot } from '../styles/Skills';

interface SkillsByAttribute {
	prime: SkillData[];
	might: SkillData[];
	agility: SkillData[];
	charisma: SkillData[];
	intelligence: SkillData[];
}

interface AttributesSectionsProps {
	characterData: CharacterSheetData;
	skillsByAttribute: SkillsByAttribute;
	knowledge: TradeData[];
	trades: TradeData[];
	languages: LanguageData[];
}

const AttributesSections: React.FC<AttributesSectionsProps> = ({
	characterData,
	skillsByAttribute,
	knowledge,
	trades,
	languages
}) => {
	return (
		<StyledAttributesSectionsContainer>
			{/* Prime Modifier & Awareness */}
			<StyledPrimeSection>
				<StyledPrimeBox>
					<StyledPrimeLabel>Prime</StyledPrimeLabel>
					<StyledPrimeValue>
						{characterData.finalPrimeModifierAttribute} +{characterData.finalPrimeModifierValue}
					</StyledPrimeValue>
				</StyledPrimeBox>

				{/* Awareness (Prime skill) */}
				{skillsByAttribute.prime.map((skill) => (
					<StyledSkillRow key={skill.id}>
						<StyledSkillName>{skill.name.toUpperCase()}</StyledSkillName>
						<StyledProficiencyDots>
							{[1, 2, 3, 4, 5].map((level) => (
								<StyledDot key={level} filled={level <= skill.proficiency} />
							))}
						</StyledProficiencyDots>
					</StyledSkillRow>
				))}
			</StyledPrimeSection>

			{/* Might Section */}
			<StyledAttributeSection>
				<StyledAttributeHeader>
					<StyledAttributeBox>
						<StyledAttributeAbbr>MIG</StyledAttributeAbbr>
						<StyledAttributeValue>{characterData.finalMight}</StyledAttributeValue>
					</StyledAttributeBox>
					<StyledAttributeInfo>
						<StyledAttributeName>MIGHT</StyledAttributeName>
						<StyledAttributeSave>SAVE +{characterData.finalSaveMight}</StyledAttributeSave>
					</StyledAttributeInfo>
				</StyledAttributeHeader>

				{/* Might Skills */}
				{skillsByAttribute.might.map((skill) => (
					<StyledAttributeSkillRow key={skill.id}>
						<StyledSkillName>{skill.name.toUpperCase()}</StyledSkillName>
						<StyledProficiencyDots>
							{[1, 2, 3, 4, 5].map((level) => (
								<StyledDot key={level} filled={level <= skill.proficiency} />
							))}
						</StyledProficiencyDots>
					</StyledAttributeSkillRow>
				))}
			</StyledAttributeSection>

			{/* Agility Section */}
			<StyledAttributeSection>
				<StyledAttributeHeader>
					<StyledAttributeBox>
						<StyledAttributeAbbr>AGI</StyledAttributeAbbr>
						<StyledAttributeValue>{characterData.finalAgility}</StyledAttributeValue>
					</StyledAttributeBox>
					<StyledAttributeInfo>
						<StyledAttributeName>AGILITY</StyledAttributeName>
						<StyledAttributeSave>SAVE +{characterData.finalSaveAgility}</StyledAttributeSave>
					</StyledAttributeInfo>
				</StyledAttributeHeader>

				{/* Agility Skills */}
				{skillsByAttribute.agility.map((skill) => (
					<StyledAttributeSkillRow key={skill.id}>
						<StyledSkillName>{skill.name.toUpperCase()}</StyledSkillName>
						<StyledProficiencyDots>
							{[1, 2, 3, 4, 5].map((level) => (
								<StyledDot key={level} filled={level <= skill.proficiency} />
							))}
						</StyledProficiencyDots>
					</StyledAttributeSkillRow>
				))}
			</StyledAttributeSection>

			{/* Charisma Section */}
			<StyledAttributeSection>
				<StyledAttributeHeader>
					<StyledAttributeBox>
						<StyledAttributeAbbr>CHA</StyledAttributeAbbr>
						<StyledAttributeValue>{characterData.finalCharisma}</StyledAttributeValue>
					</StyledAttributeBox>
					<StyledAttributeInfo>
						<StyledAttributeName>CHARISMA</StyledAttributeName>
						<StyledAttributeSave>SAVE +{characterData.finalSaveCharisma}</StyledAttributeSave>
					</StyledAttributeInfo>
				</StyledAttributeHeader>

				{/* Charisma Skills */}
				{skillsByAttribute.charisma.map((skill) => (
					<StyledAttributeSkillRow key={skill.id}>
						<StyledSkillName>{skill.name.toUpperCase()}</StyledSkillName>
						<StyledProficiencyDots>
							{[1, 2, 3, 4, 5].map((level) => (
								<StyledDot key={level} filled={level <= skill.proficiency} />
							))}
						</StyledProficiencyDots>
					</StyledAttributeSkillRow>
				))}
			</StyledAttributeSection>

			{/* Intelligence Section */}
			<StyledAttributeSection>
				<StyledAttributeHeader>
					<StyledAttributeBox>
						<StyledAttributeAbbr>INT</StyledAttributeAbbr>
						<StyledAttributeValue>{characterData.finalIntelligence}</StyledAttributeValue>
					</StyledAttributeBox>
					<StyledAttributeInfo>
						<StyledAttributeName>INTELLIGENCE</StyledAttributeName>
						<StyledAttributeSave>SAVE +{characterData.finalSaveIntelligence}</StyledAttributeSave>
					</StyledAttributeInfo>
				</StyledAttributeHeader>

				{/* Intelligence Skills */}
				{skillsByAttribute.intelligence.map((skill) => (
					<StyledAttributeSkillRow key={skill.id}>
						<StyledSkillName>{skill.name.toUpperCase()}</StyledSkillName>
						<StyledProficiencyDots>
							{[1, 2, 3, 4, 5].map((level) => (
								<StyledDot key={level} filled={level <= skill.proficiency} />
							))}
						</StyledProficiencyDots>
					</StyledAttributeSkillRow>
				))}
			</StyledAttributeSection>

			{/* Knowledge Section */}
			<StyledKnowledgeTradesSection>
				<StyledSectionTitle>KNOWLEDGE</StyledSectionTitle>
				<StyledSectionSubtitle>Intelligence-based knowledge trades</StyledSectionSubtitle>
				{knowledge.map((knowledgeItem) => (
					<StyledAttributeSkillRow key={knowledgeItem.id}>
						<StyledSkillName>{knowledgeItem.name.toUpperCase()}</StyledSkillName>
						<StyledProficiencyDots>
							{[1, 2, 3, 4, 5].map((level) => (
								<StyledDot key={level} filled={level <= knowledgeItem.proficiency} />
							))}
						</StyledProficiencyDots>
					</StyledAttributeSkillRow>
				))}
			</StyledKnowledgeTradesSection>

			{/* Trades Section */}
			<StyledKnowledgeTradesSection>
				<StyledSectionTitle>TRADES</StyledSectionTitle>
				<StyledSectionSubtitle>Selected practical trades & crafts</StyledSectionSubtitle>
				{trades.length > 0 ? (
					trades.map((trade) => (
						<StyledAttributeSkillRow key={trade.id}>
							<StyledSkillName>{trade.name.toUpperCase()}</StyledSkillName>
							<StyledProficiencyDots>
								{[1, 2, 3, 4, 5].map((level) => (
									<StyledDot key={level} filled={level <= trade.proficiency} />
								))}
							</StyledProficiencyDots>
						</StyledAttributeSkillRow>
					))
				) : (
					<StyledNoItemsMessage>No trades selected</StyledNoItemsMessage>
				)}
			</StyledKnowledgeTradesSection>

			{/* Languages Section */}
			<StyledKnowledgeTradesSection>
				<StyledSectionTitle>LANGUAGES</StyledSectionTitle>
				<StyledSectionSubtitle>
					LANGUAGE CHECK = d20 + Intelligence or Charisma
				</StyledSectionSubtitle>
				{languages.map((language) => (
					<StyledLanguageRow key={language.id}>
						<StyledLanguageName>{language.name.toUpperCase()}</StyledLanguageName>
						<StyledFluencyControls>
							<StyledFluencyBox active={language.fluency === 'limited'} />
							<StyledFluencyLabel>LIMITED</StyledFluencyLabel>
							<StyledFluencyBox active={language.fluency === 'fluent'} />
							<StyledFluencyLabel>FLUENT</StyledFluencyLabel>
						</StyledFluencyControls>
					</StyledLanguageRow>
				))}
			</StyledKnowledgeTradesSection>
		</StyledAttributesSectionsContainer>
	);
};

export default AttributesSections;
````

## File: src/routes/character-sheet/components/DefenseChangeModal.tsx
````typescript
import React, { useState } from 'react';
import styled from 'styled-components';

const ModalOverlay = styled.div`
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background: rgba(0, 0, 0, 0.5);
	display: flex;
	align-items: center;
	justify-content: center;
	z-index: 1000;
`;

const ModalContent = styled.div`
	background: white;
	border: 3px solid #8b4513;
	border-radius: 8px;
	padding: 2rem;
	max-width: 500px;
	width: 90%;
	max-height: 90vh;
	overflow-y: auto;
`;

const ModalTitle = styled.h3`
	color: #8b4513;
	font-size: 1.25rem;
	font-weight: bold;
	margin: 0 0 1rem 0;
	text-align: center;
`;

const ChangeInfo = styled.div`
	background: #f9f9f9;
	border: 1px solid #8b4513;
	border-radius: 4px;
	padding: 1rem;
	margin-bottom: 1rem;
	font-size: 0.9rem;
	color: #2d2d2d;
`;

const Label = styled.label`
	display: block;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.5rem;
`;

const TextArea = styled.textarea`
	width: 100%;
	min-height: 100px;
	padding: 0.75rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	font-family: 'Georgia', serif;
	font-size: 0.9rem;
	color: #2d2d2d;
	resize: vertical;

	&:focus {
		outline: none;
		border-color: #8b4513;
		box-shadow: 0 0 0 1px #8b4513;
	}
`;

const ButtonGroup = styled.div`
	display: flex;
	gap: 0.75rem;
	justify-content: flex-end;
	margin-top: 1.5rem;
`;

const Button = styled.button<{ variant?: 'primary' | 'secondary' }>`
	padding: 0.5rem 1rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	font-weight: bold;
	cursor: pointer;
	transition: all 0.2s ease;

	${(props) =>
		props.variant === 'primary'
			? `
		background: #8b4513;
		color: white;
		
		&:hover {
			background-color: #6d3410;
		}
	`
			: `
		background: #f9f9f9;
		color: #8b4513;
		
		&:hover {
			background: #8b4513;
			color: white;
		}
	`}

	&:disabled {
		opacity: 0.5;
		cursor: not-allowed;
	}
`;

interface DefenseChangeModalProps {
	isOpen: boolean;
	defenseType: string;
	oldValue: number;
	newValue: number;
	onConfirm: (reason: string) => void;
	onCancel: () => void;
}

const DefenseChangeModal: React.FC<DefenseChangeModalProps> = ({
	isOpen,
	defenseType,
	oldValue,
	newValue,
	onConfirm,
	onCancel
}) => {
	const [reason, setReason] = useState('');

	if (!isOpen) return null;

	const handleSubmit = () => {
		if (reason.trim()) {
			onConfirm(reason.trim());
			setReason('');
		}
	};

	const handleCancel = () => {
		onCancel();
		setReason('');
	};

	const handleKeyDown = (e: React.KeyboardEvent) => {
		if (e.key === 'Escape') {
			handleCancel();
		} else if (e.key === 'Enter' && e.ctrlKey && reason.trim()) {
			handleSubmit();
		}
	};

	return (
		<ModalOverlay onClick={handleCancel} onKeyDown={handleKeyDown}>
			<ModalContent onClick={(e) => e.stopPropagation()}>
				<ModalTitle>Defense Change Reason</ModalTitle>

				<ChangeInfo>
					<strong>{defenseType}</strong> changed from <strong>{oldValue}</strong> to{' '}
					<strong>{newValue}</strong>
				</ChangeInfo>

				<Label htmlFor="reason">
					Why are you changing this defense value?
					<span style={{ fontSize: '0.8rem', fontWeight: 'normal', color: '#666' }}>
						{' '}
						(e.g., "Equipped +2 Shield", "Cast Shield spell", "Monk stance bonus")
					</span>
				</Label>

				<TextArea
					id="reason"
					value={reason}
					onChange={(e) => setReason(e.target.value)}
					placeholder="Enter the reason for this defense change..."
					autoFocus
				/>

				<ButtonGroup>
					<Button variant="secondary" onClick={handleCancel}>
						Cancel
					</Button>
					<Button variant="primary" onClick={handleSubmit} disabled={!reason.trim()}>
						Save Change
					</Button>
				</ButtonGroup>

				<div
					style={{
						fontSize: '0.8rem',
						color: '#666',
						marginTop: '0.5rem',
						textAlign: 'center'
					}}
				>
					Press Ctrl+Enter to save, Esc to cancel
				</div>
			</ModalContent>
		</ModalOverlay>
	);
};

export default DefenseChangeModal;
````

## File: src/routes/character-sheet/components/DiceRoller.tsx
````typescript
import React, { useState } from 'react';
import { StyledDiceRollerContainer } from '../styles/DiceRoller';
import {
	StyledDiceContainer,
	StyledDiceIcon,
	StyledDiceControls,
	StyledModeButton,
	StyledAddDiceSection,
	StyledDiceTypeButton,
	StyledRollButton,
	StyledResultsDisplay,
	StyledDiceResult,
	StyledTotalResult,
	StyledDiceHistory,
	StyledCollapseButton,
	StyledDiceList,
	StyledDiceItem,
	StyledRemoveDiceButton
} from '../styles/DiceRoller';

type DiceType = 'd4' | 'd6' | 'd8' | 'd10' | 'd12' | 'd20';
type RollMode = 'normal' | 'advantage' | 'disadvantage' | 'no-d20';

interface DiceRollResult {
	type: DiceType;
	value: number;
	isMax: boolean;
	isMin: boolean;
	id: string;
	isChosen?: boolean; // For advantage/disadvantage tracking
	isCriticalSuccess?: boolean;
	isCriticalFail?: boolean;
}

interface AdditionalDice {
	type: DiceType;
	count: number;
}

interface DiceRollerProps {
	onRoll?: (results: DiceRollResult[], total: number, rollMode: RollMode) => void;
}

const DiceRoller: React.FC<DiceRollerProps> = ({ onRoll }) => {
	const [rollMode, setRollMode] = useState<RollMode>('normal');
	const [advantageCount, setAdvantageCount] = useState<number>(2);
	const [disadvantageCount, setDisadvantageCount] = useState<number>(2);
	const [additionalDice, setAdditionalDice] = useState<AdditionalDice[]>([]);
	const [isRolling, setIsRolling] = useState(false);
	const [lastResults, setLastResults] = useState<DiceRollResult[]>([]);
	const [total, setTotal] = useState<number | null>(null);
	const [isExpanded, setIsExpanded] = useState(false);
	const [rollHistory, setRollHistory] = useState<{ results: DiceRollResult[]; total: number; mode: RollMode; timestamp: Date }[]>([]);

	const rollDice = (sides: number): number => {
		return Math.floor(Math.random() * sides) + 1;
	};

	const getDiceMax = (type: DiceType): number => {
		const sideMap: Record<DiceType, number> = {
			'd4': 4,
			'd6': 6,
			'd8': 8,
			'd10': 10,
			'd12': 12,
			'd20': 20
		};
		return sideMap[type];
	};

	const getDiceIcon = (type: DiceType): string => {
		// Using dice symbols
		const iconMap: Record<DiceType, string> = {
			'd4': '⚃',
			'd6': '⚅',
			'd8': '🎲',
			'd10': '🎯',
			'd12': '⭐',
			'd20': '🔥'
		};
		return iconMap[type];
	};

	const addDice = (type: DiceType) => {
		setAdditionalDice(prev => {
			const existing = prev.find(d => d.type === type);
			if (existing) {
				return prev.map(d => 
					d.type === type ? { ...d, count: d.count + 1 } : d
				);
			} else {
				return [...prev, { type, count: 1 }];
			}
		});
	};

	const removeDice = (type: DiceType) => {
		setAdditionalDice(prev => {
			const existing = prev.find(d => d.type === type);
			if (existing && existing.count > 1) {
				return prev.map(d => 
					d.type === type ? { ...d, count: d.count - 1 } : d
				);
			} else {
				return prev.filter(d => d.type !== type);
			}
		});
	};

	const handleRoll = async () => {
		if (isRolling) return;

		setIsRolling(true);
		
		// Simulate rolling animation duration
		await new Promise(resolve => setTimeout(resolve, 1200));
		
		const results: DiceRollResult[] = [];

		// Only roll D20 if not in 'no-d20' mode
		if (rollMode !== 'no-d20') {
			// Roll main d20(s)
			const d20Results: number[] = [];
			let rollCount = 1;
			
			// Determine how many D20s to roll based on mode
			if (rollMode === 'advantage') {
				rollCount = advantageCount;
			} else if (rollMode === 'disadvantage') {
				rollCount = disadvantageCount;
			}
			
			for (let i = 0; i < rollCount; i++) {
				d20Results.push(rollDice(20));
			}

			if (rollMode === 'normal') {
				// Single D20 roll
				const value = d20Results[0];
				results.push({
					type: 'd20',
					value,
					isMax: value === 20,
					isMin: value === 1,
					isCriticalSuccess: value === 20,
					isCriticalFail: value === 1,
					isChosen: true,
					id: `d20-main-${Date.now()}`
				});
			} else {
				// Advantage/Disadvantage - show all dice, choose best/worst
				const chosenValue = rollMode === 'advantage' ? Math.max(...d20Results) : Math.min(...d20Results);
				
				d20Results.forEach((value, index) => {
					const isChosen = value === chosenValue && (index === d20Results.indexOf(chosenValue));
					results.push({
						type: 'd20',
						value,
						isMax: value === 20,
						isMin: value === 1,
						isCriticalSuccess: value === 20 && isChosen,
						isCriticalFail: value === 1 && isChosen,
						isChosen,
						id: `d20-${rollMode}-${index}-${Date.now()}`
					});
				});
			}
		}

		// Roll additional dice
		additionalDice.forEach(({ type, count }) => {
			const maxValue = getDiceMax(type);
			for (let i = 0; i < count; i++) {
				const value = rollDice(maxValue);
				results.push({
					type,
					value,
					isMax: value === maxValue,
					isMin: value === 1,
					id: `${type}-${i}-${Date.now()}`
				});
			}
		});

		const totalValue = results.reduce((sum, result) => {
			// For D20s in advantage/disadvantage, only count the chosen one
			if (result.type === 'd20' && (rollMode === 'advantage' || rollMode === 'disadvantage')) {
				return sum + (result.isChosen ? result.value : 0);
			}
			// For all other dice, count normally
			return sum + result.value;
		}, 0);

		setLastResults(results);
		setTotal(totalValue);
		setIsRolling(false);

		// Add to history
		setRollHistory(prev => [
			{ results, total: totalValue, mode: rollMode, timestamp: new Date() },
			...prev.slice(0, 9) // Keep last 10 rolls
		]);

		// Call callback if provided
		onRoll?.(results, totalValue, rollMode);
	};

	const clearDice = () => {
		setAdditionalDice([]);
	};

	return (
		<StyledDiceRollerContainer $isExpanded={isExpanded}>
			<StyledCollapseButton 
				onClick={() => setIsExpanded(!isExpanded)}
				$isExpanded={isExpanded}
			>
				🎲
			</StyledCollapseButton>

			{isExpanded && (
				<>
					{/* Roll Mode Controls */}
					<StyledDiceControls>
						<div className="section-label">
							Roll Mode
						</div>
						<div style={{ display: 'flex', gap: '0.25rem', flexWrap: 'wrap' }}>
							<StyledModeButton
								$active={rollMode === 'normal'}
								onClick={() => setRollMode('normal')}
							>
								Normal
							</StyledModeButton>
							<StyledModeButton
								$active={rollMode === 'advantage'}
								onClick={() => setRollMode('advantage')}
							>
								Advantage
							</StyledModeButton>
							<StyledModeButton
								$active={rollMode === 'disadvantage'}
								onClick={() => setRollMode('disadvantage')}
							>
								Disadvantage
							</StyledModeButton>
							<StyledModeButton
								$active={rollMode === 'no-d20'}
								onClick={() => setRollMode('no-d20')}
							>
								No D20
							</StyledModeButton>
						</div>
						
						{/* Advantage/Disadvantage Count Controls */}
						{(rollMode === 'advantage' || rollMode === 'disadvantage') && (
							<div style={{ 
								marginTop: '0.5rem',
								display: 'flex', 
								alignItems: 'center', 
								gap: '0.5rem',
								fontSize: '0.8rem',
								color: '#ffd700'
							}}>
								<span style={{ textShadow: '1px 1px 2px rgba(0, 0, 0, 0.8)' }}>
									{rollMode === 'advantage' ? 'Advantage' : 'Disadvantage'} Count:
								</span>
								<button
									onClick={() => {
										if (rollMode === 'advantage') {
											setAdvantageCount(Math.max(2, advantageCount - 1));
										} else {
											setDisadvantageCount(Math.max(2, disadvantageCount - 1));
										}
									}}
									style={{
										width: '20px',
										height: '20px',
										background: '#8b4513',
										color: 'white',
										border: '1px solid #654321',
										borderRadius: '3px',
										cursor: 'pointer',
										fontSize: '0.8rem',
										display: 'flex',
										alignItems: 'center',
										justifyContent: 'center'
									}}
								>
									−
								</button>
								<span style={{ 
									minWidth: '20px', 
									textAlign: 'center',
									fontWeight: 'bold',
									textShadow: '1px 1px 2px rgba(0, 0, 0, 0.8)'
								}}>
									{rollMode === 'advantage' ? advantageCount : disadvantageCount}
								</span>
								<button
									onClick={() => {
										if (rollMode === 'advantage') {
											setAdvantageCount(Math.min(4, advantageCount + 1));
										} else {
											setDisadvantageCount(Math.min(3, disadvantageCount + 1));
										}
									}}
									style={{
										width: '20px',
										height: '20px',
										background: '#8b4513',
										color: 'white',
										border: '1px solid #654321',
										borderRadius: '3px',
										cursor: 'pointer',
										fontSize: '0.8rem',
										display: 'flex',
										alignItems: 'center',
										justifyContent: 'center'
									}}
								>
									+
								</button>
								<span style={{ 
									fontSize: '0.7rem', 
									color: 'rgba(255, 255, 255, 0.8)',
									marginLeft: '0.25rem'
								}}>
									(Roll {rollMode === 'advantage' ? advantageCount : disadvantageCount} dice, take {rollMode === 'advantage' ? 'highest' : 'lowest'})
								</span>
							</div>
						)}
					</StyledDiceControls>

					{/* Additional Dice Section */}
					<StyledAddDiceSection>
						<div className="section-label">
							Add Dice
						</div>
						<div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '0.25rem', marginBottom: '0.5rem' }}>
							{(['d4', 'd6', 'd8', 'd10', 'd12'] as DiceType[]).map(type => (
								<StyledDiceTypeButton
									key={type}
									onClick={() => addDice(type)}
								>
									{type.toUpperCase()}
								</StyledDiceTypeButton>
							))}
						</div>
					</StyledAddDiceSection>

					{/* Current Dice Display */}
					{additionalDice.length > 0 && (
						<StyledDiceList>
							<div className="section-label">
								Current Dice
							</div>
							{additionalDice.map(({ type, count }) => (
								<StyledDiceItem key={type}>
									<span>{count}x {type.toUpperCase()}</span>
									<StyledRemoveDiceButton onClick={() => removeDice(type)}>
										×
									</StyledRemoveDiceButton>
								</StyledDiceItem>
							))}
							<button
								onClick={clearDice}
								style={{
									fontSize: '0.7rem',
									padding: '0.2rem 0.4rem',
									background: '#d32f2f',
									color: 'white',
									border: 'none',
									borderRadius: '3px',
									cursor: 'pointer',
									marginTop: '0.25rem'
								}}
							>
								Clear All
							</button>
						</StyledDiceList>
					)}

					{/* Main Dice Display */}
					<StyledDiceContainer>
						{rollMode !== 'no-d20' && (
							<>
								<StyledDiceIcon $isRolling={isRolling} $type="d20">
									{isRolling ? '🌪️' : '🔥'}
								</StyledDiceIcon>
								{rollMode !== 'normal' && (
									<div style={{ fontSize: '0.7rem', color: '#ffd700', textAlign: 'center', marginTop: '0.25rem', textShadow: '1px 1px 2px rgba(0, 0, 0, 0.8)' }}>
										{rollMode === 'advantage' && `${advantageCount}x ADVANTAGE`}
										{rollMode === 'disadvantage' && `${disadvantageCount}x DISADVANTAGE`}
									</div>
								)}
							</>
						)}
						{rollMode === 'no-d20' && additionalDice.length === 0 && (
							<div style={{ fontSize: '0.8rem', color: '#ffd700', textAlign: 'center', padding: '1rem', textShadow: '1px 1px 2px rgba(0, 0, 0, 0.8)' }}>
								Add dice to roll!
							</div>
						)}
						{additionalDice.map(({ type, count }) => (
							<div key={type} style={{ display: 'flex', alignItems: 'center', gap: '0.25rem', marginTop: '0.25rem' }}>
								{Array.from({ length: count }).map((_, index) => (
									<StyledDiceIcon key={index} $isRolling={isRolling} $type={type} $size="small">
										{isRolling ? '💫' : getDiceIcon(type)}
									</StyledDiceIcon>
								))}
							</div>
						))}
					</StyledDiceContainer>

					{/* Roll Button */}
					<StyledRollButton
						onClick={handleRoll}
						disabled={isRolling || (rollMode === 'no-d20' && additionalDice.length === 0)}
						$isRolling={isRolling}
					>
						{isRolling ? 'Rolling...' : 'ROLL DICE'}
					</StyledRollButton>

					{/* Results Display */}
					{total !== null && !isRolling && (
						<StyledResultsDisplay>
							<StyledTotalResult $isHighRoll={total >= 15}>
								Total: {total}
								{lastResults.some(r => r.isCriticalSuccess && r.isChosen !== false) && ' 🌟'}
								{lastResults.some(r => r.isCriticalFail && r.isChosen !== false) && ' 💀'}
							</StyledTotalResult>
							<div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.25rem', marginTop: '0.5rem' }}>
								{lastResults.map((result) => (
									<StyledDiceResult
										key={result.id}
										$isMax={result.isMax}
										$isMin={result.isMin}
										$isChosen={result.isChosen}
										$isCriticalSuccess={result.isCriticalSuccess}
										$isCriticalFail={result.isCriticalFail}
									>
										{result.type.toUpperCase()}: {result.value}
									</StyledDiceResult>
								))}
							</div>
						</StyledResultsDisplay>
					)}

					{/* Roll History */}
					{rollHistory.length > 0 && (
						<StyledDiceHistory>
							<div className="section-label">
								Recent Rolls
							</div>
							{rollHistory.slice(0, 3).map((roll, index) => (
								<div key={index} style={{ fontSize: '0.7rem', color: 'rgba(255, 255, 255, 0.9)', marginBottom: '0.1rem' }}>
									{roll.mode !== 'normal' && `${roll.mode} `}Total: {roll.total}
								</div>
							))}
						</StyledDiceHistory>
					)}
				</>
			)}
		</StyledDiceRollerContainer>
	);
};

export default DiceRoller;
````

## File: src/routes/character-sheet/components/EnhancedFeatures.tsx
````typescript
/**
 * Enhanced Features Display with Source Attribution
 * 
 * This component displays character abilities organized by type
 * with clear source attribution and categorization.
 */

import React from 'react';
import styled from '@emotion/styled';
import type { EnhancedCalculationResult } from '../../../lib/types/effectSystem';

// Styled components
const FeaturesContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
`;

const SectionHeader = styled.h3`
  margin: 0 0 1rem 0;
  color: #1f2937;
  font-size: 1.1rem;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding-bottom: 0.5rem;
  border-bottom: 2px solid #e5e7eb;
`;

const FeatureCard = styled.div`
  background-color: #ffffff;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  padding: 1rem;
  margin-bottom: 0.75rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  transition: all 0.2s ease;

  &:hover {
    border-color: #d1d5db;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }
`;

const FeatureHeader = styled.div`
  display: flex;
  justify-content: between;
  align-items: flex-start;
  margin-bottom: 0.5rem;
`;

const FeatureName = styled.h4`
  margin: 0;
  color: #1f2937;
  font-size: 1rem;
  font-weight: 600;
  flex: 1;
`;

const FeatureType = styled.span<{ $type: 'passive' | 'active' | 'resistance' | 'advantage' }>`
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-size: 0.75rem;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.025em;
  
  ${props => {
    switch (props.$type) {
      case 'passive':
        return `
          background-color: #dbeafe;
          color: #1e40af;
        `;
      case 'active':
        return `
          background-color: #dcfce7;
          color: #166534;
        `;
      case 'resistance':
        return `
          background-color: #fed7d7;
          color: #9b2c2c;
        `;
      case 'advantage':
        return `
          background-color: #fef3c7;
          color: #92400e;
        `;
      default:
        return `
          background-color: #f3f4f6;
          color: #374151;
        `;
    }
  }}
`;

const FeatureDescription = styled.p`
  margin: 0.5rem 0;
  color: #4b5563;
  font-size: 0.875rem;
  line-height: 1.4;
`;

const FeatureSource = styled.div`
  display: flex;
  justify-content: between;
  align-items: center;
  margin-top: 0.75rem;
  padding-top: 0.5rem;
  border-top: 1px solid #f3f4f6;
  font-size: 0.75rem;
  color: #6b7280;
`;

const SourceBadge = styled.span<{ $sourceType: string }>`
  padding: 0.125rem 0.375rem;
  border-radius: 4px;
  font-weight: 500;
  
  ${props => {
    switch (props.$sourceType) {
      case 'ancestry_default':
        return `
          background-color: #fef3c7;
          color: #92400e;
        `;
      case 'trait':
        return `
          background-color: #e0e7ff;
          color: #3730a3;
        `;
      case 'class_feature':
        return `
          background-color: #dcfce7;
          color: #166534;
        `;
      case 'choice':
        return `
          background-color: #fce7f3;
          color: #9d174d;
        `;
      default:
        return `
          background-color: #f3f4f6;
          color: #374151;
        `;
    }
  }}
`;

const ConditionalTag = styled.span`
  padding: 0.125rem 0.375rem;
  background-color: #fbbf24;
  color: #78350f;
  border-radius: 4px;
  font-size: 0.7rem;
  font-weight: 500;
  margin-left: 0.5rem;
`;

const ConditionalSection = styled.div`
  margin-top: 1.5rem;
  padding: 1rem;
  background-color: #fffbeb;
  border: 1px solid #fed7aa;
  border-radius: 8px;
`;

const ConditionalHeader = styled.h4`
  margin: 0 0 0.75rem 0;
  color: #92400e;
  font-size: 0.9rem;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  
  &:before {
    content: '⚠️';
  }
`;

const ConditionalItem = styled.div`
  display: flex;
  justify-content: between;
  align-items: center;
  padding: 0.5rem;
  background-color: #ffffff;
  border: 1px solid #fed7aa;
  border-radius: 4px;
  margin-bottom: 0.5rem;
  font-size: 0.875rem;
  
  &:last-child {
    margin-bottom: 0;
  }
`;

const ConditionTag = styled.span`
  padding: 0.25rem 0.5rem;
  background-color: #f59e0b;
  color: #ffffff;
  border-radius: 4px;
  font-size: 0.75rem;
  font-weight: 500;
  text-transform: lowercase;
`;

interface EnhancedFeaturesProps {
  calculationResult: EnhancedCalculationResult;
}

const EnhancedFeatures: React.FC<EnhancedFeaturesProps> = ({ calculationResult }) => {
  // Group abilities by type
  const passiveAbilities = calculationResult.grantedAbilities.filter(
    ability => ability.type === 'passive' && !ability.isConditional
  );
  
  const activeAbilities = calculationResult.grantedAbilities.filter(
    ability => ability.type === 'active' && !ability.isConditional
  );
  
  const resistances = calculationResult.grantedAbilities.filter(
    ability => ability.type === 'resistance'
  );
  
  const advantages = calculationResult.grantedAbilities.filter(
    ability => ability.type === 'advantage'
  );
  
  // Helper function to get icon for section
  const getSectionIcon = (type: string) => {
    switch (type) {
      case 'passive': return '🛡️';
      case 'active': return '⚡';
      case 'resistance': return '🛡️';
      case 'advantage': return '🎯';
      default: return '✨';
    }
  };
  
  // Helper function to format source category
  const formatSourceCategory = (category?: string) => {
    if (!category) return '';
    return category.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
  };
  
  return (
    <FeaturesContainer>
      {/* Passive Abilities */}
      {passiveAbilities.length > 0 && (
        <div>
          <SectionHeader>
            {getSectionIcon('passive')} Passive Abilities
          </SectionHeader>
          {passiveAbilities.map((ability, index) => (
            <FeatureCard key={`passive-${index}`}>
              <FeatureHeader>
                <FeatureName>{ability.name}</FeatureName>
                <FeatureType $type="passive">Passive</FeatureType>
              </FeatureHeader>
              
              <FeatureDescription>{ability.description}</FeatureDescription>
              
              <FeatureSource>
                <span>
                  Source: <strong>{ability.source.name}</strong>
                  {ability.source.category && ` • ${formatSourceCategory(ability.source.category)}`}
                </span>
                <SourceBadge $sourceType={ability.source.type}>
                  {ability.source.type.replace('_', ' ')}
                </SourceBadge>
              </FeatureSource>
            </FeatureCard>
          ))}
        </div>
      )}
      
      {/* Active Abilities */}
      {activeAbilities.length > 0 && (
        <div>
          <SectionHeader>
            {getSectionIcon('active')} Active Abilities
          </SectionHeader>
          {activeAbilities.map((ability, index) => (
            <FeatureCard key={`active-${index}`}>
              <FeatureHeader>
                <FeatureName>{ability.name}</FeatureName>
                <FeatureType $type="active">Active</FeatureType>
              </FeatureHeader>
              
              <FeatureDescription>{ability.description}</FeatureDescription>
              
              <FeatureSource>
                <span>
                  Source: <strong>{ability.source.name}</strong>
                  {ability.source.category && ` • ${formatSourceCategory(ability.source.category)}`}
                </span>
                <SourceBadge $sourceType={ability.source.type}>
                  {ability.source.type.replace('_', ' ')}
                </SourceBadge>
              </FeatureSource>
            </FeatureCard>
          ))}
        </div>
      )}
      
      {/* Resistances */}
      {(resistances.length > 0 || calculationResult.resistances.length > 0) && (
        <div>
          <SectionHeader>
            {getSectionIcon('resistance')} Resistances & Immunities
          </SectionHeader>
          {resistances.map((ability, index) => (
            <FeatureCard key={`resistance-${index}`}>
              <FeatureHeader>
                <FeatureName>{ability.name}</FeatureName>
                <FeatureType $type="resistance">Resistance</FeatureType>
              </FeatureHeader>
              
              <FeatureDescription>{ability.description}</FeatureDescription>
              
              <FeatureSource>
                <span>
                  Source: <strong>{ability.source.name}</strong>
                  {ability.source.category && ` • ${formatSourceCategory(ability.source.category)}`}
                </span>
                <SourceBadge $sourceType={ability.source.type}>
                  {ability.source.type.replace('_', ' ')}
                </SourceBadge>
              </FeatureSource>
            </FeatureCard>
          ))}
          
          {/* Direct resistances from effects */}
          {calculationResult.resistances.map((resistance, index) => (
            <FeatureCard key={`direct-resistance-${index}`}>
              <FeatureHeader>
                <FeatureName>{resistance.type} Resistance</FeatureName>
                <FeatureType $type="resistance">Resistance</FeatureType>
              </FeatureHeader>
              
              <FeatureDescription>
                Resistance ({resistance.value}) to {resistance.type} damage
              </FeatureDescription>
              
              <FeatureSource>
                <span>
                  Source: <strong>{resistance.source.name}</strong>
                  {resistance.source.category && ` • ${formatSourceCategory(resistance.source.category)}`}
                </span>
                <SourceBadge $sourceType={resistance.source.type}>
                  {resistance.source.type.replace('_', ' ')}
                </SourceBadge>
              </FeatureSource>
            </FeatureCard>
          ))}
        </div>
      )}
      
      {/* Advantages */}
      {advantages.length > 0 && (
        <div>
          <SectionHeader>
            {getSectionIcon('advantage')} Advantages & Bonuses
          </SectionHeader>
          {advantages.map((ability, index) => (
            <FeatureCard key={`advantage-${index}`}>
              <FeatureHeader>
                <FeatureName>{ability.name}</FeatureName>
                <FeatureType $type="advantage">Advantage</FeatureType>
              </FeatureHeader>
              
              <FeatureDescription>{ability.description}</FeatureDescription>
              
              <FeatureSource>
                <span>
                  Source: <strong>{ability.source.name}</strong>
                  {ability.source.category && ` • ${formatSourceCategory(ability.source.category)}`}
                </span>
                <SourceBadge $sourceType={ability.source.type}>
                  {ability.source.type.replace('_', ' ')}
                </SourceBadge>
              </FeatureSource>
            </FeatureCard>
          ))}
        </div>
      )}
      
      {/* Conditional Modifiers */}
      {calculationResult.conditionalModifiers.length > 0 && (
        <ConditionalSection>
          <ConditionalHeader>Conditional Bonuses</ConditionalHeader>
          {calculationResult.conditionalModifiers.map((modifier, index) => (
            <ConditionalItem key={`conditional-${index}`}>
              <span>{modifier.description}</span>
              <ConditionTag>{modifier.condition.replace('_', ' ')}</ConditionTag>
            </ConditionalItem>
          ))}
        </ConditionalSection>
      )}
    </FeaturesContainer>
  );
};

export default EnhancedFeatures;
````

## File: src/routes/character-sheet/components/EnhancedStatTooltips.tsx
````typescript
/**
 * Enhanced Stat Tooltips with Effect Attribution
 * 
 * This component creates detailed tooltips that show exactly where
 * each stat bonus comes from, replacing the simplified version.
 */

import React from 'react';
import type { EnhancedStatBreakdown } from '../../../lib/types/effectSystem';
import type { CharacterSheetData } from '../../../types/character';

const tooltipStyles = {
  margin: '8px 0 0 0',
  fontFamily: 'monospace',
  fontSize: '0.75rem',
  lineHeight: '1.2',
  whiteSpace: 'pre-line' as const
};

const conditionalStyle = {
  marginTop: '8px',
  padding: '4px 8px',
  backgroundColor: 'rgba(59, 130, 246, 0.1)',
  borderLeft: '3px solid #3b82f6',
  fontSize: '0.7rem',
  fontStyle: 'italic' as const
};

/**
 * Create enhanced tooltip with detailed breakdown
 */
export function createEnhancedTooltip(
  statName: string,
  breakdown: EnhancedStatBreakdown
): React.ReactNode {
  const formatBreakdown = () => {
    const lines: string[] = [];
    
    // Main total
    lines.push(breakdown.total.toString());
    lines.push('');
    
    // Base value
    lines.push(`├─ Base: ${breakdown.base}`);
    
    // Effect breakdown
    breakdown.effects.forEach((effect, index) => {
      const isLast = index === breakdown.effects.length - 1;
      const prefix = isLast ? '└─' : '├─';
      const sign = effect.value >= 0 ? '+' : '';
      lines.push(`${prefix} ${effect.source.name}: ${sign}${effect.value}`);
    });
    
    return lines.join('\n');
  };

  const conditionalEffects = breakdown.effects.filter(effect => effect.condition);
  
  return (
    <div>
      <strong>{breakdown.statName}</strong>
      <pre style={tooltipStyles}>
        {formatBreakdown()}
      </pre>
      
      {/* Show conditional effects separately */}
      {conditionalEffects.length > 0 && (
        <div style={conditionalStyle}>
          <strong>Conditional Bonuses:</strong><br />
          {conditionalEffects.map((effect, index) => (
            <span key={index}>
              • {effect.description}<br />
            </span>
          ))}
        </div>
      )}
      
      {/* Show potential total if conditionals were active */}
      {breakdown.conditionalTotal && breakdown.conditionalTotal !== breakdown.total && (
        <div style={{ ...conditionalStyle, backgroundColor: 'rgba(34, 197, 94, 0.1)', borderLeftColor: '#22c55e' }}>
          <strong>Maximum Potential:</strong> {breakdown.conditionalTotal} (if all conditions met)
        </div>
      )}
    </div>
  );
}

/**
 * Enhanced HP tooltip with detailed sources
 */
export const createEnhancedHPTooltip = (
  characterData: CharacterSheetData,
  breakdown?: EnhancedStatBreakdown
): React.ReactNode => {
  if (breakdown) {
    return createEnhancedTooltip('Hit Points', breakdown);
  }
  
  // Fallback to simple calculation if breakdown not available
  const mightBonus = characterData.finalMight || 0;
  const simpleBreakdown: EnhancedStatBreakdown = {
    statName: 'Hit Points',
    base: mightBonus,
    effects: [
      {
        source: { type: 'class_feature', id: 'class_hp', name: 'Class HP', category: 'Base' },
        value: characterData.finalHPMax - mightBonus,
        description: `Class base: +${characterData.finalHPMax - mightBonus}`,
        isActive: true
      }
    ],
    total: characterData.finalHPMax
  };
  
  return createEnhancedTooltip('Hit Points', simpleBreakdown);
};

/**
 * Enhanced Speed tooltip with movement details
 */
export const createEnhancedSpeedTooltip = (
  characterData: CharacterSheetData,
  breakdown?: EnhancedStatBreakdown
): React.ReactNode => {
  if (breakdown) {
    return createEnhancedTooltip('Movement Speed', breakdown);
  }
  
  // Fallback calculation
  const simpleBreakdown: EnhancedStatBreakdown = {
    statName: 'Movement Speed',
    base: 5, // DC20 base speed
    effects: [
      {
        source: { type: 'class_feature', id: 'speed_bonus', name: 'Modifiers', category: 'Various' },
        value: characterData.finalMoveSpeed - 5,
        description: `Speed modifiers: ${characterData.finalMoveSpeed - 5 > 0 ? '+' : ''}${characterData.finalMoveSpeed - 5}`,
        isActive: true
      }
    ],
    total: characterData.finalMoveSpeed
  };
  
  return createEnhancedTooltip('Movement Speed', simpleBreakdown);
};

/**
 * Enhanced Defense tooltip (PD/AD) with formula breakdown
 */
export const createEnhancedDefenseTooltip = (
  defenseName: 'PD' | 'AD',
  characterData: CharacterSheetData,
  breakdown?: EnhancedStatBreakdown
): React.ReactNode => {
  if (breakdown) {
    return createEnhancedTooltip(defenseName === 'PD' ? 'Precision Defense' : 'Area Defense', breakdown);
  }
  
  // Fallback calculation with DC20 formula
  const combatMastery = 1; // Would get from character data
  let baseFormula, baseValue;
  
  if (defenseName === 'PD') {
    baseFormula = '8 + CM + AGI + INT';
    baseValue = 8 + combatMastery + (characterData.finalAgility || 0) + (characterData.finalIntelligence || 0);
  } else {
    baseFormula = '8 + CM + MIG + CHA';
    baseValue = 8 + combatMastery + (characterData.finalMight || 0) + (characterData.finalCharisma || 0);
  }
  
  const finalValue = defenseName === 'PD' ? characterData.finalPD : characterData.finalAD;
  const modifiers = finalValue - baseValue;
  
  const simpleBreakdown: EnhancedStatBreakdown = {
    statName: defenseName === 'PD' ? 'Precision Defense' : 'Area Defense',
    base: baseValue,
    effects: modifiers !== 0 ? [
      {
        source: { type: 'trait', id: 'defense_modifiers', name: 'Modifiers', category: 'Various' },
        value: modifiers,
        description: `Defense modifiers: ${modifiers > 0 ? '+' : ''}${modifiers}`,
        isActive: true
      }
    ] : [],
    total: finalValue
  };
  
  return (
    <div>
      <strong>{defenseName === 'PD' ? 'Precision Defense' : 'Area Defense'}</strong>
      <div style={{ fontSize: '0.7rem', color: '#9ca3af', marginBottom: '4px' }}>
        Formula: {baseFormula}
      </div>
      <pre style={tooltipStyles}>
        {finalValue}
        
        ├─ Base ({baseFormula}): {baseValue}
        {modifiers !== 0 && `└─ Modifiers: ${modifiers > 0 ? '+' : ''}${modifiers}`}
      </pre>
    </div>
  );
};

/**
 * Enhanced MP tooltip
 */
export const createEnhancedMPTooltip = (
  characterData: CharacterSheetData,
  breakdown?: EnhancedStatBreakdown
): React.ReactNode => {
  if (breakdown) {
    return createEnhancedTooltip('Mana Points', breakdown);
  }
  
  const intelligenceBonus = characterData.finalIntelligence || 0;
  const simpleBreakdown: EnhancedStatBreakdown = {
    statName: 'Mana Points',
    base: intelligenceBonus,
    effects: [
      {
        source: { type: 'class_feature', id: 'class_mp', name: 'Class MP', category: 'Base' },
        value: characterData.finalMPMax - intelligenceBonus,
        description: `Class base: +${characterData.finalMPMax - intelligenceBonus}`,
        isActive: true
      }
    ],
    total: characterData.finalMPMax
  };
  
  return createEnhancedTooltip('Mana Points', simpleBreakdown);
};

/**
 * Enhanced Jump Distance tooltip
 */
export const createEnhancedJumpTooltip = (
  characterData: CharacterSheetData,
  breakdown?: EnhancedStatBreakdown
): React.ReactNode => {
  if (breakdown) {
    return createEnhancedTooltip('Jump Distance', breakdown);
  }
  
  const agilityBase = characterData.finalAgility || 0;
  const simpleBreakdown: EnhancedStatBreakdown = {
    statName: 'Jump Distance',
    base: agilityBase,
    effects: [
      {
        source: { type: 'base', id: 'jump_formula', name: 'Modifiers', category: 'Various' },
        value: characterData.finalJumpDistance - agilityBase,
        description: `Jump modifiers: ${characterData.finalJumpDistance - agilityBase > 0 ? '+' : ''}${characterData.finalJumpDistance - agilityBase}`,
        isActive: true
      }
    ],
    total: characterData.finalJumpDistance
  };
  
  return (
    <div>
      <strong>Jump Distance</strong>
      <div style={{ fontSize: '0.7rem', color: '#9ca3af', marginBottom: '4px' }}>
        Formula: AGI + modifiers
      </div>
      <pre style={tooltipStyles}>
        {characterData.finalJumpDistance}
        
        ├─ Base (AGI): {agilityBase}
        {characterData.finalJumpDistance !== agilityBase && 
          `└─ Modifiers: ${characterData.finalJumpDistance - agilityBase > 0 ? '+' : ''}${characterData.finalJumpDistance - agilityBase}`
        }
      </pre>
    </div>
  );
};
````

## File: src/routes/character-sheet/components/Features.tsx
````typescript
import React from 'react';
import type { FeatureData } from '../../../types';
import {
	StyledFeaturesContainer,
	StyledFeaturesTitle,
	StyledFeatureCategory,
	StyledFeatureCategoryTitle,
	StyledFeatureGrid,
	StyledFeatureItem,
	StyledFeatureName,
	StyledFeatureReadMore,
	StyledNoFeaturesMessage,
	StyledFeaturesContent
} from '../styles/Features.styles';

interface FeaturesProps {
	features: FeatureData[];
	onFeatureClick: (feature: FeatureData) => void;
}

const Features: React.FC<FeaturesProps> = ({ features, onFeatureClick }) => {
	// Organize features by source
	const ancestryFeatures = features.filter((f) => f.source === 'ancestry');
	const classFeatures = features.filter((f) => f.source === 'class');
	const choiceFeatures = features.filter((f) => f.source === 'choice');

	return (
		<StyledFeaturesContainer>
			<StyledFeaturesTitle>FEATURES</StyledFeaturesTitle>

			<StyledFeaturesContent>
				{/* Ancestry Traits */}
				{ancestryFeatures.length > 0 && (
					<StyledFeatureCategory>
						<StyledFeatureCategoryTitle>Ancestry Traits</StyledFeatureCategoryTitle>
						<StyledFeatureGrid>
							{ancestryFeatures.map((feature) => (
								<StyledFeatureItem key={feature.id}>
									<StyledFeatureName>{feature.name}</StyledFeatureName>
									<StyledFeatureReadMore onClick={() => onFeatureClick(feature)}>
										Info
									</StyledFeatureReadMore>
								</StyledFeatureItem>
							))}
						</StyledFeatureGrid>
					</StyledFeatureCategory>
				)}

				{/* Class Features */}
				{classFeatures.length > 0 && (
					<StyledFeatureCategory>
						<StyledFeatureCategoryTitle>Class Features</StyledFeatureCategoryTitle>
						<StyledFeatureGrid>
							{classFeatures.map((feature) => (
								<StyledFeatureItem key={feature.id}>
									<StyledFeatureName>{feature.name}</StyledFeatureName>
									<StyledFeatureReadMore onClick={() => onFeatureClick(feature)}>
										Info
									</StyledFeatureReadMore>
								</StyledFeatureItem>
							))}
						</StyledFeatureGrid>
					</StyledFeatureCategory>
				)}

				{/* Feature Choices */}
				{choiceFeatures.length > 0 && (
					<StyledFeatureCategory>
						<StyledFeatureCategoryTitle>Selected Features</StyledFeatureCategoryTitle>
						<StyledFeatureGrid>
							{choiceFeatures.map((feature) => (
								<StyledFeatureItem key={feature.id}>
									<StyledFeatureName>{feature.name}</StyledFeatureName>
									<StyledFeatureReadMore onClick={() => onFeatureClick(feature)}>
										Info
									</StyledFeatureReadMore>
								</StyledFeatureItem>
							))}
						</StyledFeatureGrid>
					</StyledFeatureCategory>
				)}

				{/* No features message */}
				{features.length === 0 && (
					<StyledNoFeaturesMessage>No features available</StyledNoFeaturesMessage>
				)}
			</StyledFeaturesContent>
		</StyledFeaturesContainer>
	);
};

export default Features;
````

## File: src/routes/character-sheet/components/Resources.tsx.backup
````
import React from 'react';
import {
	ResourcesContainer,
	ResourceColumn,
	ResourceLabel,
	ResourceControls,
	TempHPControls,
	TempHPLabel,
	TempHPInputSmall
} from '../styles/Resources';
import { StyledResourceButton } from '../styles/Resources';
import {
	StyledPotionContainer,
	StyledPotionFill,
	StyledPotionBubbles,
	StyledPotionValue,
	StyledLargePotionContainer,
	StyledLargePotionValue
} from '../styles/Potions';

interface ResourcesProps {
	characterData: {
		finalSPMax: number;
		finalMPMax: number;
		finalHPMax: number;
	};
	currentValues: {
		currentSP: number;
		currentMP: number;
		currentHP: number;
		tempHP: number;
	};
	onAdjustResource: (
		resource: 'currentSP' | 'currentMP' | 'currentHP' | 'tempHP',
		amount: number
	) => void;
	onResourceInputChange: (resource: 'tempHP', value: string) => void;
	getFillPercentage: (current: number, max: number) => number;
	getHPFillPercentage: (current: number, max: number, tempHP: number) => number;
	isMobile?: boolean;
}

const Resources: React.FC<ResourcesProps> = ({
	characterData,
	currentValues,
	onAdjustResource,
	onResourceInputChange,
	getFillPercentage,
	getHPFillPercentage,
	isMobile = false
}) => {
	return (
		<ResourcesContainer $isMobile={isMobile}>
			{/* Stamina Points */}
			<ResourceColumn $isMobile={isMobile}>
				<ResourceLabel>STAMINA POINTS</ResourceLabel>
				<ResourceControls>
					<StyledResourceButton onClick={() => onAdjustResource('currentSP', -1)}>
						-
					</StyledResourceButton>
					<StyledPotionContainer style={{ borderColor: '#22c55e' }}>
						<StyledPotionFill
							fillPercentage={getFillPercentage(currentValues.currentSP, characterData.finalSPMax)}
							color="#22c55e"
						/>
						<StyledPotionBubbles
							color="#22c55e"
							fillPercentage={getFillPercentage(currentValues.currentSP, characterData.finalSPMax)}
						/>
						<StyledPotionValue>{currentValues.currentSP}</StyledPotionValue>
					</StyledPotionContainer>
					<StyledResourceButton onClick={() => onAdjustResource('currentSP', 1)}>
						+
					</StyledResourceButton>
				</ResourceControls>
				<div
					style={{
						fontSize: '1.1rem',
						fontWeight: '300',
						color: '#666',
						marginTop: '0.3rem',
						fontStyle: 'italic'
					}}
				>
					{characterData.finalSPMax}
				</div>
			</ResourceColumn>

			{/* Mana Points */}
			<ResourceColumn $isMobile={isMobile}>
				<ResourceLabel>MANA POINTS</ResourceLabel>
				<ResourceControls>
					<StyledResourceButton onClick={() => onAdjustResource('currentMP', -1)}>
						-
					</StyledResourceButton>
					<StyledPotionContainer style={{ borderColor: '#3b82f6' }}>
						<StyledPotionFill
							fillPercentage={getFillPercentage(currentValues.currentMP, characterData.finalMPMax)}
							color="#3b82f6"
						/>
						<StyledPotionBubbles
							color="#3b82f6"
							fillPercentage={getFillPercentage(currentValues.currentMP, characterData.finalMPMax)}
						/>
						<StyledPotionValue>{currentValues.currentMP}</StyledPotionValue>
					</StyledPotionContainer>
					<StyledResourceButton onClick={() => onAdjustResource('currentMP', 1)}>
						+
					</StyledResourceButton>
				</ResourceControls>
				<div
					style={{
						fontSize: '1.1rem',
						fontWeight: '300',
						color: '#666',
						marginTop: '0.3rem',
						fontStyle: 'italic'
					}}
				>
					{characterData.finalMPMax}
				</div>
			</ResourceColumn>

			{/* Hit Points */}
			<ResourceColumn $isMobile={isMobile}>
				<ResourceLabel>HIT POINTS</ResourceLabel>
				<ResourceControls>
					<StyledResourceButton onClick={() => onAdjustResource('currentHP', -1)}>
						-
					</StyledResourceButton>
					<StyledLargePotionContainer style={{ borderColor: '#dc2626' }}>
						<StyledPotionFill
							fillPercentage={getHPFillPercentage(
								currentValues.currentHP,
								characterData.finalHPMax,
								currentValues.tempHP
							)}
							color="#dc2626"
						/>
						<StyledPotionBubbles
							color="#dc2626"
							fillPercentage={getHPFillPercentage(
								currentValues.currentHP,
								characterData.finalHPMax,
								currentValues.tempHP
							)}
						/>
						<StyledLargePotionValue>{currentValues.currentHP}</StyledLargePotionValue>
					</StyledLargePotionContainer>
					<StyledResourceButton onClick={() => onAdjustResource('currentHP', 1)}>
						+
					</StyledResourceButton>
				</ResourceControls>
				<div
					style={{
						fontSize: '1.1rem',
						fontWeight: '300',
						color: '#666',
						marginTop: '0.3rem',
						fontStyle: 'italic',
						display: 'flex',
						alignItems: 'center',
						justifyContent: 'center',
						gap: '0.5rem'
					}}
				>
					<span>{characterData.finalHPMax}</span>
					{currentValues.tempHP > 0 && (
						<span style={{ color: '#dc2626', fontWeight: 'bold', fontSize: '0.9rem' }}>
							(+{currentValues.tempHP} temp)
						</span>
					)}
				</div>

				{/* Temp HP Controls */}
				<TempHPControls>
					<TempHPLabel>TEMP HP:</TempHPLabel>
					<StyledResourceButton
						onClick={() => onAdjustResource('tempHP', -1)}
						style={{ fontSize: '0.7rem', width: '20px', height: '20px', padding: '0' }}
					>
						-
					</StyledResourceButton>
					<TempHPInputSmall
						type="number"
						value={currentValues.tempHP}
						onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
							onResourceInputChange('tempHP', e.target.value)
						}
					/>
					<StyledResourceButton
						onClick={() => onAdjustResource('tempHP', 1)}
						style={{ fontSize: '0.7rem', width: '20px', height: '20px', padding: '0' }}
					>
						+
					</StyledResourceButton>
				</TempHPControls>
			</ResourceColumn>
		</ResourcesContainer>
	);
};

export default Resources;
````

## File: src/routes/character-sheet/components/RightColumnResources.tsx
````typescript
import React from 'react';
import type { CharacterSheetData, CurrentValues } from '../../../types';
import {
	StyledRightResourcesContainer,
	StyledRightResourcesTitle,
	StyledRightResourceRow,
	StyledRightResourceLabel,
	StyledRightResourceControls,
	StyledRightResourceInput,
	StyledRightResourceMax
} from '../styles/RightColumnResources.styles';

interface RightColumnResourcesProps {
	characterData: CharacterSheetData;
	currentValues: CurrentValues;
	onResourceInputChange: (resource: keyof CurrentValues, value: string) => void;
}

const RightColumnResources: React.FC<RightColumnResourcesProps> = ({
	characterData,
	currentValues,
	onResourceInputChange
}) => {
	return (
		<StyledRightResourcesContainer>
			<StyledRightResourcesTitle>RESOURCES</StyledRightResourcesTitle>

			<StyledRightResourceRow>
				<StyledRightResourceLabel>REST POINTS</StyledRightResourceLabel>
				<StyledRightResourceControls>
					<StyledRightResourceInput
						type="number"
						value={currentValues.currentRestPoints}
						onChange={(e) => onResourceInputChange('currentRestPoints', e.target.value)}
					/>
					<StyledRightResourceMax>/ {characterData.finalRestPoints}</StyledRightResourceMax>
				</StyledRightResourceControls>
			</StyledRightResourceRow>

			<StyledRightResourceRow>
				<StyledRightResourceLabel>GRIT POINTS</StyledRightResourceLabel>
				<StyledRightResourceControls>
					<StyledRightResourceInput
						type="number"
						value={currentValues.currentGritPoints}
						onChange={(e) => onResourceInputChange('currentGritPoints', e.target.value)}
					/>
					<StyledRightResourceMax>/ {characterData.finalGritPoints}</StyledRightResourceMax>
				</StyledRightResourceControls>
			</StyledRightResourceRow>
		</StyledRightResourcesContainer>
	);
};

export default RightColumnResources;
````

## File: src/routes/character-sheet/components/Spells.tsx
````typescript
import React, { useState, useMemo } from 'react';
import type { SpellData, CharacterSheetData } from '../../../types';
import type { Spell } from '../../../lib/rulesdata/spells-data/types/spell.types';
import { allSpells } from '../../../lib/rulesdata/spells-data/spells';
import { SpellSchool } from '../../../lib/rulesdata/spells-data/types/spell.types';
import {
	StyledSpellsSection,
	StyledSpellsHeader,
	StyledSpellsTitle,
	StyledSpellsControls,
	StyledAddSpellButton,
	StyledSpellsContainer,
	StyledSpellsHeaderRow,
	StyledHeaderColumn,
	StyledEmptyState,
	StyledSpellRow,
	StyledRemoveButton,
	StyledSpellSelect,
	StyledSchoolFilter,
	StyledSpellCell,
	StyledInfoIcon
} from '../styles/Spells';

export interface SpellsProps {
	spells: SpellData[];
	setSpells: React.Dispatch<React.SetStateAction<SpellData[]>>;
	characterData: CharacterSheetData;
	onSpellClick: (spell: Spell) => void;
}

const Spells: React.FC<SpellsProps> = ({ spells, setSpells, characterData, onSpellClick }) => {
	const [schoolFilter, setSchoolFilter] = useState<string>('all');

	// Filter spells based on selected school
	const filteredSpells = useMemo(() => {
		if (schoolFilter === 'all') {
			return allSpells;
		}
		return allSpells.filter(spell => spell.school === schoolFilter);
	}, [schoolFilter]);

	const addSpellSlot = () => {
		const newSpell: SpellData = {
			id: `spell_${Date.now()}`,
			spellName: '',
			school: '',
			isCantrip: false,
			cost: { ap: 0 },
			range: '',
			duration: '',
			isPrepared: false,
			notes: ''
		};
		setSpells((prev) => [...prev, newSpell]);
	};

	const removeSpellSlot = (spellIndex: number) => {
		setSpells((prev) => prev.filter((_, index) => index !== spellIndex));
	};

	const updateSpell = (index: number, field: keyof SpellData, value: any) => {
		setSpells((prev) => {
			const updated = [...prev];
			if (field === 'spellName' && value) {
				// When spell is selected, populate all fields from spell data
				const selectedSpell = allSpells.find(spell => spell.name === value);
				if (selectedSpell) {
					updated[index] = {
						...updated[index],
						spellName: selectedSpell.name,
						school: selectedSpell.school,
						isCantrip: selectedSpell.isCantrip,
						cost: selectedSpell.cost,
						range: selectedSpell.range,
						duration: selectedSpell.duration
					};
				}
			} else {
				updated[index] = { ...updated[index], [field]: value };
			}
			return updated;
		});
	};

	const handleSchoolFilterChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
		setSchoolFilter(event.target.value);
	};

	return (
		<StyledSpellsSection>
			<StyledSpellsHeader>
				<StyledSpellsTitle>Spells</StyledSpellsTitle>
				<StyledSpellsControls>
					<label style={{ fontSize: '0.8rem', color: '#8b4513', marginRight: '0.3rem' }}>
						Filter by School:
					</label>
					<StyledSchoolFilter value={schoolFilter} onChange={handleSchoolFilterChange}>
						<option value="all">All Schools</option>
						{(Object.values(SpellSchool) as string[]).map(school => (
							<option key={school} value={school}>
								{school}
							</option>
						))}
					</StyledSchoolFilter>
					<StyledAddSpellButton onClick={addSpellSlot}>+ Add Spell</StyledAddSpellButton>
				</StyledSpellsControls>
			</StyledSpellsHeader>

			<StyledSpellsContainer>
				<StyledSpellsHeaderRow>
					<span></span> {/* Empty column for remove button */}
					<StyledHeaderColumn>Spell Name</StyledHeaderColumn>
					<StyledHeaderColumn>School</StyledHeaderColumn>
					<StyledHeaderColumn>Type</StyledHeaderColumn>
					<StyledHeaderColumn>AP Cost</StyledHeaderColumn>
					<StyledHeaderColumn>MP Cost</StyledHeaderColumn>
					<StyledHeaderColumn>Range</StyledHeaderColumn>
					<StyledHeaderColumn>
						<StyledInfoIcon title="Spell details and description">i</StyledInfoIcon>
					</StyledHeaderColumn>
				</StyledSpellsHeaderRow>

				{spells.length === 0 ? (
					<StyledEmptyState>
						No spells selected. Click "Add Spell" to add spells to your character.
					</StyledEmptyState>
				) : (
					spells.map((spell, index) => {
						// Get the selected spell details for info display
						const selectedSpell = spell.spellName ? 
							allSpells.find(s => s.name === spell.spellName) : null;
							
						return (
							<StyledSpellRow key={spell.id}>
								{/* Remove Button */}
								<StyledRemoveButton onClick={() => removeSpellSlot(index)}>
									×
								</StyledRemoveButton>

								{/* Spell Name Dropdown */}
								<StyledSpellSelect
									value={spell.spellName}
									onChange={(e) => updateSpell(index, 'spellName', e.target.value)}
								>
									<option value="">Select Spell...</option>
									{filteredSpells.map((spellOption) => (
										<option key={spellOption.name} value={spellOption.name}>
											{spellOption.name}
										</option>
									))}
								</StyledSpellSelect>

								{/* School */}
								<StyledSpellCell>{spell.school}</StyledSpellCell>

								{/* Type (Cantrip or Spell) */}
								<StyledSpellCell>
									{spell.isCantrip ? 'Cantrip' : 'Spell'}
								</StyledSpellCell>

								{/* AP Cost */}
								<StyledSpellCell>{spell.cost.ap}</StyledSpellCell>

								{/* MP Cost */}
								<StyledSpellCell>{spell.cost.mp || '-'}</StyledSpellCell>

								{/* Range */}
								<StyledSpellCell style={{ fontSize: '0.7rem' }}>
									{spell.range || '-'}
								</StyledSpellCell>

								{/* Spell Info */}
								<StyledSpellCell style={{ fontSize: '0.6rem', textAlign: 'center' }}>
									{selectedSpell ? (
										<StyledInfoIcon onClick={() => onSpellClick(selectedSpell)}>
											i
										</StyledInfoIcon>
									) : (
										'-'
									)}
								</StyledSpellCell>
							</StyledSpellRow>
						);
					})
				)}
			</StyledSpellsContainer>
		</StyledSpellsSection>
	);
};

export default Spells;
````

## File: src/routes/character-sheet/components/Tooltip.tsx
````typescript
import React, { useState } from 'react';
import styled, { css } from 'styled-components';

interface TooltipProps {
  content: React.ReactNode;
  children: React.ReactNode;
  position?: 'top' | 'bottom' | 'left' | 'right';
  maxWidth?: string;
}

const TooltipContainer = styled.div`
  position: relative;
  display: inline-block;
`;

const TooltipContent = styled.div<{ 
  $visible: boolean; 
  $position: 'top' | 'bottom' | 'left' | 'right';
  $maxWidth: string;
}>`
  position: absolute;
  z-index: 1000;
  padding: 8px 12px;
  background: #1a1a1a;
  color: #ffffff;
  border-radius: 6px;
  font-size: 0.8rem;
  line-height: 1.3;
  white-space: pre-line;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  border: 1px solid #333;
  max-width: ${props => props.$maxWidth};
  width: max-content;
  min-width: 150px;
  
  opacity: ${props => props.$visible ? 1 : 0};
  visibility: ${props => props.$visible ? 'visible' : 'hidden'};
  transition: opacity 0.2s ease, visibility 0.2s ease;
  
  ${props => {
    switch (props.$position) {
      case 'top':
        return css`
          bottom: 100%;
          left: 50%;
          transform: translateX(-50%);
          margin-bottom: 8px;
          
          &::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #1a1a1a;
          }
        `;
      case 'bottom':
        return css`
          top: 100%;
          left: 50%;
          transform: translateX(-50%);
          margin-top: 8px;
          
          &::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-bottom-color: #1a1a1a;
          }
        `;
      case 'left':
        return css`
          right: 100%;
          top: 50%;
          transform: translateY(-50%);
          margin-right: 8px;
          
          &::after {
            content: '';
            position: absolute;
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            border: 6px solid transparent;
            border-left-color: #1a1a1a;
          }
        `;
      case 'right':
        return css`
          left: 100%;
          top: 50%;
          transform: translateY(-50%);
          margin-left: 8px;
          
          &::after {
            content: '';
            position: absolute;
            right: 100%;
            top: 50%;
            transform: translateY(-50%);
            border: 6px solid transparent;
            border-right-color: #1a1a1a;
          }
        `;
      default:
        return css``;
    }
  }}
`;

const TriggerWrapper = styled.div`
  display: inline-block;
  cursor: help;
`;

const Tooltip: React.FC<TooltipProps> = ({ 
  content, 
  children, 
  position = 'top',
  maxWidth = '250px'
}) => {
  const [visible, setVisible] = useState(false);

  return (
    <TooltipContainer>
      <TriggerWrapper
        onMouseEnter={() => setVisible(true)}
        onMouseLeave={() => setVisible(false)}
      >
        {children}
      </TriggerWrapper>
      <TooltipContent 
        $visible={visible} 
        $position={position}
        $maxWidth={maxWidth}
      >
        {content}
      </TooltipContent>
    </TooltipContainer>
  );
};

export default Tooltip;
````

## File: src/routes/character-sheet/styles/DiceRoller.ts
````typescript
import styled, { keyframes, css } from 'styled-components';

// Draconic fire animations
const fireGlow = keyframes`
	0% { box-shadow: 0 0 5px #ff4500, 0 0 10px #ff4500, 0 0 15px #ff4500; }
	50% { box-shadow: 0 0 10px #ff6347, 0 0 20px #ff6347, 0 0 30px #ff6347; }
	100% { box-shadow: 0 0 5px #ff4500, 0 0 10px #ff4500, 0 0 15px #ff4500; }
`;

const rollAnimation = keyframes`
	0% { transform: rotate(0deg) scale(1); }
	25% { transform: rotate(90deg) scale(1.1); }
	50% { transform: rotate(180deg) scale(1.2); }
	75% { transform: rotate(270deg) scale(1.1); }
	100% { transform: rotate(360deg) scale(1); }
`;

const emberFloat = keyframes`
	0% { transform: translateY(0px); opacity: 1; }
	100% { transform: translateY(-20px); opacity: 0; }
`;

// Main container positioned in bottom right
export const StyledDiceRollerContainer = styled.div<{ $isExpanded: boolean }>`
	position: fixed;
	bottom: 1rem;
	right: 1rem;
	width: ${props => props.$isExpanded ? '380px' : '60px'};
	height: ${props => props.$isExpanded ? 'auto' : '60px'};
	background: linear-gradient(135deg, #2c1810 0%, #4a2c20 50%, #6b3e30 100%);
	border: 3px solid #8b4513;
	border-radius: 12px;
	padding: ${props => props.$isExpanded ? '1rem' : '0'};
	z-index: 1000;
	box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
	transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
	overflow: hidden;
	
	&::before {
		content: '';
		position: absolute;
		top: -2px;
		left: -2px;
		right: -2px;
		bottom: -2px;
		background: linear-gradient(45deg, #ff4500, #ff6347, #ff8c00, #ffa500);
		border-radius: 15px;
		z-index: -1;
		opacity: 0.3;
		animation: ${fireGlow} 2s infinite;
	}

	@media (max-width: 768px) {
		bottom: 0.5rem;
		right: 0.5rem;
		width: ${props => props.$isExpanded ? '260px' : '50px'};
		height: ${props => props.$isExpanded ? 'auto' : '50px'};
	}
`;

// Collapse/expand button
export const StyledCollapseButton = styled.button<{ $isExpanded: boolean }>`
	position: ${props => props.$isExpanded ? 'absolute' : 'static'};
	top: ${props => props.$isExpanded ? '0.5rem' : 'auto'};
	right: ${props => props.$isExpanded ? '0.5rem' : 'auto'};
	width: ${props => props.$isExpanded ? '30px' : '100%'};
	height: ${props => props.$isExpanded ? '30px' : '100%'};
	background: linear-gradient(135deg, #ff4500, #ff6347);
	border: 2px solid #8b4513;
	border-radius: ${props => props.$isExpanded ? '6px' : '12px'};
	color: white;
	font-size: ${props => props.$isExpanded ? '1rem' : '1.5rem'};
	cursor: pointer;
	display: flex;
	align-items: center;
	justify-content: center;
	transition: all 0.2s ease;
	
	&:hover {
		background: linear-gradient(135deg, #ff6347, #ff8c00);
		transform: scale(1.05);
		animation: ${fireGlow} 1s infinite;
	}
`;

// Dice controls section
export const StyledDiceControls = styled.div`
	margin-bottom: 1rem;
	padding-bottom: 0.5rem;
	border-bottom: 1px solid #8b4513;
	
	.section-label {
		margin-bottom: 0.5rem;
		font-size: 0.8rem;
		font-weight: bold;
		color: #ffd700;
		text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
		text-transform: uppercase;
		letter-spacing: 0.5px;
	}
`;

// Mode buttons (Normal, Advantage, Disadvantage, No D20)
export const StyledModeButton = styled.button<{ $active: boolean }>`
	padding: 0.3rem 0.5rem;
	font-size: 0.65rem;
	background: ${props => props.$active ? 
		'linear-gradient(135deg, #ff4500, #ff6347)' : 
		'linear-gradient(135deg, #4a2c20, #6b3e30)'};
	color: white;
	border: 1px solid #8b4513;
	border-radius: 4px;
	cursor: pointer;
	transition: all 0.2s ease;
	font-weight: bold;
	flex: 1;
	min-width: 0;
	text-align: center;
	
	&:hover {
		background: linear-gradient(135deg, #ff6347, #ff8c00);
		transform: translateY(-1px);
	}
`;

// Add dice section
export const StyledAddDiceSection = styled.div`
	margin-bottom: 1rem;
	padding-bottom: 0.5rem;
	border-bottom: 1px solid #8b4513;
	
	.section-label {
		margin-bottom: 0.5rem;
		font-size: 0.8rem;
		font-weight: bold;
		color: #ffd700;
		text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
		text-transform: uppercase;
		letter-spacing: 0.5px;
	}
`;

// Dice type buttons (d4, d6, etc.)
export const StyledDiceTypeButton = styled.button`
	padding: 0.4rem;
	font-size: 0.7rem;
	background: linear-gradient(135deg, #8b4513, #a0522d);
	color: white;
	border: 1px solid #654321;
	border-radius: 4px;
	cursor: pointer;
	transition: all 0.2s ease;
	font-weight: bold;
	
	&:hover {
		background: linear-gradient(135deg, #a0522d, #cd853f);
		transform: translateY(-1px);
		box-shadow: 0 2px 8px rgba(255, 69, 0, 0.3);
	}
`;

// Dice counter component
export const StyledDiceCounter = styled.div`
	display: flex;
	align-items: center;
	gap: 0.5rem;
	padding: 0.3rem;
	background: rgba(255, 255, 255, 0.1);
	border-radius: 4px;
	border: 1px solid #8b4513;
`;

// Current dice list
export const StyledDiceList = styled.div`
	margin-bottom: 1rem;
	padding-bottom: 0.5rem;
	border-bottom: 1px solid #8b4513;
	
	.section-label {
		margin-bottom: 0.5rem;
		font-size: 0.8rem;
		font-weight: bold;
		color: #ffd700;
		text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
		text-transform: uppercase;
		letter-spacing: 0.5px;
	}
`;

// Individual dice item in list
export const StyledDiceItem = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0.2rem 0.4rem;
	margin-bottom: 0.2rem;
	background: rgba(255, 255, 255, 0.1);
	border-radius: 4px;
	font-size: 0.7rem;
	color: white;
`;

// Remove dice button
export const StyledRemoveDiceButton = styled.button`
	width: 20px;
	height: 20px;
	background: #d32f2f;
	color: white;
	border: none;
	border-radius: 50%;
	cursor: pointer;
	font-size: 0.8rem;
	display: flex;
	align-items: center;
	justify-content: center;
	
	&:hover {
		background: #b71c1c;
		transform: scale(1.1);
	}
`;

// Main dice container
export const StyledDiceContainer = styled.div`
	display: flex;
	flex-direction: column;
	align-items: center;
	margin: 1rem 0;
	padding: 1rem;
	background: radial-gradient(circle, rgba(255, 69, 0, 0.1) 0%, rgba(139, 69, 19, 0.1) 100%);
	border-radius: 8px;
	border: 1px solid rgba(255, 69, 0, 0.3);
`;

// Individual dice icons
export const StyledDiceIcon = styled.div<{ 
	$isRolling: boolean; 
	$type: string;
	$size?: 'small' | 'normal';
}>`
	font-size: ${props => props.$size === 'small' ? '1.2rem' : '2rem'};
	width: ${props => props.$size === 'small' ? '30px' : '50px'};
	height: ${props => props.$size === 'small' ? '30px' : '50px'};
	display: flex;
	align-items: center;
	justify-content: center;
	background: ${props => props.$type === 'd20' ? 
		'radial-gradient(circle, #ff4500 0%, #ff6347 50%, #8b0000 100%)' :
		'radial-gradient(circle, #8b4513 0%, #a0522d 50%, #654321 100%)'};
	border: 2px solid #654321;
	border-radius: 8px;
	color: white;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	transition: all 0.3s ease;
	
	${props => props.$isRolling && css`
		animation: ${rollAnimation} 0.3s linear infinite;
	`}
	
	&::after {
		content: '';
		position: absolute;
		width: 4px;
		height: 4px;
		background: #ffa500;
		border-radius: 50%;
		animation: ${emberFloat} 1.5s infinite;
		margin-left: 10px;
		margin-top: -5px;
		opacity: ${props => props.$isRolling ? 1 : 0};
	}
`;

// Dice value display
export const StyledDiceValue = styled.div<{ $isMax?: boolean; $isMin?: boolean }>`
	font-size: 1.2rem;
	font-weight: bold;
	color: ${props => 
		props.$isMax ? '#ffd700' : 
		props.$isMin ? '#ff4500' : 
		'white'};
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
	margin-top: 0.5rem;
`;

// Roll button
export const StyledRollButton = styled.button<{ $isRolling: boolean }>`
	width: 100%;
	padding: 0.8rem;
	font-size: 1rem;
	font-weight: bold;
	background: ${props => props.$isRolling ? 
		'linear-gradient(135deg, #666, #888)' :
		'linear-gradient(135deg, #ff4500, #ff6347, #ff8c00)'};
	color: white;
	border: 2px solid #8b4513;
	border-radius: 8px;
	cursor: ${props => props.$isRolling ? 'not-allowed' : 'pointer'};
	transition: all 0.3s ease;
	text-transform: uppercase;
	letter-spacing: 1px;
	
	${props => !props.$isRolling && css`
		&:hover {
			background: linear-gradient(135deg, #ff6347, #ff8c00, #ffa500);
			transform: translateY(-2px);
			box-shadow: 0 6px 20px rgba(255, 69, 0, 0.4);
			animation: ${fireGlow} 1s infinite;
		}
	`}
	
	&:active {
		transform: translateY(0);
	}
`;

// Results display
export const StyledResultsDisplay = styled.div`
	margin-top: 1rem;
	padding: 1rem 0.8rem 1.5rem 0.8rem;
	background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 69, 0, 0.1));
	border: 2px solid rgba(255, 215, 0, 0.3);
	border-radius: 8px;
	position: relative;
`;

// Individual dice result
export const StyledDiceResult = styled.div<{ 
	$isMax: boolean; 
	$isMin: boolean; 
	$isChosen?: boolean;
	$isCriticalSuccess?: boolean;
	$isCriticalFail?: boolean;
}>`
	padding: 0.2rem 0.4rem;
	background: ${props => 
		props.$isCriticalSuccess ? 'linear-gradient(135deg, #ffd700, #ffed4e)' :
		props.$isCriticalFail ? 'linear-gradient(135deg, #dc143c, #ff0000)' :
		props.$isMax ? 'linear-gradient(135deg, #32cd32, #90ee90)' :
		props.$isMin ? 'linear-gradient(135deg, #ff4500, #ff6347)' :
		props.$isChosen === false ? 'linear-gradient(135deg, #4a4a4a, #6a6a6a)' :
		'linear-gradient(135deg, #8b4513, #a0522d)'};
	color: ${props => 
		props.$isCriticalSuccess || props.$isCriticalFail || props.$isMax || props.$isMin ? 'black' : 
		props.$isChosen === false ? '#e0e0e0' :
		'white'};
	border-radius: 4px;
	font-size: 0.7rem;
	font-weight: bold;
	border: 2px solid ${props => 
		props.$isCriticalSuccess ? '#b8860b' :
		props.$isCriticalFail ? '#8b0000' :
		props.$isChosen === false ? '#888' :
		props.$isMax ? '#228b22' :
		props.$isMin ? '#8b0000' :
		'#654321'};
	position: relative;
	opacity: ${props => props.$isChosen === false ? 0.8 : 1};
	
	${props => props.$isCriticalSuccess && css`
		animation: ${fireGlow} 1.5s infinite;
		box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
		&::after {
			content: '✨ CRIT SUCCESS';
			position: absolute;
			top: -20px;
			left: 50%;
			transform: translateX(-50%);
			font-size: 0.6rem;
			color: #ffd700;
			font-weight: bold;
			text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
			white-space: nowrap;
		}
	`}
	
	${props => props.$isCriticalFail && css`
		animation: ${fireGlow} 1.5s infinite;
		box-shadow: 0 0 15px rgba(220, 20, 60, 0.8);
		&::after {
			content: '💀 CRIT FAIL';
			position: absolute;
			top: -20px;
			left: 50%;
			transform: translateX(-50%);
			font-size: 0.6rem;
			color: #dc143c;
			font-weight: bold;
			text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
			white-space: nowrap;
		}
	`}
	
	${props => props.$isChosen === false && css`
		&::before {
			content: 'NOT USED';
			position: absolute;
			bottom: -16px;
			left: 50%;
			transform: translateX(-50%);
			font-size: 0.5rem;
			color: #ccc;
			font-weight: bold;
			white-space: nowrap;
			text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
		}
	`}
`;

// Total result display
export const StyledTotalResult = styled.div<{ $isHighRoll: boolean }>`
	font-size: 1.2rem;
	font-weight: bold;
	color: ${props => props.$isHighRoll ? '#ffd700' : 'white'};
	text-align: center;
	margin-bottom: 0.5rem;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
	
	${props => props.$isHighRoll && css`
		animation: ${fireGlow} 2s infinite;
		text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
	`}
`;

// Roll history
export const StyledDiceHistory = styled.div`
	margin-top: 0.8rem;
	padding-top: 0.5rem;
	border-top: 1px solid #8b4513;
	color: rgba(255, 255, 255, 0.9);
	
	.section-label {
		font-size: 0.8rem;
		font-weight: bold;
		color: #ffd700;
		text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
		margin-bottom: 0.25rem;
		text-transform: uppercase;
		letter-spacing: 0.5px;
	}
`;
````

## File: src/routes/character-sheet/styles/Spells.ts
````typescript
import styled from 'styled-components';

export const StyledSpellsSection = styled.div`
	margin-bottom: 1.5rem;
	background: white;
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
`;

export const StyledSpellsHeader = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 1rem;
	padding-bottom: 0.5rem;
	border-bottom: 1px solid #8b4513;
`;

export const StyledSpellsTitle = styled.h3`
	margin: 0;
	color: #8b4513;
	font-size: 1.1rem;
	font-weight: bold;
`;

export const StyledSpellsControls = styled.div`
	display: flex;
	gap: 0.5rem;
	align-items: center;
`;

export const StyledAddSpellButton = styled.button`
	background: #8b4513;
	color: white;
	border: none;
	padding: 0.4rem 0.8rem;
	border-radius: 4px;
	cursor: pointer;
	font-size: 0.8rem;
	font-weight: bold;

	&:hover {
		background: #a0522d;
	}
`;

export const StyledSpellsContainer = styled.div`
	display: flex;
	flex-direction: column;
	gap: 0.5rem;
`;

export const StyledSpellsHeaderRow = styled.div`
	display: grid;
	grid-template-columns: 40px 2fr 1fr 1fr 0.8fr 0.8fr 1fr 0.8fr;
	gap: 0.5rem;
	padding: 0.5rem;
	background: #f5f5dc;
	border: 1px solid #8b4513;
	border-radius: 4px;
	font-weight: bold;
	font-size: 0.8rem;
	color: #8b4513;
`;

export const StyledHeaderColumn = styled.div`
	display: flex;
	align-items: center;
	justify-content: center;
	text-align: center;
`;

export const StyledEmptyState = styled.div`
	text-align: center;
	padding: 1rem;
	color: #666;
	font-style: italic;
`;

export const StyledSpellRow = styled.div`
	display: grid;
	grid-template-columns: 40px 2fr 1fr 1fr 0.8fr 0.8fr 1fr 0.8fr;
	gap: 0.5rem;
	padding: 0.5rem;
	border: 1px solid #ddd;
	border-radius: 4px;
	background: white;
	align-items: center;

	&:hover {
		background: #f9f9f9;
	}
`;

export const StyledRemoveButton = styled.button`
	background: #dc3545;
	color: white;
	border: none;
	width: 24px;
	height: 24px;
	border-radius: 50%;
	cursor: pointer;
	font-size: 0.8rem;
	display: flex;
	align-items: center;
	justify-content: center;

	&:hover {
		background: #c82333;
	}
`;

export const StyledSpellSelect = styled.select`
	width: 100%;
	padding: 0.3rem;
	border: 1px solid #ddd;
	border-radius: 4px;
	font-size: 0.8rem;

	&:focus {
		outline: none;
		border-color: #8b4513;
	}
`;

export const StyledSchoolFilter = styled.select`
	padding: 0.3rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	font-size: 0.8rem;
	background: white;

	&:focus {
		outline: none;
		border-color: #a0522d;
	}
`;

export const StyledSpellCell = styled.div`
	font-size: 0.8rem;
	color: #333;
	display: flex;
	align-items: center;
	justify-content: center;
	text-align: center;
`;

export const StyledPreparedCheckbox = styled.input`
	width: 16px;
	height: 16px;
	cursor: pointer;
`;

export const StyledNotesInput = styled.input`
	width: 100%;
	padding: 0.2rem;
	border: 1px solid #ddd;
	border-radius: 4px;
	font-size: 0.7rem;

	&:focus {
		outline: none;
		border-color: #8b4513;
	}
`;

export const StyledInfoIcon = styled.span`
	display: inline-flex;
	align-items: center;
	justify-content: center;
	width: 14px;
	height: 14px;
	border-radius: 50%;
	background-color: #8b4513;
	color: white;
	font-size: 10px;
	font-weight: bold;
	cursor: pointer;
`;
````

## File: src/types/defenseNotes.ts
````typescript
export interface DefenseNote {
	id: string;
	timestamp: Date;
	reason: string;
	oldValue: number;
	newValue: number;
	field: 'manualPD' | 'manualPDR' | 'manualAD';
}

export interface DefenseNotesData {
	characterId: string;
	notes: DefenseNote[];
}
````

## File: src/types/index.ts
````typescript
// Main export file for all types
export * from './character';
````

## File: src/main.tsx
````typescript
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

ReactDOM.createRoot(document.getElementById('root')!).render(
	<React.StrictMode>
		<App />
	</React.StrictMode>
);
````

## File: .npmrc
````
engine-strict=true
registry=https://registry.npmjs.org/
````

## File: .prettierrc
````
{
	"useTabs": true,
	"singleQuote": true,
	"trailingComma": "none",
	"printWidth": 100,
	"plugins": ["prettier-plugin-tailwindcss"]
}
````

## File: CALCULATION_FIXES_SUMMARY.md
````markdown
# ✅ **CHARACTER SHEET CALCULATION FIXES**

## 🚨 **ISSUES IDENTIFIED AND FIXED**

The user identified several critical calculation errors in the character sheet. All issues have been **successfully fixed** in both calculation systems.

---

## 🔧 **FIXES IMPLEMENTED**

### **1. ✅ AD/PD Missing Modifiers**
**BEFORE (BROKEN):**
```typescript
calculatedPD = 8 + finalCombatMastery + finalAgility + finalIntelligence;
calculatedAD = 8 + finalCombatMastery + finalMight + finalCharisma;
```

**AFTER (FIXED):**
```typescript
calculatedPD = 8 + finalCombatMastery + finalAgility + finalIntelligence + processedTraitEffects.staticBonuses.pd;
calculatedAD = 8 + finalCombatMastery + finalMight + finalCharisma + processedTraitEffects.staticBonuses.ad;
```

### **2. ✅ HP Calculation from Level Progression**
**BEFORE (BROKEN):**
```typescript
finalHPMax = finalMight + classData.baseHpContribution;
```

**AFTER (FIXED):**
```typescript
// Sum HP from all levels up to current level
finalHPMax = finalMight; // Base from Might
for (let level = 1; level <= characterData.level; level++) {
  const levelData = classData.levelProgression.find(lp => lp.level === level);
  if (levelData) {
    finalHPMax += levelData.healthPoints || 0;
  }
}
finalHPMax += trait_modifiers; // Add trait bonuses
```

### **3. ✅ MP Calculation from Level Progression**
**BEFORE (BROKEN):**
```typescript
finalMPMax = classData.startingMP + finalIntelligence;
```

**AFTER (FIXED):**
```typescript
// Sum MP from all levels up to current level
finalMPMax = 0;
for (let level = 1; level <= characterData.level; level++) {
  const levelData = classData.levelProgression.find(lp => lp.level === level);
  if (levelData) {
    finalMPMax += levelData.manaPoints || 0;
  }
}
finalMPMax += trait_modifiers; // Add trait bonuses
```

### **4. ✅ SP Calculation from Level Progression**
**BEFORE (BROKEN):**
```typescript
finalSPMax = classData.startingSP + finalAgility;
```

**AFTER (FIXED):**
```typescript
// Sum SP from all levels up to current level
finalSPMax = 0;
for (let level = 1; level <= characterData.level; level++) {
  const levelData = classData.levelProgression.find(lp => lp.level === level);
  if (levelData) {
    finalSPMax += levelData.staminaPoints || 0;
  }
}
finalSPMax += trait_modifiers; // Add trait bonuses
```

### **5. ✅ Death Threshold Formula**
**BEFORE (BROKEN):**
```typescript
finalDeathThreshold = 10; // Hard-coded base
```

**AFTER (FIXED):**
```typescript
finalDeathThreshold = primeModifier.value + finalCombatMastery; // Prime + Combat Mastery (usually -4)
```

### **6. ✅ Grit Points Formula**
**BEFORE (BROKEN):**
```typescript
finalGritPoints = classData.gritPointsBase + finalCharisma; // Could go negative
```

**AFTER (FIXED):**
```typescript
finalGritPoints = Math.max(0, 2 + finalCharisma); // 2 + Charisma (minimum 0)
```

### **7. ✅ Rest Points Formula**
**BEFORE (INCONSISTENT):**
```typescript
finalRestPoints = 4; // Hard-coded, then later set to HP
```

**AFTER (FIXED):**
```typescript
finalRestPoints = finalHPMax; // Rest Points = HP (DC20 rule)
```

---

## 📊 **CORRECTED FORMULAS SUMMARY**

### **Core Formulas:**
```typescript
// Defenses
PD = 8 + Combat Mastery + Agility + Intelligence + trait_modifiers
AD = 8 + Combat Mastery + Might + Charisma + trait_modifiers

// Health & Resources (from level progression)
HP = Might + sum(level_hp_progression) + trait_modifiers
SP = sum(level_sp_progression) + trait_modifiers  
MP = sum(level_mp_progression) + trait_modifiers

// Other Stats
Death Threshold = Prime Attribute + Combat Mastery
Grit Points = max(0, 2 + Charisma)
Rest Points = HP
Jump Distance = Agility + modifiers
Move Speed = 5 + modifiers
```

---

## 🧪 **TEST VALIDATION**

### **Level 2 Barbarian (Might +3) Example:**
```
✅ HP = Might(3) + Lvl1(9) + Lvl2(3) + modifiers(0) = 15
✅ Death Threshold = Prime(3) + Combat Mastery(1) = 4  
✅ Grit = max(0, 2 + Charisma(0)) = 2
✅ Rest Points = HP = 15
✅ Jump Distance = Agility(1) + modifiers(0) = 1
```

**Example validates that the formulas work correctly!** 🎯

---

## 🎯 **EXAMPLE: Level 2 Giantborn Barbarian with Tough Trait**

**As specified by user:**
- **HP**: Level 1 (9) + Level 2 (3) + Might (3) + Tough modifier (1) = **16 HP**
- **MP**: Level 3 Bard would have 6 (lvl1) + 2 (lvl3) = **8 MP**

**The system now correctly handles these complex calculations!** ✅

---

## 🚀 **IMPACT**

These fixes ensure that:
1. **Defense calculations** include all trait bonuses
2. **Resource calculations** properly sum from class progression tables
3. **Death threshold** follows DC20 rules (prime + combat mastery)
4. **Grit points** never go below 0
5. **Rest points** always equal HP
6. **All modifiers** are properly applied

**The character sheet now provides accurate, DC20-compliant calculations!** 🎉
````

## File: character_schema.json
````json
{
	"character": {
		"name": "String",
		"playerName": "String",
		"level": "Int",
		"attributes": {
			"might": "Int",
			"agility": "Int",
			"charisma": "Int",
			"intelligence": "Int"
		},
		"primeModifier": {
			"attribute": "String",
			"value": "Int"
		},
		"combatMastery": "Int",
		"saveMastery": {
			"might": "Int",
			"agility": "Int",
			"charisma": "Int",
			"intelligence": "Int"
		},
		"resources": {
			"hpMax": "Int",
			"spMax": "Int",
			"mpMax": "Int",
			"restPoints": "Int",
			"gritPoints": "Int"
		},
		"defenses": {
			"pd": "Int",
			"ad": "Int",
			"pdr": "String",
			"edr": "String",
			"mdr": "String"
		},
		"coreStats": {
			"saveDC": "Int",
			"deathThreshold": "Int",
			"moveSpeed": "Int",
			"jumpDistance": "Int",
			"initiativeBonus": "Int"
		},
		"ancestry": {
			"ancestry1Name": "String",
			"ancestry2Name": "String",
			"selectedTraits": "JSON"
		},
		"class": {
			"name": "String",
			"level1Features": "JSON"
		},
		"skills": "JSON",
		"trades": "JSON",
		"languages": "JSON",
		"equipment": "JSON"
	}
}
````

## File: classAndAncestryAndCalcRefactor.md
````markdown
### **A Unified Plan for a Robust Character Data Schema**

#### **1. Purpose of This Refactor**

The primary goal of this refactor is to evolve the character creation system from a partially descriptive model to a fully **structured, machine-readable data model**.

**The Problem:**
Currently, many character bonuses (especially from class features) are stored as plain text in `description` fields. The system then attempts to parse these strings with regular expressions to extract their mechanical effects. This approach is:
*   **Brittle:** A small change in wording (e.g., "grants +1 to AD" vs. "AD increases by 1") can break the calculation logic.
*   **Hard to Maintain:** Adding new features with new effects requires writing new, specific parsing logic in the calculator, making the code complex and error-prone.
*   **Not Scalable:** It's difficult to represent complex or conditional effects (e.g., "gain +2 PD only when not wearing armor") reliably with text parsing.
*   **Unclear:** It's difficult for developers to see at a glance what the exact mechanical impact of a feature is without cross-referencing the calculator's code.

**The Solution:**
We will implement a unified `Effect` schema. Every trait, class feature, and feature choice that has a mechanical impact will have a structured `effects` array. This array will explicitly define each bonus, ability, or modification in a format the calculation engine can understand directly, eliminating ambiguity and the need for string parsing.

**The Benefits:**
*   **Reliability:** Calculations will be based on concrete data, not fragile text parsing, making them accurate and predictable.
*   **Maintainability:** Game rules will be defined entirely within the JSON data files. Modifying a bonus is a simple data change, requiring no alteration to the calculation code.
*   **Scalability:** The system will be ableto handle any future feature, item, or status effect, no matter how complex, simply by defining its effects in the schema.
*   **Clarity:** The data becomes the single source of truth. Anyone can look at a feature's JSON definition and understand its precise mechanical effects.

---

#### **2. The Unified Data Schema: The `Effect` Model**

We will introduce a universal `Effect` interface that will be the cornerstone of our data model. This interface will be added to `src/types/index.ts` (or a relevant types file).

```typescript
// Proposed universal Effect interface
export interface Effect {
  type: 
    // Modifies a core number value
    | 'MODIFY_ATTRIBUTE'      // For Might, Agility, etc. (+1, -1)
    | 'MODIFY_STAT'           // For hpMax, mpMax, pd, ad, moveSpeed, jumpDistance, etc.
    
    // Grants a specific, named ability or status
    | 'GRANT_RESISTANCE'      // e.g., Fire Resistance (Half), Dazed Resistance (Condition)
    | 'GRANT_VULNERABILITY'   // e.g., Psychic Vulnerability (1)
    | 'GRANT_ADV_ON_SAVE'     // e.g., ADV on saves vs. 'Charmed'
    | 'GRANT_COMBAT_TRAINING' // e.g., 'Heavy_Armor'
    | 'GRANT_ABILITY'         // A descriptive gameplay feature, e.g., "Ignore Difficult Terrain"
    | 'GRANT_SPELL'           // Grants a specific spell
    
    // For choices the player makes
    | 'GRANT_CHOICE'          // Prompts user to select from a list, e.g., a Maneuver or Technique
    | 'GRANT_SKILL_EXPERTISE' // Increases skill mastery cap and level
    | 'GRANT_TRADE_EXPERTISE' // Increases trade mastery cap and level

    // For overriding default calculations
    | 'SET_VALUE'             // Overrides a value, e.g., setting Jump Distance calculation to use Might
  ;
  target: string;             // The ID of what is being affected, e.g., 'might', 'hpMax', 'Poison', 'athletics'
  value: any;                 // The magnitude of the effect, e.g., 1, 'half', 'Heavy_Armor'
  condition?: string;         // An optional condition for the effect to apply, e.g., 'not_wearing_armor'
  userChoice?: {              // For effects where the user must choose the specific target
    prompt: string;
    options?: string[];       // e.g., ['might', 'agility', 'charisma', 'intelligence']
  };
}
```

This `Effect` structure will be added to traits in `traits.ts` and, most importantly, to the feature and choice definitions within the `*_features.json` files.

---

#### **3. The New Calculation Flow**

The character calculation process will be refactored to be a pure "effects processor."

1.  **Data Aggregation:** The process starts by collecting all `Effect` objects from every choice the user has made:
    *   Default traits from the selected Ancestry/Ancestries.
    *   Manually selected Traits.
    *   Core features from the selected Class.
    *   Subclass features.
    *   Effects granted by choices made within features (e.g., the effects of the "Grassland" Favored Terrain option).

2.  **Effect Resolution:** The system will handle effects that require user input. For example, if an `Effect` has a `userChoice` for an attribute, the system will use the player's stored selection (e.g., `'might'`) to create a final, concrete `Effect` object like `{ type: 'MODIFY_ATTRIBUTE', target: 'might', value: 1 }`.

3.  **Effect Processing Engine:** A central processor function will iterate through the final list of all `Effect` objects and sort them into categories:
    *   **Stat Modifiers:** A summary object containing totals for attributes (`might: +1`), stats (`hpMax: +3`, `moveSpeed: +1`), etc.
    *   **Abilities List:** A simple array of strings for all granted abilities, resistances, and advantages to be displayed on the character sheet.
    *   **Conditional Modifiers:** A separate list of effects that have a `condition` field, to be handled by the UI in real-time.

4.  **Final Stat Calculation:** The calculator will:
    *   Start with the character's base attributes from point-buy.
    *   Fetch the class's base stats (HP, SP, MP, etc.) from its `*_table.json` file.
    *   Apply the aggregated **Stat Modifiers** from the processing engine.
    *   Perform the final derived calculations (e.g., `finalPD = 8 + CM + finalAgility + finalIntelligence + pd_modifiers`).

5.  **Render In-Game Abilities:** The **Abilities List** is passed directly to the `Features.tsx` component on the character sheet to be displayed for the player's reference during gameplay.

---

#### **4. The Refactoring Implementation Plan**

**Phase 1: Update Core Schema**
1.  Define the unified `Effect` interface as described above in `src/lib/rulesdata/types.ts`.

**Phase 2: Data Migration - Ancestry Traits**
1.  Go to `src/lib/rulesdata/traits.ts`.
2.  Iterate through every `ITrait` object.
3.  Convert the existing `effects` array to conform to the new, stricter `Effect` model. This is mostly a formality as this file is already well-structured.

    *   **Example (`elf_quick_reactions`):**
        ```typescript
        // FROM:
        effects: [{ type: 'MODIFY_PD', value: 1, condition: 'not_wearing_armor' }]
        // TO:
        effects: [{ type: 'MODIFY_STAT', target: 'pd', value: 1, condition: 'not_wearing_armor' }]
        ```

**Phase 3: Data Migration - Class Features (The Core Task)**
1.  Go through each `*_features.json` file (e.g., `barbarian_features.json`).
2.  For every `feature`, `benefit`, and `option` that has a mechanical effect, add a corresponding `effects` array.
3.  Translate the descriptive text into structured `Effect` objects.

    *   **Example (`barbarian_features.json` -> Berserker -> Berserker Defense):**
        ```json
        // FROM:
        {
          "name": "Berserker Defense",
          "description": "While you aren't wearing Armor you gain +2 AD."
        }
        // TO:
        {
          "name": "Berserker Defense",
          "description": "While you aren't wearing Armor you gain +2 AD.",
          "effects": [
            { "type": "MODIFY_STAT", "target": "ad", "value": 2, "condition": "not_wearing_armor" }
          ]
        }
        ```

    *   **Example (`hunter_features.json` -> Favored Terrain -> Grassland):**
        ```json
        // FROM:
        {
          "name": "Grassland",
          "description": "Your Speed and Jump Distance increases by 1."
        }
        // TO:
        {
          "name": "Grassland",
          "description": "Your Speed and Jump Distance increases by 1.",
          "effects": [
            { "type": "MODIFY_STAT", "target": "moveSpeed", "value": 1 },
            { "type": "MODIFY_STAT", "target": "jumpDistance", "value": 1 }
          ]
        }
        ```
    *   **Flavor/In-Game Features**: Features like `Rage` or `Battlecry` that are activated in-game should be mapped to a single `GRANT_ABILITY` effect. Purely descriptive features will have no `effects` array.

**Phase 4: Refactor Calculation Services**
1.  **Rewrite `traitEffectProcessor.ts`:** Rename it to `effectProcessor.ts`. Its new job will be to take the aggregated list of all `Effect` objects (from traits, classes, etc.) and run the "Effect Processing Engine" logic described in the flow above.
2.  **Rewrite `characterCalculator.ts`:**
    *   Remove all regular expression parsing and string manipulation logic.
    *   Implement the "Data Aggregation" step to collect all effects.
    *   Call the new `effectProcessor.ts` to get the summary of modifiers.
    *   Implement the "Final Stat Calculation" step, applying the modifiers to base stats.
    *   Return both the final calculated stats *and* the list of granted abilities.

**Phase 5: Update Frontend State & UI**
1.  **`characterContext.tsx`**: Add state to store the user's choices for effects that require them (e.g., `featureEffectChoices: { 'human_attribute_increase': 'might' }`).
2.  **`ClassFeatures.tsx`**: Modify this component to render new input fields when an `Effect` object contains a `userChoice` property.
3.  **`CharacterSheetClean.tsx`**:
    *   The main stat sections (Defenses, Resources, etc.) will simply display the final calculated values.
    *   The `Features.tsx` component will be updated to receive and display the **Abilities List** generated by the calculator, ensuring all passive and active abilities are visible to the player.

Of course. This is the perfect next step. A comprehensive audit of every choice will create a clear roadmap for the refactor.

I will go through every Ancestry Trait and every Class Feature. For each item, I will list its name, note its current state, and specify the exact changes needed to conform to the new, robust schema.

### Key for the Analysis

*   **✅ Works Well / No Change:** The current implementation is already structured or is purely descriptive (flavor) and doesn't need mechanical changes.
*   **🔄 Needs Refactor to Effects Array:** The feature has mechanical benefits described in a string that must be converted into a machine-readable `effects` array. I will provide the target schema.
*   **ℹ️ In-Game Ability / Flavor:** This feature grants an ability to be used in-game or is purely for roleplaying. It should be mapped to `type: 'GRANT_ABILITY'` so it can be listed on the character sheet, but it won't affect the calculated stat block.

---

### Full Ancestry Trait Analysis (`traits.ts`)


**✅ Works Well:** Your `effects` array on most traits is a solid foundation. The main change is standardizing the `type` and `target` properties for the new universal effect processor.

#### Human Traits
*   `human_attribute_increase`: ✅ **Works Well**. The `userChoiceRequired` is the correct pattern.
*   `human_skill_expertise`: ✅ **Works Well**.
*   `human_resolve`: 🔄 **Needs Refactor (Minor)**. `type: 'MODIFY_DEATH_THRESHOLD_MODIFIER'` should be standardized.
    *   **Proposed:** `effects: [{ type: 'MODIFY_STAT', target: 'deathThresholdModifier', value: 1 }]`
*   `human_undying`: ✅ **Works Well**. Standardize to `type: 'GRANT_ADV_ON_SAVE'`.
*   `human_trade_expertise`: ✅ **Works Well**.
*   `human_determination`: ℹ️ **In-Game Ability**. The effect is conditional and situational.
    *   **Proposed:** `effects: [{ type: 'GRANT_ABILITY', value: 'Once per Combat, you can give yourself ADV on an Attack Check or Spell Check while Bloodied.' }]`
*   `human_unbreakable`: ✅ **Works Well**. Standardize to `type: 'GRANT_ADV_ON_SAVE'`.
*   `human_attribute_decrease`: ✅ **Works Well**.

#### Elf Traits
*   `elf_elven_will`: ✅ **Works Well**. `target` can be an array: `target: ['Charmed', 'Sleep_Magic']`.
*   `elf_nimble`: ℹ️ **In-Game Ability**.
    *   **Proposed:** `effects: [{ type: 'GRANT_ABILITY', value: 'When you take the Dodge Action, you gain the benefits of the Full Dodge Action.' }]`
*   `elf_agile_explorer`: ℹ️ **In-Game Ability**.
    *   **Proposed:** `effects: [{ type: 'GRANT_ABILITY', value: 'You are not affected by Difficult Terrain.' }]`
*   `elf_discerning_sight`: ℹ️ **In-Game Ability**.
    *   **Proposed:** `effects: [{ type: 'GRANT_ADV_ON_CHECK', target: 'Discern Visual Illusions', value: 'ADV' }]`
*   `elf_quick_reactions`: 🔄 **Needs Refactor**.
    *   **Proposed:** `effects: [{ type: 'MODIFY_STAT', target: 'pd', value: 1, condition: 'not_wearing_armor' }]`
*   `elf_peerless_sight`: ℹ️ **In-Game Ability**.
    *   **Proposed:** `effects: [{ type: 'GRANT_ABILITY', value: 'You do not have DisADV on Ranged Weapon Attacks at Long Range.' }]`
*   `elf_climb_speed`: 🔄 **Needs Refactor**.
    *   **Proposed:** `effects: [{ type: 'GRANT_MOVEMENT', target: 'climb', value: 'equal_to_speed' }]`
*   `elf_speed_increase`: 🔄 **Needs Refactor**.
    *   **Proposed:** `effects: [{ type: 'MODIFY_STAT', target: 'moveSpeed', value: 1 }]`
*   `elf_brittle`: 🔄 **Needs Refactor**.
    *   **Proposed:** `effects: [{ type: 'MODIFY_STAT', target: 'ad', value: -1 }]`
*   `elf_frail`: 🔄 **Needs Refactor**.
    *   **Proposed:** `effects: [{ type: 'MODIFY_STAT', target: 'hpMax', value: -2 }]`
*   `elf_might_decrease`: ✅ **Works Well**.

#### Dwarf Traits
*   `dwarf_tough`: 🔄 **Needs Refactor**.
    *   **Proposed:** `effects: [{ type: 'MODIFY_STAT', target: 'hpMax', value: 1 }]`
*   `dwarf_toxic_fortitude`: ✅ **Works Well**.
    *   **Proposed:** `effects: [{ type: 'GRANT_RESISTANCE', target: 'Poison', value: 'half' }, { type: 'GRANT_ADV_ON_SAVE', target: 'Poisoned', value: 'ADV' }]`
*   `dwarf_physically_sturdy`: ✅ **Works Well**. `target` can be an array.
*   `dwarf_iron_stomach`: ℹ️ **In-Game Ability**.
*   `dwarf_thick_skinned`: 🔄 **Needs Refactor**.
    *   **Proposed:** `effects: [{ type: 'MODIFY_STAT', target: 'ad', value: 1, condition: 'not_wearing_armor' }]`
*   `dwarf_natural_combatant`: 🔄 **Needs Refactor**.
    *   **Proposed:** `effects: [{ type: 'GRANT_COMBAT_TRAINING', target: 'Heavy_Armor', value: true }, { type: 'GRANT_COMBAT_TRAINING', target: 'All_Shields', value: true }]`
*   `dwarf_stone_blood`: ℹ️ **In-Game Ability**.
*   `dwarf_minor_tremorsense`: 🔄 **Needs Refactor**.
    *   **Proposed:** `effects: [{ type: 'GRANT_SENSE', target: 'tremorsense', value: 3 }]`
*   `dwarf_stubborn`: ✅ **Works Well**.
*   `dwarf_earthen_knowledge`: ℹ️ **In-Game Ability**.
*   `dwarf_charisma_attribute_decrease`: ✅ **Works Well**.
*   `dwarf_short_legged`: 🔄 **Needs Refactor**.
    *   **Proposed:** `effects: [{ type: 'MODIFY_STAT', target: 'moveSpeed', value: -1 }]`

*(The pattern for other ancestries like Halfling, Gnome, Orc, etc., follows the same logic as above. I will highlight only the most illustrative examples moving forward to maintain clarity.)*

#### Dragonborn Traits
*   `dragonborn_draconic_resistance`: 🔄 **Needs Refactor**. The target depends on the origin choice.
    *   **Proposed:** `effects: [{ type: 'GRANT_RESISTANCE', target: 'origin_damage_type', value: 'half' }]`
*   `dragonborn_draconic_breath_weapon`: ℹ️ **In-Game Ability**.
*   `dragonborn_mana_increase`: 🔄 **Needs Refactor**.
    *   **Proposed:** `effects: [{ type: 'MODIFY_STAT', target: 'mpMax', value: 1 }]`

---

### Part 2: Full Class Feature Analysis (`*_features.json`)

This is where the most significant refactoring is required, as these files currently have no `effects` arrays.

#### Barbarian
*   **Martial Path**: 🔄 **Needs Refactor**.
    *   `combatTraining`: Should be converted to `effects`. `[{ type: 'GRANT_COMBAT_TRAINING', target: 'Weapons', value: true }, ...]`
    *   `maneuvers.learnsAllAttack`: This is a key mechanical rule. `effects: [{ type: 'GRANT_MANEUVERS', value: 'all_attack' }]`
*   **Rage**: ℹ️ **In-Game Ability**. The description is complex and describes a temporary state. It should be granted as an ability for the player to track. `effects: [{ type: 'GRANT_ABILITY', name: 'Rage', description: '...' }]`
*   **Berserker**: 🔄 **Needs Refactor**. This feature has multiple mechanical benefits that need to be broken out.
    *   `Berserker Defense`: `effects: [{ type: 'MODIFY_STAT', target: 'ad', value: 2, condition: 'not_wearing_armor' }]`
    *   `Fast Movement`: `effects: [{ type: 'MODIFY_STAT', target: 'moveSpeed', value: 1, condition: 'not_wearing_armor' }]`
    *   `Mighty Leap`: `effects: [{ type: 'SET_VALUE', target: 'jumpCalculationAttribute', value: 'might' }]`
*   **Shattering Force**: ℹ️ **In-Game Ability**.
*   **Battlecry**: ℹ️ **In-Game Ability** with a player choice.

#### Champion
*   **Master-at-Arms**: 🔄 **Needs Refactor**.
    *   `Maneuver Master`: "learn 2 Maneuvers of your choice" -> `effects: [{ type: 'GRANT_CHOICE', target: 'maneuver', value: 2 }]`
    *   `Technique Master`: "learn 1 Technique of your choice" -> `effects: [{ type: 'GRANT_CHOICE', target: 'technique', value: 1 }]`
*   **Fighting Spirit**: ℹ️ **In-Game Ability**.
*   **Know Your Enemy**: ℹ️ **Flavor/In-Game**.
*   **Adaptive Tactics**: ℹ️ **In-Game Ability**.

#### Cleric
*   **Spellcasting Path**: 🔄 **Needs Refactor**.
    *   `combatTraining`: Convert to `effects` array.
    *   `spellList`: The `betaNote` should be part of the `description`. The list of schools should be structured data.
*   **Cleric Order**: 🔄 **Needs Refactor**.
    *   `Divine Damage`: This is a choice for the player. `effects: [{ type: 'GRANT_CHOICE', target: 'divineDamageType', options: ['Cold', 'Fire', ...] }]`
    *   `Divine Domain`: The main choice. `effects: [{ type: 'GRANT_CHOICE', target: 'divineDomain', value: 2 }]`
*   **Divine Domains (Options within a choice)**: 🔄 **Needs Major Refactor**. Each option needs an `effects` array.
    *   `Magic` option: `effects: [{ type: 'MODIFY_STAT', target: 'mpMax', value: 1 }, { type: 'GRANT_CHOICE', target: 'spellByTag', value: 1 }]`
    *   `Peace` option: `effects: [{ type: 'GRANT_COMBAT_TRAINING', target: 'Heavy_Armor', value: true }, ...]`
    *   `Ancestral` option: `effects: [{ type: 'MODIFY_STAT', target: 'ancestryPoints', value: 2 }]`
*   **Knowledge**: 🔄 **Needs Refactor**.
    *   "Mastery Limit increases by 1 for all Knowledge Trades" -> `effects: [{ type: 'MODIFY_STAT', target: 'knowledgeMasteryLimit', value: 1 }]`
    *   "you gain 2 Skill Points" -> `effects: [{ type: 'MODIFY_STAT', target: 'skillPoints', value: 2 }]`
*   **Divine Blessing**: ℹ️ **In-Game Ability**.

#### Hunter
*   **Favored Terrain**: 🔄 **Needs Major Refactor**. Each option needs an `effects` array.
    *   `Grassland` option: `effects: [{ type: 'MODIFY_STAT', target: 'moveSpeed', value: 1 }, { type: 'MODIFY_STAT', target: 'jumpDistance', value: 1 }]`
    *   `Desert` option: `effects: [{ type: 'GRANT_RESISTANCE', target: 'Fire', value: 'half' }, { type: 'GRANT_RESISTANCE', target: 'Exhaustion_Hot_Temp', value: true }]`
    *   `Subterranean` option: `effects: [{ type: 'GRANT_SENSE', target: 'darkvision', value: 10 }, { type: 'GRANT_SENSE', target: 'tremorsense', value: 3 }]`
*   **Hunter's Mark / Hunter's Strike**: ℹ️ **In-Game Abilities**.
*   **Bestiary**: ℹ️ **Flavor/In-Game**.

#### Monk
*   **Monk Training**: 🔄 **Needs Refactor**.
    *   `Iron Palm`: `effects: [{ type: 'GRANT_ABILITY', name: 'Iron Palm', value: 'Unarmed strikes deal 1 Bludgeoning and have the Impact property.' }]`
    *   `Patient Defense`: `effects: [{ type: 'MODIFY_STAT', target: 'pd', value: 2, condition: 'not_wearing_armor' }]`
    *   `Step of the Wind`: `effects: [{ type: 'MODIFY_STAT', target: 'moveSpeed', value: 1, condition: 'not_wearing_armor' }, { type: 'MODIFY_STAT', target: 'jumpDistance', value: 1, condition: 'not_wearing_armor' }, { type: 'SET_VALUE', target: 'jumpCalculationAttribute', value: 'prime' }]`
*   **Monk Stance**: ℹ️ **In-Game Ability**. This is a choice of which stances you *know*, not a permanent stat change. `effects: [{ type: 'GRANT_CHOICE', target: 'knownStance', value: 2 }]`

#### Rogue
*   **Debilitating Strike**: ℹ️ **In-Game Ability**.
*   **Roguish Finesse**: 🔄 **Needs Refactor**.
    *   `Skill Expertise`: "Your Skill Mastery Limit increases by 1" -> `effects: [{ type: 'MODIFY_STAT', target: 'skillMasteryLimit', value: 1 }]`
    *   `Multi-Skilled`: "You gain 1 Skill Point" -> `effects: [{ type: 'MODIFY_STAT', target: 'skillPoints', value: 1 }]`
*   **Cheap Shot**: ℹ️ **In-Game Ability**.

#### Sorcerer
*   **Innate Power**: 🔄 **Needs Refactor**.
    *   "Your Maximum MP increases by 1" -> `effects: [{ type: 'MODIFY_STAT', target: 'mpMax', value: 1 }, ...]`
*   **Sorcerous Origins (Choice)**: 🔄 **Needs Refactor**. Options need effects.
    *   `Intuitive Magic`: `effects: [{ type: 'MODIFY_STAT', target: 'spellsKnown', value: 1 }, { type: 'MODIFY_STAT', target: 'cantripsKnown', value: 1 }]`
    *   `Resilient Magic`: `effects: [{ type: 'GRANT_RESISTANCE', target: 'Dazed', value: 'condition' }]`
*   **Overload Magic / Meta Magic**: ℹ️ **In-Game Abilities**.

#### Spellblade
*   **Spellblade Disciplines (Choice)**: 🔄 **Needs Major Refactor**.
    *   `Magus` option: `effects: [{ type: 'MODIFY_STAT', target: 'mpMax', value: 1 }, { type: 'MODIFY_STAT', target: 'spellsKnown', value: 1 }]`
    *   `Warrior` option: `effects: [{ type: 'GRANT_COMBAT_TRAINING', ... }, { type: 'GRANT_CHOICE', target: 'maneuver', value: 2 }]`

#### Warlock
*   **Hasty Bargain / Desperate Bargain**: ℹ️ **In-Game Abilities**.
*   **Pact Boon (Choice)**: 🔄 **Needs Major Refactor**. These are complex bundles of effects.
    *   `Pact Armor`: `effects: [{ type: 'GRANT_COMBAT_TRAINING', ... }, { type: 'GRANT_CHOICE', target: 'defensiveManeuver', value: 3 }, { type: 'MODIFY_STAT', target: 'mdr', value: 1 }, ...]`
*   **Life Tap**: ℹ️ **In-Game Ability**.

#### Wizard
*   **Spell School Initiate**: 🔄 **Needs Refactor**.
    *   `School Magic`: This choice depends on another choice (which school). This is a dependent choice.
        *   The feature grants a choice: `effects: [{ type: 'GRANT_CHOICE', target: 'wizardSchool', options: ['Abjuration', 'Conjuration', ...] }]`
        *   A separate effect would be: `effects: [{ type: 'GRANT_SPELL', count: 1, filter: { school: 'wizardSchool' } }, { type: 'GRANT_CANTRIP', count: 1, filter: { school: 'wizardSchool' } }]`
*   **Arcane Sigil / Prepared Spell**: ℹ️ **In-Game Abilities**.

---

#### **5. The Complete, Definitive Data Schema**

Based on the comprehensive analysis above, here is the full, production-ready schema designed to make all character creation choices machine-readable and robust.

This schema is presented as a set of TypeScript interfaces, which can be placed in `src/lib/rulesdata/schemas/character.schema.ts`. It consolidates and formalizes all the concepts discussed throughout this plan.

The core of this architecture is the Effect interface, a universal model for describing any mechanical change to a character.

```typescript
/**
 * @file src/lib/rulesdata/schemas/character.schema.ts
 * @description The definitive schema for all character creation data, designed for robust, machine-readable processing.
 */

// ================================================================= //
// I. CORE EFFECT MODEL - The Heart of the System
// ================================================================= //

/**
 * A universal, machine-readable representation of a single mechanical effect.
 * This can be attached to traits, class features, choices, items, etc.
 */
export interface Effect {
  /** The action to be performed by the calculation engine. */
  type:
    // --- Stat & Attribute Modification ---
    | 'MODIFY_ATTRIBUTE'        // Modifies a core attribute (Might, Agility, etc.).
    | 'MODIFY_STAT'             // Modifies a derived or resource stat (hpMax, pd, moveSpeed, etc.).
    | 'SET_VALUE'               // Overrides a stat with a specific value or another stat's value.

    // --- Grants & Abilities ---
    | 'GRANT_ABILITY'           // Grants a descriptive, in-game ability or feature.
    | 'GRANT_RESISTANCE'        // Grants resistance to damage types or conditions.
    | 'GRANT_VULNERABILITY'     // Grants vulnerability to a damage type.
    | 'GRANT_ADV_ON_SAVE'       // Grants advantage on saves against specific conditions or types.
    | 'GRANT_ADV_ON_CHECK'      // Grants advantage on specific skill/ability checks.
    | 'GRANT_COMBAT_TRAINING'   // Grants proficiency with armor, weapons, or shields.
    | 'GRANT_MOVEMENT'          // Grants a special movement type like Climb or Swim.
    | 'GRANT_SENSE'             // Grants a sense like Darkvision or Tremorsense.

    // --- Choices & Progression ---
    | 'GRANT_CHOICE'            // Grants the player a choice (e.g., learn 2 maneuvers).
    | 'GRANT_SKILL_EXPERTISE'   // A specific effect for Human/Rogue skill expertise.
    | 'GRANT_TRADE_EXPERTISE'   // A specific effect for Human trade expertise.
    | 'GRANT_SPELL'             // Grants a known spell.
    | 'GRANT_CANTRIP'           // Grants a known cantrip.
    ;

  /** The specific stat, attribute, or item being affected. Standardized for the calculator. */
  target: string; // e.g., 'might', 'hpMax', 'pd', 'ad', 'moveSpeed', 'jumpDistance', 'deathThresholdModifier', 'skillPoints', 'ancestryPoints', 'maneuver', 'technique', 'Poison', 'Charmed', 'Heavy_Armor', 'climb', 'darkvision', 'any_attribute', 'any_skill'

  /** The value of the effect. Can be a number, string, or complex object. */
  value: number | string | boolean | { [key: string]: any }; // e.g., 1, -1, 'half', 'equal_to_speed', true, { capIncrease: 1, levelIncrease: 1 }

  /** An optional condition under which this effect is active. */
  condition?: string; // e.g., 'not_wearing_armor', 'bloodied'

  /** If this effect requires a choice from the player to be resolved. */
  userChoice?: {
    prompt: string;
    options?: string[]; // e.g., ['might', 'agility', 'charisma', 'intelligence']
  };
}


// ================================================================= //
// II. ANCESTRY & TRAIT SCHEMAS
// ================================================================= //

export interface Trait {
  id: string;
  name: string;
  description: string;
  cost: number;
  isMinor?: boolean;
  isNegative?: boolean;
  prerequisites?: string[];
  effects: Effect[]; // Every mechanical benefit is now an Effect.
}

export interface Ancestry {
  id: string;
  name: string;
  description: string;
  defaultTraitIds: string[];
  expandedTraitIds: string[];
  origin?: {
    prompt: string;
    options: string[];
  };
  variantTraits?: Trait[];
}


// ================================================================= //
// III. CLASS & FEATURE SCHEMAS
// ================================================================= //

/** A named benefit within a larger class feature, containing its own effects. */
export interface FeatureBenefit {
  name: string;
  description: string;
  effects: Effect[];
}

/** An option a player can select as part of a feature choice. */
export interface FeatureChoiceOption {
  name: string;      // The value/ID of the option.
  description: string;
  effects: Effect[]; // Effects granted if this specific option is chosen.
}

/** A choice presented to the player by a class feature. */
export interface FeatureChoice {
  id: string; // A unique ID for this choice, e.g., "cleric_divine_domain_choice"
  prompt: string;
  count: number; // Number of options the player must select.
  options: FeatureChoiceOption[];
}

/** A single class feature, either core or from a subclass. */
export interface ClassFeature {
  featureName: string;
  levelGained: number;
  description: string;
  isFlavor?: boolean;
  /** Direct effects of the feature, applied automatically. */
  effects?: Effect[];
  /** Named sub-sections of a feature, each with its own effects. */
  benefits?: FeatureBenefit[];
  /** Choices the player must make to fully define the feature. */
  choices?: FeatureChoice[];
}

/** A subclass option for a given class. */
export interface Subclass {
  subclassName: string;
  description?: string;
  features: ClassFeature[];
}

/** The complete, robust definition for a single class. */
export interface ClassDefinition {
  className: string;
  // This section contains data derived from the level progression table for easy access at Lvl 1.
  startingStats: {
      hp: number;
      sp: number;
      mp: number;
      skillPoints: number;
      tradePoints: number;
      languagePoints: number;
      maneuversKnown: number;
      techniquesKnown: number;
      cantripsKnown: number;
      spellsKnown: number;
  };
  coreFeatures: ClassFeature[];
  subclasses: Subclass[];
}

---

#### **6. How It All Works Together: An Example Flow**

This schema creates a powerful and predictable system. Here's how the data flows during character creation and calculation for a Level 1 Human Barbarian:

**Player Choices (Input):**

1. **Ancestry**: `human`
2. **Class**: `barbarian`
3. **Trait Choice**: Player selects `human_attribute_increase`. The UI prompts with "Choose an Attribute...". The player selects "Might". The frontend stores this choice: `{ 'human_attribute_increase_effect_0': 'might' }`.
4. **Attribute Buy**: The player sets their base attributes.

**Effect Aggregation (The "What"):**

The `characterCalculator` starts. It gathers all Effect objects from the player's choices.

- From `human` ancestry → `human_resolve` trait → `effects: [{ type: 'MODIFY_STAT', target: 'deathThresholdModifier', value: 1 }]`
- From `human_attribute_increase` trait → `effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'any_attribute', ... }]`. The calculator sees the `userChoice` and resolves `target` to `'might'`.
- From `barbarian` class → `Berserker` feature → `Berserker Defense` benefit → `effects: [{ type: 'MODIFY_STAT', target: 'ad', value: 2, condition: 'not_wearing_armor' }]`

...and so on, for every single chosen item.

**Effect Processing (The "How"):**

The calculator now has a flat list of resolved Effect objects. It iterates through this list.

- It sees `{ type: 'MODIFY_ATTRIBUTE', target: 'might', value: 1 }` and adds +1 to a running total for Might modifications.
- It sees `{ type: 'MODIFY_STAT', target: 'deathThresholdModifier', value: 1 }` and adds +1 to a running total for the death threshold modifier.
- It sees `{ type: 'MODIFY_STAT', target: 'ad', value: 2, condition: 'not_wearing_armor' }` and stores this as a conditional modifier to be evaluated by the UI.
- It sees `GRANT_ABILITY` effects and collects their descriptions to be displayed in the "Features" list on the character sheet.

**Final Calculation (The Result):**

The calculator takes the base stats (from point buy and class table) and applies the aggregated modifiers.

- `finalMight = base_might + 1`
- `finalDeathThreshold = 10 + 1`
- `finalAD = (8 + CM + finalMight + finalCharisma)` (The conditional +2 is not applied here, but passed to the UI to handle).

This structured approach ensures that every mechanical bonus is accounted for correctly and separates the rules data from the calculation logic, which is the core of a robust and maintainable system.

---

#### **7. Implementation Recommendations & Technical Considerations**

**Key Improvements in This Final Schema:**

1. **Comprehensive Effect Coverage**: All missing effect types have been added (`GRANT_MOVEMENT`, `GRANT_SENSE`, `GRANT_CANTRIP`, etc.)
2. **Hierarchical Structure**: Clear modeling of classes → features → benefits/choices → options
3. **Flexible Value System**: Accommodates simple numbers and complex objects
4. **User Choice Resolution**: Clean pattern for handling player decisions

**Technical Recommendations:**

1. **Effect Resolution Order**: Process `MODIFY_*` effects before `SET_VALUE` effects to handle potential conflicts
2. **Choice Storage Pattern**: Consider using more intuitive keys like `{ 'human_attribute_increase': { attribute: 'might' } }`
3. **Runtime Validation**: Add validation functions for effect targets and values
4. **Type Safety**: Consider making common targets type-safe with union types

**Implementation Strategy:**

1. **Start Small**: Begin with Human traits and Barbarian class to validate the approach
2. **Build Core Processor**: Create the effect aggregation and processing engine first
3. **Add Validation**: Implement schema validation early to catch data errors
4. **Incremental Migration**: Convert one class at a time to reduce risk

This schema provides a solid foundation for a robust, maintainable character creation system that can scale to handle any future game mechanics through data definition rather than code changes.

---

#### **8. Phase 1 Proof of Concept: Safe Parallel Development Strategy**

**The Challenge:** Modifying the existing data files will break the current system before we have a working replacement. We need a strategy that allows incremental development without breaking the build or rendering system.

**The Solution:** Create a parallel development environment that preserves the existing system while building the new one alongside it.

### **Step 1: Backup & Isolate Current System**

```bash
# Create backup directories
mkdir -p src/lib/rulesdata/_backup_original
mkdir -p src/lib/rulesdata/_new_schema

# Backup critical files
mv src/lib/rulesdata/ancestries.ts src/lib/rulesdata/_backup_original/
mv src/lib/rulesdata/classes/ src/lib/rulesdata/_backup_original/
mv src/lib/rulesdata/loaders/ src/lib/rulesdata/_backup_original/
mv src/lib/services/characterCalculator.ts src/lib/services/_backup_characterCalculator.ts
mv src/lib/services/traitEffectProcessor.ts src/lib/services/_backup_traitEffectProcessor.ts
```

### **Step 2: Create Minimal Legacy Stubs**

Create minimal files that keep the current system working:

```typescript
// src/lib/rulesdata/ancestries.ts (minimal stub)
export interface IAncestry {
  id: string;
  name: string;
  description: string;
  defaultTraitIds: string[];
  expandedTraitIds: string[];
  origin?: { prompt: string; options: string[]; };
}

export interface ITrait {
  id: string;
  name: string;
  description: string;
  cost: number;
  isMinor?: boolean;
  isNegative?: boolean;
  prerequisites?: string[];
  effects?: any[]; // Keep loose for now
}

// Just include Human for testing
export const ancestries: IAncestry[] = [
  {
    id: "human",
    name: "Human",
    description: "Adaptable and ambitious.",
    defaultTraitIds: ["human_attribute_increase", "human_skill_expertise"],
    expandedTraitIds: ["human_resolve", "human_undying", "human_trade_expertise", "human_determination", "human_unbreakable", "human_attribute_decrease"]
  }
];

export const traits: ITrait[] = [
  {
    id: "human_attribute_increase",
    name: "Attribute Increase",
    description: "Choose one Attribute. That Attribute increases by 1.",
    cost: 0,
    effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'any_attribute', value: 1, userChoiceRequired: true }]
  },
  {
    id: "human_skill_expertise", 
    name: "Skill Expertise",
    description: "Choose one Skill. Your Mastery Limit with that Skill increases by 1, and you gain 1 level in that Skill.",
    cost: 0,
    effects: [{ type: 'GRANT_SKILL_EXPERTISE', target: 'any_skill', value: { capIncrease: 1, levelIncrease: 1 }, userChoiceRequired: true }]
  }
];

// Re-export functions that other files expect
export const getAncestryData = (id: string) => ancestries.find(a => a.id === id);
export const getTraitData = (id: string) => traits.find(t => t.id === id);
```

### **Step 3: Create Minimal Class Stubs**

```typescript
// src/lib/rulesdata/loaders/class.loader.ts (minimal stub)
export const classesData = [
  {
    name: "barbarian",
    id: "barbarian",
    description: "A fierce warrior.",
    startingStats: {
      hp: 10,
      sp: 6,
      mp: 0,
      skillPoints: 4,
      tradePoints: 3,
      languagePoints: 2,
      maneuversKnown: 2,
      techniquesKnown: 1,
      cantripsKnown: 0,
      spellsKnown: 0
    }
  }
];

export const getClassData = async (classId: string) => {
  return classesData.find(c => c.id === classId);
};
```

### **Step 4: Environment-Based Feature Toggle**

```typescript
// src/lib/config/features.ts
export const FEATURES = {
  NEW_EFFECT_SYSTEM: process.env.NODE_ENV === 'development' && process.env.VITE_NEW_EFFECTS === 'true'
};
```

```bash
# Add to .env.local for development
VITE_NEW_EFFECTS=true
````

## File: eslint.config.js
````javascript
import prettier from 'eslint-config-prettier';
import { includeIgnoreFile } from '@eslint/compat';
import js from '@eslint/js';
import globals from 'globals';
import { fileURLToPath } from 'node:url';
import ts from 'typescript-eslint';

const gitignorePath = fileURLToPath(new URL('./.gitignore', import.meta.url));

export default ts.config(
	includeIgnoreFile(gitignorePath),
	js.configs.recommended,
	...ts.configs.recommended,
	prettier,
	{
		languageOptions: {
			globals: { ...globals.browser, ...globals.node }
		},
		rules: {
			// typescript-eslint strongly recommend that you do not use the no-undef lint rule on TypeScript projects.
			// see: https://typescript-eslint.io/troubleshooting/faqs/eslint/#i-get-errors-from-the-no-undef-rule-about-global-variables-not-being-defined-even-though-there-are-no-typescript-errors
			'no-undef': 'off'
		}
	}
);
````

## File: IMPLEMENTATION_COMPLETE.md
````markdown
# ✅ ENHANCED CHARACTER SYSTEM - IMPLEMENTATION COMPLETE

## 🎉 **MAJOR MILESTONE ACHIEVED**

The comprehensive character data schema refactor with enhanced UI has been **successfully implemented**! The system has been transformed from text-based descriptions to a fully structured, machine-readable effect system with real-time validation and detailed attribution.

---

## 🚀 **WHAT'S BEEN IMPLEMENTED**

### **✅ PHASE 1: Foundation (COMPLETE)**
- **Enhanced Types System** (`src/lib/types/effectSystem.ts`)
  - Comprehensive `Effect` interface with 15+ effect types
  - `AttributedEffect` with source tracking and resolution status
  - `EnhancedStatBreakdown` for detailed tooltips
  - `ValidationResult` for real-time feedback
  - `UnresolvedChoice` for character creation UI

### **✅ PHASE 2: State Management (COMPLETE)**
- **Enhanced Character Context** (`src/lib/stores/characterContext.tsx`)
  - Added `selectedTraitChoices` storage (JSON format)
  - Added `cachedEffectResults` for performance
  - New action types: `SET_TRAIT_CHOICES`, `UPDATE_TRAIT_CHOICE`, `INVALIDATE_CACHE`
  - Full reducer implementation with cache invalidation

### **✅ PHASE 3: Calculation Engine (COMPLETE)**
- **Enhanced Calculator** (`src/lib/services/enhancedCharacterCalculator.ts`)
  - Unified calculation with effect attribution
  - Complete trait and class feature processing
  - User choice resolution system
  - Detailed stat breakdowns for tooltips
  - Comprehensive validation system
- **React Hook** (`src/lib/hooks/useEnhancedCharacterCalculation.ts`)
  - Real-time calculations with caching
  - Validation helpers for UI components
  - Effect preview generation
  - Cache control functions

### **✅ PHASE 4: Character Creation UI (COMPLETE)**
- **Trait Choice Selector** (`src/routes/character-creation/components/TraitChoiceSelector.tsx`)
  - Dynamic choice UI for traits requiring user input
  - Real-time validation with clear error messages
  - Effect previews showing impact of choices
  - Support for attribute, skill, and trade choices
- **Enhanced Ancestry Selection** (`src/routes/character-creation/SelectedAncestries.tsx`)
  - Integrated trait choice selectors
  - Appears when traits are selected and require choices
  - Full validation integration
- **Enhanced Attributes Page** (`src/routes/character-creation/Attributes.tsx`)
  - Real-time validation including trait bonuses
  - Detailed breakdowns showing base + trait bonuses
  - Smart button disabling when limits would be exceeded
  - Clear warning messages about trait bonus impacts

### **✅ PHASE 5: Character Sheet Enhancements (COMPLETE)**
- **Enhanced Tooltips** (`src/routes/character-sheet/components/EnhancedStatTooltips.tsx`)
  - Detailed breakdowns showing exact sources
  - Conditional effect handling
  - Proper DC20 formula attribution
  - Fallback calculations for compatibility
- **Enhanced Features Display** (`src/routes/character-sheet/components/EnhancedFeatures.tsx`)
  - Categorized abilities (Passive, Active, Resistance, Advantage)
  - Clear source attribution with color-coded badges
  - Conditional modifiers section
  - Professional UI with proper styling

---

## 🎯 **KEY ACHIEVEMENTS**

### **🛡️ Reliability Achieved**
- **BEFORE**: `"grants +1 to AD"` could break if wording changed
- **AFTER**: `{ type: 'MODIFY_STAT', target: 'ad', value: 1 }` is unambiguous

### **🔧 Maintainability Achieved**
- **BEFORE**: New effects required code changes in calculator
- **AFTER**: New effects are pure data - no code changes needed

### **📈 Scalability Achieved**
- **BEFORE**: Complex conditional effects nearly impossible
- **AFTER**: `condition: 'not_wearing_armor'` handles any condition

### **🔍 Clarity Achieved**
- **BEFORE**: Effect sources hidden in calculation code
- **AFTER**: Every bonus shows exactly where it came from

---

## 🎮 **USER EXPERIENCE TRANSFORMATION**

### **Character Creation Flow**
```
1. Select Human → Ancestry traits appear
2. Check "Attribute Increase" → Choice selector appears
3. Click [Might] → Real-time validation + preview
4. Go to Attributes → See "Might: 2 + 1 (trait) = 3/3 ✅"
5. Try to increase Might → Button disabled with tooltip
```

### **Character Sheet Experience**
```
1. Hover over HP "14" → Detailed tooltip:
   "Hit Points: 14
    ├─ Base: 10
    ├─ Might: +3  
    └─ Dwarf Tough: +1"

2. View Features → Organized by category:
   🛡️ Passive: Berserker Defense (+2 AD when not wearing armor)
   ⚡ Active: Rage (spend 1 AP + 1 SP for benefits)
   ⚠️ Conditional: +2 AD while not wearing armor
```

---

## 📊 **TECHNICAL SPECIFICATIONS**

### **Data Flow Architecture**
```
Character Creation → Enhanced State → Calculation Engine → Character Sheet
     ↓                    ↓              ↓                    ↓
Trait Choices      JSON Storage     Effect Processing    Tooltip Display
Real-time Validation Cache Management Attribution Tracking Source Links
Effect Previews    State Updates    Breakdown Creation   Conditional UI
```

### **Performance Features**
- **Intelligent Caching**: Results cached for 5 seconds with automatic invalidation
- **Parallel Processing**: Multiple validation checks run simultaneously
- **Efficient Updates**: Only recalculates when relevant state changes
- **Lazy Loading**: Effect previews generated on-demand

### **Validation System**
- **Attribute Limits**: Real-time checking of base + trait bonuses ≤ 3
- **Choice Validation**: Prevents invalid selections with clear messaging
- **Point Budgets**: Ancestry point validation with overflow prevention
- **Mastery Limits**: Skill/trade mastery cap enforcement

---

## 🧪 **DEMONSTRATION RESULTS**

### **Test Character: "Thorgar the Enhanced"**
- **Human Barbarian Level 1**
- **Trait Choices**: Might +1, Athletics Expertise, Determination
- **Final Stats**: 
  - Might: 3/3 (2 base + 1 trait) ✅
  - HP: 13, AD: 12, PD: 11
  - 9 Granted Abilities with source attribution
  - 2 Conditional Modifiers properly tracked

### **System Validation**
- ✅ All trait choices resolved correctly
- ✅ Attribute limits enforced properly  
- ✅ Effect attribution working perfectly
- ✅ Conditional modifiers tracked accurately
- ✅ No unresolved choices remaining

---

## 🛠️ **INTEGRATION READINESS**

### **Ready for Production**
- ✅ No linting errors across all files
- ✅ TypeScript definitions complete
- ✅ Backwards compatibility maintained
- ✅ Comprehensive error handling
- ✅ Performance optimizations active

### **Migration Path**
The new system runs in parallel with the existing system. To integrate:

1. **Enable New System**: Update imports to use enhanced components
2. **Gradual Rollout**: Can be enabled per-component for testing
3. **Full Migration**: Switch all components to enhanced versions
4. **Cleanup**: Remove old calculation logic once validated

---

## 🎯 **NEXT STEPS (OPTIONAL ENHANCEMENTS)**

### **Short Term**
- Migrate remaining classes (Champion, Cleric, Hunter, etc.)
- Add remaining ancestries (Halfling, Gnome, Orc, etc.)
- Implement feature flag system for gradual rollout

### **Long Term**  
- Admin interface for non-technical rule editing
- Advanced conditional effect builder
- Import/export character builds
- Rule validation tools

---

## 🏆 **IMPACT SUMMARY**

This implementation represents a **fundamental transformation** of the character creation system:

- **User Experience**: From confusing text parsing to crystal-clear effect attribution
- **Developer Experience**: From brittle string manipulation to robust data structures  
- **Maintainability**: From code changes for new effects to pure data definitions
- **Scalability**: From limited conditional support to unlimited complexity handling

**The system now provides a rock-solid foundation for any future DC20 mechanics through data definition rather than code changes.**

---

## 🎉 **MISSION ACCOMPLISHED**

The enhanced character system is **fully operational** and ready to provide users with:
- ✅ Real-time trait choice validation
- ✅ Detailed effect breakdowns in tooltips  
- ✅ Clear source attribution for all bonuses
- ✅ Professional, mistake-proof UI
- ✅ Complete transparency in character building

**The vision of a robust, maintainable, and scalable character creation system has been successfully realized!** 🚀
````

## File: index.html
````html
<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>DC20 Character Creator</title>
	</head>
	<body>
		<div id="root"></div>
		<script type="module" src="/src/main.tsx"></script>
	</body>
</html>
````

## File: project_summary.md
````markdown
# Project Summary

This document provides a comprehensive overview of the Svelte library project, including its purpose, technology stack, and structure.

## Overview

This project is a Svelte-based library starter, designed to provide a foundation for developing and publishing reusable Svelte components. It includes a full development environment with a showcase application, a robust testing suite, and a database setup, making it suitable for building complex, data-driven libraries.

## Technology Stack

The project leverages a modern technology stack, including:

- **Framework**: [SvelteKit](https://kit.svelte.dev/)
- **Language**: [TypeScript](https://www.typescriptlang.org/)
- **Bundler**: [Vite](https://vitejs.dev/)
- **Styling**: [Tailwind CSS](https://tailwindcss.com/)
- **Database**: [PostgreSQL](https://www.postgresql.org/) with [Prisma ORM](https://www.prisma.io/)
- **Authentication**: Inferred to be [Lucia Auth](https://lucia-auth.com/) based on file structure and dependencies
- **Testing**:
  - **Unit Testing**: [Vitest](https://vitest.dev/)
  - **E2E Testing**: [Playwright](https://playwright.dev/)

## Project Structure

The project is organized into the following key directories:

- `src/lib`: Contains the core library code intended for packaging and distribution.
- `src/routes`: A showcase application for demonstrating the library's features.
- `src/routes/demo/lucia`: Includes pages and server-side logic for handling user authentication.
- `src/lib/server/auth.ts`: Server-side authentication logic.
- `src/lib/server/db`: Database schema and connection management.
- `e2e`: End-to-end tests for the showcase application.

## Key Scripts

The `package.json` file defines several important scripts for managing the project:

- `dev`: Starts the development server for the showcase app.
- `build`: Creates a production build of the showcase app.
- `package`: Packages the `src/lib` directory into a distributable format.
- `test`: Executes both unit and end-to-end tests.
- `db:*`: A set of scripts for managing the PostgreSQL database, including starting the container, applying schema changes, and running migrations.
````

## File: REFACTOR_SUMMARY.md
````markdown
# Character Data Schema Refactor - COMPLETED ✅

## Executive Summary

Successfully implemented the unified Effect system that transforms the character creation system from text-based descriptions to structured, machine-readable data. The new system eliminates brittle regex parsing and enables reliable, maintainable character calculations.

## What Was Accomplished

### ✅ Phase 1: Unified Effect Schema
- Created comprehensive `Effect` interface in `/src/lib/rulesdata/schemas/character.schema.ts`
- Defined 20+ effect types covering all character mechanics
- Added supporting types for `StatModifiers`, `GrantedAbility`, `ConditionalModifier`, etc.

### ✅ Phase 2: Ancestry Traits Migration  
- Migrated Human, Elf, and Dwarf traits to new schema in `/src/lib/rulesdata/_new_schema/traits.ts`
- Converted text descriptions to structured Effect objects
- Standardized effect types and targets (e.g., `MODIFY_STAT`, `GRANT_ABILITY`)

### ✅ Phase 3: Class Features Migration
- Migrated Barbarian class features to new schema in `/src/lib/rulesdata/_new_schema/barbarian_features.ts`
- Converted complex features like Rage, Berserker, and Battlecry to structured effects
- Implemented choice system for subclass options and feature selections

### ✅ Phase 4: Calculation Engine Refactor
- Built new `effectProcessor.ts` that processes Effect objects without text parsing
- Created new `characterCalculator.ts` that aggregates effects and calculates final stats
- Implemented choice resolution system for user selections

### ✅ Phase 5: Working Demonstration
- Created successful demo showing Level 1 Human Barbarian calculation
- All stats calculated correctly: HP, defenses, attributes, abilities
- System properly handles conditional modifiers and user choices

## Key Benefits Achieved

### 🛡️ **Reliability**
- **Before:** "grants +1 to AD" vs "AD increases by 1" could break calculations
- **After:** `{ type: 'MODIFY_STAT', target: 'ad', value: 1 }` is unambiguous

### 🔧 **Maintainability** 
- **Before:** Adding new effects required code changes in calculator
- **After:** New effects are pure data - no code changes needed

### 📈 **Scalability**
- **Before:** Complex conditional effects were nearly impossible to represent
- **After:** `condition: 'not_wearing_armor'` handles any condition cleanly

### 🔍 **Clarity**
- **Before:** Effect mechanics hidden in text requiring code cross-reference
- **After:** JSON definition shows exact mechanical impact at a glance

## Technical Architecture

```
CharacterBuildData → aggregateAllEffects() → processEffects() → CalculatedCharacterStats
                          ↓                      ↓                      ↓
                    All Effect[]           StatModifiers         Final Character
                   (traits, classes,      GrantedAbility[]      (HP, PD, AD, etc.)
                    user choices)        ConditionalModifier[]
```

## Demo Results

Successfully calculated Level 1 Human Barbarian "Thorgar the Mighty":
- **Attributes:** Might 4, Agility 2, Charisma 1, Intelligence 0  
- **HP/Resources:** 14 HP, 8 SP, 0 MP
- **Defenses:** PD 11, AD 14 (16 without armor), PDR 0
- **Abilities:** 14 granted abilities including Rage, Determination, Combat Training
- **Conditional Effects:** +2 AD and +1 Speed while not wearing armor

## Impact

This refactor establishes a **robust foundation** for character creation that can handle:
- Any future class or ancestry additions
- Complex multi-conditional effects
- Dynamic rule changes without code modifications
- Clear separation between game rules (data) and calculation logic (code)

The system successfully eliminates the primary technical debt in character calculation while maintaining full compatibility with existing DC20 rules.

## Next Steps (Future Implementation)

1. Migrate remaining ancestries (Halfling, Gnome, Orc, Dragonborn, etc.)
2. Migrate remaining classes (Champion, Cleric, Hunter, etc.)
3. Update frontend components to use new calculation engine
4. Add validation and error handling for effect definitions
5. Create admin tools for non-technical rule editing

**Status: Core refactor complete and validated ✅**
````

## File: repomix.config.json
````json
{
	"input": {
		"maxFileSize": 52428800
	},
	"output": {
		"filePath": "repomix-output.md",
		"style": "markdown",
		"parsableStyle": false,
		"fileSummary": true,
		"directoryStructure": true,
		"files": true,
		"removeComments": false,
		"removeEmptyLines": false,
		"compress": false,
		"topFilesLength": 5,
		"showLineNumbers": false,
		"copyToClipboard": false,
		"git": {
			"sortByChanges": true,
			"sortByChangesMaxCommits": 100
		}
	},
	"include": [],
	"ignore": {
		"useGitignore": true,
		"useDefaultPatterns": true,
		"customPatterns": []
	},
	"security": {
		"enableSecurityCheck": true
	},
	"tokenCount": {
		"encoding": "o200k_base"
	}
}
````

## File: tsconfig.json
````json
{
	"compilerOptions": {
		"target": "ES2020",
		"useDefineForClassFields": true,
		"lib": ["ES2020", "DOM", "DOM.Iterable"],
		"types": ["vite/client"],
		"module": "ESNext",
		"skipLibCheck": true,
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"resolveJsonModule": true,
		"isolatedModules": true,
		"noEmit": true,
		"jsx": "react-jsx",
		"strict": true,
		"noUnusedLocals": true,
		"noUnusedParameters": true,
		"noFallthroughCasesInSwitch": true,
		"allowJs": true,
		"checkJs": true,
		"esModuleInterop": true,
		"forceConsistentCasingInFileNames": true,
		"sourceMap": true
	},
	"include": ["src", "pdf-service"],
	"references": [{ "path": "./tsconfig.node.json" }]
}
````

## File: tsconfig.node.json
````json
{
	"compilerOptions": {
		"composite": true,
		"tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
		"skipLibCheck": true,
		"module": "ESNext",
		"moduleResolution": "bundler",
		"allowSyntheticDefaultImports": true,
		"strict": true,
		"noEmit": true
	},
	"include": ["vite.config.ts"]
}
````

## File: UI_TESTING_GUIDE.md
````markdown
# 🎯 **UI Testing Guide for Enhanced Effect System**

## ✅ **What's Available for Testing**

### **Ancestries (Complete)**:
- ✅ **Human** - All traits fully migrated with user choices
- ✅ **Elf** - All traits migrated with conditional effects
- ✅ **Dwarf** - All traits migrated with resistances and abilities

### **Classes (Complete)**:
- ✅ **Barbarian** - Rage, Berserker features, conditional AD/PD bonuses
- ✅ **Cleric** - Divine domains, spellcasting, divine damage choices
- ✅ **Hunter** - Favored terrain choices, Hunter's Mark, terrain bonuses

---

## 🚀 **How to Test in the UI**

### **1. Switch to Enhanced System**

The enhanced system is automatically used in character creation. The system will:
- ✅ **Auto-detect** when creating characters with available classes/ancestries
- ✅ **Show choice prompts** for effects requiring user input
- ✅ **Display real-time calculations** with the new formulas
- ✅ **Render tooltips** with detailed breakdowns

### **2. Test Scenarios**

#### **🏃 Scenario 1: Human Barbarian (Choice Testing)**
```
1. Create new character
2. Select "Human" ancestry
3. Select "Barbarian" class
4. In traits: Choose "Human Attribute Increase"
   ▶️ You should see a dropdown to choose which attribute
5. Set base attributes (try Might +3)
6. Check character sheet calculations
```

**Expected Results:**
- ✅ HP = Might + Level progression + bonuses (should be ~12 at level 1)
- ✅ Death threshold = Prime attribute + Combat Mastery (should be 4)
- ✅ AD shows conditional bonus when not wearing armor
- ✅ Rage and Battlecry appear in Features section

#### **🧙 Scenario 2: Elf Cleric (Multiple Choices)**
```
1. Create new character  
2. Select "Elf" ancestry
3. Select "Cleric" class
4. Choose Divine Damage type (Fire/Cold/Lightning/etc.)
5. Choose 2 Divine Domains (Life, Magic, War, etc.)
6. Check tooltips on character sheet
```

**Expected Results:**
- ✅ MP = Level progression + Domain bonuses
- ✅ Divine abilities appear in Features
- ✅ Combat training from War/Peace domains if chosen
- ✅ Conditional PD bonus from Elf Quick Reactions

#### **🏹 Scenario 3: Dwarf Hunter (Complex Choices)**
```
1. Create new character
2. Select "Dwarf" ancestry  
3. Select "Hunter" class
4. Choose 2 Favored Terrains (Mountain, Subterranean recommended)
5. Check granted movement abilities and senses
```

**Expected Results:**
- ✅ Climb speed from Mountain terrain
- ✅ Darkvision + Tremorsense from Subterranean
- ✅ Poison resistance from Dwarf traits
- ✅ Combat training with Heavy Armor from Dwarf

---

## 🔍 **Testing the Enhanced Features**

### **Choice UI Testing**
- ✅ **Human Attribute Increase**: Dropdown with all attributes
- ✅ **Cleric Divine Damage**: Radio buttons for damage types
- ✅ **Divine Domains**: Multi-select with exactly 2 choices
- ✅ **Favored Terrain**: Multi-select with exactly 2 choices

### **Real-Time Calculation Testing**
- ✅ **Attribute limits**: Should show total and breakdown (base + bonuses)
- ✅ **HP calculation**: Should use new formula (Might + progression + bonuses)
- ✅ **Defense calculations**: Should include trait bonuses
- ✅ **Conditional effects**: Should appear with condition indicators

### **Tooltip Testing**
1. Hover over **HP** → Should show "Might + Level HP + bonuses"
2. Hover over **Death Threshold** → Should show "Prime + Combat Mastery"
3. Hover over **Jump Distance** → Should show "Agility + modifiers"
4. Hover over **AD/PD** → Should show conditional bonuses

### **Character Sheet Display**
- ✅ **Features section**: Should list all granted abilities
- ✅ **Resistances**: Should show granted resistances (Dwarf Poison, etc.)
- ✅ **Movement**: Should show special movement types (Climb, Swim)
- ✅ **Senses**: Should show Darkvision, Tremorsense if granted

---

## 🧪 **Advanced Testing**

### **Multi-Level Testing**
```
1. Create a character at Level 1
2. Level up to Level 2
3. Check HP progression (should add from class table)
4. Verify all bonuses still apply correctly
```

### **Edge Case Testing**
```
1. Test negative attributes (Charisma -1, etc.)
2. Test Grit calculation with negative Charisma (should be minimum 0)
3. Test multiple ancestry traits at once
4. Test choice dependencies (traits affecting each other)
```

### **Cross-Class Testing**
```
1. Create all three class combinations:
   - Human Barbarian, Elf Barbarian, Dwarf Barbarian
   - Human Cleric, Elf Cleric, Dwarf Cleric  
   - Human Hunter, Elf Hunter, Dwarf Hunter
2. Verify trait + class feature interactions work correctly
```

---

## 🎮 **Quick Start Commands**

### **Test the Enhanced Calculator Directly**
```bash
cd /Users/yasafv/projects/dc20clean
npx tsx src/lib/rulesdata/_new_schema/demo_expanded.ts
```

### **Check Specific Character Builds**
```javascript
// In browser console or test script:
import { useEnhancedCharacterCalculation } from 'src/lib/hooks/useEnhancedCharacterCalculation';

// The hook provides:
// - Real-time calculated stats
// - Attribute limits and validation  
// - Detailed breakdowns for tooltips
// - Granted abilities list
```

---

## 🚨 **What to Watch For**

### **Should Work ✅**
- Choice dropdowns appear for user choices
- Real-time stat updates when making selections
- Tooltip breakdowns show sources
- All calculations use new formulas
- Features section populates automatically

### **Expected Limitations ⚠️**
- Only Human/Elf/Dwarf ancestries have new schema
- Only Barbarian/Cleric/Hunter classes have new schema  
- Other classes fall back to old system
- Some complex choices might not be fully implemented

### **Red Flags 🚨**
- Choice UI doesn't appear when expected
- Calculations don't update in real-time
- HP still using old formula (just Might + base)
- Tooltips show "undefined" or empty breakdowns

---

## 🎯 **Expected Performance**

The enhanced system should:
- ✅ **Load faster** (no regex parsing)
- ✅ **Calculate accurately** (all our fixes applied)
- ✅ **Display beautifully** (rich tooltips and breakdowns)
- ✅ **Handle choices** (intuitive UI for user selections)
- ✅ **Scale well** (easy to add new classes/traits)

## 🚀 **Ready for Production?**

This POC demonstrates:
- ✅ **Core system works** (3 classes, 3 ancestries)
- ✅ **Complex choices work** (Divine Domains, Favored Terrain)  
- ✅ **Calculations are correct** (all formula fixes applied)
- ✅ **UI integration works** (real-time updates, tooltips)

**Next step**: Expand to remaining classes or deploy this subset! 🎉
````

## File: vercel.json
````json
{
	"outputDirectory": "dist"
}
````

## File: WEAPON_REFACTOR_PLAN.md
````markdown
# Weapon System Refactor Plan
## Using inventoryItems.ts for Weapons

### Current Situation
- `weapons.ts` has been deleted to avoid duplication
- Attack system (`Attacks.tsx`) currently broken due to missing weapon imports
- Need to migrate attack system to use `inventoryItems.ts` weapon structure

---

## Phase 1: Interface Compatibility Analysis

### Current Attack System Expectations (from deleted weapons.ts)
```typescript
interface WeaponData {
  id: string;
  name: string;
  weightCategory: 'light' | 'heavy';
  type: 'melee' | 'ranged';
  damage: number; // Base damage (1, 2, 3, 4)
  versatileDamage?: number;
  damageType: 'bludgeoning' | 'piercing' | 'slashing';
  properties: string[];
  range?: { short: number; long: number };
  ammunition?: string;
  reload?: number;
  specialNotes?: string;
}
```

### Inventory Weapon Structure (inventoryItems.ts)
```typescript
interface Weapon {
  itemType: ItemType.Weapon;
  name: string;
  type: WeaponType; // enum: Melee, Ranged, Special
  style: WeaponStyle | WeaponStyle[]; // enum values
  handedness: WeaponHandedness; // enum: OneHanded, Versatile, TwoHanded
  damage: string; // "1 S", "2 B", "1 S/P", etc.
  properties: WeaponProperty[]; // typed weapon properties
}
```

### Key Differences to Address
1. **ID vs Name**: Inventory uses `name` as identifier, old system used `id`
2. **Damage Format**: Inventory uses strings ("1 S"), old system used numbers + separate type
3. **Weight Category**: Inventory uses `handedness`, old system used `weightCategory`
4. **Versatile Damage**: Inventory doesn't have separate versatile damage field
5. **Range/Ammo**: Inventory embeds range in `properties`, old system had separate fields

---

## Phase 2: Attack System Migration Strategy

### 2.1 Update Attack Data Interface
**File**: `src/types/character.ts`
```typescript
// Update AttackData to work with inventory weapons
export interface AttackData {
  id: string;
  weaponName: string; // Changed from weaponId to weaponName
  name: string;
  attackBonus: number;
  damage: string; // Keep as string to match inventory format
  damageType: string; // Parsed from inventory damage string
  critRange: string;
  critDamage: string;
  brutalDamage: string;
  heavyHitEffect: string;
}
```

### 2.2 Create Weapon Utility Functions
**File**: `src/lib/utils/weaponUtils.ts`
```typescript
import { Weapon, WeaponType } from '../rulesdata/inventoryItems';

// Parse damage string "1 S" → { amount: 1, type: 'slashing' }
export function parseDamage(damageStr: string): { amount: number; type: string };

// Get damage type from damage string
export function getDamageType(damageStr: string): 'slashing' | 'piercing' | 'bludgeoning' | 'mixed';

// Check if weapon is ranged
export function isRangedWeapon(weapon: Weapon): boolean;

// Get range from properties (parse "Range (15/45)")
export function getWeaponRange(weapon: Weapon): { short: number; long: number } | null;

// Get reload value from properties
export function getReloadValue(weapon: Weapon): number | null;

// Calculate attack bonus (CM + stat modifier)
export function calculateAttackBonus(weapon: Weapon, combatMastery: number, might: number, agility: number): number;

// Calculate damage for different hit types
export function calculateDamage(weapon: Weapon, hitType: 'normal' | 'heavy' | 'brutal'): string;
```

### 2.3 Update Attacks Component
**File**: `src/routes/character-sheet/components/Attacks.tsx`

#### Import Changes
```typescript
// Replace old imports
import { weapons, type Weapon, WeaponType } from '../../../lib/rulesdata/inventoryItems';
import { 
  parseDamage, 
  getDamageType, 
  isRangedWeapon, 
  calculateAttackBonus,
  calculateDamage 
} from '../../../lib/utils/weaponUtils';
```

#### Core Function Updates
```typescript
const calculateAttackData = (weapon: Weapon): AttackData => {
  if (!weapon || !characterData) {
    return createEmptyAttackData();
  }

  const mightMod = Math.floor((characterData.finalMight - 10) / 2);
  const agilityMod = Math.floor((characterData.finalAgility - 10) / 2);
  
  const attackBonus = calculateAttackBonus(weapon, characterData.finalCombatMastery, mightMod, agilityMod);
  const damageType = getDamageType(weapon.damage);
  
  return {
    id: '',
    weaponName: weapon.name,
    name: weapon.name,
    attackBonus,
    damage: weapon.damage,
    damageType,
    critRange: '20', // Default, could be enhanced later
    critDamage: calculateDamage(weapon, 'normal'),
    brutalDamage: calculateDamage(weapon, 'brutal'),
    heavyHitEffect: weapon.properties.includes('Impact') ? '+1 damage on Heavy Hit' : ''
  };
};
```

#### Weapon Selection Updates
```typescript
// Update weapon dropdown
{weapons.map((weapon) => (
  <option key={weapon.name} value={weapon.name}>
    {weapon.name} ({weapon.handedness})
  </option>
))}

// Update weapon lookup
const weapon = attack.weaponName 
  ? weapons.find((w) => w.name === attack.weaponName)
  : null;
```

---

## Phase 3: Enhanced Features

### 3.1 Versatile Weapon Support
```typescript
// For versatile weapons, show both one-handed and two-handed damage
function getVersatileDamage(weapon: Weapon): { oneHanded: string; twoHanded: string } | null {
  if (weapon.handedness === WeaponHandedness.Versatile) {
    const baseDamage = parseDamage(weapon.damage);
    return {
      oneHanded: weapon.damage,
      twoHanded: `${baseDamage.amount + 1} ${baseDamage.type.charAt(0).toUpperCase()}`
    };
  }
  return null;
}
```

### 3.2 Property-Based Features
```typescript
// Enhanced property handling
function getWeaponFeatures(weapon: Weapon): string[] {
  const features: string[] = [];
  
  weapon.properties.forEach(prop => {
    switch (prop) {
      case 'Impact':
        features.push('+1 damage on Heavy Hit');
        break;
      case 'Guard':
        features.push('Defensive bonus');
        break;
      case 'Reach':
        features.push('Extended reach');
        break;
      // Add more property interpretations
    }
  });
  
  return features;
}
```

### 3.3 Range and Ammunition
```typescript
// Parse range from properties
function parseRange(properties: WeaponProperty[]): { short: number; long: number } | null {
  const rangeProp = properties.find(p => p.includes('Range'));
  if (rangeProp) {
    const match = rangeProp.match(/Range \((\d+)\/(\d+)\)/);
    if (match) {
      return { short: parseInt(match[1]), long: parseInt(match[2]) };
    }
  }
  return null;
}
```

---

## Phase 4: Testing & Validation

### 4.1 Weapon Data Verification
- Ensure all weapons have valid damage strings
- Verify property consistency
- Test edge cases (0 damage weapons, special weapons)

### 4.2 Attack Calculation Testing
- Test melee vs ranged weapon attack bonuses
- Verify damage type parsing for complex types (S/P, B/P)
- Test versatile weapon damage calculation

### 4.3 UI/UX Testing
- Weapon selection dropdown functionality
- Attack popup display with new weapon properties
- Damage calculation tooltips

---

## Phase 5: Migration Steps

### Step 1: Create Utility Functions
1. Create `src/lib/utils/weaponUtils.ts`
2. Implement damage parsing and calculation functions
3. Add comprehensive tests

### Step 2: Update Type Definitions
1. Update `AttackData` interface in `src/types/character.ts`
2. Ensure compatibility with existing character data

### Step 3: Refactor Attacks Component
1. Update imports to use `inventoryItems.ts`
2. Replace weapon calculation logic
3. Update weapon selection UI
4. Test weapon lookup and selection

### Step 4: Update Character Sheet Integration
1. Update `CharacterSheetClean.tsx` weapon popup display
2. Ensure weapon properties display correctly
3. Test attack interaction flows

### Step 5: Clean Up and Documentation
1. Remove any remaining references to old weapon system
2. Update comments and documentation
3. Add comprehensive testing

---

## Expected Benefits

1. **Single Source of Truth**: All weapon data in one place
2. **Consistent Data**: Inventory and attack systems use same weapon definitions
3. **Enhanced Features**: Rich property system enables better weapon mechanics
4. **Maintainability**: Easier to add new weapons and properties
5. **Type Safety**: Better TypeScript support with proper enums

---

## Risk Mitigation

1. **Backward Compatibility**: Ensure existing saved characters still work
2. **Data Migration**: Handle any stored weapon references gracefully
3. **Testing**: Comprehensive testing before deployment
4. **Rollback Plan**: Keep ability to revert changes if issues arise

---

## Timeline Estimate

- **Phase 1 (Analysis)**: 1-2 hours
- **Phase 2 (Core Migration)**: 4-6 hours  
- **Phase 3 (Enhanced Features)**: 2-3 hours
- **Phase 4 (Testing)**: 2-3 hours
- **Phase 5 (Implementation)**: 1-2 hours per step

**Total Estimated Time**: 15-20 hours

This plan provides a structured approach to migrating from the deleted `weapons.ts` to the comprehensive `inventoryItems.ts` system while maintaining functionality and adding new capabilities.
````

## File: src/components/Menu.tsx
````typescript
import React from 'react';
import styled from 'styled-components';

const StyledContainer = styled.div`
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	min-height: 100vh;
	padding: 2rem;
	background: linear-gradient(135deg, #0f0f23 0%, #1e1b4b 50%, #312e81 100%);
`;

const StyledTitle = styled.h1`
	margin-bottom: 3rem;
	color: #fbbf24;
	text-align: center;
	font-size: 3rem;
	font-weight: bold;
	text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7);
	letter-spacing: 2px;
	background: linear-gradient(45deg, #fbbf24 0%, #f59e0b 100%);
	background-clip: text;
	-webkit-background-clip: text;
	-webkit-text-fill-color: transparent;
`;

const StyledSubtitle = styled.p`
	margin-bottom: 4rem;
	color: #e5e7eb;
	text-align: center;
	font-size: 1.2rem;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	max-width: 600px;
	line-height: 1.6;
`;

const StyledMenuGrid = styled.div`
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
	gap: 2rem;
	max-width: 800px;
	width: 100%;
`;

const StyledMenuCard = styled.button`
	border: 2px solid #8b5cf6;
	padding: 3rem 2rem;
	border-radius: 20px;
	background: linear-gradient(145deg, #1e1b4b 0%, #312e81 100%);
	cursor: pointer;
	transition: all 0.3s ease;
	text-align: center;
	box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3);
	backdrop-filter: blur(10px);

	&:hover {
		transform: translateY(-8px);
		box-shadow: 0 16px 48px rgba(139, 92, 246, 0.5);
		border-color: #fbbf24;
	}
`;

const StyledIcon = styled.div`
	font-size: 4rem;
	margin-bottom: 1.5rem;
	background: linear-gradient(145deg, #8b5cf6 0%, #a855f7 100%);
	border-radius: 50%;
	width: 100px;
	height: 100px;
	display: flex;
	align-items: center;
	justify-content: center;
	margin: 0 auto 1.5rem;
	box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
	transition: all 0.3s ease;

	${StyledMenuCard}:hover & {
		background: linear-gradient(145deg, #fbbf24 0%, #f59e0b 100%);
		transform: scale(1.1);
	}
`;

const StyledCardTitle = styled.h2`
	margin: 0 0 1rem 0;
	color: #fbbf24;
	font-size: 1.8rem;
	font-weight: bold;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	transition: all 0.3s ease;

	${StyledMenuCard}:hover & {
		color: #f59e0b;
	}
`;

const StyledCardDescription = styled.p`
	margin: 0;
	color: #e5e7eb;
	font-size: 1rem;
	line-height: 1.6;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	opacity: 0.9;
`;

interface MenuProps {
	onCreateCharacter: () => void;
	onLoadCharacter: () => void;
}

function Menu({ onCreateCharacter, onLoadCharacter }: MenuProps) {
	return (
		<StyledContainer>
			<StyledTitle>DC20 Character Creator</StyledTitle>
			<StyledSubtitle>
				Welcome to the ultimate D&D character creation experience. Choose your path to begin your
				adventure.
			</StyledSubtitle>

			<StyledMenuGrid>
				<StyledMenuCard onClick={onCreateCharacter}>
					<StyledIcon>⚔️</StyledIcon>
					<StyledCardTitle>Create Character</StyledCardTitle>
					<StyledCardDescription>
						Start fresh and create a new character from scratch. Choose your class, allocate
						attributes, and select your ancestry to forge your unique hero.
					</StyledCardDescription>
				</StyledMenuCard>

				<StyledMenuCard onClick={onLoadCharacter}>
					<StyledIcon>📜</StyledIcon>
					<StyledCardTitle>Load Character</StyledCardTitle>
					<StyledCardDescription>
						Continue working on an existing character or load a previously saved creation. Perfect
						for refining your build or making adjustments.
					</StyledCardDescription>
				</StyledMenuCard>
			</StyledMenuGrid>
		</StyledContainer>
	);
}

export default Menu;
````

## File: src/components/Snackbar.tsx
````typescript
import React, { useEffect, useState } from 'react';
import styled, { keyframes } from 'styled-components';

const slideIn = keyframes`
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
`;

const slideOut = keyframes`
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(100%);
    opacity: 0;
  }
`;

const StyledSnackbar = styled.div<{ $isVisible: boolean; $isExiting: boolean }>`
	position: fixed;
	top: 2rem;
	right: 2rem;
	padding: 1rem 1.5rem;
	background: linear-gradient(145deg, #10b981 0%, #059669 100%);
	color: white;
	border-radius: 8px;
	box-shadow: 0 8px 32px rgba(16, 185, 129, 0.3);
	font-weight: bold;
	font-size: 0.9rem;
	z-index: 1000;
	min-width: 300px;
	animation: ${(props) => (props.$isExiting ? slideOut : slideIn)} 0.3s ease-out;
	display: ${(props) => (props.$isVisible ? 'block' : 'none')};

	&::before {
		content: '✓';
		margin-right: 0.5rem;
		font-size: 1.2rem;
	}
`;

interface SnackbarProps {
	message: string;
	isVisible: boolean;
	onClose: () => void;
	duration?: number;
}

const Snackbar: React.FC<SnackbarProps> = ({ message, isVisible, onClose, duration = 3000 }) => {
	const [isExiting, setIsExiting] = useState(false);

	useEffect(() => {
		if (isVisible) {
			const timer = setTimeout(() => {
				setIsExiting(true);
				setTimeout(() => {
					onClose();
					setIsExiting(false);
				}, 300); // Animation duration
			}, duration);

			return () => clearTimeout(timer);
		}
	}, [isVisible, onClose, duration]);

	return (
		<StyledSnackbar $isVisible={isVisible} $isExiting={isExiting}>
			{message}
		</StyledSnackbar>
	);
};

export default Snackbar;
````

## File: src/lib/rulesdata/classes/barbarian_features.json
````json
{
	"className": "Barbarian",
	"startingEquipment": {
		"weaponsOrShields": ["2 Weapons or Shields"],
		"rangedWeapon": "1 Ranged Weapon with 20 Ammo OR 3 Weapons with the Toss or Thrown Property",
		"armor": "1 set of Light Armor or Heavy Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"martialPath": {
		"combatTraining": {
			"weapons": ["Weapons"],
			"armor": ["All Armor"],
			"shields": ["All Shields"]
		},
		"maneuvers": {
			"learnsAllAttack": true,
			"additionalKnown": "Maneuvers Known column of the Barbarian Class Table"
		},
		"techniques": {
			"additionalKnown": "Techniques Known column of the Barbarian Class Table"
		},
		"staminaPoints": {
			"maximumIncreasesBy": "Stamina Points column of the Barbarian Class Table"
		},
		"staminaRegen": {
			"description": "Once per round, you can regain up to half your maximum SP when:",
			"conditions": [
				"You score a Heavy or Critical Hit against a creature.",
				"A Heavy or Critical Hit is scored against you."
			]
		}
	},
	"coreFeatures": [
		{
			"featureName": "Rage",
			"levelGained": 1,
			"description": "During Combat, you can spend 1 AP and 1 SP to enter a Rage for 1 minute. For the duration, you're subjected to the following effects:\n• You deal +1 damage on Melee Martial Attacks.\n• You have ADV on Might Saves.\n• Your PD decreases by 5.\n• You gain Resistance (Half) to Elemental and Physical damage.\nEnding Early: Your Rage ends early if you fall Unconscious, die, or you choose to end it for free on your turn."
		},
		{
			"featureName": "Berserker",
			"levelGained": 1,
			"description": "Your primal savagery grants you the following benefits:",
			"benefits": [
				{
					"name": "Charge",
					"description": "When you make a Melee Martial Attack on your turn, you can move up to 2 Spaces immediately before making the Attack."
				},
				{
					"name": "Berserker Defense",
					"description": "While you aren't wearing Armor you gain +2 AD."
				},
				{
					"name": "Fast Movement",
					"description": "You gain +1 Speed while not wearing Armor."
				},
				{
					"name": "Mighty Leap",
					"description": "You can use your Might instead of Agility to determine your Jump Distance and the damage you take from Falling."
				}
			]
		},
		{
			"featureName": "Shattering Force",
			"levelGained": 1,
			"description": "When you Hit a structure or mundane object with a Melee Attack, it's considered a Critical Hit.",
			"isFlavor": true
		},
		{
			"featureName": "Battlecry",
			"levelGained": 2,
			"description": "You can spend 1 AP and 1 SP to release a shout of your choice listed below. Until the start of your next turn, you and creatures of your choice within 10 Spaces that can see or hear you are subjected to the effects of your shout. A creature can only benefit from the same type of shout once at a time.",
			"choices": [
				{
					"prompt": "Choose a shout to release.",
					"count": 1,
					"options": [
						{
							"name": "Fortitude Shout",
							"description": "Each creature gains Resistance (1) against the next source of Physical or Elemental damage."
						},
						{
							"name": "Fury Shout",
							"description": "Each creature deals +1 damage on their next Attack against 1 target."
						},
						{
							"name": "Urgent Shout",
							"description": "Each creature gains +1 Speed until the start of your next turn."
						}
					]
				}
			]
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Elemental Fury",
			"features": [
				{
					"featureName": "Raging Elements",
					"levelGained": 3,
					"description": "You can surround yourself with the elements (such as fire, lightning, water, earth) or violent weather (such as blizzards, storms, volcanoes, or earthquakes). Choose 1 of the following damage types: Cold, Fire, Lightning, or Physical. The chosen Damage Type becomes your Elemental Rage damage. If you chose Physical damage, then each time you Rage you choose Bludgeoning, Piercing, or Slashing damage. While Raging, you gain a 2 Space Aura of elements that grants the following benefits:",
					"benefits": [
						{
							"name": "Erupting Elements",
							"description": "When a creature within your Aura deals damage to you, they immediately take 1 Elemental Rage damage."
						},
						{
							"name": "Elemental Blast",
							"description": "You can spend 1 AP and 1 SP to blast 1 or more creatures of your choice within your Aura. Make a Spell Check against the AD of each target within range. Attack Hit: A target takes 1 Elemental Rage damage. Single Target: If the Attack only targets 1 creature, it targets the creature's PD and they take 3 damage."
						}
					],
					"choices": [
						{
							"prompt": "Choose 1 of the following additional benefits for your Aura Type:",
							"count": 1,
							"options": [
								{
									"name": "Slowing Aura",
									"description": "Spaces within your Aura count as Difficult Terrain for creatures of your choice. Additionally, when a creature within your Aura fails a Save you force it to make, they're also Slowed until the end of their next turn."
								},
								{
									"name": "Splashing Aura",
									"description": "Once per Turn when you deal Elemental Rage damage to a creature, you can automatically deal 1 Elemental Rage damage to a creature within 1 Space of it."
								},
								{
									"name": "Stunning Aura",
									"description": "Once per Turn when a creature within your Aura fails a Save you force it to make, it also can't spend AP on Reactions until the start of its next turn."
								},
								{
									"name": "Pushing Aura",
									"description": "When you use your Elemental Blast, creatures affected must make a Physical Save. Failure: Each target is moved 2 Spaces toward or away from you (your choice)."
								}
							]
						}
					]
				},
				{
					"featureName": "Elemental Affinity (Flavor Feature)",
					"levelGained": 3,
					"description": "You are infused with the power of your Element and can make yourself heard over crackling infernos, howling blizzards, thundering storms, and rumbling earthquakes. You gain the following benefits:\n• You can make your voice boom up to 3 times louder than normal.\n• You can call upon non-harmful magic of your Elemental damage type to swirl around you in a visual display.\n• You have Resistance to Exhaustion due to environmental effects.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Spirit Guardian",
			"features": [
				{
					"featureName": "Ancestral Guardian",
					"levelGained": 3,
					"description": "Bestowed Protection: You learn 1 of the following Maneuvers: Parry, Protect, or Raise Shield. If you already know all 3, then you can learn any Maneuver of your choice instead.\nSpiritual Aura: While Raging, you gain Mystical Resistance (1) and a 5 Space Aura that grants the following benefits:\n• You can use the Shove Action on any creature within your Aura. When you do, the creature is pushed horizontally in a direction of your choice.\n• You can use the Parry, Protect, and Raise Shield Maneuvers on any creature within your Aura, provided you know the Maneuver. Using Raise Shield in this way doesn't require you to be wielding a Shield."
				},
				{
					"featureName": "Ancestral Knowledge (Flavor Feature)",
					"levelGained": 3,
					"description": "You have ADV on Checks to recall information about the history of your Ancestries (such as Human, Dwarf, or Elf). Additionally, once per Long Rest when you make a Trade or Language Check, you can choose to gain ADV on the Check as a spirit lends you its experience.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/classes/barbarian_table.json
````json
{
	"className": "Barbarian",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 4,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/classes/bard_table.json
````json
{
	"className": "Bard",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 8,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 6,
			"cantripsKnown": 2,
			"spellsKnown": 3,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/classes/champion_features.json
````json
{
	"className": "Champion",
	"startingEquipment": {
		"weaponsOrShields": ["3 Weapons or Shields"],
		"rangedWeapon": "1 Ranged Weapon with 20 Ammo OR 3 Weapons with the Toss or Thrown Property",
		"armor": "1 set of Light Armor or Heavy Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"martialPath": {
		"combatTraining": {
			"weapons": ["Weapons"],
			"armor": ["All Armors"],
			"shields": ["All Shields"]
		},
		"maneuvers": {
			"learnsAllAttack": true,
			"additionalKnown": "Maneuvers Known column of the Champion Class Table"
		},
		"techniques": {
			"additionalKnown": "Techniques Known column of the Champion Class Table"
		},
		"staminaPoints": {
			"maximumIncreasesBy": "Stamina Points column of the Champion Class Table"
		},
		"staminaRegen": {
			"description": "Once per round, you can regain up to half your maximum SP when you perform a Maneuver.",
			"conditions": []
		}
	},
	"coreFeatures": [
		{
			"featureName": "Master-at-Arms",
			"levelGained": 1,
			"description": "Your training in warfare has granted you the following benefits:",
			"benefits": [
				{
					"name": "Weapon Master",
					"description": "At the start of each of your turns, you can freely swap any Weapon you're currently wielding in each hand for any other Weapon without provoking Opportunity Attacks."
				},
				{
					"name": "Maneuver Master",
					"description": "You learn 2 Maneuvers of your choice."
				},
				{
					"name": "Technique Master",
					"description": "You learn 1 Technique of your choice. Once per Combat, when you perform a Technique you can reduce its SP cost by 1."
				}
			]
		},
		{
			"featureName": "Fighting Spirit",
			"levelGained": 1,
			"description": "You stand ready for Combat at any moment, granting you the following benefits:",
			"benefits": [
				{
					"name": "Combat Readiness",
					"description": "At the start of your first turn in Combat, you gain one of the following benefits:\n• Brace: You gain the benefits of the Dodge Action and ADV on the next Save you make until the end of Combat.\n• Advance: You gain the benefits of the Move Action and ADV on the next Physical Check you make until the end of Combat."
				},
				{
					"name": "Second Wind",
					"description": "Once per Combat when you start your turn Bloodied, you can regain 2 HP and 1 SP."
				}
			]
		},
		{
			"featureName": "Know Your Enemy (Flavor Feature)",
			"levelGained": 1,
			"description": "You can spend 1 minute observing or interacting with a creature out of Combat (or spend 1 AP in Combat) to learn information about its physical capabilities compared to your own. Choose one of the following stats of the creature to assess: Might, Agility, PD, AD, and HP. Make a DC 10 Knowledge or Insight Check (your choice). Success: You learn if the chosen stat is higher, lower, or the same as yours.",
			"isFlavor": true
		},
		{
			"featureName": "Adaptive Tactics",
			"levelGained": 2,
			"description": "When you roll for Initiative, and at the end of each of your turns, you gain a d8 Tactical Die if you don't already have one. You can spend a Tactical Die to gain one of the following Tactics:",
			"benefits": [
				{
					"name": "Assault",
					"description": "When you make a Martial Attack, you can add the die to the Attack's result."
				},
				{
					"name": "Deflect",
					"description": "When you are Attacked, you can subtract the die from the Attack's result."
				}
			]
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Hero",
			"features": [
				{
					"featureName": "Hero's Resolve",
					"levelGained": 3,
					"description": "Your warrior spirit refuses to yield in battle. You gain the following benefits:\n• Adrenaline Boost: When you use your Second Wind, you gain a +5 bonus to Attack Checks you make until the end of your turn.\n• Cut Through: Your Martial Attacks that score Heavy Hits ignore the target's Physical damage Resistances.\n• Unyielding Spirit: While Bloodied, you gain 1 Temp HP at the start of each of your turns."
				},
				{
					"featureName": "Adventuring Hero (Flavor Feature)",
					"levelGained": 3,
					"description": "You ignore the penalties of Forced March and being Encumbered (but not Heavily Encumbered).",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Sentinel",
			"features": [
				{
					"featureName": "Stalwart Protector",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Steadfast Defender: You can use your Deflect Tactic against any Attack that targets a creature within your Melee Range.\n• Defensive Bash: When you use a Defensive Maneuver as a Reaction to an Attack from a creature within 1 Space of you, the attacker must make a Physical Save against your Attack Check. Save Failure: The target is pushed 1 Space away or Taunted by you until the end of its next turn (your choice).\n• Not on my Watch: Creatures Taunted by you deal 1 less damage to targets within 1 Space of you."
				},
				{
					"featureName": "Vigilant Watcher (Flavor Feature)",
					"levelGained": 3,
					"description": "During a Long Rest, if you spend both 4 hour periods doing Light Activity, you have ADV on the Might Save you make to avoid gaining Exhaustion. Additionally, the Save DC doesn't increase on a Failure.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/classes/champion_table.json
````json
{
	"className": "Champion",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 4,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/classes/CLASS_FEATURES_SCHEMA.json
````json
{
	"$schema": "http://json-schema.org/draft-07/schema#",
	"title": "DC20 Class And Subclass Features",
	"description": "A schema for defining all features for a single class, including its core features and all of its subclass options. This structure provides full context for how features relate to each other and when they are acquired.",
	"type": "object",
	"properties": {
		"className": {
			"type": "string",
			"description": "The name of the class this file defines."
		},
		"coreFeatures": {
			"type": "array",
			"description": "A list of all features available to the base class, regardless of subclass choice.",
			"items": {
				"$ref": "#/definitions/feature"
			}
		},
		"subclasses": {
			"type": "array",
			"description": "A list of all available subclass options for this class.",
			"items": {
				"type": "object",
				"properties": {
					"subclassName": {
						"type": "string",
						"description": "The name of the subclass."
					},
					"description": {
						"type": "string",
						"description": "A brief, optional description of the subclass."
					},
					"features": {
						"type": "array",
						"description": "A list of all features specific to this subclass.",
						"items": {
							"$ref": "#/definitions/feature"
						}
					}
				},
				"required": ["subclassName", "features"]
			}
		}
	},
	"required": ["className", "coreFeatures", "subclasses"],
	"definitions": {
		"feature": {
			"type": "object",
			"description": "A reusable definition for a single feature's mechanics.",
			"properties": {
				"featureName": {
					"type": "string",
					"description": "The name of the class feature."
				},
				"levelGained": {
					"type": "integer",
					"description": "The character level at which this feature is acquired. This provides essential context that the high-level progression table lacks."
				},
				"description": {
					"type": "string",
					"description": "The main text explaining what the feature does, including its activation, cost, duration, and general effects."
				},
				"isFlavor": {
					"type": "boolean",
					"description": "True if this is a non-mechanical flavor feature.",
					"default": false
				},
				"choices": {
					"type": "array",
					"description": "A list of choices the player must make for this feature.",
					"items": {
						"type": "object",
						"properties": {
							"prompt": {
								"type": "string",
								"description": "The instruction for the player."
							},
							"count": {
								"type": "integer",
								"description": "The number of options to choose."
							},
							"options": {
								"type": "array",
								"items": {
									"type": "object",
									"properties": {
										"name": {
											"type": "string"
										},
										"description": {
											"type": "string"
										}
									},
									"required": ["name", "description"]
								}
							}
						},
						"required": ["prompt", "count"]
					}
				},
				"benefits": {
					"type": "array",
					"description": "A list of distinct, named benefits or effects that are part of this feature.",
					"items": {
						"type": "object",
						"properties": {
							"name": {
								"type": "string"
							},
							"description": {
								"type": "string"
							},
							"effects": {
								"type": "array",
								"description": "A list of formal, machine-readable effects that this benefit provides.",
								"items": {
									"type": "object",
									"properties": {
										"type": {
											"type": "string",
											"enum": ["MODIFIER", "GRANT_ABILITY", "GRANT_PASSIVE"]
										},
										"target": {
											"type": "string",
											"description": "The path to the character sheet value to be modified (e.g., 'defenses.ad')."
										},
										"value": {
											"type": "integer",
											"description": "The value of the modification."
										},
										"condition": {
											"type": "string",
											"description": "A formal condition under which this effect applies (e.g., 'character.armor.type == null')."
										}
									},
									"required": ["type", "target", "value"]
								}
							}
						},
						"required": ["name", "description"]
					}
				}
			},
			"required": ["featureName", "levelGained", "description"]
		}
	}
}
````

## File: src/lib/rulesdata/classes/cleric_features.json
````json
{
	"className": "Cleric",
	"startingEquipment": {
		"weaponsOrShields": [
			"2 Weapons or 1 Light Shield (or Heavy Shield if you choose the Templar Holy Order, see below)"
		],
		"armor": "1 set of Light Armor (or Heavy Armor if you choose the Templar Holy Order, see below)",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"spellcastingPath": {
		"combatTraining": {
			"armor": ["Light Armor"],
			"shields": ["Light Shields"]
		},
		"spellList": {
			"type": "specific",
			"listName": "Divine Spell List",
			"betaNote": "You get access to the \"Premade List\" of Holy & Restoration. This is the only Premade List that you have to choose from until the Spell List Update."
		},
		"cantrips": {
			"knownIncreasesBy": "Cantrips Known column of the Cleric Class Table",
			"description": "Cantrips are Spells with the Cantrip Spell Tag."
		},
		"spells": {
			"knownIncreasesBy": "Spells Known column of the Cleric Class Table",
			"description": "These can be Spells with or without the Cantrip Spell Tag."
		},
		"manaPoints": {
			"maximumIncreasesBy": "Mana Points column of the Cleric Class Table"
		}
	},
	"coreFeatures": [
		{
			"featureName": "Cleric Order",
			"levelGained": 1,
			"description": "Your connection to your deity grants you the following benefits:",
			"benefits": [
				{
					"name": "Divine Damage",
					"description": "Choose an Elemental or Mystical damage type. The chosen damage type becomes your Divine Damage which is used for some Cleric Features."
				},
				{
					"name": "Divine Domain",
					"description": "You gain the benefits of 2 Divine Domains of your choice."
				}
			]
		},
		{
			"featureName": "Knowledge",
			"levelGained": 1,
			"description": "Your Mastery Limit increases by 1 for all Knowledge Trades. A Trade can only benefit from 1 Feature that increases its Mastery Limit at a time. Additionally, you gain 2 Skill Points."
		},
		{
			"featureName": "Divine Domains",
			"levelGained": 1,
			"description": "The Divine Domains available to choose from with the Cleric Order feature.",
			"choices": [
				{
					"prompt": "Choose 2 Divine Domains.",
					"count": 2,
					"options": [
						{
							"name": "Magic",
							"description": "You gain the benefits listed below. You can choose this Divine Domain multiple times.\n• Your maximum MP increases by 1.\n• Choose a Spell Tag (such as Fire, Holy, or Undeath). You learn 1 Spell with the chosen Spell Tag, and when you learn a new Spell you can choose any Spell that also has the chosen Spell Tag."
						},
						{
							"name": "Divine Damage Expansion",
							"description": "When you deal damage with a Spell you can convert the damage to your Divine Damage type. Additionally, you gain Resistance (1) to your Divine Damage type."
						},
						{
							"name": "Life",
							"description": "When you produce an MP Effect that restores HP to at least 1 creature, you can restore 1 HP to 1 creature of your choice within 1 Space of you (including yourself)."
						},
						{
							"name": "Death",
							"description": "Enemy creatures within 10 Spaces of you take an additional 1 damage from Attacks while they're Well-Bloodied."
						},
						{
							"name": "Grave",
							"description": "Allied creatures within 10 Spaces of you take 1 less damage from Attacks while they're Well-Bloodied."
						},
						{
							"name": "Light",
							"description": "When you produce an MP Effect that targets at least 1 creature, you can force 1 target of your choice to make a Might or Charisma Save (their choice). Failure: Until the end of their next turn, they shed a 1 Space Aura of Bright Light and are Hindered on their next Attack."
						},
						{
							"name": "Dark",
							"description": "Your mastery over shadows grants you supernatural sight and the ability to hide yourself from other creatures. You gain the following benefits:\n• You gain 10 Space Darkvision. If you already have Darkvision it increases by 5 Spaces.\n• While in an area of Dim Light, you can take the Hide Action to Hide from creatures that can see you. On a Success, you remain Hidden until you move or the area you're in becomes Bright Light."
						},
						{
							"name": "War",
							"description": "You gain Combat Training with Weapons and access to Attack Maneuvers."
						},
						{
							"name": "Peace",
							"description": "You gain Combat Training with Heavy Armor and Heavy Shields and learn 1 Defensive Maneuver of your choice."
						},
						{
							"name": "Order",
							"description": "Once per turn, when a creature you can see within 10 Spaces of you makes a Check, you can spend 1 AP as a Reaction to remove all instances of ADV and DisADV from that Check."
						},
						{
							"name": "Chaos",
							"description": "When you make a Spell Check you can choose to give yourself ADV on it, but you must also roll on the Wild Magic Table. You can use this Feature once per Long Rest, and regain the ability to use it again when you roll for Initiative."
						},
						{
							"name": "Divination",
							"description": "You gain the following benefits:\n• You can't be Flanked.\n• When you spend MP, you gain the ability to see Invisible creatures and objects until the start of your next turn."
						},
						{
							"name": "Trickery",
							"description": "When you produce an MP Effect that targets at least 1 creature, you can choose 1 of the targets and create an illusory duplicate of it that lasts until the start of your next turn. The next Attack made against the target has DisADV, and causes the illusory duplicate to disappear."
						},
						{
							"name": "Ancestral",
							"description": "You get 2 Ancestry Points that you can spend on Traits from any Ancestry."
						}
					]
				}
			]
		},
		{
			"featureName": "Divine Blessing",
			"levelGained": 1,
			"description": "You can spend 1 AP to say a prayer and petition your deity for their divine blessing. Choose 1 of the blessings listed below. Each blessing has a listed MP cost that you must spend to gain the blessing. Once during the next minute, you can apply the blessing to a Spell you cast. If your Spell targets more than 1 creature, the blessing only applies to 1 target of your choice.",
			"choices": [
				{
					"prompt": "Choose a blessing.",
					"count": 1,
					"options": [
						{
							"name": "Destruction (1 MP)",
							"description": "The target takes 3 Divine damage, provided that the result of your Spell Check is equal to or higher than the target's AD. If the Spell doesn't normally require a Spell Check, then you must make one when you apply this blessing."
						},
						{
							"name": "Guidance (1 MP)",
							"description": "The target gains a d8 Help Die that they can add to 1 Check of their choice they make within the next minute."
						},
						{
							"name": "Restoration (1 MP)",
							"description": "The target regains 3 HP."
						}
					]
				}
			]
		},
		{
			"featureName": "Divine Omen (Flavor Feature)",
			"levelGained": 1,
			"description": "Once per Long Rest, you can spend 10 minutes to commune with your Deity. You can ask them 1 question, which must be posed in a way that could be answered with a yes or no. The deity responds to the best of their knowledge and intentions in one of the following responses: Yes, No, or Unclear. A response of Unclear could come from the deity not knowing the answer, wanting to purposefully keep it a secret, the question being phrased in a confusing or complicated way, or there not being a simple answer to the question.",
			"isFlavor": true
		},
		{
			"featureName": "Channel Divinity",
			"levelGained": 2,
			"description": "You gain the ability to channel the direct power of your deity. When you use this Feature, choose 1 of the options below. You can use this Feature once per Short Rest.",
			"choices": [
				{
					"prompt": "Choose a Channel Divinity option.",
					"count": 1,
					"options": [
						{
							"name": "Divine Rebuke",
							"description": "You can spend 2 AP to censure all creatures of your choice who can see or hear you within 5 Spaces. Make a Spell Check against each target's AD, and each target makes a Repeated Mental Save against your Save DC. Attack Hit: The target takes Divine Damage equal to your Prime Modifier. Save Failure: The target becomes Intimidated by you for 1 minute or until it takes damage again."
						},
						{
							"name": "Lesser Divine Intervention",
							"description": "You can spend 2 AP to call on your deity to intervene on your behalf when your need is great to replenish you and your allies. Make a DC 15 Spell Check. Success: You gain a pool of healing equal to your Prime Modifier that you can use to restore HP to any number of creatures within 5 Spaces, distributing the HP among them. Additionally, you regain 1 MP. Success (each 5): Increase the amount healed by an amount equal to your Prime. Failure: You can only gain a pool of healing equal to your Prime Modifier."
						}
					]
				}
			]
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Inquisitor",
			"features": [
				{
					"featureName": "Vanquish Heresy",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Iron Resolve: You have Resistance to the Charmed, Intimidated, and Taunted Conditions.\n• Rebuke Heretics: Creatures Intimidated by your Divine Rebuke (Channel Divinity) don't stop being Intimidated if they take damage.\nYou gain the following Divine Blessing:\n• Chastise: (1 MP) The target is branded as a heretic for 1 minute. You have ADV on Insight and Intimidation Checks made against the creature and you deal +1 Divine Damage to it with your Attacks."
				},
				{
					"featureName": "Divine Interrogator (Flavor Feature)",
					"levelGained": 3,
					"description": "Once per Long Rest, you can interrogate a creature by asking it a Yes or No question. It makes a Charisma Save against your Save DC. Failure: It can't tell a lie to the question that you asked it. It can choose not to answer at all, but if it does answer it must be either, “Yes,” “No,” or “I don't know.”",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Priest",
			"features": [
				{
					"featureName": "Sanctification",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Divine Barrier: When you spend MP to heal a creature beyond their HP maximum, they gain an amount of Temp HP equal to the remaining healing. Any Temp HP gained in this way expires after 1 minute.\n• Spare the Dying: When you spend MP to heal a creature on Death's Door, the HP restored is increased by an amount equal to your Prime Modifier.\nYou gain a new Channel Divinity option:\nHand of Salvation: When another creature that you can see within 5 Spaces would be Hit by an Attack, you can spend 2 AP as a Reaction to magically pull the creature to an unoccupied Space within 1 Space of you, provided the creature is willing. The Attack misses and has no effect, and the creature is immune to all damage during this movement."
				},
				{
					"featureName": "All That Ails (Flavor Feature)",
					"levelGained": 3,
					"description": "You have an understanding and divine guidance when attempting to learn what is ailing a creature. You have ADV on Checks made to identify or determine the effects of a Disease, Poison, or Curse affecting a creature.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/classes/cleric_table.json
````json
{
	"className": "Cleric",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 8,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 6,
			"cantripsKnown": 2,
			"spellsKnown": 3,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/classes/commander_features.json
````json
{
	"className": "Commander",
	"startingEquipment": {
		"weaponsOrShields": ["2 Weapons or Shields"],
		"rangedWeapon": "1 Ranged Weapon with 20 Ammo OR 3 Weapons with the Toss or Thrown Property",
		"armor": "1 set of Light Armor or Heavy Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"martialPath": {
		"combatTraining": {
			"weapons": ["Weapons"],
			"armor": ["All Armor"],
			"shields": ["All Shields"]
		},
		"maneuvers": {
			"learnsAllAttack": true,
			"additionalKnown": "Maneuvers Known column of the Commander Class Table"
		},
		"techniques": {
			"additionalKnown": "Techniques Known column of the Commander Class Table"
		},
		"staminaPoints": {
			"maximumIncreasesBy": "Stamina Points column of the Commander Class Table"
		},
		"staminaRegen": {
			"description": "Once per round, you can regain up to half your maximum SP when you grant a creature a Help Die.",
			"conditions": []
		}
	},
	"coreFeatures": [
		{
			"featureName": "Inspiring Presence",
			"levelGained": 1,
			"description": "Whenever you spend SP while in Combat, you can restore an amount of HP equal to the SP spent. Choose any creatures within 5 Spaces that can see or hear you, and divide the HP among them."
		},
		{
			"featureName": "Commander's Call",
			"levelGained": 1,
			"description": "You can spend 1 AP and 1 SP to command a willing creature that you can see within 5 Spaces that can also see or hear you. The chosen creature can immediately take 1 of the following Actions of your choice as a Reaction for free. You can only use each of the following commands once on each of your turns.",
			"benefits": [
				{
					"name": "Attack",
					"description": "The creature makes an Attack with ADV. They can't spend any resources on this Attack, such as AP, SP, or MP."
				},
				{
					"name": "Dodge",
					"description": "The creature takes the Full Dodge Action."
				},
				{
					"name": "Move",
					"description": "The creature moves up to their Speed without provoking Opportunity Attacks."
				}
			]
		},
		{
			"featureName": "Natural Leader (Flavor Feature)",
			"levelGained": 1,
			"description": "You have ADV on Checks made to convince creatures that you are an authority figure. Additionally, you have ADV on the first Charisma Check made to interact with non-hostile members of military groups (such as soldiers, guards, etc.).",
			"isFlavor": true
		},
		{
			"featureName": "Commanding Aura",
			"levelGained": 2,
			"description": "You're surrounded by a 5 Space Aura. You can target any creature within your Aura to grant one of the following effects below, provided the target can see or hear you.",
			"benefits": [
				{
					"name": "Bolster (1 AP)",
					"description": "You take the Help Action to aid the target with an Attack. You can also do so as a Reaction whenever a valid target makes an Attack."
				},
				{
					"name": "Rally (1 AP)",
					"description": "You grant creatures of your choice (including yourself) 1 Temp HP."
				},
				{
					"name": "Reinforce (1 AP)",
					"description": "When a creature in your aura is targeted by an Attack, you can impose DisADV on the Attack as a Reaction."
				}
			]
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Crusader",
			"features": [
				{
					"featureName": "Virtuous Vanguard",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Aura of Courage: While within your Commanding Aura, creatures of your choice have Resistance to Frightened and Intimidated.\n• Protective Orders: When a creature gains the benefits of your Commander's Call, they also gain Resistance (1) against the next damage they take before the start of your next turn.\n• Restoring Rally: When you grant a Bloodied creature Temp HP in Combat using Rally (Commanding Aura), they regain that amount of HP instead."
				},
				{
					"featureName": "Gallant Hero (Flavor Feature)",
					"levelGained": 3,
					"description": "Your presence is a symbol of hope and safety to those around you. You have ADV on Checks to convince creatures not to be afraid.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Warlord",
			"features": [
				{
					"featureName": "Offensive Tactics",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Morale Breaker: Once per Combat when you use your Commander's Call, you can use the Intimidate Action for free against a creature of your choice within 15 Spaces.\n• Battlefield Tactics: Allies within your Commanding Aura deal +1 damage on their first Melee Attack on each of their turns against a creature they're Flanking.\nYou gain a new Commanding Aura option:\n• Priority Target: (1 AP + 1 SP) Choose a creature within 15 Spaces. Until the start of your next turn, each creature within your Aura has ADV on the first Attack it makes on each of its turns against the chosen creature."
				},
				{
					"featureName": "Battlefield Tactician (Flavor Feature)",
					"levelGained": 3,
					"description": "Through years of study and experience, you've mastered military history and strategy. You gain ADV on Checks related to analyzing fields of battle, understanding historical battles and military organizations, or deciphering complex tactical maneuvers.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/classes/commander_table.json
````json
{
	"className": "Commander",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 4,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/classes/druid_features.json
````json
{
	"className": "Druid",
	"startingEquipment": {
		"weaponsOrShields": ["1 Weapon"],
		"armor": "1 set of Light Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"spellcastingPath": {
		"combatTraining": {
			"armor": ["Light Armor"]
		},
		"spellList": {
			"type": "specific",
			"listName": "Primal Spell List",
			"betaNote": "You can choose from the following Spells when picking your Cantrips and Spells Known:\nCantrips: Poison Bolt, Lightning Bolt, Frost Bolt, Fire Bolt, Close Wounds, Gust, Dancing Flames\n1 MP Spells: Heal, Crackling Lightning, Return Shock, Ice Knife, Grease, Fire Shield, Fog Cloud, Burning Flames, Tethering Vines"
		},
		"cantrips": {
			"knownIncreasesBy": "Cantrips Known column of the Druid Class Table",
			"description": "Cantrips are Spells with the Cantrip Spell Tag."
		},
		"spells": {
			"knownIncreasesBy": "Spells Known column of the Druid Class Table",
			"description": "These can be Spells with or without the Cantrip Spell Tag."
		},
		"manaPoints": {
			"maximumIncreasesBy": "Mana Points column of the Druid Class Table"
		}
	},
	"coreFeatures": [
		{
			"featureName": "Druid Domain",
			"levelGained": 1,
			"description": "You can spend 1 AP and 1 MP to create your own Druid Domain that includes small plant life, sand, shallow water, or other naturally occurring features. You create up to 8 Domain Spaces along the ground or walls. The first Domain Space must be within 1 Space of you, and each additional Domain Space must be adjacent to another Domain Space. If you use this Feature again, the first Domain Space of it must be within 1 Space of you or another Domain Space.\nDomain Spaces: The area is considered to be Difficult Terrain for creatures of your choice, and when you cast a Spell, you can do so as if you were standing in any Space within your Domain.\nLosing Domain Spaces: A Domain Space also disappears if you end your turn farther than 15 Spaces away from it or you die.\nDomain Actions: While you have Domain Spaces, you can take any of the following Domain Actions:\n• Nature's Grasp: You can spend 1 AP to attempt to bind a creature of your choice within your Domain. Make a Spell Check against the target's Repeated Physical Save. Success: The target is bound by your Domain, preventing it from moving for 1 minute or until the Domain Space it occupies ends.\n• Move Creature: You can spend 1 AP to move a creature bound by this feature up to 2 Spaces within your Domain.\n• Move Object: You can take the Object Action to use your vines to interact with any object within your Domain as if you were standing in any of your Domain Spaces. When you do, you can move the object up to 5 Spaces within your Domain.\n• Wild Growth: You can spend 1 AP and 1 MP to make a DC 10 Spell Check to heal a target within your Domain. Success: The target immediately regains 2 HP. For the next minute, they regain an additional 1 HP each time they end their turn within your Domain. Success (each 5): They immediately regain +1 HP. Failure: The target only regains 2 HP immediately."
		},
		{
			"featureName": "Wild Form",
			"levelGained": 1,
			"description": "You can spend 1 AP and 1 MP to transform into a Wild Form of your choice. You can spend 1 AP on your turn to shift back and forth between your True Form and any Wild Forms you currently have available. Once per Long Rest, you can transform without spending MP or using MP enhancements.\nTrue Form: When you transform from your Wild Form to your True Form, your statistics return to normal. You immediately revert to your True Form when your Wild Form HP is reduced to 0 or you die.\nWild Form: When you transform into a Wild Form, you gain the Wild Form's current Wild Form HP (see Wild Form HP below), retaining any HP losses. \n• Duration: Each Wild Form remains available until its Wild Form HP is reduced to 0 or you complete a Long Rest.\n• Multiple Forms: You can have multiple Wild Forms available at a time which have their own Wild Form HP and Traits.\n• Equipment: Your equipment falls to the ground or merges into your Wild Form (your choice for each item). You gain the benefits of Magic Items merged with your Wild Form, but you can't activate them or spend their charges.\nStatistics: While in your Wild Form, you're subjected to the following changes (unless otherwise stated):\n• Stat Block: You use the Wild Form Stat Block below to determine your statistics.\n• Identity: You maintain your personality, intellect, and ability to speak.\n• Wild Form HP: You gain a secondary pool of Wild Form Health Points, which is 3 with a maximum of 3. Damage and healing effects target your Wild Form HP before your True Form HP, and any excess damage or healing carries over to your own HP.\n• Natural Weapon: You have Natural Weapons (claws, horns, fangs, etc.) which you can use to make Unarmed Strikes that deal 1 Bludgeoning, Piercing, or Slashing damage (your choice when you use this Feature).\n• Features & Talents: You don't benefit from Talents or Class Features, except Druid Class Features, Subclass Features, and Talents. Additionally, you can't cast Spells or perform Techniques.\n• Traits: You don't benefit from your Ancestry Traits, but you gain 3 Trait Points to spend on Beast Traits or Wild Form Traits of your choice. You can't select negative Beast Traits. When you use this Feature, you can spend additional MP (up to your Mana Spend Limit) to gain 2 additional Trait Points per MP spent."
		},
		{
			"featureName": "Wild Speech (Flavor)",
			"levelGained": 1,
			"description": "You learn the Druidcraft Cantrip and can choose 1 of the following options:\n• Animals: You can understand and speak with Beasts in a limited manner. You can understand the meaning of their movements, sounds, and behaviors, and they can understand the meanings of simple words, concepts, and emotions.\n• Plants: You can understand and speak with Plants in a limited manner. You can understand the meaning of their swaying, folding, unfolding of their leaves and flowers, and they can understand the meanings of simple words, concepts, and emotions.\n• Weather: You can reach out to nature and cast the Commune with Nature Spell as a Ritual once per Long Rest.",
			"isFlavor": true
		},
		{
			"featureName": "Nature's Torrent",
			"levelGained": 2,
			"description": "When a creature within 10 spaces of you takes Elemental damage, you can spend 1 AP as a Reaction to summon a torrent of nature. The torrent fills a 1 Space Radius Sphere centered on the target that lasts for 1 minute. While creatures are within the area, they have Vulnerability (1) against the triggering damage type and have DisADV on Checks and Saves to resist being moved or knocked Prone. Ending Early: The torrent ends early if you use this Feature again, become Incapacitated, die, or choose to end it for free at anytime."
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Phoenix",
			"features": [
				{
					"featureName": "Flames of Rebirth",
					"levelGained": 3,
					"description": "You wield the power of fire to lay destruction to what exists and foster new life. You gain the following benefits:\n• Fiery Form: When you use your Wild Form, you can choose for your creature type to become Elemental (Fire) instead of Beast. Additionally, your Wild Forms gain Fire Resistance (1) and you can choose Fire as the damage type of your Wild Form's Natural Weapon.\n• Cleansing Flames: When a creature within your Druid Domain is Healed by one of your MP effects, you can remove one of the following Conditions from it: Impaired, Dazed, Burning, or Poisoned.\n• Rolling Wild Fire: Creatures of your choice take 1 Fire damage for each Space they move within your Druid Domain, or if they start their turn within your Domain."
				},
				{
					"featureName": "Fire Within (Flavor Feature)",
					"levelGained": 3,
					"description": "You are unaffected by cold weather conditions and can bring a gallon (4 liters) of liquid to a boil after making physical contact with it or its container for 1 minutes.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Rampant Growth",
			"features": [
				{
					"featureName": "Overgrowth",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Plant Form: When you use your Wild Form, you can choose for your creature type to become Plant instead of Beast. Additionally, your Wild Forms become immune to Bleeding and you can choose Poison as the damage type of your Wild Form's Natural Weapon.\n• Vineguard: Plant-life in your Domain swirls to protect and support you. Creatures of your choice within your Domain gain the benefits of 1/2 Cover.\n• Thorny Grasp: When a creature fails a Save against your Nature's Grasp, it begins Bleeding."
				},
				{
					"featureName": "Seed Vault (Flavor Feature)",
					"levelGained": 3,
					"description": "You can magically produce the seeds of any mundane plant that you've ever touched.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/classes/druid_table.json
````json
{
	"className": "Druid",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 8,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 6,
			"cantripsKnown": 2,
			"spellsKnown": 3,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/classes/hunter_features.json
````json
{
	"className": "Hunter",
	"startingEquipment": {
		"weaponsOrShields": ["2 Weapons or Light Shields"],
		"rangedWeapon": "1 Ranged Weapon with 20 Ammo OR 3 Weapons with the Toss or Thrown Property",
		"armor": "1 set of Light Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"martialPath": {
		"combatTraining": {
			"weapons": ["Weapons"],
			"armor": ["Light Armor"],
			"shields": ["Light Shields"]
		},
		"maneuvers": {
			"learnsAllAttack": true,
			"additionalKnown": "Maneuvers Known column of the Hunter Class Table"
		},
		"techniques": {
			"additionalKnown": "Techniques Known column of the Hunter Class Table"
		},
		"staminaPoints": {
			"maximumIncreasesBy": "Stamina Points column of the Hunter Class Table"
		},
		"staminaRegen": {
			"description": "Once per round, you can regain up to half your maximum SP when:",
			"conditions": [
				"When you Hit the target of your Hunter's Mark with a Martial Attack.",
				"The target of your Hunter's Mark is reduced to 0 HP or dies.",
				"You succeed on a Check to recall information about a creature.",
				"You succeed on a Check to locate an Unseen creature."
			]
		}
	},
	"coreFeatures": [
		{
			"featureName": "Hunter's Mark",
			"levelGained": 1,
			"description": "You can spend 1 AP and 1 SP to focus on and mark a creature you can see within 15 Spaces as your quarry. Alternatively, you can mark a creature by studying its tracks for at least 1 minute. While a creature is marked, you gain the following benefits:\n• You have ADV on Awareness and Survival Checks made to find the target.\n• The first Martial Attack against your target on your turn has ADV and ignores PDR.\n• When you score a Heavy or Critical Hit against the target, you automatically grant a d8 Help Die to the next Attack made against the target before the start of your next turn.\nThe target is marked as long as it's on the same Plane of Existence as you, and vanishes early if you complete a Long Rest, fall Unconscious, or use this Feature again to mark another creature."
		},
		{
			"featureName": "Favored Terrain",
			"levelGained": 1,
			"description": "You are particularly familiar with two types of environments and are adept at the skills unique to the region. Choose 2 types of Favored Terrain listed below. Additionally, while you're in one of your Favored Terrains, you have ADV on Stealth and Survival Checks and can't be Surprised.",
			"choices": [
				{
					"prompt": "Choose 2 types of Favored Terrain.",
					"count": 2,
					"options": [
						{
							"name": "Coast",
							"description": "You gain a Swim Speed equal to your Ground Speed (your Weapon Attacks no longer have DisADV as a result of being underwater), you can hold your breath twice as long as normal, and you have ADV on Awareness Checks while underwater."
						},
						{
							"name": "Desert",
							"description": "You gain Fire Resistance (Half) and Resistance to Exhaustion from hot temperatures."
						},
						{
							"name": "Forest",
							"description": "You gain 2 Skill Points to use on up to 2 of the following Skills: Animal, Awareness, Medicine, Survival, and Stealth."
						},
						{
							"name": "Grassland",
							"description": "Your Speed and Jump Distance increases by 1."
						},
						{
							"name": "Jungle",
							"description": "You ignore Difficult Terrain, gain Poisoned Resistance, and have ADV on Saves against against contracting Diseases."
						},
						{
							"name": "Mountain",
							"description": "You gain a Climb Speed equal to your Ground Speed, Resistance to Exhaustion from high altitudes, and Resistance (Half) to damage from Falling."
						},
						{
							"name": "Swamp",
							"description": "You gain Poison Resistance (Half) and Poisoned Resistance, and have ADV on Saves against against contracting Diseases."
						},
						{
							"name": "Tundra",
							"description": "You gain Cold Resistance (Half) and Resistance to Exhaustion from cold temperatures."
						},
						{
							"name": "Subterranean",
							"description": "You gain Darkvision 10 Spaces. If you already have Darkvision, its range is increased by 5 Spaces. Additionally, you also gain a Tremorsense of 3 Spaces. If you already have a Tremorsense, it increases by 2 Spaces."
						},
						{
							"name": "Urban",
							"description": "You gain 2 Skill Points to use on up to 2 of the following Skills: Influence, Insight, Investigation, Intimidation, and Trickery."
						}
					]
				}
			]
		},
		{
			"featureName": "Bestiary (Flavor Feature)",
			"levelGained": 1,
			"description": "You have developed a trove of knowledge hunting creatures which you've recorded in your Bestiary. Your Bestiary can take the form of a book, a memory vault within your mind, or some other representation of your choice. You have ADV on Checks made to learn or recall information about any creature recorded in your Bestiary.\nStarting Entries: Choose a Creature Type: Aberration, Beast, Celestial, Construct, Dragon, Elemental, Fey, Fiend, Giant, Humanoid, Monstrosity, Ooze, Plant, or Undead. Your Bestiary includes prerecorded notes about various creatures of the chosen type.\nMaking New Entries: You can spend 10 minutes of Light Activity recording information into your Bestiary about a specific creature you have slain within the last 24 hours.",
			"isFlavor": true
		},
		{
			"featureName": "Hunter's Strike",
			"levelGained": 2,
			"description": "You have an assortment of unique oils, tools, and weapon accessories that you can use to modify a Weapon (or piece of ammunition) when making an Attack. You can spend 1 SP as part of a Weapon Attack to add 1 of the effects listed below. You can only use 1 of these effects per Attack. If an effect forces the target to make a Save, it does so against your Save DC.",
			"choices": [
				{
					"prompt": "Choose a Hunter's Strike effect.",
					"count": 1,
					"options": [
						{
							"name": "Piercing",
							"description": "2 Piercing damage and Physical Save against Bleeding."
						},
						{
							"name": "Snare",
							"description": "2 Bludgeoning damage and Physical Save against Immobilized until the end of your next turn."
						},
						{
							"name": "Acid",
							"description": "2 Corrosion damage and Agility Save against Slowed until the end of your next turn."
						},
						{
							"name": "Toxin",
							"description": "2 Poison damage and Might Save against Impaired until the end of your next turn."
						},
						{
							"name": "Flash Bang",
							"description": "2 Sonic damage and Mental Save against Dazed until the end of your next turn."
						},
						{
							"name": "Fire Oil",
							"description": "2 Fire damage and Physical Save against Burning."
						}
					]
				}
			]
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Monster Slayer",
			"features": [
				{
					"featureName": "Monstrous Concoctions",
					"levelGained": 3,
					"description": "You hunt down your targets with the aid of Concoctions you have learned to create by hunting monsters.\nConcoction Recipes: You learn 3 Concoction Recipes of your choice from the list below. During a Long Rest, you can prepare ingredients for a number of Vials equal to your Prime Modifier. The ingredients within the Vials are unstable and become inert when you take a Long Rest, at which point you can prepare new ones.\nConcoctions: You can use the Object Action to convert one Vial into a Concoction of your choice and immediately drink it or administer it to a creature within 1 Space, gaining the Concoction's benefits for 10 minutes. You can only benefit from the effects of 1 Concoction at a time. If you consume a new one, the effects of the previous Concoction ends.",
					"choices": [
						{
							"prompt": "Learn 3 Concoction Recipes.",
							"count": 3,
							"options": [
								{
									"name": "Elemental Infusion",
									"description": "Choose an Elemental damage type when you make this Concoction. Hunter's Mark: Attacks you make against your Marked target deal +1 damage of the chosen Elemental Damage type. Elemental Tolerance: You gain Resistance (1) to the chosen Elemental Damage."
								},
								{
									"name": "Hydra's Blood",
									"description": "Hunter's Mark: When you Heavy Hit your Marked target, you regain 1 HP. Poisonous Blood: You have Poisoned Resistance and when a creature within 1 Space of you deals damage to you with an Attack, they take 1 Poison damage."
								},
								{
									"name": "Basilisk Eye",
									"description": "Hunter's Mark: You can sense the vibrations made by your Marked target, giving you Tremorsense 20 Spaces when locating them. Stone Skin: You gain Physical Resistance (1)."
								},
								{
									"name": "Ooze Gel",
									"description": "Hunter's Mark: When you Heavy Hit your Marked Target, you cover it in slime. It's Hindered until it or a creature within 1 Space of it spends 1 AP to remove the slime. Amorphous Body: You can climb difficult surfaces without needing to make a Check (including upside down on ceilings) and can squeeze through gaps as small as 2 inches (5 cm)."
								},
								{
									"name": "Aberrant Tumor",
									"description": "Hunter's Mark: While within 20 Spaces of your Marked target, you have ADV when you use Analyze Creature on them and you have ADV on Mental Saves your Marked target forces you to make. Unreadable: You gain Psychic Resistance (1) and your thoughts can't be read by others unless you allow it."
								},
								{
									"name": "Deathweed",
									"description": "Hunter's Mark: When you score a Heavy Hit against a Marked target it bypasses their Physical Resistances and prevents them from regaining HP until the start of your next turn. Death State: You enter a state between life and death, granting you Umbral Resistance (Half), immunity to being Doomed, and ADV on Death Saves."
								},
								{
									"name": "Plant Fibers",
									"description": "Hunter's Mark: If your Marked Target fails a Save you force it to make, they can't move until the end of your next turn. Plant Stitching: You become Immune to Bleeding and gain 1 Temp HP at the end of each of your turns."
								},
								{
									"name": "Divine Water",
									"description": "Hunter's Mark: Once on each of your turns when you score a Heavy Hit against your Marked target, it also becomes Exposed on the next Attack against it before the end of your next turn. Brilliant Essence: You gain Radiant Resistance (Half) and radiate Bright Light in a 5 Space Radius."
								}
							]
						}
					]
				},
				{
					"featureName": "Monster Hunter (Flavor Feature)",
					"levelGained": 3,
					"description": "You are a master at hunting monsters. If you have 3 entries of creatures with the same Creature Type in your Hunter's Bestiary, you can add the entire Creature Type as an entry.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Trapper",
			"features": [
				{
					"featureName": "Dynamic Traps",
					"levelGained": 3,
					"description": "You are able to use a variety of supplies to craft traps.\nCreating Traps: You can have a maximum number of Hunter's Traps equal to your Prime Modifier at any time. During a Long Rest, you can craft a number of Traps equal to your Prime Modifier. You can make 1 additional Trap as part of a Short Rest. These Traps use your Save DC when they force a creature to make a Save or when a Check is made to interact with them.\nSetting a Trap: You can spend 1 AP to Set and Hide one of your Traps in a Space within 5 Spaces that doesn't already contain a Trap. The Trap is Hidden to creatures, and the DC to discover or disarm the Trap is equal to your Save DC. When you do, you can spend 1 SP to add the damage and effect of one of your Hunter's Strike options to the Trap. Once Set, your Traps are unstable and fall apart harmlessly after 1 hour.\nTriggering a Trap: A Trap is Triggered when a creature other than you enters or leaves a Space occupied by the Trap. Alternatively, you can spend 1 AP to Trigger a Trap within 5 Spaces. When Triggered, the Trap makes an Attack for free against the AD of a creature in its Space using your Attack Check. This Attack ignores your Multiple Check Penalty and doesn't progress that penalty.\nHit: The Trap deals Bludgeoning, Piercing, or Slashing damage (your choice when you Set the Trap) equal to your Prime Modifier, plus the damage and effects of your Hunter's Strike (if used when you Set the Trap).\nRecovering a Trap: You can spend 1 AP while within 1 Space of one of your Set Traps to disarm and recover the use of the Trap. When you do, it loses any damage and effects of your Hunter's Mark (if applicable)."
				},
				{
					"featureName": "Discerning Eye (Flavor Feature)",
					"levelGained": 3,
					"description": "You have ADV on Awareness Checks to discover Hidden Traps and on Investigation Checks to discern how to disarm them.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/classes/hunter_table.json
````json
{
	"className": "Hunter",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 4,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/classes/monk_features.json
````json
{
	"className": "Monk",
	"startingEquipment": {
		"weaponsOrShields": ["2 Weapons", "3 Weapons with the Toss or Thrown Property"],
		"armor": "1 set of Light Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"martialPath": {
		"combatTraining": {
			"weapons": ["Weapons"],
			"armor": ["Light Armor"]
		},
		"maneuvers": {
			"learnsAllAttack": true,
			"additionalKnown": "Maneuvers Known column of the Monk Class Table"
		},
		"techniques": {
			"additionalKnown": "Techniques Known column of the Monk Class Table"
		},
		"staminaPoints": {
			"maximumIncreasesBy": "Stamina Points column of the Monk Class Table"
		},
		"staminaRegen": {
			"description": "Once per round, you can regain up to half your maximum SP when you succeed on an Attack Check, Athletics Check, or Acrobatics Check.",
			"conditions": []
		}
	},
	"coreFeatures": [
		{
			"featureName": "Monk Training",
			"levelGained": 1,
			"description": "Your martial arts training grants you greater offense, defense, and movement.",
			"benefits": [
				{
					"name": "Iron Palm",
					"description": "Your limbs are considered Natural Weapons with the Impact Property that deal 1 Bludgeoning damage."
				},
				{
					"name": "Patient Defense",
					"description": "While you aren't wearing Armor, you gain +2 PD."
				},
				{
					"name": "Step of the Wind",
					"description": "While you aren't wearing Armor, you gain the following benefits:\n• You gain +1 Speed and Jump Distance.\n• You can move a number of Spaces up to your Speed along vertical surfaces and across liquids without falling during your move.\n• You can use your Prime Modifier instead of Agility to determine your Jump Distance and the damage you take from Falling."
				}
			]
		},
		{
			"featureName": "Monk Stance",
			"levelGained": 1,
			"description": "You learn 2 Monk Stances from the list below. Entering & Exiting: In Combat, at the start of each of your turns you can freely enter or swap into one of your Monk Stances. You can also spend 1 SP on your turn to swap to a different stance. You can end your Stance at any moment for free. You can only be in 1 Monk Stance at a time.",
			"choices": [
				{
					"prompt": "Learn 2 Monk Stances.",
					"count": 2,
					"options": [
						{
							"name": "Bear Stance (Big Hits)",
							"description": "• +1 damage when you score a Heavy, Brutal, or Critical Hit with a Melee Martial Attack.\n• Once on each of your turns, when you Miss an Attack with a Melee Martial Attack, you gain ADV on the next Melee Martial Attack you make before the end of your turn."
						},
						{
							"name": "Bull Stance (Knockback)",
							"description": "• You deal +1 Bludgeoning damage whenever you Succeed on a Physical Check to push a target or knock them back.\n• When you shove or push a target, it's knocked back 1 additional space. Additionally, you can choose to move in a straight line with the target an amount of spaces equal to how far they're knocked back. This movement requires no AP and doesn't provoke Opportunity Attacks."
						},
						{
							"name": "Cobra Stance (Counter)",
							"description": "• +1 damage with Melee Martial Attack against creatures that have damaged you since the start of your last turn.\n• When a creature within your Melee Range misses you with a Melee Attack, you can spend 1 AP as a Reaction to make a Melee Martial Attack against it."
						},
						{
							"name": "Gazelle Stance (Nimble)",
							"description": "While not wearing Heavy Armor you gain the following benefits:\n• +1 Movement Speed and Jump Distance.\n• Ignore Difficult Terrain.\n• ADV on Agility Saves and Acrobatics Checks."
						},
						{
							"name": "Mantis Stance (Grapple)",
							"description": "• ADV on all Martial Checks to initiate, maintain, or escape Grapples.\n• If you have a creature Grappled at the start of your turn, you get +1 AP to use on a Grapple Maneuver against the Grappled creature."
						},
						{
							"name": "Mongoose Stance (Multi)",
							"description": "• Your Melee Martial Attacks deal +1 damage while you're Flanked.\n• When you make a Melee Martial Attack against a target, you can make another Melee Martial Attack for free against a different target within your Melee Range. You can only make this bonus Melee Martial Attack once on each of your turns. Make a single Attack Check and apply the number rolled to each target's Physical Defense. Attack Hit: You deal your Melee Martial Attack damage."
						},
						{
							"name": "Scorpion Stance (Quick Strike)",
							"description": "• When a creature enters your Melee Range, you can make an Opportunity Attack against them with a Melee Martial Attack.\n• When you make a Melee Martial Attack, you can spend 1 AP to deal +1 damage and force the target to make a Physical Save against your Save DC. Failure: The target is Impaired (DisADV on Physical Checks) on the next Physical Check it makes before the end of your next turn."
						},
						{
							"name": "Turtle Stance (Sturdy)",
							"description": "• Your Speed becomes 1 (unless it's already lower).\n• You gain PDR, EDR, and MDR.\n• You have ADV on Might Saves and Saves against being moved or knocked Prone."
						},
						{
							"name": "Wolf Stance (Hit & Run)",
							"description": "• After you make an Attack with a Melee Martial Attack, you can immediately move up to 1 Space for free.\n• You have ADV on Opportunity Attacks, and creatures have DisADV on Opportunity Attacks made against you."
						}
					]
				}
			]
		},
		{
			"featureName": "Meditation (Flavor Feature)",
			"levelGained": 1,
			"description": "You can enter a state of meditation during a Short Rest (1 hour) or longer. Choose 1 Charisma or Intelligence Skill. When you complete the Rest, your Skill Mastery level increases by 1 (up to your Skill Mastery Cap) for the chosen Skill until you complete another Short or longer Rest. While meditating, you remain alert to danger.",
			"isFlavor": true
		},
		{
			"featureName": "Spiritual Balance",
			"levelGained": 2,
			"description": "You gain the power to harness your inner spirit as a counterbalance against your physical energy.\nKi Points: You have a maximum number of Ki Points equal to your Stamina Points. When your Stamina Point maximum increases, your Ki Point maximum increases equally.\nRegaining Ki: When you spend a Stamina Point on your turn, you regain a Ki Point. You regain all spent Ki Points when Combat ends. While out of Combat, any Ki Points you spend replenish immediately."
		},
		{
			"featureName": "Ki Actions",
			"levelGained": 2,
			"description": "You can spend 1 Ki Point at any time to perform 1 of the activities listed below:",
			"benefits": [
				{
					"name": "Deflect Attack",
					"description": "When a creature misses you with a Ranged Attack using a physical projectile that targets your PD, you can catch the projectile with a free hand. You can immediately redirect the Attack as part of the same action at a different creature you can see within 5 Spaces. Make an Attack Check against the new target's PD. Hit: The target takes the projectile's normal damage."
				},
				{
					"name": "Slow Fall",
					"description": "Reduce damage you take from falling by an amount equal to your level."
				},
				{
					"name": "Uncanny Dodge",
					"description": "When a creature makes an Attack against you, you can impose DisADV on the attack."
				}
			]
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Astral Self",
			"features": [
				{
					"featureName": "Astral Awakening",
					"levelGained": 3,
					"description": "Astral Damage: When you gain this feature, choose a Mystical damage type. This damage type is your Astral Damage.\nDuring Combat, you can spend 1 AP and 1 SP to manifest a portion of your astral self for 1 minute. For the duration, you gain the following benefits:\n• Astral Arms: You manifest 2 astral arms that can only be used to make Unarmed Strikes. They can't otherwise interact with creatures or objects. Attacks made using these Astral Arms have the Reach property, deal Astral Damage instead of the normal damage type, and can target PD or AD (choose for each Attack).\n• Astral Deflection: You can now use Deflect Attack on Ranged Attacks that miss any target within 2 Spaces.\nEnding Early: The effect ends early if you fall Unconscious, die, or choose to end it for free."
				},
				{
					"featureName": "Astral Watch (Flavor Feature)",
					"levelGained": 3,
					"description": "While Unconscious, your astral self remains aware of your surroundings. You can hold conversations with nearby creatures as if you were awake. While sleeping normally, you can choose to wake yourself up at any time.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Shifting Tide",
			"features": [
				{
					"featureName": "Ebb and Flow",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Ebb: When you enter a new Monk Stance, you gain 2 Spaces of movement.\n• Flow: When you use your Uncanny Dodge against a Melee Attack, you can spend 1 AP to make an Opportunity Attack against the Attacker.\n• Changing Tides: You can use your Deflect Attack on Melee Martial Attacks from Large or smaller creatures. When you do, you can redirect the Attack to another target within 1 Space of you."
				},
				{
					"featureName": "Fluid Movement (Flavor Feature)",
					"levelGained": 3,
					"description": "You can move through Spaces as if you were one size Smaller.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/classes/monk_table.json
````json
{
	"className": "Monk",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 4,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/classes/rogue_features.json
````json
{
	"className": "Rogue",
	"startingEquipment": {
		"weaponsOrShields": ["2 Weapons or Light Shields"],
		"rangedWeapon": "1 Ranged Weapon with 20 Ammo OR 3 Weapons with the Toss or Thrown Property",
		"armor": "1 set of Light Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"martialPath": {
		"combatTraining": {
			"weapons": ["Weapons"],
			"armor": ["Light Armor"],
			"shields": ["Light Shields"]
		},
		"maneuvers": {
			"learnsAllAttack": true,
			"additionalKnown": "Maneuvers Known column of the Rogue Class Table"
		},
		"techniques": {
			"additionalKnown": "Techniques Known column of the Rogue Class Table"
		},
		"staminaPoints": {
			"maximumIncreasesBy": "Stamina Points column of the Rogue Class Table"
		},
		"staminaRegen": {
			"description": "Once per round, you can regain up to half your maximum SP when:",
			"conditions": [
				"You Hit a Flanked or Prone target.",
				"You Hit a target affected by at least 1 Condition.",
				"You Hit a target you're Hidden from.",
				"You gain the benefits of your Cunning Action."
			]
		}
	},
	"coreFeatures": [
		{
			"featureName": "Debilitating Strike",
			"levelGained": 1,
			"description": "When you make an Attack with a Weapon, you can spend 1 SP to force the target to make a Physical Save against your Save DC. Save Failure: Until the start of your next turn, the target suffers 1 of the following effects of your choice: Deafened, Exposed, Hindered, or Slowed 2. A target can't be affected by the same option more than once at a time."
		},
		{
			"featureName": "Roguish Finesse",
			"levelGained": 1,
			"description": "You gain the following benefits:",
			"benefits": [
				{
					"name": "Cunning Action",
					"description": "You gain movement equal to half your Speed when you take the Disengage, Feint, or Hide Actions. You can use this movement immediately before or after you take the Action."
				},
				{
					"name": "Skill Expertise",
					"description": "Your Skill Mastery Limit increases by 1, up to Grandmaster (+10). A Skill can only benefit from one increase to its Mastery limit."
				},
				{
					"name": "Multi-Skilled",
					"description": "You gain 1 Skill Point."
				}
			]
		},
		{
			"featureName": "Cypher Speech (Flavor Feature)",
			"levelGained": 1,
			"description": "You become Fluent in a Mortal Language of your choice. Additionally, you understand how to speak in code with a specific demographic of your choice (such as upper society, lower society, a faction, etc.). Your coded messages can be concealed in normal conversation and written communications. This allows you to leave simple messages such as 'Safety', 'Threat' or 'Wealth' or mark the location of a cache, a secret passageway, a safehouse, or an area of danger.",
			"isFlavor": true
		},
		{
			"featureName": "Cheap Shot",
			"levelGained": 2,
			"description": "You deal +1 damage on Martial Attacks against a creature that fulfills at least one of the following:\n• It's Flanked or Prone.\n• It has any Condition other than Invisible.\n• You're Hidden from it."
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Long Death",
			"features": [
				{
					"featureName": "Thousand Cuts",
					"levelGained": 3,
					"description": "When a creature fails its Save against your Debilitating Strike, it also begins Bleeding (even if it's immune to the Condition). If a creature is affected by Bleeding from this Feature, the DC to end the Bleeding Condition is equal to your Save DC and it can no longer be ended by regaining HP."
				},
				{
					"featureName": "Hundred Ways to Die (Flavor Feature)",
					"levelGained": 3,
					"description": "You are an expert at studying and identifying weaknesses in bodies and how best to kill creatures. You have ADV on any Check made to determine how something died or could die easier. This also extends to poisons, toxins, or identifying other materials used to kill.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Swashbuckler",
			"features": [
				{
					"featureName": "Renegade Duelist",
					"levelGained": 3,
					"description": "You're skilled at make a mockery of your opponents while taking advantage of their openings. You gain the following benefits:\n• Flourishes: Your Cunning Action now also includes the Disarm and Dodge Actions.\n• Taunting Shot: Once on each of your turns when you make an Attack against a creature with a Condition, you can forgo your Cheap Shot damage to force the target to make a Charisma Save. Failure: The target is Taunted until the end of your next turn.\n• Riposte: When a creature within your Melee Range misses you with an Attack, it provokes an Opportunity Attack from you."
				},
				{
					"featureName": "Tall Tales (Flavor Feature)",
					"levelGained": 3,
					"description": "You know how to play to a crowd. You can spend up to 5 minutes telling a story to a crowd of creatures (that are not immediately hostile to you) and keep their rapt attention the entire time. During this story, creatures within the crowd have DisADV on Awareness Checks.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/classes/rogue_table.json
````json
{
	"className": "Rogue",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 4,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/classes/sorcerer_features.json
````json
{
	"className": "Sorcerer",
	"startingEquipment": {
		"weaponsOrShields": ["1 Weapon"],
		"armor": "1 set of Light Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"spellcastingPath": {
		"combatTraining": {
			"armor": ["Light Armor"]
		},
		"spellList": {
			"type": "any",
			"listName": "Choose 1 Spell List (Arcane, Divine, or Primal)",
			"description": "When you learn a new Spell, you can choose any Spell from the chosen Spell List.",
			"betaNote": "You get access to the following \"Premade List\" that have had their Spells pre-selected for you: Fire & Flames, Ice & Illusions, Lightning & Teleportation, or Psychic & Enchantment"
		},
		"cantrips": {
			"knownIncreasesBy": "Cantrips Known column of the Sorcerer Class Table",
			"description": "Cantrips are Spells with the Cantrip Spell Tag."
		},
		"spells": {
			"knownIncreasesBy": "Spells Known column of the Sorcerer Class Table",
			"description": "These can be Spells with or without the Cantrip Spell Tag."
		},
		"manaPoints": {
			"maximumIncreasesBy": "Mana Points column of the Sorcerer Class Table"
		}
	},
	"coreFeatures": [
		{
			"featureName": "Innate Power",
			"levelGained": 1,
			"description": "Choose a Sorcerous Origin that grants you a benefit: Intuitive Magic, Resilient Magic, or Unstable Magic. Additionally, you gain the following benefits:\n• Your Maximum MP increases by 1.\n• Once per Long Rest, you can use a 1 MP Spell Enhancement without spending any MP (up to your Mana Spend Limit). You regain the ability to use this benefit when you roll for Initiative."
		},
		{
			"featureName": "Sorcerous Origins",
			"levelGained": 1,
			"description": "Choose one of the following Sorcerous Origins.",
			"choices": [
				{
					"prompt": "Choose a Sorcerous Origin.",
					"count": 1,
					"options": [
						{
							"name": "Intuitive Magic",
							"description": "You learn an additional Spell and Cantrip from your Sorcerer Spell List."
						},
						{
							"name": "Resilient Magic",
							"description": "You gain Dazed Resistance."
						},
						{
							"name": "Unstable Magic",
							"description": "When you Critically Succeed or Fail on a Spell Check, roll on the Wild Magic Table. If it's a Critical Success you roll with ADV, if it's a Critical Failure you roll with DisADV. The effect lasts until the end of your next turn, unless stated otherwise. When you roll on the Wild Magic Table in this way, you gain ADV on the next Spell Check you make before the end of your next turn."
						}
					]
				}
			]
		},
		{
			"featureName": "Overload Magic",
			"levelGained": 1,
			"description": "You can spend 2 AP in Combat to channel raw magical energy for 1 minute, or until you become Incapacitated, die, or choose to end it early at any time for free. For the duration, your magic is overloaded and you're subjected to the following effects:\n• You gain +5 to all Spell Checks you make.\n• You must immediately make an Attribute Save (your choice) against your Save DC upon using this Feature, and again at the start of each of your turns. Failure: You gain Exhaustion. You lose any Exhaustion gained in this way when you complete a Short Rest."
		},
		{
			"featureName": "Sorcery (Flavor Feature)",
			"levelGained": 1,
			"description": "You learn the Sorcery Spell.",
			"isFlavor": true
		},
		{
			"featureName": "Meta Magic",
			"levelGained": 2,
			"description": "You gain 2 unique Spell Enhancements from the list below. You can only use 1 of these Spell Enhancements per Spell you cast. MP spent on these Spell Enhancements doesn't count against your Mana Spend Limit.",
			"choices": [
				{
					"prompt": "Choose 2 Meta Magic options.",
					"count": 2,
					"options": [
						{
							"name": "Careful Spell",
							"description": "When you Cast a Spell that targets an Area of Effect, you can choose to protect some of the creatures from the Spell's full force. Spend 1 MP and choose a number of creatures up to your Prime Modifier. All chosen creatures are immune to the Spell's damage and effects."
						},
						{
							"name": "Heightened Spell",
							"description": "When you cast a Spell that forces a creature to make a Save to resist its effects, you can spend 1 MP to give 1 target DisADV on its first Save against the Spell."
						},
						{
							"name": "Quickened Spell",
							"description": "You can spend 1 MP to reduce the AP cost of a Spell by 1 (minimum of 1 AP)."
						},
						{
							"name": "Subtle Spell",
							"description": "When you cast a Spell, you can spend 1 MP to cast it without any Somatic or Verbal Components."
						},
						{
							"name": "Transmuted Spell",
							"description": "When you cast a Spell that deals a type of damage from the following list, you can spend 1 MP to change that damage type to one of the other listed types: Cold, Corrosion, Fire, Lightning, Poison, or Sonic."
						}
					]
				}
			]
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Angelic",
			"features": [
				{
					"featureName": "Celestial Spark",
					"levelGained": 3,
					"description": "You can use a Minor Action to emit Bright Light within a 5 Space Radius and can end the effect at any time. You also gain the following abilities:\n• Celestial Origin: You gain 2 Ancestry Points that can only be spent on Angelborn Traits.\n• Celestial Protection: You learn the Careful Spell Meta Magic option (choose another Meta Magic option if you already know it) and Careful Spell now costs 0 MP to use.\n• Celestial Overload: Once per Combat while you're Overloaded, you can spend 1 AP to release a burst of radiant light in a 5 Space Aura. Creatures of your choice within range are either healed or seared by the light (your choice for each creature).\n  - Healed: The creature regains 1 HP.\n  - Seared: Make a Spell Check against the target's AD. Success: The target takes 1 Radiant damage."
				},
				{
					"featureName": "Celestial Appearance (Flavor Feature)",
					"levelGained": 3,
					"description": "You gain additional angelic features such as sparkling skin, feathers, a faint halo, or other changes of your choice. If you already have these features, they're enhanced or expanded upon. Additionally, you gain 1 level of Language Mastery in Celestial. If you're already Fluent in Celestial, you gain 1 level of Language Mastery in another Language of your choice.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Draconic",
			"features": [
				{
					"featureName": "Draconic Spark",
					"levelGained": 3,
					"description": "You gain the following abilities:\n• Draconic Origin: You gain 2 Ancestry Points that can only be spent on Dragonborn Traits. Additionally, choose a Draconic Origin from the Dragonborn Ancestry if you haven't already.\n• Draconic Overload: While Overloaded, you gain Resistance (1) to Physical damage and your Draconic Origin damage type.\n• Draconic Transmutation: You gain the Transmuted Spell Meta Magic (choose another Meta Magic option if you already have Transmuted Spell). Transmuted Spell now costs you 0 MP to use if you change the damage type to your Draconic Origin damage type."
				},
				{
					"featureName": "Draconic Appearance (Flavor Feature)",
					"levelGained": 3,
					"description": "You gain additional draconic features such as scales, fangs, claws, or other changes of your choice. If you already have these features, they're enhanced or expanded upon. Additionally, you gain 1 level of Language Mastery in Draconic. If you're already Fluent in Draconic, you gain 1 level of Language Mastery in another Language of your choice.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/classes/sorcerer_table.json
````json
{
	"className": "Sorcerer",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 8,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 6,
			"cantripsKnown": 2,
			"spellsKnown": 3,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/classes/warlock_table.json
````json
{
	"className": "Warlock",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 6,
			"cantripsKnown": 2,
			"spellsKnown": 3,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/classes/wizard_table.json
````json
{
	"className": "Wizard",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 8,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 6,
			"cantripsKnown": 2,
			"spellsKnown": 3,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/loaders/class.loader.ts
````typescript
import { classesDataSchema, type IClassDefinition } from '../schemas/class.schema';

// Use Vite's import.meta.glob to import only the class table JSON files.
// The `eager: true` option imports the modules directly, so they are available synchronously.
const tableModules = import.meta.glob('../classes/*_table.json', { eager: true });

// Extract the default export (the class object) from each module.
const tableData = Object.values(tableModules).map((module: any) => module.default);

// Create progression data structure from table files (stats only, no features)
const compatibleData = tableData.map((classTable: any) => {
	const className = classTable.className;

	return {
		id: className.toLowerCase(),
		name: className,
		description: `${className} class progression table`,
		baseHpContribution: classTable.levelProgression?.[0]?.healthPoints || 0,
		startingSP: classTable.levelProgression?.[0]?.staminaPoints || 0,
		startingMP: classTable.levelProgression?.[0]?.manaPoints || 0,
		// Add other required fields with default values
		skillPointGrantLvl1: classTable.levelProgression?.[0]?.skillPoints || 0,
		tradePointGrantLvl1: classTable.levelProgression?.[0]?.tradePoints || 0,
		combatTraining: [],
		maneuversKnownLvl1: classTable.levelProgression?.[0]?.maneuversKnown || 0,
		techniquesKnownLvl1: classTable.levelProgression?.[0]?.techniquesKnown || 0,
		saveDCBase: 8,
		deathThresholdBase: 10,
		moveSpeedBase: 5, // DC20: Base movement speed is 5 spaces
		restPointsBase: 4,
		gritPointsBase: 2,
		initiativeBonusBase: 0,
		cantripsKnownLvl1: classTable.levelProgression?.[0]?.cantripsKnown || 0,
		spellsKnownLvl1: classTable.levelProgression?.[0]?.spellsKnown || 0,
		// Store the full level progression for future level gaining
		levelProgression: classTable.levelProgression,
		// Empty arrays for features - these should be handled by class-features.loader.ts
		level1Features: [],
		featureChoicesLvl1: []
	};
});

// Validate the combined data against the Zod schema.
// The parse method will throw a detailed error if validation fails.
const validatedData = classesDataSchema.parse(compatibleData);

// Export the validated data with the correct type.
export const classesData: IClassDefinition[] = validatedData;
````

## File: src/lib/rulesdata/spells-data/spells/additional-spells/close-wounds.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const closeWounds: Spell = {
	name: 'Close Wounds',
	premadeList: PremadeSpellList.Additional,
	school: SpellSchool.Restoration,
	isCantrip: true,
	cost: { ap: 1 },
	range: '1 Space',
	duration: 'Instant',
	spellLists: [SpellList.Divine],
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Heal Allied Creature',
			description:
				'You touch an allied creature that has at least 1 HP, tapping into its inner life force to cause a surge of natural healing. Make a DC 10 Spell Check. Success: The target can spend 1 Rest Point to regain 2 HP. Failure: The target spends 1 Rest Point to regain 1 HP.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Range',
			description: 'You increase the range to 10 Spaces (and don’t have to touch the target).'
		},
		{
			type: 'MP',
			cost: 1,
			name: 'Bolster',
			description:
				'You increase the HP regained by 3. You can take this enhancement multiple times.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/additional-spells/death-bolt.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const deathBolt: Spell = {
	name: 'Death Bolt',
	premadeList: PremadeSpellList.Additional,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [SpellList.Arcane, SpellList.Divine],
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Spell Attack',
			description:
				'You can make a Spell Check against the PD of a target within range. Hit: The target takes 2 Umbral damage.'
		},
		{
			title: 'Black Orb',
			description:
				'Black wispy magic swirls around your hands. Your touch send chills down the spine of creatures and make small plants wither. You can hold this dark energy in your hands for 1 minute.'
		}
	],
	cantripPassive: 'You deal +1 damage against creatures that are Bloodied.',
	enhancements: [
		{ type: 'AP', cost: 1, name: 'Damage', description: 'You deal +1 Umbral damage.' },
		{ type: 'AP', cost: 1, name: 'Range', description: 'You increase the range by 5 Spaces.' },
		{
			type: 'AP',
			cost: 1,
			name: 'Dampen Heal',
			description:
				'Creatures that take damage from this Spell can’t regain HP until the start of their next turn.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/additional-spells/druidcraft.ts
````typescript
import { Spell, SpellSchool, PremadeSpellList } from '../../types/spell.types';

export const druidcraft: Spell = {
	name: 'Druidcraft',
	premadeList: PremadeSpellList.Additional,
	school: SpellSchool.Transmutation,
	isCantrip: true,
	cost: { ap: 1 },
	range: '5 Spaces',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Natural Sensory Effect',
			description:
				'You target an area within range and produce a harmless natural smell (such as flowers, faint odor of skunk, etc.) or sound (rustling leaves, a small animal, etc.).'
		},
		{
			title: 'Accelerate Plant Growth',
			description:
				'You target a living mundane plant and instantly accelerate the growth of the plant (flowers bloom, seeds open, etc.).'
		},
		{
			title: 'Revive Plant',
			description:
				'You target a wounded or dead mundane plant (smaller than a 1 Space cube) and bring it back to life.'
		}
	],
	enhancements: [] // No enhancements specified in PDF
};
````

## File: src/lib/rulesdata/spells-data/spells/additional-spells/tethering-vines.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const tetheringVines: Spell = {
	name: 'Tethering Vines',
	premadeList: PremadeSpellList.Additional,
	school: SpellSchool.Conjuration,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '10 Spaces',
	duration: '1 min (Sustained)',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Sprout Vines',
			description:
				'Choose a Space within range. Vines and weeds sprout up from the ground in a 3 Space Radius from the chosen Space, making the area Difficult Terrain. Make a Spell Check Contested by a Physical Save from all creatures (other than you) within range. Success: The creature is Tethered. Tethered: While Tethered, the creature can’t leave the area. The creature can spend 1 AP to make a Physical Check of your choice against your Save DC. Success: The target is no longer Tethered. When the Spell ends, the conjured plants wilt away.'
		}
	],
	enhancements: [
		{ type: 'MP', cost: 1, name: 'Widen Vines', description: 'The radius increases by 1 Space.' }
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/fiendborn-ancestry-spells/acid-bolt.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const acidBolt: Spell = {
	name: 'Acid Bolt',
	premadeList: PremadeSpellList.FiendbornAncestry,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [SpellList.Arcane, SpellList.Primal],
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Spell Attack',
			description:
				'You can make a Spell Check against the PD of a target within range. Hit: The target takes 2 Corrosion damage.'
		}
	],
	cantripPassive: 'You deal +1 damage against creatures that are Hindered.',
	enhancements: [
		{ type: 'AP', cost: 1, name: 'Damage', description: 'You deal +1 Corrosion damage.' },
		{ type: 'AP', cost: 1, name: 'Range', description: 'You increase the range by 5 Spaces.' },
		{
			type: 'AP',
			cost: 1,
			name: 'Corrode',
			description:
				'The target makes a Physical Save. Failure: Target becomes Hindered for 1 minute or until a creature (including itself) within 1 Space spends 1 AP to clear off the acid.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/fiendborn-ancestry-spells/poison-bolt.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const poisonBolt: Spell = {
	name: 'Poison Bolt',
	premadeList: PremadeSpellList.FiendbornAncestry,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [SpellList.Arcane, SpellList.Primal],
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Spell Attack',
			description:
				'You can make a Spell Check against the PD of a target within range. Hit: The target takes 2 Poison damage.'
		}
	],
	cantripPassive: 'You deal +1 damage against creatures that are Impaired.',
	enhancements: [
		{ type: 'AP', cost: 1, name: 'Damage', description: 'You deal +1 Poison damage.' },
		{ type: 'AP', cost: 1, name: 'Range', description: 'You increase the range by 5 Spaces.' },
		{
			type: 'AP',
			cost: 1,
			name: 'Sicken',
			description:
				'The target makes a Physical Save. Failure: Target becomes Impaired for 1 minute. A creature within 1 Space, including itself, can spend 1 AP to make a DC 10 Medicine Check to end the Condition early.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/fire-and-flames/burning-flames.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const burningFlames: Spell = {
	name: 'Burning Flames',
	premadeList: PremadeSpellList.FireAndFlames,
	school: SpellSchool.Destruction,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: 'Self (10 Spaces)',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Area of Effect',
			description:
				'A brilliant flame manifests around you. Choose a type of area: Line, Cone, or Sphere. You are the Spell’s Point of Origin. Line: The Spell affects every target in a 1 Space wide and 10 Space long line. Cone: The Spell creates a 3 Space long Cone. Sphere: The Spell affects every target in a 2 Space radius. Make a Spell Check against every target’s AD within the Spell’s area. Hit: The target takes 2 Fire damage.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Burning',
			description:
				'Each target makes a Physical Save. Failure: The target begins Burning until a creature (including itself) within 1 Space spends 1 AP to put it out.'
		},
		{
			type: 'MP',
			cost: 1,
			name: 'Range',
			description:
				'The Point of Origin of the Spell becomes a point of your choice within 15 Spaces (instead of Self).'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/fire-and-flames/dancing-flames.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const dancingFlames: Spell = {
	name: 'Dancing Flames',
	premadeList: PremadeSpellList.FireAndFlames,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '20 Spaces',
	duration: '1 min (Sustained)',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Create Flames',
			description:
				'Make a DC 10 Spell Check. Success: You create up to 3 torch-sized Flames within range, making them appear as torches, lanterns, or glowing orbs that hover in the air for the duration. Success (each 5): +1 Flame. Failure: 2 Flames. You can also combine 4 Flames into 1 glowing vaguely humanoid form of Medium Size. Whichever form you choose, each Flame sheds Bright Light in a 2 Space radius. You can spend 1 AP to move the Flames up to 10 Spaces to a new Space within range. A Flame must be within 5 Spaces of another Flame created by this Spell and be within 20 Spaces from you, or it winks out of existence.'
		}
	],
	enhancements: [
		{
			type: 'AP',
			cost: 2,
			name: 'Detonate',
			description:
				'Spend 2 AP and 1 MP to detonate the Flames. Make a single Spell Check and compare it against the AD of each target sharing a Space with a Flame. Hit: Each Flame in that Space deals 1 Fire damage to the target, but doesn’t benefit from Heavy, Brutal, or Critical Hits.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/fire-and-flames/fire-shield.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const fireShield: Spell = {
	name: 'Fire Shield',
	premadeList: PremadeSpellList.FireAndFlames,
	school: SpellSchool.Abjuration,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: 'Self',
	duration: '1 hour',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Protective Force',
			description:
				'A protective magical force surrounds you, manifesting as spectral flames that cover you and your gear. You emit Bright Light in a 2 Space Radius. Make a DC 15 Spell Check. Success: You gain 3 Temp HP. Success (each 5): +1 Temp HP. Failure: 2 Temp HP. If a creature hits you with a Melee Attack while you have this Temp HP, the creature takes 1 Fire damage for each Temp HP it consumed with its Attack. The Spell ends once the Temp HP is consumed.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 3,
			name: 'Fire Protection',
			description: 'You gain Fire Resistance (Half) and 10 more Temp HP.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/fire-and-flames/fog-cloud.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const fogCloud: Spell = {
	name: 'Fog Cloud',
	premadeList: PremadeSpellList.FireAndFlames,
	school: SpellSchool.Conjuration,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '20 Spaces',
	duration: '1 hour (Sustained)',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Create Fog',
			description:
				'Make a DC 10 Spell Check. Success: You create a sphere of fog with up to a 4 Space radius, centered on a point within range. Succeed (each 5): Radius increases by 1 Space. Failure: 3 Space radius. The Sphere spreads around corners and its area is Fully Concealed. Creatures within 1 Space of each other can see each other normally. The fog lasts for the duration or until a wind of moderate or greater speed disperses it.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Area of Effect',
			description: 'The radius of the Spell’s effect increases by 3 Spaces.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/fire-and-flames/grease.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const grease: Spell = {
	name: 'Grease',
	premadeList: PremadeSpellList.FireAndFlames,
	school: SpellSchool.Conjuration,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '10 Spaces',
	duration: '1 min',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Slick Ground',
			description:
				'Make a DC 10 Spell Check. Success: Slick grease covers the ground in 4 Spaces of your choosing within range. Failure: Only 3 Spaces. The Spaces must connect to each other and all be within range of the Spell. These Spaces are considered to be Difficult Terrain for the duration and are flammable. If fire touches one of these Spaces, the grease ignites and deals 1 Fire damage to any creature within the Space instantly and again to any creature who ends their turn in this Space before the Spell ends. If a creature is standing in one of the Spaces when the grease initially appears, when they end their turn, or when they enter it for the first time on a turn they must make an Agility Save. Failure: They fall Prone.'
		}
	],
	enhancements: [
		{ type: 'MP', cost: 1, name: 'More Grease', description: 'You add 4 more Spaces of grease.' },
		{
			type: 'MP',
			cost: 1,
			name: 'More Fire',
			description: 'Fire damage dealt by the Spell is increased by 1.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/fire-and-flames/minor-flame-blade.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const minorFlameBlade: Spell = {
	name: 'Minor Flame Blade',
	premadeList: PremadeSpellList.FireAndFlames,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: 'Self',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Imbue Weapon',
			description:
				'You imbue a Melee Weapon you’re wielding with flames. Until the end of your next turn, the next Attack Check that hits with this weapon deals an additional 1 Fire damage to your target or a creature within 1 Space of the target.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Flame Strike',
			description:
				'You deal an extra 2 Fire damage to the target (must be done before the Attack is made). Miss: Deal 1 Fire damage to the target.'
		},
		{
			type: 'MP',
			cost: 1,
			name: 'Flame Bound',
			description:
				'You deal an extra 1 Fire damage to the target and another target within 1 Space.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/holy-and-restoration/bless.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const bless: Spell = {
	name: 'Bless',
	premadeList: PremadeSpellList.HolyAndRestoration,
	school: SpellSchool.Divination,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '5 Spaces',
	duration: '1 min (Sustained)',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Bless Creatures',
			description:
				'Make a DC 10 Spell Check. Success: You bless up to 3 creatures of your choice within range. Success (each 10): +1 additional creature. Failure: Only 2 creatures. Whenever a target makes a Check or Save before the Spell ends, the target can roll a d4 and add the number rolled to the total.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Targets',
			description: 'You increase the number of targets by 1.'
		},
		{
			type: 'MP',
			cost: 2,
			name: 'Grace',
			description: 'You change the d4 granted by the Spell to a d6.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/holy-and-restoration/guidance.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const guidance: Spell = {
	name: 'Guidance',
	premadeList: PremadeSpellList.HolyAndRestoration,
	school: SpellSchool.Divination,
	isCantrip: true,
	cost: { ap: 1 },
	range: '5 Spaces',
	duration: '1 Round',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Grant Help Die',
			description:
				'You grant a Help Die (d8) to an ally within range. The target can use this Help Die to add to any Check they make before the start of your next turn. Casting Guidance counts as taking the Help Action and still triggers the “Multiple Action Penalty (Help)”. If you cast Guidance again or take the Help Action, the Help Die would be a d6, then a d4, then you wouldn’t be able to grant any more during the same round of Combat.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Sustained',
			description: 'The duration increases to 1 minute, but it requires the Sustain Action.'
		},
		{
			type: 'MP',
			cost: 1,
			name: 'Expand',
			description:
				'You grant an additional Help Die (of the same size you granted with the casting of the Spell).'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/holy-and-restoration/guiding-bolt.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const guidingBolt: Spell = {
	name: 'Guiding Bolt',
	premadeList: PremadeSpellList.HolyAndRestoration,
	school: SpellSchool.Destruction,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '15 Spaces',
	duration: '1 Round',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Flash of Light',
			description:
				'A flash of light streaks toward a creature of your choice within range, surrounding them in a holy glow. Make a Spell Check against the target’s PD. Hit: The target takes 3 Radiant damage and the next Attack Check made against the target before the end of your next turn has ADV.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Guiding Damage',
			description:
				'The next Attack Check made against the target also deals an extra 3 Radiant damage on a Hit.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/holy-and-restoration/heal.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const heal: Spell = {
	name: 'Heal',
	premadeList: PremadeSpellList.HolyAndRestoration,
	school: SpellSchool.Restoration,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Heal Target',
			description:
				'Make a DC 10 Spell Check. Success: You heal the target creature within range for 3 HP. Success (each 5): + 1 HP. Critical Success: +2 HP. Failure: Only heal for 2 HP. If you’re touching the target of this Spell when you cast it, they regain an extra 1 HP.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Quick Heal',
			description: 'You reduce the AP cost of this Spell by 1.'
		},
		{
			type: 'MP',
			cost: 1,
			name: 'Bolster',
			description:
				'You increase the HP regained by 3. You can take this enhancement multiple times.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/holy-and-restoration/light.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const light: Spell = {
	name: 'Light',
	premadeList: PremadeSpellList.HolyAndRestoration,
	school: SpellSchool.Conjuration,
	isCantrip: true,
	cost: { ap: 1 },
	range: 'Touch',
	duration: '1 hour',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Shed Light',
			description:
				'You touch an object that’s no larger than Medium. Until the spell ends, the object sheds Bright Light in a 5 Space radius. You choose the color of the light. Completely covering the object with something opaque blocks the light. The Spell ends if you cast it again or dismiss it as a Free Action. If you target an object held or worn by a hostile creature, make an Attack Check contested by the target’s Agility Save. Success: You cast Light on the object.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Blinding Light',
			description:
				'You make a Spell Check contested by a Physical Save from all targets within 2 Spaces of the Light source. Failure: The target is Blinded for 1 Round.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/holy-and-restoration/shield-of-faith.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const shieldOfFaith: Spell = {
	name: 'Shield of Faith',
	premadeList: PremadeSpellList.HolyAndRestoration,
	school: SpellSchool.Protection,
	isCantrip: false,
	cost: { ap: 1, mp: 1 },
	range: '10 Spaces',
	duration: '10 min (Sustained)',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Protective Field',
			description:
				'A shimmering field appears and surrounds a creature of your choice within range. Make a DC 10 Spell Check. Success: The target gains +2 PD for the duration. Success (each 10): +1 PD. Failure: The target gains 1 PD instead.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Targets',
			description: 'You increase the number of creatures you can affect by 1.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/ice-and-illusions/catapult.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const catapult: Spell = {
	name: 'Catapult',
	premadeList: PremadeSpellList.IceAndIllusions,
	school: SpellSchool.Destruction,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Launch Object',
			description:
				'Choose one object weighing 1 to 5 pounds within range that isn’t being worn or carried. The object flies in a straight line up to 15 Spaces in a direction you choose before falling to the ground, stopping early if it impacts against a solid surface. If you attempt to strike a creature, make a Spell Check against the target’s PD. Hit: 3 Bludgeoning damage.'
		}
	],
	enhancements: [
		{ type: 'MP', cost: 1, name: 'Damage', description: 'You deal +2 Bludgeoning damage.' }
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/ice-and-illusions/ice-knife.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const iceKnife: Spell = {
	name: 'Ice Knife',
	premadeList: PremadeSpellList.IceAndIllusions,
	school: SpellSchool.Destruction,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Ice Shard',
			description:
				'You create a shard of ice and fling it at one creature within range. Make a Spell Check against the target’s PD. Hit: The target takes 2 Cold damage and then the ice explodes. Compare the Spell Check to the AD of each creature within 1 space of the original target (including the target). Hit: Deal 1 Cold damage. Miss: The spell doesn’t explode and only deals half damage to the original target.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Damage',
			description: 'You increase the damage of the initial hit and the explosion by 1 each.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/ice-and-illusions/magic-missile.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const magicMissile: Spell = {
	name: 'Magic Missile',
	premadeList: PremadeSpellList.IceAndIllusions,
	school: SpellSchool.Destruction,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Glowing Darts',
			description:
				'You attempt to fire out glowing darts of magical force. Make a DC 10 Spell Check. Success: You create 2 Missiles. Success (each 5): +1 Missile. Failure: Only 1 Missile. Each Missile automatically deals 1 True damage to its target. Each missile may have the same or different targets.'
		}
	],
	enhancements: [
		{ type: 'MP', cost: 1, name: 'Damage', description: '+1 Missile.' },
		{ type: 'MP', cost: 1, name: 'Range', description: 'You increase the range to 15 Spaces.' }
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/ice-and-illusions/minor-illusion.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const minorIllusion: Spell = {
	name: 'Minor Illusion',
	premadeList: PremadeSpellList.IceAndIllusions,
	school: SpellSchool.Illusion,
	isCantrip: true,
	cost: { ap: 1 },
	range: '5 Spaces',
	duration: '1 min',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Create Sound or Image',
			description:
				'You create a sound or an image of an object within range that lasts for the duration. The illusion ends if you dismiss it for 1 AP or cast this Spell again. If you create a sound, its volume can range from a whisper to a scream. It can be your voice, someone else’s voice, a lion’s roar, a beating of drums, or any other sound you choose. The sound can continue unabated throughout the duration or you can make discrete sounds at different times before the Spell ends. If you create an image of an object—such as a chair, muddy footprints, or a small chest—it must be no larger than 1 Space. The image can’t create sound, light, smell, or any other sensory effect. Discerning the Illusion: If the illusion is an image, any physical interaction with the image reveals it to be an illusion as things pass through it. A creature can spend 1 AP to examine the sound or image to attempt to determine if the illusion is real, by making an Investigation Check against your Save DC. Success: The creature discerns that the objects or sounds made by the Spell are illusions. If the illusion is an image, the illusion becomes transparent to the creature.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Sight and Sound',
			description: 'The illusion can include both a sound and an image.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/ice-and-illusions/silent-image.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const silentImage: Spell = {
	name: 'Silent Image',
	premadeList: PremadeSpellList.IceAndIllusions,
	school: SpellSchool.Illusion,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '10 Spaces',
	duration: '10 min (Sustained)',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Create Image',
			description:
				'You create the image of an object, a creature, or some other visible phenomenon in a 3 Space cube. The image appears at a spot within range and lasts for the duration. The image is purely visual and isn’t accompanied by sound, smell, or other sensory effects. You can spend 1 AP to cause the image to move to any spot within range. As the image changes location, you can alter its appearance so that its movements appear natural. Discerning the Illusion: Physical interaction with the image reveals it to be an illusion. Alternatively, a creature can spend 1 AP to examine the image to attempt to determine if the illusion is real. The creature makes an Investigation Check against your Save DC. Success: The creature discerns the illusion for what it is, revealing it to be false and making the illusion transparent to the creature.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Sound and Smell',
			description: 'You can add sounds and a smell to the illusion.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/lightning-and-teleportation/crackling-lightning.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const cracklingLightning: Spell = {
	name: 'Crackling Lightning',
	premadeList: PremadeSpellList.LightningAndTeleportation,
	school: SpellSchool.Destruction,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: 'Self (10 Spaces)',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Area of Effect',
			description:
				'Crackling lightning forms around you. Choose a type of area: Line, Cone, or Sphere. You are the Spell’s Point of Origin. Line: The Spell affects every target in a 1 Space wide and 10 Space long line. Cone: The Spell creates a 3 Space long Cone. Sphere: The Spell affects every target in a 2 Space radius. Make a Spell Check against every target’s AD within the Spell’s area. Hit: The target takes 2 Lightning damage.'
		}
	],
	enhancements: [
		{
			type: 'AP',
			cost: 1,
			name: 'Frazzled',
			description:
				'Each target makes a Mental Save. Failure: The target becomes Dazed for 1 minute.'
		},
		{
			type: 'MP',
			cost: 1,
			name: 'Range',
			description:
				'The Point of Origin of the Spell becomes a point of your choice within 15 Spaces (instead of Self).'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/lightning-and-teleportation/gust.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const gust: Spell = {
	name: 'Gust',
	premadeList: PremadeSpellList.LightningAndTeleportation,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '5 Spaces',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Push Creature',
			description:
				'Choose a Medium or smaller creature and make a Spell Check contested by their Might Save. Success: Target is pushed 1 Space in a direction of your choice. Success (each 5): +1 Space.'
		},
		{
			title: 'Push Object',
			description:
				'Choose an object that’s neither held nor carried and that weighs no more than 5 pounds. Make a DC 10 Spell Check. Success: The object is pushed up to 3 Spaces away from you. Success (each 5): +1 Space. Failure: Only 2 Spaces.'
		},
		{
			title: 'Sensory Effect',
			description:
				'You create a harmless sensory effect using air, such as causing leaves to rustle, wind to slam shutters closed, or your clothing to ripple as in a breeze.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Wind Tunnel',
			description:
				'You create a 10 Space long and 2 Space wide Line that lasts 1 minute and requires the Sustain Action. The start of the Wind Tunnel must be within 5 Spaces of you. You choose the direction the Line goes in and what direction the wind is blowing. Creatures in the Wind Tunnel are Slowed 1 moving against the wind, but can move 2 Spaces for every 1 Space spent moving the same direction as the wind. Any creature that starts their turn in the Wind Tunnel must make a Might Save or be pushed 4 Spaces in the direction of the wind. You can spend 1 AP to reverse the direction of the wind in the tunnel.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/lightning-and-teleportation/lightning-blade.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const lightningBlade: Spell = {
	name: 'Lightning Blade',
	premadeList: PremadeSpellList.LightningAndTeleportation,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: 'Self (1 Space radius)',
	duration: '1 round',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Imbue Weapon',
			description:
				'You imbue a Melee Weapon you’re wielding with crackling energy. The next Attack Check that hits with this weapon sheathes the target in booming energy. If the target leaves, or is moved from, the current Space they’re in, they automatically take 2 Lightning damage and the Spell ends. This effect can be stacked multiple times from the same or different sources.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Damage',
			description: 'You increase the Lightning damage dealt by 2.'
		},
		{ type: 'MP', cost: 1, name: 'Duration', description: 'You increase the duration to 1 minute.' }
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/lightning-and-teleportation/misty-step.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const mistyStep: Spell = {
	name: 'Misty Step',
	premadeList: PremadeSpellList.LightningAndTeleportation,
	school: SpellSchool.Astromancy,
	isCantrip: false,
	cost: { ap: 1, mp: 1 },
	range: 'Self',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Teleport',
			description:
				'You are briefly surrounded by a silvery mist and attempt to teleport to a new location. Make a DC 20 Spell Check. Success: You teleport up to 5 Spaces to an unoccupied Space that you can see. Success (each 5): +2 Spaces. Failure: Only 3 Spaces.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Far Step',
			description: 'You increase the distance you can teleport by 4 Spaces.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/lightning-and-teleportation/returning-shock.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const returningShock: Spell = {
	name: 'Returning Shock',
	premadeList: PremadeSpellList.LightningAndTeleportation,
	school: SpellSchool.Destruction,
	isCantrip: false,
	cost: { ap: 1, mp: 1 },
	range: '15 Spaces',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Shock on Damage',
			description:
				'Trigger: You are damaged by a creature within range. Reaction: Make a Spell Check against the target’s PD. Hit: 3 Lightning damage.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Chain',
			description:
				'You can choose 1 additional target within 2 Spaces of the original target. Compare you Spell Check against the new target’s PD. Hit: The additional target takes 3 Lightning damage, and is unaffected by features that allow you to deal more damage, including Heavy Hits and higher. You can use this Enhancement multiple times, choosing an additional target within 2 Spaces of the previously chosen target.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/lightning-and-teleportation/shocking-grasp.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const shockingGrasp: Spell = {
	name: 'Shocking Grasp',
	premadeList: PremadeSpellList.LightningAndTeleportation,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '1 Space',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Shock',
			description:
				'Lightning springs from your hand to shock a creature within range. Make a Spell Check against the target’s PD, and you have ADV if they’re wearing armor made of metal. The target must make a Physical Save. Hit: 1 Lightning damage. Failed Save: Target can’t spend AP until the start of its next turn.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Lightning Lure',
			description:
				'The damage increases by 1 and the range becomes 5 Spaces. Additionally, if the target fails their Save you can pull them up to 3 spaces toward you.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/psychic-and-enchantment/bane.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const bane: Spell = {
	name: 'Bane',
	premadeList: PremadeSpellList.PsychicAndEnchantment,
	school: SpellSchool.Enchantment,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '5 Spaces',
	duration: '1 min (Sustained)',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Curse',
			description:
				'Choose 3 creatures that you can see within range. Make a Spell Check contested by their Mental Save. Failure: The target must roll a d4 and subtract the number from each Attack Check or Save they make until the Spell ends.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Targets',
			description: 'You increase the number of targets by 1.'
		},
		{
			type: 'MP',
			cost: 2,
			name: 'Dread',
			description: 'Targets subtract a d6 instead of a d4 from their Attack Checks and Saves.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/psychic-and-enchantment/befriend.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const befriend: Spell = {
	name: 'Befriend',
	premadeList: PremadeSpellList.PsychicAndEnchantment,
	school: SpellSchool.Enchantment,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: '1 min (Sustained)',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Charm Creature',
			description:
				'You attempt to Charm a creature within range. Choose a non-hostile creature that can see and hear you and make a Spell Check contested by the target’s Charisma Save. Success: The creature is Charmed by you for the duration or until it takes damage. When the Spell effect ends or you fail the Check, the creature realizes that you used magic to influence its mood and may become hostile toward you.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Hostile Charm',
			description: 'You can target even hostile creatures with the Spell.'
		},
		{
			type: 'MP',
			cost: 2,
			name: 'Clear Suspicion',
			description: 'The target doesn’t realize that magic was used on them when the Spell ends.'
		},
		{
			type: 'MP',
			cost: 2,
			name: 'More Friends',
			description: 'You can target an additional creature and increase the range by 10 Spaces.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/psychic-and-enchantment/command.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const command: Spell = {
	name: 'Command',
	premadeList: PremadeSpellList.PsychicAndEnchantment,
	school: SpellSchool.Enchantment,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '10 Spaces',
	duration: '1 Round',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Issue Command',
			description:
				'You speak a command to a creature that you can see within range that can hear you. You don’t have to see the creature if you’ve seen them within the last minute. Make a Spell Check contested by the target’s Charisma Save. Success: The creature immediately spends 2 AP to follow the command given, regardless of its usual AP cost. The creature can’t spend any resources (AP, SP, or MP) to modify the Action it takes. Ignoring a Command: The Spell has no effect if the target doesn’t understand your language, if it’s unable to follow your command, or if your command is directly harmful to itself. Choosing a Command: You can choose from the list of example commands below or improvise your own at the GM’s discretion. Move: The target moves up to its Speed to a location (or in a direction) of your choice. Prone: The target falls Prone. Drop: The target drops anything it’s holding. Attack: The target makes 1 Attack Check or Spell Check (your choice) that normally costs 1 AP. You choose the target of the Attack, which must be within the commanded creature’s range.'
		}
	],
	enhancements: [
		{ type: 'MP', cost: 1, name: 'Duration', description: 'You increase the duration by 1 Round.' },
		{ type: 'MP', cost: 2, name: 'Targets', description: 'You can add 1 additional target.' }
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/psychic-and-enchantment/message.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const message: Spell = {
	name: 'Message',
	premadeList: PremadeSpellList.PsychicAndEnchantment,
	school: SpellSchool.Divination,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: '1 Round (each way)',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Whisper Message',
			description:
				'You point your finger toward a creature you can see within range and verbally whisper a message. The target hears the message in their head and they can reply back with a whisper that you can hear in your head. If you’re familiar with a creature, but you can’t see them or you know they’re beyond a wall or barrier, you can still target them with this Spell but the range is reduced by half.'
		}
	],
	enhancements: [
		{ type: 'MP', cost: 1, name: 'Range', description: 'You increase the range to 30 Spaces.' }
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/psychic-and-enchantment/psychic-fear.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const psychicFear: Spell = {
	name: 'Psychic Fear',
	premadeList: PremadeSpellList.PsychicAndEnchantment,
	school: SpellSchool.Enchantment,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Discordant Melody',
			description:
				'You whisper a discordant melody, only audible to your target, to a creature of your choice within range that you can see and that can hear you, wracking it with terrible pain. Make a Spell Check against the target’s AD while it makes an Intelligence Save. Hit: The target takes 2 Psychic damage. Save Failure: If it has any AP, the target spends 1 AP to move as far as its Speed allows away from you. The creature doesn’t move into obviously dangerous ground, such as a fire or a pit.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Loud Whispers',
			description:
				'On a failed Save, the target to uses an additional 1 AP (if available) to move an additional number of Spaces away from you equal to its Speed.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/psychic-and-enchantment/sleep.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const sleep: Spell = {
	name: 'Sleep',
	premadeList: PremadeSpellList.PsychicAndEnchantment,
	school: SpellSchool.Enchantment,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '15 Spaces',
	duration: '1 min',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Magical Slumber',
			description:
				'You attempt to force creatures within 4 Spaces of a point you choose within range to fall into a magical slumber. Make a DC 10 Spell Check. Success: This Spell can effect 10 HP worth of creatures. Success (each 5): +2 HP. Failure: 5 HP. Starting with the creature with the lowest current HP, each creature affected by this Spell falls Unconscious. Subtract each creature’s HP from the total before moving on to the creature with the next lowest current HP. A creature’s HP must be equal to or less than the remaining total for that creature to be affected. The sleep lasts until the Spell ends or another creature within 1 Space spends 1 AP to shake or slap the sleeping creature awake. Undead and creatures that don’t sleep aren’t affected by this spell.'
		}
	],
	enhancements: [
		{ type: 'MP', cost: 1, name: 'Slumber', description: 'You increase the HP affected by 10.' }
	]
};
````

## File: src/lib/rulesdata/attributes.ts
````typescript
// src/lib/rulesdata/attributes.ts

import type { IAttributeData } from './types';
// To be placed in: src/lib/rulesdata/attributes.ts
export const attributesData: IAttributeData[] = [
	// TODO: Replace bracketed placeholders with accurate information from the DC20 Beta 0.9.5 rulebook.
	{
		id: 'might',
		name: 'Might',
		description: 'Your Strength of Body.',
		derivedStats: [
			// Examples, verify/adjust based on actual rules for each attribute
			{ statName: 'AD (area defense)', formula: '8 + CM + Might + Charisma + Bonuses' },
			{ statName: 'Max HP', formula: 'Class HP + Might + Ancestry HP' }
		]
	},
	{
		id: 'agility',
		name: 'Agility',
		description: 'Your Balance, Nimbleness, and Dexterity.',
		derivedStats: [
			{ statName: 'PD (precision defense)', formula: '8 + CM + Agility + Intelligence + Bonuses' },
			{ statName: 'Jump Distance', formula: 'Agility (min 1)' },
			{ statName: 'Initiative', formula: 'CM + Agility' },
			{ statName: 'Movement Speed', formula: '5 spaces (base) + trait modifiers' }
		]
	},
	{
		id: 'charisma',
		name: 'Charisma',
		description: 'Your Charm, Presence, Persuasiveness, and Force of Will.',
		derivedStats: [{ statName: 'Grit Points', formula: '2 + Charisma' }]
	},
	{
		id: 'intelligence',
		name: 'Intelligence',
		description: 'Your Reasoning, Understanding, and Wisdom.',
		derivedStats: [{ statName: 'Base Skill Points', formula: '5 + Intelligence' }]
	}
];
````

## File: src/lib/rulesdata/inventoryItems.ts
````typescript
// inventoryItems.ts

//==============================================================================
// SCHEMAS / TYPES
//==============================================================================

export enum ItemType {
	Weapon = 'Weapon',
	Armor = 'Armor',
	Shield = 'Shield',
	AdventuringSupply = 'Adventuring Supply',
	Potion = 'Potion'
}

export enum WeaponType {
	Melee = 'Melee',
	Ranged = 'Ranged',
	Special = 'Special'
}

export enum WeaponHandedness {
	OneHanded = 'One-Handed',
	Versatile = 'Versatile',
	TwoHanded = 'Two-Handed'
}

export enum WeaponStyle {
	Axe = 'Axe',
	Fist = 'Fist',
	Hammer = 'Hammer',
	Pick = 'Pick',
	Spear = 'Spear',
	Sword = 'Sword',
	Whip = 'Whip',
	Chained = 'Chained',
	Bow = 'Bow',
	Crossbow = 'Crossbow',
	AxePick = 'Axe/Pick',
	HammerPick = 'Hammer/Pick',
	SwordSpear = 'Sword/Spear',
	ChainedHammer = 'Chained/Hammer',
	Staff = 'Staff'
}

export enum DamageType {
	Slashing = 'S',
	Piercing = 'P',
	Bludgeoning = 'B',
	SlashingOrPiercing = 'S/P',
	BludgeoningOrPiercing = 'B/P'
}

// Based on properties from pages 76 & 77
export type WeaponProperty =
	| 'Ammo'
	| 'Concealable'
	| 'Guard'
	| 'Heavy'
	| 'Impact'
	| 'Long-Ranged'
	| 'Multi-Faceted'
	| 'Reach'
	| 'Reload'
	| 'Silent'
	| 'Toss (5/10)'
	| 'Thrown (10/20)'
	| 'Two-Handed'
	| 'Unwieldy'
	| 'Versatile'
	| 'Returning'
	| 'Capture (5/10)'
	| 'Capture (10/20)'
	| 'Range (15/45)'
	| 'Range (30/90)';

export interface Weapon {
	itemType: ItemType.Weapon;
	name: string;
	type: WeaponType;
	style: WeaponStyle | WeaponStyle[];
	handedness: WeaponHandedness;
	damage: string; // Using string to accommodate '0 B' etc.
	properties: WeaponProperty[];
}

export enum ArmorType {
	Light = 'Light Armor',
	Heavy = 'Heavy Armor'
}

export interface Armor {
	itemType: ItemType.Armor;
	name: string;
	type: ArmorType;
	pdBonus: number;
	adBonus: number;
	pdr?: 'Half';
	speedPenalty: number;
	agilityCheckDisadvantage: boolean;
}

export enum ShieldType {
	Light = 'Light Shield',
	Heavy = 'Heavy Shield'
}

export type ShieldProperty = 'Grasp' | 'Toss (5/10)' | 'Mounted';

export interface Shield {
	itemType: ItemType.Shield;
	name: string;
	type: ShieldType;
	pdBonus: number;
	adBonus: number;
	speedPenalty: number;
	agilityCheckDisadvantage: boolean;
	properties?: ShieldProperty[];
}

export interface AdventuringSupply {
	itemType: ItemType.AdventuringSupply;
	name: string;
	description: string;
	price?: string; // e.g., "5g"
}

export interface HealingPotion {
	itemType: ItemType.Potion;
	name: string;
	level: number;
	healing: string; // e.g., "2 HP"
	price: number; // in gold pieces (g)
}

// Union type for all inventory items
export type InventoryItem = Weapon | Armor | Shield | AdventuringSupply | HealingPotion;

//==============================================================================
// INVENTORY DATA
//==============================================================================

export const weapons: Weapon[] = [
	// Melee Weapons - One-Handed
	{
		itemType: ItemType.Weapon,
		name: 'Sickle',
		type: WeaponType.Melee,
		style: WeaponStyle.Axe,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 S',
		properties: ['Concealable', 'Toss (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Hand Axe',
		type: WeaponType.Melee,
		style: WeaponStyle.Axe,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 S',
		properties: ['Concealable', 'Toss (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Throwing Star',
		type: WeaponType.Melee,
		style: WeaponStyle.Axe,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 S',
		properties: ['Concealable', 'Toss (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Brass Knuckles',
		type: WeaponType.Melee,
		style: WeaponStyle.Fist,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 B',
		properties: ['Concealable', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Club',
		type: WeaponType.Melee,
		style: WeaponStyle.Hammer,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 B',
		properties: ['Concealable', 'Toss (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Light Hammer',
		type: WeaponType.Melee,
		style: WeaponStyle.Hammer,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 B',
		properties: ['Impact', 'Toss (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Dart',
		type: WeaponType.Melee,
		style: WeaponStyle.Pick,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 P',
		properties: ['Concealable', 'Toss (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Mining Pick',
		type: WeaponType.Melee,
		style: WeaponStyle.Pick,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 P',
		properties: ['Concealable', 'Toss (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Javelin',
		type: WeaponType.Melee,
		style: WeaponStyle.Spear,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 P',
		properties: ['Thrown (10/20)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Throwing Dagger',
		type: WeaponType.Melee,
		style: WeaponStyle.Sword,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 S',
		properties: ['Concealable', 'Toss (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Short Sword',
		type: WeaponType.Melee,
		style: WeaponStyle.Sword,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 S',
		properties: ['Guard', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Rapier',
		type: WeaponType.Melee,
		style: [WeaponStyle.Sword, WeaponStyle.Spear],
		handedness: WeaponHandedness.OneHanded,
		damage: '1 S/P',
		properties: ['Guard', 'Multi-Faceted']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Chain Whip',
		type: WeaponType.Melee,
		style: WeaponStyle.Whip,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 S',
		properties: ['Reach', 'Impact']
	},

	// Melee Weapons - Versatile
	{
		itemType: ItemType.Weapon,
		name: 'Battleaxe',
		type: WeaponType.Melee,
		style: WeaponStyle.Axe,
		handedness: WeaponHandedness.Versatile,
		damage: '1 S',
		properties: ['Versatile', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Flail',
		type: WeaponType.Melee,
		style: WeaponStyle.Chained,
		handedness: WeaponHandedness.Versatile,
		damage: '1 B',
		properties: ['Versatile', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Morningstar',
		type: WeaponType.Melee,
		style: [WeaponStyle.Hammer, WeaponStyle.Pick],
		handedness: WeaponHandedness.Versatile,
		damage: '1 B/P',
		properties: ['Versatile', 'Multi-Faceted']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Warhammer',
		type: WeaponType.Melee,
		style: [WeaponStyle.Hammer, WeaponStyle.Pick],
		handedness: WeaponHandedness.Versatile,
		damage: '1 B/P',
		properties: ['Versatile', 'Multi-Faceted']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Pickaxe',
		type: WeaponType.Melee,
		style: WeaponStyle.Pick,
		handedness: WeaponHandedness.Versatile,
		damage: '1 P',
		properties: ['Versatile', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Spear',
		type: WeaponType.Melee,
		style: WeaponStyle.Spear,
		handedness: WeaponHandedness.Versatile,
		damage: '1 P',
		properties: ['Versatile', 'Toss (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Long Spear',
		type: WeaponType.Melee,
		style: WeaponStyle.Spear,
		handedness: WeaponHandedness.Versatile,
		damage: '1 P',
		properties: ['Versatile', 'Reach']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Quarterstaff',
		type: WeaponType.Melee,
		style: WeaponStyle.Staff,
		handedness: WeaponHandedness.Versatile,
		damage: '1 B',
		properties: ['Versatile', 'Guard']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Longsword',
		type: WeaponType.Melee,
		style: WeaponStyle.Sword,
		handedness: WeaponHandedness.Versatile,
		damage: '1 S',
		properties: ['Versatile', 'Guard']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Bastard Sword',
		type: WeaponType.Melee,
		style: WeaponStyle.Sword,
		handedness: WeaponHandedness.Versatile,
		damage: '1 S',
		properties: ['Versatile', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Bull Whip',
		type: WeaponType.Melee,
		style: WeaponStyle.Whip,
		handedness: WeaponHandedness.Versatile,
		damage: '1 S',
		properties: ['Versatile', 'Reach', 'Unwieldy', 'Impact']
	},

	// Melee Weapons - Two-Handed
	{
		itemType: ItemType.Weapon,
		name: 'Scythe',
		type: WeaponType.Melee,
		style: WeaponStyle.Axe,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 S',
		properties: ['Two-Handed', 'Heavy', 'Reach']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Greataxe',
		type: WeaponType.Melee,
		style: WeaponStyle.Axe,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 S',
		properties: ['Two-Handed', 'Heavy', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Halberd',
		type: WeaponType.Melee,
		style: [WeaponStyle.Axe, WeaponStyle.Pick],
		handedness: WeaponHandedness.TwoHanded,
		damage: '1 S/P',
		properties: ['Two-Handed', 'Multi-Faceted', 'Reach', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'War Flail',
		type: WeaponType.Melee,
		style: WeaponStyle.Chained,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 B',
		properties: ['Two-Handed', 'Heavy', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Meteor Hammer',
		type: WeaponType.Melee,
		style: [WeaponStyle.Chained, WeaponStyle.Hammer],
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 B',
		properties: ['Two-Handed', 'Heavy', 'Multi-Faceted', 'Reach', 'Unwieldy']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Greatmaul',
		type: WeaponType.Melee,
		style: WeaponStyle.Hammer,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 B',
		properties: ['Two-Handed', 'Heavy', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Pike',
		type: WeaponType.Melee,
		style: WeaponStyle.Spear,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 P',
		properties: ['Two-Handed', 'Heavy', 'Reach', 'Impact', 'Unwieldy']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Longpole',
		type: WeaponType.Melee,
		style: WeaponStyle.Staff,
		handedness: WeaponHandedness.TwoHanded,
		damage: '1 B',
		properties: ['Two-Handed', 'Guard', 'Reach', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Glaive',
		type: WeaponType.Melee,
		style: WeaponStyle.Sword,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 S',
		properties: ['Two-Handed', 'Heavy', 'Reach']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Greatsword',
		type: WeaponType.Melee,
		style: WeaponStyle.Sword,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 S',
		properties: ['Two-Handed', 'Heavy', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Great Whip',
		type: WeaponType.Melee,
		style: WeaponStyle.Whip,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 S',
		properties: ['Two-Handed', 'Heavy', 'Reach', 'Impact', 'Unwieldy']
	},

	// Ranged Weapons
	{
		itemType: ItemType.Weapon,
		name: 'Sling',
		type: WeaponType.Ranged,
		style: WeaponStyle.Bow,
		handedness: WeaponHandedness.TwoHanded,
		damage: '1 B',
		properties: ['Ammo', 'Unwieldy', 'Impact', 'Range (15/45)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Shortbow',
		type: WeaponType.Ranged,
		style: WeaponStyle.Bow,
		handedness: WeaponHandedness.TwoHanded,
		damage: '1 P',
		properties: ['Two-Handed', 'Ammo', 'Silent', 'Range (15/45)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Longbow',
		type: WeaponType.Ranged,
		style: WeaponStyle.Bow,
		handedness: WeaponHandedness.TwoHanded,
		damage: '1 P',
		properties: ['Two-Handed', 'Ammo', 'Unwieldy', 'Impact', 'Long-Ranged']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Greatbow',
		type: WeaponType.Ranged,
		style: WeaponStyle.Bow,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 P',
		properties: ['Two-Handed', 'Ammo', 'Unwieldy', 'Heavy', 'Range (15/45)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Blowgun (Needle)',
		type: WeaponType.Ranged,
		style: WeaponStyle.Crossbow,
		handedness: WeaponHandedness.TwoHanded,
		damage: '1 P',
		properties: ['Two-Handed', 'Ammo', 'Silent', 'Range (15/45)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Hand Crossbow',
		type: WeaponType.Ranged,
		style: WeaponStyle.Crossbow,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 P',
		properties: ['Ammo', 'Reload', 'Range (15/45)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Light Crossbow',
		type: WeaponType.Ranged,
		style: WeaponStyle.Crossbow,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 P',
		properties: ['Two-Handed', 'Ammo', 'Reload', 'Impact', 'Range (15/45)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Heavy Crossbow',
		type: WeaponType.Ranged,
		style: WeaponStyle.Crossbow,
		handedness: WeaponHandedness.TwoHanded,
		damage: '3 P',
		properties: ['Two-Handed', 'Ammo', 'Unwieldy', 'Reload', 'Heavy', 'Range (15/45)']
	},

	// Special Weapons
	{
		itemType: ItemType.Weapon,
		name: 'Bolas',
		type: WeaponType.Special,
		style: WeaponStyle.Chained,
		handedness: WeaponHandedness.OneHanded,
		damage: '0 B',
		properties: ['Thrown (10/20)', 'Capture (10/20)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Net',
		type: WeaponType.Special,
		style: WeaponStyle.Chained,
		handedness: WeaponHandedness.Versatile,
		damage: '0 B',
		properties: ['Toss (5/10)', 'Versatile', 'Capture (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Boomerang',
		type: WeaponType.Special,
		style: WeaponStyle.Hammer,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 B',
		properties: ['Toss (5/10)', 'Returning']
	}
];

export const armors: Armor[] = [
	// Light Armor
	{
		itemType: ItemType.Armor,
		name: 'Light Defensive Armor',
		type: ArmorType.Light,
		pdBonus: 1,
		adBonus: 1,
		speedPenalty: 0,
		agilityCheckDisadvantage: false
	},
	{
		itemType: ItemType.Armor,
		name: 'Light Deflecting Armor',
		type: ArmorType.Light,
		pdBonus: 2,
		adBonus: 0,
		speedPenalty: 0,
		agilityCheckDisadvantage: false
	},
	{
		itemType: ItemType.Armor,
		name: 'Light Fortified Armor',
		type: ArmorType.Light,
		pdBonus: 0,
		adBonus: 2,
		speedPenalty: 0,
		agilityCheckDisadvantage: false
	},

	// Heavy Armor
	{
		itemType: ItemType.Armor,
		name: 'Heavy Defensive Armor',
		type: ArmorType.Heavy,
		pdBonus: 1,
		adBonus: 1,
		pdr: 'Half',
		speedPenalty: -1,
		agilityCheckDisadvantage: true
	},
	{
		itemType: ItemType.Armor,
		name: 'Heavy Deflecting Armor',
		type: ArmorType.Heavy,
		pdBonus: 2,
		adBonus: 0,
		pdr: 'Half',
		speedPenalty: -1,
		agilityCheckDisadvantage: true
	},
	{
		itemType: ItemType.Armor,
		name: 'Heavy Fortified Armor',
		type: ArmorType.Heavy,
		pdBonus: 0,
		adBonus: 2,
		pdr: 'Half',
		speedPenalty: -1,
		agilityCheckDisadvantage: true
	},
	{
		itemType: ItemType.Armor,
		name: 'Highly Defensive Armor',
		type: ArmorType.Heavy,
		pdBonus: 2,
		adBonus: 2,
		pdr: 'Half',
		speedPenalty: -1,
		agilityCheckDisadvantage: true
	}
];

export const shields: Shield[] = [
	// Light Shields
	{
		itemType: ItemType.Shield,
		name: 'Buckler',
		type: ShieldType.Light,
		pdBonus: 1,
		adBonus: 0,
		speedPenalty: 0,
		agilityCheckDisadvantage: false,
		properties: ['Grasp']
	},
	{
		itemType: ItemType.Shield,
		name: 'Round Shield',
		type: ShieldType.Light,
		pdBonus: 0,
		adBonus: 1,
		speedPenalty: 0,
		agilityCheckDisadvantage: false,
		properties: ['Toss (5/10)']
	},
	{
		itemType: ItemType.Shield,
		name: 'Heater Shield',
		type: ShieldType.Light,
		pdBonus: 1,
		adBonus: 1,
		speedPenalty: 0,
		agilityCheckDisadvantage: false,
		properties: []
	},

	// Heavy Shields
	{
		itemType: ItemType.Shield,
		name: 'Kite Shield',
		type: ShieldType.Heavy,
		pdBonus: 1,
		adBonus: 2,
		speedPenalty: -1,
		agilityCheckDisadvantage: true,
		properties: ['Mounted']
	},
	{
		itemType: ItemType.Shield,
		name: 'Tower Shield',
		type: ShieldType.Heavy,
		pdBonus: 2,
		adBonus: 2,
		speedPenalty: -1,
		agilityCheckDisadvantage: true,
		properties: []
	}
];

export const adventuringSupplies: AdventuringSupply[] = [
	{
		itemType: ItemType.AdventuringSupply,
		name: 'Gauntlet',
		description:
			'Wearing a Gauntlet gives your Unarmed Strikes with that hand the Impact Weapon Property (+1 damage on Heavy Hits).',
		price: '5g'
	},
	{
		itemType: ItemType.AdventuringSupply,
		name: 'First Aid Kit',
		description:
			"A fully stocked kit contains 5 charges, which can be spent to treat a creature's wounds or cure an ailment by taking the Object Action."
	}
];

export const healingPotions: HealingPotion[] = [
	{
		itemType: ItemType.Potion,
		name: '1st Level Healing Potion',
		level: 1,
		healing: '2 HP',
		price: 10
	},
	{
		itemType: ItemType.Potion,
		name: '2nd Level Healing Potion',
		level: 2,
		healing: '4 HP',
		price: 25
	},
	{
		itemType: ItemType.Potion,
		name: '3rd Level Healing Potion',
		level: 3,
		healing: '6 HP',
		price: 40
	},
	{
		itemType: ItemType.Potion,
		name: '4th Level Healing Potion',
		level: 4,
		healing: '8 HP',
		price: 60
	},
	{
		itemType: ItemType.Potion,
		name: '5th Level Healing Potion',
		level: 5,
		healing: '10 HP',
		price: 100
	}
];

export const allItems = [
	...weapons,
	...armors,
	...shields,
	...adventuringSupplies,
	...healingPotions
];
````

## File: src/lib/rulesdata/knowledge.ts
````typescript
import { ITradeData } from './types';

export const knowledgeData: ITradeData[] = [
	{
		id: 'arcana',
		name: 'Arcana',
		attributeAssociation: 'intelligence',
		description:
			'Arcana is the study of magic, its history, theories, and the planes of existence. This includes recalling information about spells, magical creatures, and magical phenomena.',
		tools: undefined // Knowledge trade
	},
	{
		id: 'history',
		name: 'History',
		attributeAssociation: 'intelligence',
		description:
			'History is the study of past events, ancient lore, and how civilizations have shaped the present. This includes recalling information about historical figures, events, and cultures.',
		tools: undefined // Knowledge trade
	},
	{
		id: 'nature',
		name: 'Nature',
		attributeAssociation: 'intelligence',
		description:
			'Nature is the study of the natural world, including plants, animals, weather patterns, and natural phenomena.',
		tools: undefined // Knowledge trade
	},
	{
		id: 'religion',
		name: 'Religion',
		attributeAssociation: 'intelligence',
		description:
			'Religion is the knowledge of deities, religious practices, and holy texts. This includes understanding religious beliefs, rituals, and scriptures.',
		tools: undefined // Knowledge trade
	},
	{
		id: 'occultism',
		name: 'Occultism',
		attributeAssociation: 'intelligence',
		description:
			'Occultism is the study of hidden mysteries, forbidden lore, and supernatural phenomena beyond normal magical understanding.',
		tools: undefined // Knowledge trade
	}
];
````

## File: src/lib/rulesdata/trades.ts
````typescript
import { ITradeData } from './types';

export const tradesData: ITradeData[] = [
	{
		id: 'alchemy',
		name: 'Alchemy',
		attributeAssociation: 'intelligence',
		description:
			'Alchemy is the practice of creating something by combining or changing other things. This includes creating potions, poisons, and other alchemical substances.',
		tools: "Alchemist's Supplies"
	},
	{
		id: 'architecture',
		name: 'Architecture',
		attributeAssociation: 'intelligence',
		description:
			'Architecture is the knowledge of building design, construction, and structural integrity. This includes understanding how buildings are constructed, identifying weak points, and designing structures.',
		tools: undefined // Knowledge trade
	},
	{
		id: 'blacksmithing',
		name: 'Blacksmithing',
		attributeAssociation: 'might',
		description:
			'Blacksmithing is the crafting and repairing of metal objects, including weapons and armor. This includes working with forges, hammers, and other tools to shape metal.',
		tools: "Smith's Tools"
	},
	{
		id: 'brewing',
		name: 'Brewing',
		attributeAssociation: 'intelligence',
		description:
			'Brewing is the art of creating beverages through fermentation, such as beer, wine, and spirits. This includes understanding the process of fermentation and using brewing equipment.',
		tools: "Brewer's Supplies"
	},
	{
		id: 'calligraphy',
		name: 'Calligraphy',
		attributeAssociation: 'agility',
		description:
			'Calligraphy is the art of decorative handwriting and lettering. This includes using various pens, inks, and techniques to create visually appealing text.',
		tools: "Calligrapher's Supplies"
	},
	{
		id: 'carpentry',
		name: 'Carpentry',
		attributeAssociation: 'might',
		description:
			'Carpentry is the crafting and repairing of wooden objects and structures. This includes working with wood, saws, hammers, and other tools to build and repair.',
		tools: "Carpenter's Tools"
	},
	{
		id: 'cartography',
		name: 'Cartography',
		attributeAssociation: 'intelligence',
		description:
			'Cartography is the art and science of mapmaking. This includes creating maps, reading maps, and navigating using maps.',
		tools: "Cartographer's Tools"
	},
	{
		id: 'cobbling',
		name: 'Cobbling',
		attributeAssociation: 'agility',
		description:
			'Cobbling is the crafting and repairing of footwear. This includes working with leather, thread, and tools to create and repair shoes and boots.',
		tools: "Cobbler's Tools"
	},
	{
		id: 'cooking',
		name: 'Cooking',
		attributeAssociation: 'intelligence',
		description:
			'Cooking is the preparation of food for consumption. This includes understanding ingredients, recipes, and cooking techniques.',
		tools: "Cook's Utensils"
	},
	{
		id: 'deciphering',
		name: 'Deciphering',
		attributeAssociation: 'intelligence',
		description:
			'Deciphering is the understanding of coded messages, ancient scripts, or hidden meanings. This includes analyzing patterns, symbols, and languages to uncover hidden information.',
		tools: undefined // Knowledge trade
	},
	{
		id: 'disguise',
		name: 'Disguise',
		attributeAssociation: 'charisma',
		description:
			"Disguise is the altering of one's appearance to resemble someone else or a different type of person. This includes using makeup, costumes, and props to change appearance.",
		tools: 'Disguise Kit'
	},
	{
		id: 'forgery',
		name: 'Forgery',
		attributeAssociation: 'agility',
		description:
			'Forgery is the creating of convincing copies of documents, signatures, or objects. This includes replicating details and materials to create fakes.',
		tools: 'Forgery Kit'
	},
	{
		id: 'gaming',
		name: 'Gaming',
		attributeAssociation: 'charisma',
		description:
			'Gaming is the proficiency in various games of chance or skill. This includes understanding rules, strategies, and playing games.',
		tools: 'Gaming Set'
	},
	{
		id: 'herbalism',
		name: 'Herbalism',
		attributeAssociation: 'intelligence',
		description:
			'Herbalism is the knowledge of plants, their properties, and uses. This includes identifying plants, preparing herbal remedies, and understanding plant effects.',
		tools: 'Herbalism Kit'
	},
	{
		id: 'jeweler',
		name: 'Jeweler',
		attributeAssociation: 'agility',
		description:
			'Jeweler is the crafting and repairing of jewelry. This includes working with precious metals, gems, and tools to create and repair jewelry.',
		tools: "Jeweler's Tools"
	},
	{
		id: 'leatherworking',
		name: 'Leatherworking',
		attributeAssociation: 'agility',
		description:
			'Leatherworking is the crafting and repairing of leather goods. This includes working with leather, tools, and techniques to create and repair items.',
		tools: "Leatherworker's Tools"
	},
	{
		id: 'linguistics',
		name: 'Linguistics',
		attributeAssociation: 'intelligence',
		description:
			'Linguistics is the study of languages, their structure, and origins. This includes understanding grammar, syntax, and the history of languages.',
		tools: undefined // Knowledge trade
	},
	{
		id: 'masonry',
		name: 'Masonry',
		attributeAssociation: 'might',
		description:
			'Masonry is the working with stone to build structures or objects. This includes cutting, shaping, and laying stone to create buildings and other structures.',
		tools: "Mason's Tools"
	},
	{
		id: 'medicine',
		name: 'Medicine',
		attributeAssociation: 'intelligence',
		description:
			'Medicine is the knowledge and practice of healing injuries and treating diseases. This includes diagnosing ailments, administering treatments, and understanding medical procedures.',
		tools: "Healer's Kit"
	},
	{
		id: 'music',
		name: 'Music',
		attributeAssociation: 'charisma',
		description:
			'Music is the performance of music using instruments or voice. This includes playing instruments, singing, and understanding musical theory.',
		tools: 'Musical Instrument'
	},
	{
		id: 'navigation',
		name: 'Navigation',
		attributeAssociation: 'intelligence',
		description:
			"Navigation is the determining of one's position and plotting a course. This includes using maps, compasses, and celestial bodies to navigate.",
		tools: "Navigator's Tools"
	},
	{
		id: 'painting',
		name: 'Painting',
		attributeAssociation: 'agility',
		description:
			'Painting is the creating of art using paints. This includes using various paints, brushes, and techniques to create visual art.',
		tools: "Painter's Supplies"
	},
	{
		id: 'poisoner',
		name: 'Poisoner',
		attributeAssociation: 'intelligence',
		description:
			'Poisoner is the knowledge and creation of poisons. This includes identifying poisonous substances, preparing poisons, and understanding their effects.',
		tools: "Poisoner's Kit"
	},
	{
		id: 'pottery',
		name: 'Pottery',
		attributeAssociation: 'agility',
		description:
			'Pottery is the crafting of objects from clay. This includes shaping, firing, and glazing clay to create various objects.',
		tools: "Potter's Tools"
	},
	{
		id: 'sculpting',
		name: 'Sculpting',
		attributeAssociation: 'might',
		description:
			'Sculpting is the creating of three-dimensional art from various materials. This includes shaping materials like stone, wood, or clay to create sculptures.',
		tools: "Sculptor's Tools"
	},
	{
		id: 'smithing',
		name: 'Smithing',
		attributeAssociation: 'might',
		description:
			'Smithing is the general knowledge of working with metals. This includes understanding different metals, their properties, and basic metalworking techniques.',
		tools: "Smith's Tools"
	},
	{
		id: 'survival',
		name: 'Survival',
		attributeAssociation: 'intelligence',
		description:
			'Survival is the knowledge and skills needed to survive in the wilderness. This includes tracking, foraging, shelter building, and navigating in natural environments.',
		tools: undefined // Knowledge trade
	},
	{
		id: 'tailoring',
		name: 'Tailoring',
		attributeAssociation: 'agility',
		description:
			'Tailoring is the crafting and repairing of clothing and textiles. This includes working with fabric, needles, and thread to create and repair garments.',
		tools: "Weaver's Tools"
	},
	{
		id: 'thieves',
		name: "Thieves'",
		attributeAssociation: 'agility',
		description:
			"Thieves' is the knowledge and skills related to thievery, including lockpicking and disarming traps. This includes understanding security measures and using specialized tools.",
		tools: "Thieves' Tools"
	},
	{
		id: 'vehicles_land',
		name: 'Vehicles (Land)',
		attributeAssociation: 'agility',
		description:
			'Vehicles (Land) is the proficiency in operating land-based vehicles. This includes riding horses, driving carts, and operating other land vehicles.',
		tools: undefined
	},
	{
		id: 'vehicles_water',
		name: 'Vehicles (Water)',
		attributeAssociation: 'agility',
		description:
			'Vehicles (Water) is the proficiency in operating water-based vehicles. This includes sailing boats, piloting ships, and operating other water vehicles.',
		tools: undefined
	},
	{
		id: 'woodcarving',
		name: 'Woodcarving',
		attributeAssociation: 'agility',
		description:
			'Woodcarving is the creating of art or objects from wood. This includes shaping wood using knives, chisels, and other tools.',
		tools: "Woodcarver's Tools"
	}
];
````

## File: src/lib/services/dataMapping.ts
````typescript
// Data mapping utilities for converting between IDs and names
import { ancestriesData } from '../rulesdata/ancestries';
import { classesData } from '../rulesdata/loaders/class.loader';
import type { IAncestry, IClassDefinition } from '../rulesdata/types';

export interface IdNameMapping {
	id: string;
	name: string;
}

/**
 * Get ancestry name from ancestry ID
 */
export const getAncestryName = (ancestryId: string | null): string | null => {
	if (!ancestryId) return null;
	const ancestry = ancestriesData.find((a: IAncestry) => a.id === ancestryId);
	return ancestry?.name || null;
};

/**
 * Get ancestry ID from ancestry name
 */
export const getAncestryId = (ancestryName: string | null): string | null => {
	if (!ancestryName) return null;
	const ancestry = ancestriesData.find(
		(a: IAncestry) => a.name.toLowerCase() === ancestryName.toLowerCase()
	);
	return ancestry?.id || null;
};

/**
 * Get class name from class ID
 */
export const getClassName = (classId: string | null): string | null => {
	if (!classId) return null;
	const classData = classesData.find((c: IClassDefinition) => c.id === classId);
	return classData?.name || null;
};

/**
 * Get class ID from class name
 */
export const getClassId = (className: string | null): string | null => {
	if (!className) return null;
	const classData = classesData.find(
		(c: IClassDefinition) => c.name.toLowerCase() === className.toLowerCase()
	);
	return classData?.id || null;
};

/**
 * Get all available ancestries as ID-name mappings
 */
export const getAncestryMappings = (): IdNameMapping[] => {
	return ancestriesData.map((ancestry: IAncestry) => ({
		id: ancestry.id,
		name: ancestry.name
	}));
};

/**
 * Get all available classes as ID-name mappings
 */
export const getClassMappings = (): IdNameMapping[] => {
	return classesData.map((classData: IClassDefinition) => ({
		id: classData.id,
		name: classData.name
	}));
};

/**
 * Ensure character data has both IDs and names for classes and ancestries
 * This is useful for backwards compatibility and data consistency
 */
export const normalizeCharacterData = (characterData: any): any => {
	const normalized = { ...characterData };

	// Ensure class has both ID and name
	if (normalized.classId && !normalized.className) {
		normalized.className = getClassName(normalized.classId);
	} else if (normalized.className && !normalized.classId) {
		normalized.classId = getClassId(normalized.className);
	}

	// Ensure ancestry1 has both ID and name
	if (normalized.ancestry1Id && !normalized.ancestry1Name) {
		normalized.ancestry1Name = getAncestryName(normalized.ancestry1Id);
	} else if (normalized.ancestry1Name && !normalized.ancestry1Id) {
		normalized.ancestry1Id = getAncestryId(normalized.ancestry1Name);
	}

	// Ensure ancestry2 has both ID and name
	if (normalized.ancestry2Id && !normalized.ancestry2Name) {
		normalized.ancestry2Name = getAncestryName(normalized.ancestry2Id);
	} else if (normalized.ancestry2Name && !normalized.ancestry2Id) {
		normalized.ancestry2Id = getAncestryId(normalized.ancestry2Name);
	}

	return normalized;
};
````

## File: src/lib/services/enhancedCharacterCalculator.ts
````typescript
/**
 * Enhanced Character Calculator with Effect Attribution
 * 
 * This is the unified calculation engine that provides detailed breakdowns
 * for tooltips and real-time validation for the UI.
 */

import type { 
  EnhancedCalculationResult, 
  EnhancedCharacterBuildData, 
  AttributedEffect, 
  EffectSource, 
  EnhancedStatBreakdown,
  ValidationResult,
  AttributeLimit,
  UnresolvedChoice,
  ChoiceOption,
  EffectPreview,
  TraitChoiceStorage
} from '../types/effectSystem';

import { traitsData } from '../rulesdata/_new_schema/traits';
import { ancestriesData } from '../rulesdata/_new_schema/ancestries';
import { barbarianClass } from '../rulesdata/_new_schema/barbarian_features';
import { clericClass } from '../rulesdata/_new_schema/cleric_features';
import { hunterClass } from '../rulesdata/_new_schema/hunter_features';
import { championClass } from '../rulesdata/_new_schema/champion_features';
import { wizardClass } from '../rulesdata/_new_schema/wizard_features';
import { monkClass } from '../rulesdata/_new_schema/monk_features';
import { rogueClass } from '../rulesdata/_new_schema/rogue_features';
import { sorcererClass } from '../rulesdata/_new_schema/sorcerer_features';
import { spellbladeClass } from '../rulesdata/_new_schema/spellblade_features';
import { warlockClass } from '../rulesdata/_new_schema/warlock_features';
import barbarianTable from '../rulesdata/classes/barbarian_table.json';
import clericTable from '../rulesdata/classes/cleric_table.json';
import hunterTable from '../rulesdata/classes/hunter_table.json';
import championTable from '../rulesdata/classes/champion_table.json';
import wizardTable from '../rulesdata/classes/wizard_table.json';
import monkTable from '../rulesdata/classes/monk_table.json';
import rogueTable from '../rulesdata/classes/rogue_table.json';
import sorcererTable from '../rulesdata/classes/sorcerer_table.json';
import spellbladeTable from '../rulesdata/classes/spellblade_table.json';
import warlockTable from '../rulesdata/classes/warlock_table.json';
import { attributesData } from '../rulesdata/attributes';
import { skillsData } from '../rulesdata/skills';
import { tradesData } from '../rulesdata/trades';
import type { Effect, ClassDefinition } from '../rulesdata/schemas/character.schema';

/**
 * Convert character context data to enhanced build data
 */
export function convertToEnhancedBuildData(contextData: any): EnhancedCharacterBuildData {
  return {
    id: contextData.id || '',
    finalName: contextData.finalName || '',
    finalPlayerName: contextData.finalPlayerName,
    level: contextData.level || 1,
    
    attribute_might: contextData.attribute_might || 0,
    attribute_agility: contextData.attribute_agility || 0,
    attribute_charisma: contextData.attribute_charisma || 0,
    attribute_intelligence: contextData.attribute_intelligence || 0,
    
    combatMastery: contextData.combatMastery || 1,
    
    classId: contextData.classId || '',
    ancestry1Id: contextData.ancestry1Id,
    ancestry2Id: contextData.ancestry2Id,
    
    selectedTraitIds: JSON.parse(contextData.selectedTraitIds || '[]'),
    selectedTraitChoices: JSON.parse(contextData.selectedTraitChoices || '{}'),
    featureChoices: JSON.parse(contextData.selectedFeatureChoices || '{}'),
    
    skillsJson: contextData.skillsJson || '{}',
    tradesJson: contextData.tradesJson || '{}',
    languagesJson: contextData.languagesJson || '{"common": {"fluency": "fluent"}}',
    
    manualPD: contextData.manualPD,
    manualAD: contextData.manualAD,
    manualPDR: contextData.manualPDR,
    
    lastModified: Date.now()
  };
}

/**
 * Get class level progression data by ID
 */
function getClassProgressionData(classId: string): any | null {
  switch (classId) {
    case 'barbarian':
      return barbarianTable;
    case 'cleric':
      return clericTable;
    case 'hunter':
      return hunterTable;
    case 'champion':
      return championTable;
    case 'wizard':
      return wizardTable;
    case 'monk':
      return monkTable;
    case 'rogue':
      return rogueTable;
    case 'sorcerer':
      return sorcererTable;
    case 'spellblade':
      return spellbladeTable;
    case 'warlock':
      return warlockTable;
    default:
      return null;
  }
}

/**
 * Get class features by ID (for abilities)
 */
function getClassFeatures(classId: string): ClassDefinition | null {
  switch (classId) {
    case 'barbarian':
      return barbarianClass;
    case 'cleric':
      return clericClass;
    case 'hunter':
      return hunterClass;
    case 'champion':
      return championClass;
    case 'wizard':
      return wizardClass;
    case 'monk':
      return monkClass;
    case 'rogue':
      return rogueClass;
    case 'sorcerer':
      return sorcererClass;
    case 'spellblade':
      return spellbladeClass;
    case 'warlock':
      return warlockClass;
    default:
      return null;
  }
}

/**
 * Aggregate all effects with source attribution
 */
function aggregateAttributedEffects(buildData: EnhancedCharacterBuildData): AttributedEffect[] {
  const effects: AttributedEffect[] = [];
  
  // Add effects from ancestry default traits
  if (buildData.ancestry1Id) {
    const ancestry = ancestriesData.find(a => a.id === buildData.ancestry1Id);
    if (ancestry?.defaultTraitIds) {
      for (const traitId of ancestry.defaultTraitIds) {
        const trait = traitsData.find(t => t.id === traitId);
        if (trait?.effects) {
          for (const [effectIndex, effect] of trait.effects.entries()) {
            effects.push({
              ...effect,
              source: {
                type: 'ancestry_default',
                id: traitId,
                name: trait.name,
                description: trait.description,
                category: `${ancestry.name} (Default)`
              },
              resolved: !effect.userChoice,
              dependsOnChoice: effect.userChoice ? `${traitId}-${effectIndex}` : undefined
            });
          }
        }
      }
    }
  }
  
  // Add effects from selected traits
  for (const traitId of buildData.selectedTraitIds) {
    const trait = traitsData.find(t => t.id === traitId);
    if (trait?.effects) {
      for (const [effectIndex, effect] of trait.effects.entries()) {
        effects.push({
          ...effect,
          source: {
            type: 'trait',
            id: traitId,
            name: trait.name,
            description: trait.description,
            category: 'Selected Trait'
          },
          resolved: !effect.userChoice,
          dependsOnChoice: effect.userChoice ? `${traitId}-${effectIndex}` : undefined
        });
      }
    }
  }
  
  // Add effects from class features
  const classFeatures = getClassFeatures(buildData.classId);
  if (classFeatures) {
    for (const feature of classFeatures.coreFeatures) {
      // Direct feature effects
      if (feature.effects) {
        for (const effect of feature.effects) {
          effects.push({
            ...effect,
            source: {
              type: 'class_feature',
              id: feature.featureName,
              name: feature.featureName,
              description: feature.description,
              category: `${classFeatures.className} Level ${feature.levelGained}`
            },
            resolved: true
          });
        }
      }
      
      // Benefits within features
      if (feature.benefits) {
        for (const benefit of feature.benefits) {
          if (benefit.effects) {
            for (const effect of benefit.effects) {
              effects.push({
                ...effect,
                source: {
                  type: 'class_feature',
                  id: `${feature.featureName}_${benefit.name}`,
                  name: benefit.name,
                  description: benefit.description,
                  category: `${classFeatures.className} Level ${feature.levelGained}`
                },
                resolved: true
              });
            }
          }
        }
      }
      
      // Chosen options from feature choices
      if (feature.choices) {
        for (const choice of feature.choices) {
          const userChoice = buildData.featureChoices[choice.id];
          if (userChoice) {
            for (const option of choice.options) {
              if (userChoice === option.name || 
                  (Array.isArray(userChoice) && userChoice.includes(option.name))) {
                if (option.effects) {
                  for (const effect of option.effects) {
                    effects.push({
                      ...effect,
                      source: {
                        type: 'choice',
                        id: `${choice.id}_${option.name}`,
                        name: option.name,
                        description: option.description,
                        category: `${classFeatures.className} Choice`
                      },
                      resolved: true
                    });
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  return effects;
}

/**
 * Resolve user choices in effects
 */
function resolveEffectChoices(effects: AttributedEffect[], choices: TraitChoiceStorage): AttributedEffect[] {
  return effects.map(effect => {
    if (!effect.userChoice || !effect.dependsOnChoice) {
      return effect;
    }
    
    const chosenValue = choices[effect.dependsOnChoice];
    if (!chosenValue) {
      return effect; // Unresolved
    }
    
    // Resolve the choice
    let resolvedEffect = { ...effect };
    if (effect.target === 'any_attribute' && effect.type === 'MODIFY_ATTRIBUTE') {
      resolvedEffect.target = chosenValue;
      resolvedEffect.resolved = true;
      resolvedEffect.resolvedValue = chosenValue;
    } else if (effect.target === 'any_skill' && effect.type === 'GRANT_SKILL_EXPERTISE') {
      resolvedEffect.target = chosenValue;
      resolvedEffect.resolved = true;
      resolvedEffect.resolvedValue = chosenValue;
    } else if (effect.target === 'any_trade' && effect.type === 'GRANT_TRADE_EXPERTISE') {
      resolvedEffect.target = chosenValue;
      resolvedEffect.resolved = true;
      resolvedEffect.resolvedValue = chosenValue;
    }
    
    return resolvedEffect;
  });
}

/**
 * Create detailed stat breakdown
 */
function createStatBreakdown(
  statName: string, 
  baseValue: number, 
  effects: AttributedEffect[]
): EnhancedStatBreakdown {
  const relevantEffects = effects.filter(effect => {
    if (!effect.resolved) return false;
    
    // Map effect types to stat names
    if (effect.type === 'MODIFY_ATTRIBUTE') {
      return statName === `attribute_${effect.target}` || statName === effect.target;
    }
    if (effect.type === 'MODIFY_STAT') {
      return statName === effect.target;
    }
    
    return false;
  });
  
  const breakdown: EnhancedStatBreakdown = {
    statName,
    base: baseValue,
    effects: relevantEffects.map(effect => ({
      source: effect.source,
      value: effect.value as number,
      condition: effect.condition,
      description: `${effect.source.name}: ${effect.value > 0 ? '+' : ''}${effect.value}${effect.condition ? ` (${effect.condition})` : ''}`,
      isActive: !effect.condition // For now, assume conditional effects are not active
    })),
    total: baseValue + relevantEffects.reduce((sum, effect) => {
      if (!effect.condition) { // Only count non-conditional effects in total
        return sum + (effect.value as number);
      }
      return sum;
    }, 0)
  };
  
  // Calculate conditional total
  breakdown.conditionalTotal = baseValue + relevantEffects.reduce((sum, effect) => {
    return sum + (effect.value as number);
  }, 0);
  
  return breakdown;
}

/**
 * Validate attribute limits
 */
function validateAttributeLimits(buildData: EnhancedCharacterBuildData, effects: AttributedEffect[]): Record<string, AttributeLimit> {
  const limits: Record<string, AttributeLimit> = {};
  
  for (const attr of attributesData) {
    const baseValue = (buildData as any)[`attribute_${attr.id}`] || 0;
    const traitBonuses = effects
      .filter(effect => 
        effect.resolved && 
        effect.type === 'MODIFY_ATTRIBUTE' && 
        effect.target === attr.id
      )
      .reduce((sum, effect) => sum + (effect.value as number), 0);
    
    const current = baseValue + traitBonuses;
    const max = 3; // Level 1 limit
    
    limits[attr.id] = {
      current,
      base: baseValue,
      traitBonuses,
      max,
      exceeded: current > max,
      canIncrease: current < max,
      canDecrease: baseValue > -2
    };
  }
  
  return limits;
}

/**
 * Get unresolved choices for character creation UI
 */
function getUnresolvedChoices(effects: AttributedEffect[]): UnresolvedChoice[] {
  return effects
    .filter(effect => effect.userChoice && !effect.resolved)
    .map(effect => {
      const options = getOptionsForEffect(effect);
      
      return {
        traitId: effect.source.id,
        traitName: effect.source.name,
        effectIndex: 0, // Would need to track this properly
        effect,
        prompt: effect.userChoice!.prompt,
        options,
        isRequired: true
      };
    });
}

/**
 * Get choice options for an effect
 */
function getOptionsForEffect(effect: AttributedEffect): ChoiceOption[] {
  const baseOptions = effect.userChoice?.options || [];
  
  if (effect.type === 'MODIFY_ATTRIBUTE' && baseOptions.length === 0) {
    return attributesData.map(attr => ({
      value: attr.id,
      displayName: attr.name,
      description: attr.description,
      isValid: true // Would need proper validation
    }));
  }
  
  if (effect.type === 'GRANT_SKILL_EXPERTISE' && baseOptions.length === 0) {
    return skillsData.map(skill => ({
      value: skill.id,
      displayName: skill.name,
      description: skill.description,
      isValid: true
    }));
  }
  
  if (effect.type === 'GRANT_TRADE_EXPERTISE' && baseOptions.length === 0) {
    return tradesData.map(trade => ({
      value: trade.id,
      displayName: trade.name,
      description: trade.description,
      isValid: true
    }));
  }
  
  return baseOptions.map(option => ({
    value: option,
    displayName: option,
    isValid: true
  }));
}

/**
 * Main calculation function with detailed breakdowns
 */
export function calculateCharacterWithBreakdowns(
  buildData: EnhancedCharacterBuildData
): EnhancedCalculationResult {
  
  // 1. Aggregate all effects with source attribution
  const rawEffects = aggregateAttributedEffects(buildData);
  
  // 2. Resolve user choices
  const resolvedEffects = resolveEffectChoices(rawEffects, buildData.selectedTraitChoices);
  
  // 3. Calculate base stats
  const classProgressionData = getClassProgressionData(buildData.classId);
  const baseHP = 0; // Will calculate from level progression
  const baseSP = 0; // Will calculate from level progression  
  const baseMP = 0; // Will calculate from level progression
  
  // 4. Create detailed breakdowns
  const breakdowns: Record<string, EnhancedStatBreakdown> = {};
  
  // Attributes
  for (const attr of attributesData) {
    const baseValue = (buildData as any)[`attribute_${attr.id}`] || 0;
    breakdowns[`attribute_${attr.id}`] = createStatBreakdown(attr.id, baseValue, resolvedEffects);
  }
  
  // Calculate final attribute values
  const finalMight = breakdowns.attribute_might.total;
  const finalAgility = breakdowns.attribute_agility.total;
  const finalCharisma = breakdowns.attribute_charisma.total;
  const finalIntelligence = breakdowns.attribute_intelligence.total;
  
  // Derived stats
  const combatMastery = buildData.combatMastery;
  
  // Health & Resources - sum from level progression + modifiers
  let finalHPMax = finalMight; // Base from Might
  let finalSPMax = 0;
  let finalMPMax = 0;
  
  // Calculate from level progression if available
  if (classProgressionData?.levelProgression) {
    for (let level = 1; level <= buildData.level; level++) {
      const levelData = classProgressionData.levelProgression.find((lp: any) => lp.level === level);
      if (levelData) {
        finalHPMax += levelData.healthPoints || 0;
        finalSPMax += levelData.staminaPoints || 0;
        finalMPMax += levelData.manaPoints || 0;
      }
    }
  } else {
    // Fallback to base calculation
    finalHPMax += baseHP + (buildData.level - 1);
    finalSPMax = baseSP + finalAgility;
    finalMPMax = baseMP + finalIntelligence;
  }
  
  // Apply effect modifiers
  finalHPMax += resolvedEffects.filter(e => e.type === 'MODIFY_STAT' && e.target === 'hpMax').reduce((sum, e) => sum + (e.value as number), 0);
  finalSPMax += resolvedEffects.filter(e => e.type === 'MODIFY_STAT' && e.target === 'spMax').reduce((sum, e) => sum + (e.value as number), 0);
  finalMPMax += resolvedEffects.filter(e => e.type === 'MODIFY_STAT' && e.target === 'mpMax').reduce((sum, e) => sum + (e.value as number), 0);
  
  // Defenses with modifiers
  const basePD = 8 + combatMastery + finalAgility + finalIntelligence;
  const baseAD = 8 + combatMastery + finalMight + finalCharisma;
  const pdModifiers = resolvedEffects.filter(e => e.type === 'MODIFY_STAT' && e.target === 'pd').reduce((sum, e) => sum + (e.value as number), 0);
  const adModifiers = resolvedEffects.filter(e => e.type === 'MODIFY_STAT' && e.target === 'ad').reduce((sum, e) => sum + (e.value as number), 0);
  const finalPD = buildData.manualPD ?? (basePD + pdModifiers);
  const finalAD = buildData.manualAD ?? (baseAD + adModifiers);
  const finalPDR = buildData.manualPDR ?? 0;
  
  // Create breakdowns for derived stats
  breakdowns.hpMax = createStatBreakdown('hpMax', finalHPMax, resolvedEffects);
  breakdowns.pd = createStatBreakdown('pd', basePD, resolvedEffects);
  breakdowns.ad = createStatBreakdown('ad', baseAD, resolvedEffects);
  
  // Other stats
  const maxValue = Math.max(finalMight, finalAgility, finalCharisma, finalIntelligence);
  const primeAttribute = ['might', 'agility', 'charisma', 'intelligence'].find(attr => {
    return breakdowns[`attribute_${attr}`].total === maxValue;
  }) || 'might';
  
  const finalSaveDC = 8 + combatMastery + maxValue;
  const finalDeathThreshold = maxValue + combatMastery; // Prime + Combat Mastery (usually -4)
  const finalMoveSpeed = 5 + resolvedEffects.filter(e => e.type === 'MODIFY_STAT' && e.target === 'moveSpeed').reduce((sum, e) => sum + (e.value as number), 0);
  const finalJumpDistance = finalAgility + resolvedEffects.filter(effect => effect.type === 'MODIFY_STAT' && effect.target === 'jumpDistance').reduce((sum, effect) => sum + (effect.value as number), 0);
  const finalRestPoints = finalHPMax; // Rest Points = HP
  const finalGritPoints = Math.max(0, 2 + finalCharisma); // 2 + Charisma (minimum 0)
  const finalInitiativeBonus = finalAgility;
  
  // 5. Validation
  const attributeLimits = validateAttributeLimits(buildData, resolvedEffects);
  const validation: ValidationResult = {
    isValid: !Object.values(attributeLimits).some(limit => limit.exceeded),
    errors: [],
    warnings: [],
    attributeLimits,
    masteryLimits: {
      maxSkillMastery: 1, // Default for level 1
      maxTradeMastery: 1,
      currentAdeptCount: 0,
      maxAdeptCount: 1,
      canSelectAdept: true
    }
  };
  
  // 6. Collect abilities and features
  const grantedAbilities = resolvedEffects
    .filter(effect => effect.resolved && effect.type === 'GRANT_ABILITY')
    .map(effect => ({
      name: effect.target,
      description: effect.value as string,
      source: effect.source,
      type: 'active' as const,
      isConditional: !!effect.condition,
      condition: effect.condition
    }));
  
  // 7. Conditional modifiers
  const conditionalModifiers = resolvedEffects
    .filter(effect => effect.resolved && effect.condition)
    .map(effect => ({
      effect,
      condition: effect.condition!,
      description: `${effect.source.name}: ${effect.value > 0 ? '+' : ''}${effect.value} ${effect.target} while ${effect.condition}`,
      affectedStats: [effect.target]
    }));
  
  // 8. Get unresolved choices
  const unresolvedChoices = getUnresolvedChoices(resolvedEffects);
  
  return {
    stats: {
      finalMight,
      finalAgility,
      finalCharisma,
      finalIntelligence,
      finalHPMax,
      finalSPMax,
      finalMPMax,
      finalPD,
      finalAD,
      finalPDR,
      finalMoveSpeed,
      finalJumpDistance,
      finalDeathThreshold,
      finalSaveDC,
      finalInitiativeBonus,
      finalRestPoints,
      finalGritPoints,
      
      // Prime modifier and combat mastery (needed for UI compatibility)
      finalPrimeModifierValue: maxValue,
      finalPrimeModifierAttribute: primeAttribute,
      finalCombatMastery: combatMastery,
      
      // Class and ancestry info for UI
      className: getClassFeatures(buildData.classId)?.name || 'Unknown',
      ancestry1Name: ancestriesData.find(a => a.id === buildData.ancestry1Id)?.name,
      ancestry2Name: ancestriesData.find(a => a.id === buildData.ancestry2Id)?.name
    },
    breakdowns,
    grantedAbilities,
    conditionalModifiers,
    combatTraining: [],
    resistances: [],
    vulnerabilities: [],
    senses: [],
    movements: [],
    validation,
    unresolvedChoices,
    cacheTimestamp: Date.now(),
    isFromCache: false
  };
}
````

## File: src/lib/utils/characterState.ts
````typescript
// Comprehensive character state management utility
// Handles all character data persistence with original/current value separation

import type {
	CharacterState,
	CharacterSheetData,
	AttackData,
	SpellData,
	InventoryItemData,
	CurrentValues
} from '../../types';

// Get character state from localStorage
export const getCharacterState = (characterId: string): CharacterState | null => {
	try {
		const savedCharacters = JSON.parse(localStorage.getItem('savedCharacters') || '[]');
		const character = savedCharacters.find((char: any) => char.id === characterId);

		if (!character) return null;

		// Return the character's state, or null if not found
		return character.characterState || null;
	} catch (error) {
		console.error('Error getting character state:', error);
		return null;
	}
};

// Initialize character state from character data
export const initializeCharacterState = (
	characterData: CharacterSheetData,
	existingState?: CharacterState | null
): CharacterState => {
	// Calculate original values from character data
	const originalResources = {
		maxHP: characterData.finalHPMax || 0,
		maxSP: characterData.finalSPMax || 0,
		maxMP: characterData.finalMPMax || 0,
		maxGritPoints: characterData.finalGritPoints || 0,
		maxRestPoints: characterData.finalRestPoints || 0
	};

	const originalCurrency = {
		goldPieces: 0,
		silverPieces: 0,
		copperPieces: 0,
		electrumPieces: 0,
		platinumPieces: 0
	};

	const originalAttacks: AttackData[] = [
		{
			id: '1',
			weaponId: '',
			name: '',
			attackBonus: 0,
			damage: '',
			damageType: '',
			critRange: '',
			critDamage: '',
			brutalDamage: '',
			heavyHitEffect: ''
		},
		{
			id: '2',
			weaponId: '',
			name: '',
			attackBonus: 0,
			damage: '',
			damageType: '',
			critRange: '',
			critDamage: '',
			brutalDamage: '',
			heavyHitEffect: ''
		},
		{
			id: '3',
			weaponId: '',
			name: '',
			attackBonus: 0,
			damage: '',
			damageType: '',
			critRange: '',
			critDamage: '',
			brutalDamage: '',
			heavyHitEffect: ''
		}
	];

	const originalInventory: InventoryItemData[] = [];
	const originalSpells: SpellData[] = [];

	// Use existing state if available, otherwise initialize with defaults
	return {
		resources: {
			original: originalResources,
			current: existingState?.resources.current || {
				currentHP:
					characterData.currentHP !== undefined ? characterData.currentHP : originalResources.maxHP,
				currentSP:
					characterData.currentSP !== undefined ? characterData.currentSP : originalResources.maxSP,
				currentMP:
					characterData.currentMP !== undefined ? characterData.currentMP : originalResources.maxMP,
				currentGritPoints:
					characterData.currentGritPoints !== undefined
						? characterData.currentGritPoints
						: originalResources.maxGritPoints,
				currentRestPoints:
					characterData.currentRestPoints !== undefined
						? characterData.currentRestPoints
						: originalResources.maxRestPoints,
				tempHP: characterData.tempHP || 0,
				actionPointsUsed: characterData.actionPointsUsed || 0,
				exhaustionLevel: characterData.exhaustionLevel || 0
			}
		},
		currency: {
			original: originalCurrency,
			current: existingState?.currency.current || {
				goldPieces: 0,
				silverPieces: 0,
				copperPieces: 0,
				electrumPieces: 0,
				platinumPieces: 0
			}
		},
		attacks: {
			original: originalAttacks,
			current: existingState?.attacks.current || [...originalAttacks]
		},
		spells: {
			original: originalSpells,
			current: existingState?.spells?.current || []
		},
		inventory: {
			original: originalInventory,
			current: existingState?.inventory.current || []
		},
		defenseNotes: existingState?.defenseNotes
	};
};

// Save complete character state to localStorage
export const saveCharacterState = (characterId: string, state: CharacterState): void => {
	try {
		const savedCharacters = JSON.parse(localStorage.getItem('savedCharacters') || '[]');
		const characterIndex = savedCharacters.findIndex((char: any) => char.id === characterId);

		if (characterIndex !== -1) {
			// Update the character's state
			savedCharacters[characterIndex] = {
				...savedCharacters[characterIndex],
				characterState: state,
				// Also maintain backwards compatibility with old format
				currentHP: state.resources.current.currentHP,
				currentSP: state.resources.current.currentSP,
				currentMP: state.resources.current.currentMP,
				currentGritPoints: state.resources.current.currentGritPoints,
				currentRestPoints: state.resources.current.currentRestPoints,
				tempHP: state.resources.current.tempHP,
				actionPointsUsed: state.resources.current.actionPointsUsed,
				exhaustionLevel: state.resources.current.exhaustionLevel,
				goldPieces: state.currency.current.goldPieces,
				silverPieces: state.currency.current.silverPieces,
				copperPieces: state.currency.current.copperPieces,
				electrumPieces: state.currency.current.electrumPieces,
				platinumPieces: state.currency.current.platinumPieces,
				defenseNotes: state.defenseNotes,
				lastModified: new Date().toISOString()
			};

			localStorage.setItem('savedCharacters', JSON.stringify(savedCharacters));
			console.log('Character state saved to localStorage');
		}
	} catch (error) {
		console.error('Error saving character state:', error);
	}
};

// Update a specific part of character state
export const updateCharacterState = (
	characterId: string,
	updates: Partial<CharacterState>
): void => {
	let currentState = getCharacterState(characterId);

	// If no character state exists, try to create a minimal one from localStorage character data
	if (!currentState) {
		console.log('No character state found for ID:', characterId, '- creating minimal state');

		// Get character data from localStorage to initialize state
		try {
			const savedCharacters = JSON.parse(localStorage.getItem('savedCharacters') || '[]');
			const character = savedCharacters.find((char: any) => char.id === characterId);

			if (!character) {
				console.error('No character found in localStorage for ID:', characterId);
				return;
			}

			// Create minimal character state with default values
			currentState = {
				resources: {
					original: {
						maxHP: character.finalHPMax || 0,
						maxSP: character.finalSPMax || 0,
						maxMP: character.finalMPMax || 0,
						maxGritPoints: character.finalGritPoints || 0,
						maxRestPoints: character.finalRestPoints || 0
					},
					current: {
						currentHP:
							character.currentHP !== undefined ? character.currentHP : character.finalHPMax || 0,
						currentSP:
							character.currentSP !== undefined ? character.currentSP : character.finalSPMax || 0,
						currentMP:
							character.currentMP !== undefined ? character.currentMP : character.finalMPMax || 0,
						currentGritPoints:
							character.currentGritPoints !== undefined
								? character.currentGritPoints
								: character.finalGritPoints || 0,
						currentRestPoints:
							character.currentRestPoints !== undefined
								? character.currentRestPoints
								: character.finalRestPoints || 0,
						tempHP: character.tempHP || 0,
						actionPointsUsed: character.actionPointsUsed || 0,
						exhaustionLevel: character.exhaustionLevel || 0
					}
				},
				currency: {
					original: {
						goldPieces: 0,
						silverPieces: 0,
						copperPieces: 0,
						electrumPieces: 0,
						platinumPieces: 0
					},
					current: {
						goldPieces: character.goldPieces || 0,
						silverPieces: character.silverPieces || 0,
						copperPieces: character.copperPieces || 0,
						electrumPieces: character.electrumPieces || 0,
						platinumPieces: character.platinumPieces || 0
					}
				},
				attacks: {
					original: [],
					current: []
				},
				spells: {
					original: [],
					current: []
				},
				inventory: {
					original: [],
					current: []
				},
				defenseNotes: character.defenseNotes
			};
		} catch (error) {
			console.error('Error creating minimal character state:', error);
			return;
		}
	}

	const newState: CharacterState = {
		...currentState,
		...updates,
		// Deep merge nested objects
		resources: updates.resources
			? {
					...currentState.resources,
					...updates.resources,
					current: updates.resources.current
						? {
								...currentState.resources.current,
								...updates.resources.current
							}
						: currentState.resources.current,
					original: updates.resources.original
						? {
								...currentState.resources.original,
								...updates.resources.original
							}
						: currentState.resources.original
				}
			: currentState.resources,
		currency: updates.currency
			? {
					...currentState.currency,
					...updates.currency,
					current: updates.currency.current
						? {
								...currentState.currency.current,
								...updates.currency.current
							}
						: currentState.currency.current,
					original: updates.currency.original
						? {
								...currentState.currency.original,
								...updates.currency.original
							}
						: currentState.currency.original
				}
			: currentState.currency,
		attacks: updates.attacks
			? {
					...currentState.attacks,
					...updates.attacks
				}
			: currentState.attacks,
		spells: updates.spells
			? {
					...currentState.spells,
					...updates.spells
				}
			: currentState.spells,
		inventory: updates.inventory
			? {
					...currentState.inventory,
					...updates.inventory
				}
			: currentState.inventory
	};

	saveCharacterState(characterId, newState);
};

// Revert a specific data type to original values
export const revertToOriginal = (
	characterId: string,
	dataType: 'resources' | 'currency' | 'attacks' | 'spells' | 'inventory'
): void => {
	const currentState = getCharacterState(characterId);
	if (!currentState) {
		console.log('No character state found for revert operation on ID:', characterId);
		// Try to initialize the state first, then revert won't be needed since it will be at defaults
		return;
	}

	const updates: Partial<CharacterState> = {};

	switch (dataType) {
		case 'resources':
			updates.resources = {
				...currentState.resources,
				current: {
					currentHP: currentState.resources.original.maxHP,
					currentSP: currentState.resources.original.maxSP,
					currentMP: currentState.resources.original.maxMP,
					currentGritPoints: currentState.resources.original.maxGritPoints,
					currentRestPoints: currentState.resources.original.maxRestPoints,
					tempHP: 0,
					actionPointsUsed: 0,
					exhaustionLevel: 0
				}
			};
			break;
		case 'currency':
			updates.currency = {
				...currentState.currency,
				current: { ...currentState.currency.original }
			};
			break;
		case 'attacks':
			updates.attacks = {
				...currentState.attacks,
				current: [...currentState.attacks.original]
			};
			break;
		case 'spells':
			updates.spells = {
				...currentState.spells,
				current: [...currentState.spells.original]
			};
			break;
		case 'inventory':
			updates.inventory = {
				...currentState.inventory,
				current: [...currentState.inventory.original]
			};
			break;
	}

	updateCharacterState(characterId, updates);
};

// Convert new CharacterState to legacy CurrentValues format for backwards compatibility
export const characterStateToCurrentValues = (state: CharacterState): CurrentValues => {
	return {
		currentHP: state.resources.current.currentHP,
		currentSP: state.resources.current.currentSP,
		currentMP: state.resources.current.currentMP,
		currentGritPoints: state.resources.current.currentGritPoints,
		currentRestPoints: state.resources.current.currentRestPoints,
		tempHP: state.resources.current.tempHP,
		actionPointsUsed: state.resources.current.actionPointsUsed,
		exhaustionLevel: state.resources.current.exhaustionLevel,
		goldPieces: state.currency.current.goldPieces,
		silverPieces: state.currency.current.silverPieces,
		copperPieces: state.currency.current.copperPieces,
		electrumPieces: state.currency.current.electrumPieces,
		platinumPieces: state.currency.current.platinumPieces
	};
};
````

## File: src/lib/utils/classFeatureDescriptions.ts
````typescript
/**
 * @file classFeatureDescriptions.ts
 * @description Utility function to get detailed descriptions for class feature choices
 * from the new class features structure.
 */

import { findChoiceOption } from '../rulesdata/loaders/class-features.loader';

/**
 * Gets detailed description for a class feature choice from the new class features structure.
 *
 * @param choiceId - The ID of the feature choice (e.g., 'cleric_divine_domain')
 * @param optionValue - The value of the selected option (e.g., 'knowledge')
 * @returns Detailed description string or null if not found
 */
export function getDetailedClassFeatureDescription(
	choiceId: string,
	optionValue: string
): string | null {
	switch (choiceId) {
		case 'cleric_divine_domain':
			// Map lowercase option value to proper name for lookup
			const domainNameMap: Record<string, string> = {
				knowledge: 'Knowledge',
				magic: 'Magic',
				divine_damage_expansion: 'Divine Damage Expansion',
				life: 'Life',
				death: 'Death',
				grave: 'Grave',
				light: 'Light',
				dark: 'Dark',
				war: 'War',
				peace: 'Peace',
				order: 'Order',
				chaos: 'Chaos',
				divination: 'Divination',
				trickery: 'Trickery',
				nature: 'Nature',
				tempest: 'Tempest',
				travel: 'Travel',
				ancestral: 'Ancestral'
			};

			const domainName = domainNameMap[optionValue];
			if (!domainName) return null;

			const domainOption = findChoiceOption('Cleric', 'Cleric Order', 0, domainName);
			return domainOption?.description || null;

		case 'monk_stance_choice':
			const stanceNameMap: Record<string, string> = {
				bear_stance: 'Bear Stance',
				bull_stance: 'Bull Stance',
				cobra_stance: 'Cobra Stance',
				gazelle_stance: 'Gazelle Stance',
				mantis_stance: 'Mantis Stance',
				mongoose_stance: 'Mongoose Stance',
				scorpion_stance: 'Scorpion Stance',
				turtle_stance: 'Turtle Stance',
				wolf_stance: 'Wolf Stance'
			};

			const stanceName = stanceNameMap[optionValue];
			if (!stanceName) return null;

			const stanceOption = findChoiceOption('Monk', 'Monk Stance', 0, stanceName);
			return stanceOption?.description || null;

		// Add other class feature choices here when needed
		default:
			return null;
	}
}

/**
 * Type definition for the mapping of choice IDs to their detailed descriptions.
 * This helps with type safety and documentation of what choices have detailed descriptions.
 */
export type SupportedClassFeatureChoices = 'cleric_divine_domain' | 'monk_stance_choice';

/**
 * Checks if a choice ID has detailed descriptions available.
 *
 * @param choiceId - The choice ID to check
 * @returns True if detailed descriptions are available
 */
export function hasDetailedDescription(choiceId: string): choiceId is SupportedClassFeatureChoices {
	const supportedChoices: SupportedClassFeatureChoices[] = [
		'cleric_divine_domain',
		'monk_stance_choice'
	];
	return supportedChoices.includes(choiceId as SupportedClassFeatureChoices);
}
````

## File: src/routes/character-creation/components/LanguagesTab.tsx
````typescript
import React from 'react';
import { languagesData } from '../../../lib/rulesdata/languages';
import type {
	BackgroundPointsData,
	PointConversions,
	ConversionActions
} from './BackgroundPointsManager';
import {
	StyledTabContent,
	StyledSelectionGrid,
	StyledSelectionItem,
	StyledSelectionHeader,
	StyledSelectionName,
	StyledProficiencyButton,
	StyledLanguageFluency,
	StyledPointsRemaining
} from '../styles/Background.styles';

interface LanguagesTabProps {
	currentLanguages: Record<string, { fluency: 'limited' | 'fluent' }>;
	pointsData: BackgroundPointsData;
	conversions: PointConversions;
	actions: ConversionActions;
	onLanguageChange: (languageId: string, fluency: 'limited' | 'fluent' | null) => void;
}

const LanguagesTab: React.FC<LanguagesTabProps> = ({
	currentLanguages,
	pointsData,
	conversions,
	actions,
	onLanguageChange
}) => {
	const getLanguageCost = (fluency: 'limited' | 'fluent') => {
		return fluency === 'limited' ? 1 : 2;
	};

	// Helper function for consistent button styling
	const getButtonStyle = (enabled: boolean, variant: 'primary' | 'danger' = 'primary') => ({
		padding: '0.5rem 1rem',
		backgroundColor: enabled ? (variant === 'primary' ? '#3b82f6' : '#ef4444') : '#6b7280',
		color: 'white',
		border: 'none',
		borderRadius: '6px',
		fontSize: '0.875rem',
		fontWeight: '500',
		cursor: enabled ? 'pointer' : 'not-allowed',
		transition: 'all 0.2s ease',
		opacity: enabled ? 1 : 0.6,
		':hover': enabled
			? {
					backgroundColor: variant === 'primary' ? '#2563eb' : '#dc2626',
					transform: 'translateY(-1px)',
					boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)'
				}
			: {}
	});

	const hasConversions =
		conversions.skillToTradeConversions > 0 ||
		conversions.tradeToSkillConversions > 0 ||
		conversions.tradeToLanguageConversions > 0;

	return (
		<StyledTabContent>
			<StyledPointsRemaining>
				Language Points: {pointsData.availableLanguagePoints - pointsData.languagePointsUsed} /{' '}
				{pointsData.availableLanguagePoints} remaining
				{conversions.tradeToLanguageConversions > 0 && (
					<div
						style={{
							fontSize: '0.9rem',
							color: '#6366f1',
							marginTop: '0.5rem',
							padding: '0.25rem 0.5rem',
							backgroundColor: '#6366f11a',
							borderRadius: '4px',
							border: '1px solid #6366f133'
						}}
					>
						Active conversions: {conversions.tradeToLanguageConversions} trade →{' '}
						{conversions.tradeToLanguageConversions * 2} language
					</div>
				)}
				<div
					style={{
						marginTop: '0.75rem',
						display: 'flex',
						gap: '0.5rem',
						flexWrap: 'wrap'
					}}
				>
					<button
						onClick={actions.convertTradeToLanguage}
						disabled={pointsData.availableTradePoints - pointsData.tradePointsUsed < 1}
						style={getButtonStyle(
							pointsData.availableTradePoints - pointsData.tradePointsUsed >= 1
						)}
						onMouseEnter={(e) => {
							if (pointsData.availableTradePoints - pointsData.tradePointsUsed >= 1) {
								e.currentTarget.style.backgroundColor = '#2563eb';
								e.currentTarget.style.transform = 'translateY(-1px)';
								e.currentTarget.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
							}
						}}
						onMouseLeave={(e) => {
							if (pointsData.availableTradePoints - pointsData.tradePointsUsed >= 1) {
								e.currentTarget.style.backgroundColor = '#3b82f6';
								e.currentTarget.style.transform = 'translateY(0)';
								e.currentTarget.style.boxShadow = 'none';
							}
						}}
					>
						Convert 1 Trade → 2 Language Points
					</button>
					<button
						onClick={actions.resetConversions}
						disabled={!hasConversions}
						style={getButtonStyle(hasConversions, 'danger')}
						onMouseEnter={(e) => {
							if (hasConversions) {
								e.currentTarget.style.backgroundColor = '#dc2626';
								e.currentTarget.style.transform = 'translateY(-1px)';
								e.currentTarget.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
							}
						}}
						onMouseLeave={(e) => {
							if (hasConversions) {
								e.currentTarget.style.backgroundColor = '#ef4444';
								e.currentTarget.style.transform = 'translateY(0)';
								e.currentTarget.style.boxShadow = 'none';
							}
						}}
					>
						Reset Conversions
					</button>
				</div>
			</StyledPointsRemaining>
			<StyledSelectionGrid>
				{languagesData.map((language) => {
					const currentFluency = currentLanguages[language.id]?.fluency || null;
					const isCommon = language.id === 'common';

					return (
						<StyledSelectionItem key={language.id}>
							<StyledSelectionHeader>
								<StyledSelectionName>
									{language.name}
									{isCommon && (
										<span style={{ color: '#10b981', fontSize: '0.8rem', marginLeft: '0.5rem' }}>
											(Free)
										</span>
									)}
								</StyledSelectionName>
								<div style={{ fontSize: '0.8rem', color: '#e2e8f0', textTransform: 'uppercase' }}>
									{(language as any).type}
								</div>
							</StyledSelectionHeader>
							<div style={{ fontSize: '0.9rem', color: '#cbd5e1', marginBottom: '0.5rem' }}>
								{language.description}
							</div>
							<StyledLanguageFluency>
								{!isCommon && (
									<StyledProficiencyButton
										$active={currentFluency === null}
										onClick={() => onLanguageChange(language.id, null)}
									>
										None
									</StyledProficiencyButton>
								)}
								{(['limited', 'fluent'] as const).map((fluency) => {
									const cost = getLanguageCost(fluency);
									const canAfford =
										isCommon ||
										currentFluency === fluency ||
										pointsData.languagePointsUsed + cost <= pointsData.availableLanguagePoints;

									return (
										<StyledProficiencyButton
											key={fluency}
											$active={currentFluency === fluency}
											$disabled={!canAfford && !isCommon}
											onClick={() => {
												if (isCommon || canAfford) {
													onLanguageChange(language.id, fluency);
												}
											}}
										>
											{fluency.charAt(0).toUpperCase() + fluency.slice(1)}{' '}
											{!isCommon && `(${cost})`}
										</StyledProficiencyButton>
									);
								})}
							</StyledLanguageFluency>
						</StyledSelectionItem>
					);
				})}
			</StyledSelectionGrid>
		</StyledTabContent>
	);
};

export default LanguagesTab;
````

## File: src/routes/character-creation/styles/Attributes.styles.ts
````typescript
import styled from 'styled-components';

export const StyledContainer = styled.div`
	border: 2px solid #8b5cf6;
	padding: 1.5rem;
	border-radius: 12px;
	background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
	margin-top: 2rem;
	box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3);
`;

export const StyledTitle = styled.h2`
	margin-top: 0;
	color: #fbbf24;
	font-size: 1.3rem;
	font-weight: bold;
	text-align: center;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	letter-spacing: 1px;
	border-bottom: 2px solid #ef4444;
	padding-bottom: 0.5rem;
	margin-bottom: 1rem;
`;

export const StyledPointsRemaining = styled.p`
	margin: 0.5rem 0;
	font-weight: bold;
	color: #ef4444;
	font-size: 1.2rem;
	text-align: center;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledGrid = styled.div`
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
	gap: 1rem;
	margin-top: 1rem;
`;

export const StyledCard = styled.div`
	border: 2px solid #a855f7;
	padding: 1.5rem;
	border-radius: 10px;
	background: linear-gradient(145deg, #2d1b69 0%, #4c1d95 100%);
	text-align: center;
	transition: all 0.3s ease;
	box-shadow: 0 4px 15px rgba(168, 85, 247, 0.2);

	&:hover {
		transform: translateY(-2px);
		box-shadow: 0 8px 25px rgba(168, 85, 247, 0.4);
		border-color: #fbbf24;
	}
`;

export const StyledCardTitle = styled.h3`
	margin: 0 0 0.5rem 0;
	color: #fbbf24;
	font-size: 1.4rem;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledControls = styled.div`
	display: flex;
	align-items: center;
	justify-content: center;
	gap: 1rem;
	margin-top: 0.5rem;
`;

export const StyledButton = styled.button`
	width: 45px;
	height: 45px;
	border: 2px solid #dc2626;
	border-radius: 8px;
	background: linear-gradient(145deg, #991b1b 0%, #dc2626 100%);
	color: #fbbf24;
	cursor: pointer;
	font-size: 1.4rem;
	font-weight: bold;
	transition: all 0.2s ease;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3);

	&:hover {
		background: linear-gradient(145deg, #dc2626 0%, #ef4444 100%);
		transform: translateY(-1px);
		box-shadow: 0 4px 12px rgba(220, 38, 38, 0.5);
		border-color: #fbbf24;
	}

	&:active {
		transform: translateY(0);
	}

	&:disabled {
		opacity: 0.4;
		cursor: not-allowed;
		background: linear-gradient(145deg, #4b5563 0%, #6b7280 100%);
		border-color: #6b7280;
		transform: none;
		box-shadow: none;
	}
`;

export const StyledValue = styled.p`
	margin: 0;
	font-size: 1.5rem;
	font-weight: bold;
	min-width: 40px;
	color: #fbbf24;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	background: linear-gradient(145deg, #1e1b4b 0%, #312e81 100%);
	padding: 0.5rem;
	border-radius: 6px;
	border: 1px solid #8b5cf6;
`;

export const StyledDescription = styled.p`
	color: #e5e7eb;
	font-size: 0.9rem;
	line-height: 1.4;
	margin: 0.5rem 0 1rem 0;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;
````

## File: src/routes/character-creation/styles/Background.styles.ts
````typescript
import styled from 'styled-components';

export const StyledContainer = styled.div`
	border: 2px solid #8b5cf6;
	padding: 1.5rem;
	border-radius: 12px;
	background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
	margin-top: 2rem;
	box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3);
	color: white;
	font-family: 'Inter', sans-serif;
`;

export const StyledSubheading = styled.h2`
	margin-top: 0;
	color: #fbbf24;
	font-size: 1.3rem;
	font-weight: bold;
	text-align: center;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	letter-spacing: 1px;
	border-bottom: 2px solid #ef4444;
	padding-bottom: 0.5rem;
	margin-bottom: 1rem;
`;

export const StyledDescription = styled.p`
	color: #e2e8f0;
	text-align: center;
	margin-bottom: 1.5rem;
	line-height: 1.6;
	font-size: 1rem;
`;

export const StyledTabContainer = styled.div`
	display: flex;
	justify-content: center;
	margin-bottom: 1.5rem;
	border: 2px solid #a855f7;
	border-radius: 10px;
	background: rgba(45, 27, 105, 0.3);
	padding: 0.5rem;
	gap: 0.5rem;
`;

export const StyledTab = styled.button<{ $active: boolean }>`
	padding: 0.75rem 1.5rem;
	border: none;
	border-radius: 8px;
	font-size: 1rem;
	font-weight: 600;
	cursor: pointer;
	transition: all 0.3s ease;

	background: ${(props) =>
		props.$active ? 'linear-gradient(145deg, #fbbf24 0%, #f59e0b 100%)' : 'transparent'};
	color: ${(props) => (props.$active ? '#1e1b4b' : '#e2e8f0')};

	&:hover {
		background: ${(props) =>
			props.$active
				? 'linear-gradient(145deg, #f59e0b 0%, #d97706 100%)'
				: 'rgba(251, 191, 36, 0.1)'};
	}
`;

export const StyledTabContent = styled.div`
	margin: 0 auto;
`;

export const StyledPointsRemaining = styled.div`
	margin: 0.5rem 0;
	font-weight: bold;
	color: #ef4444;
	font-size: 1.2rem;
	text-align: center;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	margin-bottom: 1.5rem;
`;

export const StyledSelectionGrid = styled.div`
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
	gap: 1rem;
	margin-top: 1rem;
`;

export const StyledSelectionItem = styled.div`
	border: 2px solid #a855f7;
	padding: 1.5rem;
	border-radius: 10px;
	background: linear-gradient(145deg, #2d1b69 0%, #4c1d95 100%);
	transition: all 0.3s ease;
	box-shadow: 0 4px 15px rgba(168, 85, 247, 0.2);

	&:hover {
		border-color: #fbbf24;
		transform: translateY(-2px);
		box-shadow: 0 8px 25px rgba(251, 191, 36, 0.3);
	}
`;

export const StyledSelectionHeader = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 0.5rem;
`;

export const StyledSelectionName = styled.h4`
	font-size: 1.1rem;
	font-weight: 600;
	margin: 0;
	color: #fbbf24;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledProficiencySelector = styled.div`
	display: flex;
	gap: 0.5rem;
	flex-wrap: wrap;
	margin-top: 0.5rem;
`;

export const StyledProficiencyButton = styled.button<{ $active?: boolean; $disabled?: boolean }>`
	padding: 0.5rem 1rem;
	border: 2px solid ${(props) => (props.$active ? '#fbbf24' : '#6b7280')};
	border-radius: 6px;
	background: ${(props) => (props.$active ? '#fbbf24' : 'transparent')};
	color: ${(props) => (props.$active ? '#1e1b4b' : '#e2e8f0')};
	font-weight: 600;
	cursor: ${(props) => (props.$disabled ? 'not-allowed' : 'pointer')};
	transition: all 0.2s ease;
	opacity: ${(props) => (props.$disabled ? 0.5 : 1)};

	&:hover:not(:disabled) {
		background: ${(props) => (props.$active ? '#f59e0b' : 'rgba(251, 191, 36, 0.1)')};
		border-color: #fbbf24;
	}
`;

export const StyledLanguageFluency = styled.div`
	display: flex;
	gap: 0.5rem;
	flex-wrap: wrap;
	margin-top: 0.5rem;
`;

export const StyledError = styled.div`
	background-color: rgba(239, 68, 68, 0.1);
	border: 1px solid #ef4444;
	color: #ef4444;
	padding: 0.75rem;
	border-radius: 6px;
	margin-top: 1rem;
	font-size: 0.9rem;
	text-align: center;
`;
````

## File: src/routes/character-creation/styles/CharacterCreation.styles.ts
````typescript
// Styled components for CharacterCreation component
import styled from 'styled-components';

export const StyledContainer = styled.div`
	display: flex;
	flex-direction: column;
	gap: 2rem;
	padding: 1rem;
	min-height: 100vh;
	background: linear-gradient(135deg, #0f0f23 0%, #1e1b4b 50%, #312e81 100%);
`;

export const StyledTitle = styled.h1`
	margin-bottom: 2rem;
	color: #fbbf24;
	text-align: center;
	font-size: 2.2rem;
	font-weight: bold;
	text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7);
	letter-spacing: 2px;
	background: linear-gradient(45deg, #fbbf24 0%, #f59e0b 100%);
	background-clip: text;
	-webkit-background-clip: text;
	-webkit-text-fill-color: transparent;
`;

export const StyledStepIndicator = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 2rem;
	padding: 0 1rem;
`;

export const StyledStepsContainer = styled.div`
	display: flex;
	justify-content: center;
	align-items: center;
	gap: 2rem;
	flex: 1;
`;

export const StyledStep = styled.div<{ $active: boolean; $completed: boolean }>`
	display: flex;
	flex-direction: column;
	align-items: center;
	gap: 0.5rem;
	cursor: pointer;
	transition: all 0.3s ease;

	&:hover {
		transform: scale(1.05);
	}
`;

export const StyledStepNumber = styled.div<{ $active: boolean; $completed: boolean }>`
	width: 40px;
	height: 40px;
	border-radius: 50%;
	display: flex;
	align-items: center;
	justify-content: center;
	font-weight: bold;
	font-size: 1.2rem;
	transition: all 0.3s ease;

	${(props) =>
		props.$completed &&
		`
    background: linear-gradient(145deg, #10b981 0%, #059669 100%);
    color: white;
    border: 2px solid #10b981;
  `}

	${(props) =>
		props.$active &&
		!props.$completed &&
		`
    background: linear-gradient(145deg, #fbbf24 0%, #f59e0b 100%);
    color: #1e1b4b;
    border: 2px solid #fbbf24;
  `}
  
  ${(props) =>
		!props.$active &&
		!props.$completed &&
		`
    background: transparent;
    color: #9ca3af;
    border: 2px solid #9ca3af;
  `}
`;

export const StyledStepLabel = styled.span<{ $active: boolean; $completed: boolean }>`
	font-size: 0.9rem;
	font-weight: 600;
	text-align: center;

	${(props) =>
		props.$completed &&
		`
    color: #10b981;
  `}

	${(props) =>
		props.$active &&
		!props.$completed &&
		`
    color: #fbbf24;
  `}
  
  ${(props) =>
		!props.$active &&
		!props.$completed &&
		`
    color: #9ca3af;
  `}
`;

export const StyledNavigationButtons = styled.div`
	display: flex;
	gap: 1rem;
`;

export const StyledButton = styled.button<{ $variant?: 'primary' | 'secondary' }>`
	padding: 0.5rem 1rem;
	border-radius: 6px;
	font-weight: bold;
	font-size: 0.9rem;
	cursor: pointer;
	transition: all 0.3s ease;
	border: none;
	min-width: 80px;

	${(props) =>
		props.$variant === 'primary' &&
		`
    background: linear-gradient(145deg, #fbbf24 0%, #f59e0b 100%);
    color: #1e1b4b;
    
    &:hover {
      background: linear-gradient(145deg, #f59e0b 0%, #d97706 100%);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(251, 191, 36, 0.4);
    }
  `}

	${(props) =>
		props.$variant === 'secondary' &&
		`
    background: transparent;
    color: #9ca3af;
    border: 2px solid #9ca3af;
    
    &:hover {
      color: #fbbf24;
      border-color: #fbbf24;
    }
  `}
  
  &:disabled {
		opacity: 0.5;
		cursor: not-allowed;
		transform: none;
	}
`;
````

## File: src/routes/character-creation/styles/ClassSelector.styles.ts
````typescript
import styled from 'styled-components';

export const StyledContainer = styled.div`
	border: 2px solid #8b5cf6;
	padding: 1.5rem;
	border-radius: 12px;
	background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
	margin-top: 2rem;
	box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3);
`;

export const StyledTitle = styled.h2`
	margin-top: 0;
	color: #fbbf24;
	font-size: 1.3rem;
	font-weight: bold;
	text-align: center;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	letter-spacing: 1px;
	border-bottom: 2px solid #ef4444;
	padding-bottom: 0.5rem;
	margin-bottom: 1rem;
`;

export const StyledGrid = styled.div`
	display: flex;
	flex-wrap: wrap;
	gap: 1rem;
	margin-top: 1rem;
`;

export const StyledCard = styled.button<{ $selected: boolean }>`
	border: 2px solid #a855f7;
	padding: 1.5rem;
	border-radius: 10px;
	background: linear-gradient(145deg, #2d1b69 0%, #4c1d95 100%);
	cursor: pointer;
	transition: all 0.3s ease;
	flex: 1;
	min-width: 280px;
	max-width: 280px;
	height: 200px;
	text-align: left;
	box-shadow: 0 4px 15px rgba(168, 85, 247, 0.2);
	position: relative;
	display: flex;
	flex-direction: column;
	overflow: hidden;

	&:hover {
		transform: translateY(-2px);
		box-shadow: 0 8px 25px rgba(168, 85, 247, 0.4);
		border-color: #fbbf24;
	}

	${(props) =>
		props.$selected &&
		`
    border-color: #ef4444;
    background: linear-gradient(145deg, #991b1b 0%, #dc2626 100%);
    box-shadow: 0 8px 25px rgba(239, 68, 68, 0.5);
    transform: translateY(-2px);
  `}
`;

export const StyledCardHeader = styled.div`
	display: flex;
	align-items: center;
	gap: 1rem;
	margin-bottom: 1rem;
`;

export const StyledClassIcon = styled.div`
	font-size: 2rem;
	flex-shrink: 0;
	background: linear-gradient(145deg, #8b5cf6 0%, #a855f7 100%);
	border-radius: 50%;
	width: 50px;
	height: 50px;
	display: flex;
	align-items: center;
	justify-content: center;
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
`;

export const StyledCardTitle = styled.h3`
	margin: 0;
	color: #fbbf24;
	font-size: 1.4rem;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledCardDescription = styled.p`
	margin: 0;
	color: #e5e7eb;
	font-size: 0.9rem;
	line-height: 1.4;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	flex: 1;
	overflow: hidden;
	display: -webkit-box;
	-webkit-line-clamp: 3;
	-webkit-box-orient: vertical;
	position: relative;
`;

export const StyledCardFooter = styled.div`
	margin-top: 0.5rem;
	display: flex;
	justify-content: flex-end;
`;

export const StyledReadMore = styled.button`
	color: #fbbf24;
	font-size: 0.85rem;
	font-weight: bold;
	cursor: pointer;
	text-decoration: underline;
	background: none;
	border: none;
	padding: 0.5rem 0.75rem;
	border-radius: 4px;
	transition: all 0.2s ease;

	&:hover {
		color: #f59e0b;
		background: rgba(251, 191, 36, 0.1);
	}

	&:active {
		transform: scale(0.95);
	}
`;

export const StyledTooltip = styled.div<{ $show: boolean }>`
	position: fixed;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	background: linear-gradient(145deg, #1e1b4b 0%, #312e81 100%);
	color: #e5e7eb;
	padding: 2rem;
	border-radius: 12px;
	border: 3px solid #8b5cf6;
	box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
	z-index: 2000;
	width: 90vw;
	max-width: 500px;
	max-height: 80vh;
	overflow-y: auto;
	font-size: 1rem;
	line-height: 1.6;
	opacity: ${(props) => (props.$show ? 1 : 0)};
	pointer-events: ${(props) => (props.$show ? 'auto' : 'none')};
	transition: opacity 0.3s ease;

	/* Custom scrollbar for popup */
	::-webkit-scrollbar {
		width: 8px;
	}

	::-webkit-scrollbar-track {
		background: #1e1b4b;
		border-radius: 4px;
	}

	::-webkit-scrollbar-thumb {
		background: #8b5cf6;
		border-radius: 4px;
	}

	::-webkit-scrollbar-thumb:hover {
		background: #a855f7;
	}
`;

export const StyledTooltipOverlay = styled.div<{ $show: boolean }>`
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background: rgba(0, 0, 0, 0.7);
	z-index: 1999;
	opacity: ${(props) => (props.$show ? 1 : 0)};
	pointer-events: ${(props) => (props.$show ? 'auto' : 'none')};
	transition: opacity 0.3s ease;
`;

export const StyledTooltipHeader = styled.div`
	display: flex;
	align-items: center;
	gap: 1rem;
	margin-bottom: 1.5rem;
	padding-bottom: 1rem;
	border-bottom: 2px solid #8b5cf6;
`;

export const StyledTooltipIcon = styled.div`
	font-size: 3rem;
	background: linear-gradient(145deg, #8b5cf6 0%, #a855f7 100%);
	border-radius: 50%;
	width: 70px;
	height: 70px;
	display: flex;
	align-items: center;
	justify-content: center;
	box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
`;

export const StyledTooltipTitle = styled.h3`
	margin: 0;
	color: #fbbf24;
	font-size: 1.8rem;
	font-weight: bold;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
`;

export const StyledTooltipContent = styled.p`
	margin: 0;
	color: #e5e7eb;
	font-size: 1.1rem;
	line-height: 1.6;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledCloseHint = styled.div`
	margin-top: 1.5rem;
	padding-top: 1rem;
	border-top: 1px solid #8b5cf6;
	text-align: center;
	color: #9ca3af;
	font-size: 0.9rem;
	font-style: italic;
`;
````

## File: src/routes/character-creation/styles/LoadCharacter.styles.ts
````typescript
// Styled components for LoadCharacter component
import styled from 'styled-components';

export const StyledContainer = styled.div`
	padding: 2rem;
	min-height: 100vh;
	background: linear-gradient(135deg, #0f0f23 0%, #1e1b4b 50%, #312e81 100%);
`;

export const StyledTitle = styled.h1`
	margin-bottom: 2rem;
	color: #fbbf24;
	text-align: center;
	font-size: 2.2rem;
	font-weight: bold;
	text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7);
	letter-spacing: 2px;
`;

export const StyledCharacterGrid = styled.div`
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
	gap: 1.5rem;
	max-width: 1200px;
	margin: 0 auto;
`;

export const StyledCharacterCard = styled.div`
	border: 2px solid #8b5cf6;
	border-radius: 12px;
	padding: 1.5rem;
	background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
	box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3);
	transition: all 0.3s ease;

	&:hover {
		transform: translateY(-4px);
		box-shadow: 0 12px 40px rgba(139, 92, 246, 0.4);
		border-color: #fbbf24;
	}
`;

export const StyledCardActions = styled.div`
	display: flex;
	gap: 0.5rem;
	margin-top: 1rem;
`;

export const StyledActionButton = styled.button<{ variant?: 'primary' | 'secondary' }>`
	flex: 1;
	padding: 0.6rem 1rem;
	border: 2px solid ${(props) => (props.variant === 'primary' ? '#fbbf24' : '#8b5cf6')};
	border-radius: 6px;
	background: ${(props) => (props.variant === 'primary' ? '#fbbf24' : 'transparent')};
	color: ${(props) => (props.variant === 'primary' ? '#1e1b4b' : '#8b5cf6')};
	cursor: pointer;
	transition: all 0.3s ease;
	font-size: 0.9rem;
	font-weight: bold;

	&:hover {
		background: ${(props) => (props.variant === 'primary' ? '#f59e0b' : '#8b5cf6')};
		color: ${(props) => (props.variant === 'primary' ? '#1e1b4b' : 'white')};
		transform: translateY(-1px);
	}
`;

export const StyledCharacterName = styled.h2`
	margin: 0 0 1rem 0;
	color: #fbbf24;
	font-size: 1.5rem;
	font-weight: bold;
	text-align: center;
`;

export const StyledPlayerName = styled.p`
	margin: 0 0 1rem 0;
	color: #e5e7eb;
	font-size: 1rem;
	text-align: center;
	opacity: 0.8;
`;

export const StyledCharacterDetails = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 1rem;
`;

export const StyledDetailItem = styled.div`
	text-align: center;
`;

export const StyledDetailLabel = styled.div`
	color: #a855f7;
	font-size: 0.8rem;
	font-weight: bold;
	text-transform: uppercase;
	letter-spacing: 1px;
`;

export const StyledDetailValue = styled.div`
	color: #e5e7eb;
	font-size: 1rem;
	font-weight: bold;
	margin-top: 0.25rem;
`;

export const StyledCompletedDate = styled.p`
	margin: 0;
	color: #6b7280;
	font-size: 0.875rem;
	text-align: center;
	font-style: italic;
`;

export const StyledEmptyState = styled.div`
	text-align: center;
	padding: 4rem 2rem;
	color: #6b7280;
`;

export const StyledEmptyTitle = styled.h2`
	color: #a855f7;
	font-size: 1.5rem;
	margin-bottom: 1rem;
`;

export const StyledEmptyText = styled.p`
	font-size: 1rem;
	line-height: 1.6;
`;

export const StyledBackButton = styled.button`
	padding: 0.75rem 1.5rem;
	margin-bottom: 2rem;
	border: none;
	border-radius: 8px;
	background: linear-gradient(145deg, #6b7280 0%, #4b5563 100%);
	color: white;
	font-weight: bold;
	cursor: pointer;
	transition: all 0.3s ease;

	&:hover {
		background: linear-gradient(145deg, #4b5563 0%, #374151 100%);
		transform: translateY(-2px);
	}
`;
````

## File: src/routes/character-creation/styles/SelectedAncestries.styles.ts
````typescript
import styled from 'styled-components';

export const StyledOuterContainer = styled.div`
	border: 2px solid #8b5cf6;
	padding: 1.5rem;
	border-radius: 12px;
	background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
	margin-top: 2rem;
	box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3);
`;

export const StyledMainTitle = styled.h2`
	margin-top: 0;
	color: #fbbf24;
	font-size: 1.3rem;
	font-weight: bold;
	text-align: center;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	letter-spacing: 1px;
	border-bottom: 2px solid #ef4444;
	padding-bottom: 0.5rem;
	margin-bottom: 1rem;
`;

export const StyledContainer = styled.div`
	display: flex;
	flex-direction: column;
	gap: 2rem;
`;

export const StyledAncestryDetails = styled.div`
	border: 2px solid #a855f7;
	padding: 1.5rem;
	border-radius: 10px;
	background: linear-gradient(145deg, #2d1b69 0%, #4c1d95 100%);
	box-shadow: 0 4px 15px rgba(168, 85, 247, 0.2);
`;

export const StyledTitle = styled.h2`
	margin: 0 0 1rem 0;
	color: #fbbf24;
	font-size: 1.3rem;
	font-weight: bold;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	text-align: center;
	border-bottom: 2px solid #ef4444;
	padding-bottom: 0.5rem;
`;

export const StyledSubtitle = styled.h3`
	margin: 1rem 0 0.5rem 0;
	color: #ef4444;
	font-size: 1.3rem;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	border-bottom: 1px solid #ef4444;
	padding-bottom: 0.25rem;
`;

export const StyledList = styled.ul`
	list-style: none;
	padding: 0;
	margin: 0;
`;

export const StyledListItem = styled.li`
	margin-bottom: 0.8rem;
	padding: 0.5rem;
	border-radius: 5px;
	background: rgba(139, 92, 246, 0.1);
	border-left: 3px solid #8b5cf6;
`;

export const StyledLabel = styled.label`
	display: flex;
	align-items: flex-start;
	gap: 0.8rem;
	cursor: pointer;
	color: #e5e7eb;
	font-size: 0.95rem;
	line-height: 1.4;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);

	&:hover {
		color: #fbbf24;
	}
`;

export const StyledCheckbox = styled.input`
	margin-top: 0.25rem;
	flex-shrink: 0;
	width: 18px;
	height: 18px;
	accent-color: #ef4444;
	cursor: pointer;
`;
````

## File: src/routes/character-sheet/components/Combat.tsx
````typescript
import React from 'react';
import type { CharacterSheetData, CurrentValues } from '../../../types';
import { StyledCombatSection, StyledActionPoints, StyledActionPoint } from '../styles/Combat';

export interface CombatProps {
	characterData: CharacterSheetData;
	currentValues: CurrentValues;
	setCurrentValues: React.Dispatch<React.SetStateAction<CurrentValues>>;
}

const Combat: React.FC<CombatProps> = ({ characterData, currentValues, setCurrentValues }) => {
	const renderActionPoints = () => {
		return [0, 1, 2, 3].map((index) => (
			<StyledActionPoint
				key={index}
				used={index < currentValues.actionPointsUsed}
				onClick={() => {
					const newUsed = index < currentValues.actionPointsUsed ? index : index + 1;
					setCurrentValues((prev) => ({ ...prev, actionPointsUsed: newUsed }));
				}}
			>
				{index + 1}
			</StyledActionPoint>
		));
	};

	return (
		<StyledCombatSection>
			<div
				style={{
					fontSize: '1.1rem',
					fontWeight: 'bold',
					color: '#8b4513',
					textAlign: 'center',
					marginBottom: '1rem'
				}}
			>
				COMBAT
			</div>

			{/* Action Points */}
			<div style={{ textAlign: 'center', marginBottom: '1rem' }}>
				<div
					style={{
						fontSize: '0.9rem',
						fontWeight: 'bold',
						color: '#8b4513',
						marginBottom: '0.5rem'
					}}
				>
					ACTION POINTS
				</div>
				<StyledActionPoints>{renderActionPoints()}</StyledActionPoints>
			</div>

			{/* Combat Stats */}
			<div style={{ fontSize: '0.9rem', color: '#8b4513' }}>
				<div
					style={{
						display: 'flex',
						justifyContent: 'space-between',
						alignItems: 'center',
						padding: '0.3rem',
						borderBottom: '1px solid #e5e5e5'
					}}
				>
					<div style={{ display: 'flex', alignItems: 'center', gap: '0.3rem' }}>
						<span>ATTACK / SPELL CHECK</span>
						<span
							style={{
								display: 'inline-flex',
								alignItems: 'center',
								justifyContent: 'center',
								width: '14px',
								height: '14px',
								borderRadius: '50%',
								backgroundColor: '#8b4513',
								color: 'white',
								fontSize: '10px',
								fontWeight: 'bold',
								cursor: 'help',
								verticalAlign: 'middle'
							}}
							title={`Combat Mastery (${characterData.finalCombatMastery}) + ${characterData.finalPrimeModifierAttribute} Modifier (${characterData.finalPrimeModifierValue}) = +${characterData.finalCombatMastery + characterData.finalPrimeModifierValue}`}
						>
							i
						</span>
					</div>
					<span style={{ fontWeight: 'bold' }}>
						+{characterData.finalCombatMastery + characterData.finalPrimeModifierValue}
					</span>
				</div>
				<div
					style={{
						display: 'flex',
						justifyContent: 'space-between',
						alignItems: 'center',
						padding: '0.3rem',
						borderBottom: '1px solid #e5e5e5'
					}}
				>
					<div style={{ display: 'flex', alignItems: 'center', gap: '0.3rem' }}>
						<span>SAVE DC</span>
						<span
							style={{
								display: 'inline-flex',
								alignItems: 'center',
								justifyContent: 'center',
								width: '14px',
								height: '14px',
								borderRadius: '50%',
								backgroundColor: '#8b4513',
								color: 'white',
								fontSize: '10px',
								fontWeight: 'bold',
								cursor: 'help',
								verticalAlign: 'middle'
							}}
							title={`10 + Combat Mastery (${characterData.finalCombatMastery}) + ${characterData.finalPrimeModifierAttribute} Modifier (${characterData.finalPrimeModifierValue}) = ${characterData.finalSaveDC}`}
						>
							i
						</span>
					</div>
					<span style={{ fontWeight: 'bold' }}>{characterData.finalSaveDC}</span>
				</div>
				<div
					style={{
						display: 'flex',
						justifyContent: 'space-between',
						alignItems: 'center',
						padding: '0.3rem'
					}}
				>
					<div style={{ display: 'flex', alignItems: 'center', gap: '0.3rem' }}>
						<span>MARTIAL CHECK</span>
						<span
							style={{
								display: 'inline-flex',
								alignItems: 'center',
								justifyContent: 'center',
								width: '14px',
								height: '14px',
								borderRadius: '50%',
								backgroundColor: '#8b4513',
								color: 'white',
								fontSize: '10px',
								fontWeight: 'bold',
								cursor: 'help',
								verticalAlign: 'middle'
							}}
							title={`Attack/Spell Check (${characterData.finalCombatMastery + characterData.finalPrimeModifierValue}) + Action Points Bonus (${Math.floor(currentValues.actionPointsUsed / 3)}) = +${characterData.finalCombatMastery + characterData.finalPrimeModifierValue + Math.floor(currentValues.actionPointsUsed / 3)}`}
						>
							i
						</span>
					</div>
					<span style={{ fontWeight: 'bold' }}>
						+
						{characterData.finalCombatMastery +
							characterData.finalPrimeModifierValue +
							Math.floor(currentValues.actionPointsUsed / 3)}
					</span>
				</div>
			</div>
		</StyledCombatSection>
	);
};

export default Combat;
````

## File: src/routes/character-sheet/components/Currency.tsx
````typescript
import React from 'react';
import {
	CurrencyContainer,
	CurrencyTitle,
	CurrencyRow,
	CurrencyIconContainer,
	CurrencyIcon,
	CurrencyLabel,
	CurrencyInput
} from '../styles/Currency';

interface CurrencyProps {
	currentValues: {
		platinumPieces: number;
		goldPieces: number;
		electrumPieces: number;
		silverPieces: number;
		copperPieces: number;
	};
	onCurrencyChange: (currency: string, value: number) => void;
}

const Currency: React.FC<CurrencyProps> = ({ currentValues, onCurrencyChange }) => {
	const handleInputChange = (currency: string, value: string) => {
		onCurrencyChange(currency, parseInt(value) || 0);
	};

	const currencyTypes = [
		{
			key: 'platinumPieces',
			label: 'Platinum',
			color: '#e5e4e2',
			borderColor: '#d3d3d3',
			value: currentValues.platinumPieces
		},
		{
			key: 'goldPieces',
			label: 'Gold',
			color: '#ffd700',
			borderColor: '#b8860b',
			value: currentValues.goldPieces
		},
		{
			key: 'electrumPieces',
			label: 'Electrum',
			color: '#daa520',
			borderColor: '#b8860b',
			value: currentValues.electrumPieces
		},
		{
			key: 'silverPieces',
			label: 'Silver',
			color: '#c0c0c0',
			borderColor: '#a0a0a0',
			value: currentValues.silverPieces
		},
		{
			key: 'copperPieces',
			label: 'Copper',
			color: '#b87333',
			borderColor: '#8b4513',
			value: currentValues.copperPieces
		}
	];

	return (
		<CurrencyContainer>
			<CurrencyTitle>CURRENCY</CurrencyTitle>

			{currencyTypes.map(({ key, label, color, borderColor, value }) => (
				<CurrencyRow key={key}>
					<CurrencyIconContainer>
						<CurrencyIcon color={color} borderColor={borderColor} />
						<CurrencyLabel>{label}</CurrencyLabel>
					</CurrencyIconContainer>
					<CurrencyInput
						type="number"
						min="0"
						value={value}
						onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
							handleInputChange(key, e.target.value)
						}
					/>
				</CurrencyRow>
			))}
		</CurrencyContainer>
	);
};

export default Currency;
````

## File: src/routes/character-sheet/components/DeathExhaustion.tsx
````typescript
import React from 'react';
import type { CharacterSheetData, CurrentValues } from '../../../types';
import {
	StyledDeathExhaustionContainer,
	StyledExhaustionOnlyContainer,
	StyledExhaustionOnlyTitle
} from '../styles/DeathExhaustion.styles';

import {
	StyledDeathContainer,
	StyledDeathTitle,
	StyledHealthStatus,
	StyledDeathThreshold,
	StyledDeathStepsContainer,
	StyledDeathStepsTitle,
	StyledDeathStepsGrid,
	StyledDeathStep,
	StyledDeathStepTooltip,
	StyledHealthStatusTooltip
} from '../styles/Death';

import {
	StyledExhaustionContainer,
	StyledExhaustionLevel,
	StyledExhaustionTooltip
} from '../styles/Exhaustion';

import {
	getHealthStatus,
	calculateDeathThreshold,
	getDeathSteps
} from '../../../lib/rulesdata/death';

interface DeathExhaustionProps {
	characterData: CharacterSheetData;
	currentValues: CurrentValues;
	onExhaustionChange: (level: number) => void;
	onDeathStepChange: (step: number) => void;
}

const DeathExhaustion: React.FC<DeathExhaustionProps> = ({
	characterData,
	currentValues,
	onExhaustionChange,
	onDeathStepChange
}) => {
	// Exhaustion level descriptions (based on DC20 rules)
	const exhaustionLevels = [
		{ level: 1, description: 'Fatigued: -1 to all Checks and Saves' },
		{ level: 2, description: 'Exhausted: -2 to all Checks and Saves' },
		{ level: 3, description: 'Debilitated: -3 to all Checks and Saves, Speed halved' },
		{ level: 4, description: 'Incapacitated: -4 to all Checks and Saves, Speed quartered' },
		{ level: 5, description: 'Unconscious: Helpless, cannot take actions' }
	];

	return (
		<StyledDeathExhaustionContainer>
			<StyledDeathContainer>
				<StyledDeathTitle>DEATH & HEALTH STATUS</StyledDeathTitle>

				{/* Health Status */}
				{(() => {
					const deathThreshold = calculateDeathThreshold(
						characterData.finalPrimeModifierValue,
						characterData.finalCombatMastery
					);
					const healthStatus = getHealthStatus(
						currentValues.currentHP,
						characterData.finalHPMax,
						deathThreshold
					);
					const deathSteps = getDeathSteps(currentValues.currentHP, deathThreshold);

					return (
						<>
							<StyledHealthStatusTooltip data-tooltip={healthStatus.effects.join('\n')}>
								<StyledHealthStatus status={healthStatus.status}>
									{healthStatus.description.toUpperCase()}
								</StyledHealthStatus>
							</StyledHealthStatusTooltip>

							<div style={{ fontSize: '0.8rem', color: '#8b4513', marginBottom: '0.3rem' }}>
								DEATH THRESHOLD
							</div>
							<StyledDeathThreshold>{deathThreshold}</StyledDeathThreshold>

							{/* Death Steps - only show when on Death's Door */}
							{healthStatus.status === 'deaths-door' && (
								<StyledDeathStepsContainer>
									<StyledDeathStepsTitle>
										DEATH STEPS ({deathSteps.currentStep}/{deathSteps.maxSteps})
									</StyledDeathStepsTitle>
									<StyledDeathStepsGrid>
										{Array.from({ length: deathSteps.maxSteps }, (_, index) => {
											const step = index + 1;
											const isFilled = step <= deathSteps.currentStep;
											const isDead = deathSteps.isDead && step === deathSteps.maxSteps;

											return (
												<StyledDeathStep
													key={step}
													filled={isFilled}
													isDead={isDead}
													onClick={() => onDeathStepChange(step)}
												>
													{!isDead && step}
													<StyledDeathStepTooltip>
														{isDead ? 'Dead' : `${step} HP below 0`}
													</StyledDeathStepTooltip>
												</StyledDeathStep>
											);
										})}
									</StyledDeathStepsGrid>
								</StyledDeathStepsContainer>
							)}
						</>
					);
				})()}
			</StyledDeathContainer>

			<StyledExhaustionOnlyContainer>
				<StyledExhaustionOnlyTitle>EXHAUSTION</StyledExhaustionOnlyTitle>
				<StyledExhaustionContainer>
					{exhaustionLevels.map(({ level, description }) => (
						<StyledExhaustionLevel
							key={level}
							filled={level <= currentValues.exhaustionLevel}
							onClick={() => onExhaustionChange(level)}
						>
							{level}
							<StyledExhaustionTooltip>{description}</StyledExhaustionTooltip>
						</StyledExhaustionLevel>
					))}
				</StyledExhaustionContainer>
			</StyledExhaustionOnlyContainer>
		</StyledDeathExhaustionContainer>
	);
};

export default DeathExhaustion;
````

## File: src/routes/character-sheet/components/PlayerNotes.tsx
````typescript
import React, { useState } from 'react';
import EditIcon from '@mui/icons-material/Edit';
import {
	StyledPlayerNotesContainer,
	StyledPlayerNotesTitle,
	StyledNotesContent,
	StyledNotesList,
	StyledNoteItem,
	StyledNoteText,
	StyledNoteActions,
	StyledDeleteButton,
	StyledEditButton,
	StyledAddNoteSection,
	StyledNoteInput,
	StyledAddButton,
	StyledCancelButton,
	StyledSaveButton,
	StyledEmptyNotesMessage
} from '../styles/PlayerNotes.styles';

interface PlayerNote {
	id: string;
	text: string;
	createdAt: Date;
}

interface PlayerNotesProps {
	characterId: string;
}

const PlayerNotes: React.FC<PlayerNotesProps> = ({ characterId }) => {
	const [notes, setNotes] = useState<PlayerNote[]>(() => {
		const savedNotes = localStorage.getItem(`playerNotes_${characterId}`);
		return savedNotes ? JSON.parse(savedNotes) : [];
	});

	const [newNoteText, setNewNoteText] = useState('');
	const [isAddingNote, setIsAddingNote] = useState(false);
	const [editingNoteId, setEditingNoteId] = useState<string | null>(null);
	const [editingText, setEditingText] = useState('');

	const saveNotesToStorage = (updatedNotes: PlayerNote[]) => {
		localStorage.setItem(`playerNotes_${characterId}`, JSON.stringify(updatedNotes));
		setNotes(updatedNotes);
	};

	const handleAddNote = () => {
		if (newNoteText.trim()) {
			const newNote: PlayerNote = {
				id: Date.now().toString(),
				text: newNoteText.trim(),
				createdAt: new Date()
			};
			const updatedNotes = [...notes, newNote];
			saveNotesToStorage(updatedNotes);
			setNewNoteText('');
			setIsAddingNote(false);
		}
	};

	const handleDeleteNote = (noteId: string) => {
		const updatedNotes = notes.filter((note) => note.id !== noteId);
		saveNotesToStorage(updatedNotes);
	};

	const handleStartEdit = (note: PlayerNote) => {
		setEditingNoteId(note.id);
		setEditingText(note.text);
	};

	const handleSaveEdit = () => {
		if (editingText.trim() && editingNoteId) {
			const updatedNotes = notes.map((note) =>
				note.id === editingNoteId ? { ...note, text: editingText.trim() } : note
			);
			saveNotesToStorage(updatedNotes);
			setEditingNoteId(null);
			setEditingText('');
		}
	};

	const handleCancelEdit = () => {
		setEditingNoteId(null);
		setEditingText('');
	};

	const handleCancelAdd = () => {
		setIsAddingNote(false);
		setNewNoteText('');
	};

	return (
		<StyledPlayerNotesContainer>
			<StyledPlayerNotesTitle>Player Notes</StyledPlayerNotesTitle>

			<StyledNotesContent>
				{notes.length === 0 && !isAddingNote && (
					<StyledEmptyNotesMessage>
						No notes yet. Click "Add Note" to create your first note.
					</StyledEmptyNotesMessage>
				)}

				<StyledNotesList>
					{notes.map((note) => (
						<StyledNoteItem key={note.id}>
							{editingNoteId === note.id ? (
								<>
									<StyledNoteInput
										value={editingText}
										onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) =>
											setEditingText(e.target.value)
										}
										onKeyDown={(e: React.KeyboardEvent<HTMLTextAreaElement>) => {
											if (e.key === 'Enter' && !e.shiftKey) {
												e.preventDefault();
												handleSaveEdit();
											} else if (e.key === 'Escape') {
												handleCancelEdit();
											}
										}}
										placeholder="Enter your note..."
										autoFocus
									/>
									<StyledNoteActions>
										<StyledSaveButton onClick={handleSaveEdit}>Save</StyledSaveButton>
										<StyledCancelButton onClick={handleCancelEdit}>Cancel</StyledCancelButton>
									</StyledNoteActions>
								</>
							) : (
								<>
									<StyledNoteText>• {note.text}</StyledNoteText>
									<StyledNoteActions>
										<StyledEditButton onClick={() => handleStartEdit(note)} title="Edit note">
											<EditIcon fontSize="small" />
										</StyledEditButton>
										<StyledDeleteButton
											onClick={() => handleDeleteNote(note.id)}
											title="Delete note"
										>
											×
										</StyledDeleteButton>
									</StyledNoteActions>
								</>
							)}
						</StyledNoteItem>
					))}
				</StyledNotesList>

				<StyledAddNoteSection>
					{isAddingNote ? (
						<>
							<StyledNoteInput
								value={newNoteText}
								onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) =>
									setNewNoteText(e.target.value)
								}
								onKeyDown={(e: React.KeyboardEvent<HTMLTextAreaElement>) => {
									if (e.key === 'Enter' && !e.shiftKey) {
										e.preventDefault();
										handleAddNote();
									} else if (e.key === 'Escape') {
										handleCancelAdd();
									}
								}}
								placeholder="Enter your note..."
								autoFocus
							/>
							<StyledNoteActions>
								<StyledAddButton onClick={handleAddNote}>Add Note</StyledAddButton>
								<StyledCancelButton onClick={handleCancelAdd}>Cancel</StyledCancelButton>
							</StyledNoteActions>
						</>
					) : (
						<StyledAddButton onClick={() => setIsAddingNote(true)}>+ Add Note</StyledAddButton>
					)}
				</StyledAddNoteSection>
			</StyledNotesContent>
		</StyledPlayerNotesContainer>
	);
};

export default PlayerNotes;
````

## File: src/routes/character-sheet/components/StatTooltips.tsx
````typescript
import React from 'react';
import type { CharacterSheetData } from '../../../types';

interface StatBreakdown {
  base: number;
  classBonus?: number;
  ancestryBonus?: number;
  otherBonuses?: Array<{name: string, value: number}>;
  total: number;
}

const formatBreakdown = (breakdown: StatBreakdown): React.ReactNode => {
  const lines: string[] = [];
  
  lines.push(`${breakdown.total}`);
  lines.push('');
  lines.push(`├─ Base: ${breakdown.base}`);
  
  if (breakdown.classBonus && breakdown.classBonus !== 0) {
    lines.push(`├─ Class: ${breakdown.classBonus > 0 ? '+' : ''}${breakdown.classBonus}`);
  }
  
  if (breakdown.ancestryBonus && breakdown.ancestryBonus !== 0) {
    lines.push(`├─ Ancestry: ${breakdown.ancestryBonus > 0 ? '+' : ''}${breakdown.ancestryBonus}`);
  }
  
  if (breakdown.otherBonuses && breakdown.otherBonuses.length > 0) {
    breakdown.otherBonuses.forEach((bonus, index) => {
      const isLast = index === breakdown.otherBonuses!.length - 1 && !breakdown.ancestryBonus && !breakdown.classBonus;
      const prefix = isLast ? '└─' : '├─';
      lines.push(`${prefix} ${bonus.name}: ${bonus.value > 0 ? '+' : ''}${bonus.value}`);
    });
  }
  
  return lines.join('\n');
};

export const createSpeedTooltip = (characterData: CharacterSheetData): React.ReactNode => {
  // Calculate breakdown - this is simplified since we don't have detailed source tracking yet
  const breakdown: StatBreakdown = {
    base: 5, // Default base speed
    classBonus: characterData.finalMoveSpeed - 5, // Assume difference is from class for now
    total: characterData.finalMoveSpeed
  };
  
  return (
    <div>
      <strong>Movement Speed</strong>
      <pre style={{ 
        margin: '8px 0 0 0', 
        fontFamily: 'monospace', 
        fontSize: '0.75rem',
        lineHeight: '1.2'
      }}>
        {formatBreakdown(breakdown)}
      </pre>
    </div>
  );
};

export const createJumpTooltip = (characterData: CharacterSheetData): React.ReactNode => {
  const breakdown: StatBreakdown = {
    base: characterData.finalAgility || 0, // Jump = Agility + modifiers
    total: characterData.finalJumpDistance
  };
  
  if (characterData.finalJumpDistance !== breakdown.base) {
    breakdown.otherBonuses = [{
      name: 'Other',
      value: characterData.finalJumpDistance - breakdown.base
    }];
  }
  
  return (
    <div>
      <strong>Jump Distance</strong>
      <pre style={{ 
        margin: '8px 0 0 0', 
        fontFamily: 'monospace', 
        fontSize: '0.75rem',
        lineHeight: '1.2'
      }}>
        {formatBreakdown(breakdown)}
      </pre>
    </div>
  );
};

export const createHPTooltip = (characterData: CharacterSheetData): React.ReactNode => {
  const mightBonus = characterData.finalMight || 0;
  const breakdown: StatBreakdown = {
    base: mightBonus,
    classBonus: characterData.finalHPMax - mightBonus, // Assume difference is from class/other
    total: characterData.finalHPMax
  };
  
  return (
    <div>
      <strong>Hit Points</strong>
      <pre style={{ 
        margin: '8px 0 0 0', 
        fontFamily: 'monospace', 
        fontSize: '0.75rem',
        lineHeight: '1.2'
      }}>
        {formatBreakdown(breakdown)}
      </pre>
    </div>
  );
};

export const createMPTooltip = (characterData: CharacterSheetData): React.ReactNode => {
  const breakdown: StatBreakdown = {
    base: 0, // Base MP is usually 0
    classBonus: characterData.finalMPMax,
    total: characterData.finalMPMax
  };
  
  return (
    <div>
      <strong>Mana Points</strong>
      <pre style={{ 
        margin: '8px 0 0 0', 
        fontFamily: 'monospace', 
        fontSize: '0.75rem',
        lineHeight: '1.2'
      }}>
        {formatBreakdown(breakdown)}
      </pre>
    </div>
  );
};

export const createSPTooltip = (characterData: CharacterSheetData): React.ReactNode => {
  const breakdown: StatBreakdown = {
    base: 0, // Base SP is usually 0
    classBonus: characterData.finalSPMax,
    total: characterData.finalSPMax
  };
  
  return (
    <div>
      <strong>Stamina Points</strong>
      <pre style={{ 
        margin: '8px 0 0 0', 
        fontFamily: 'monospace', 
        fontSize: '0.75rem',
        lineHeight: '1.2'
      }}>
        {formatBreakdown(breakdown)}
      </pre>
    </div>
  );
};
````

## File: src/routes/character-sheet/styles/AttributesSections.styles.ts
````typescript
import styled from 'styled-components';

export const StyledAttributesSectionsContainer = styled.div`
	/* This is the container for all the remaining inline styled sections */
`;

export const StyledPrimeSection = styled.div`
	margin-bottom: 1rem;
`;

export const StyledPrimeBox = styled.div`
	text-align: center;
	padding: 0.5rem;
	border: 2px solid #8b4513;
	border-radius: 8px;
	background: #f5f5dc;
	margin-bottom: 0.5rem;
`;

export const StyledPrimeLabel = styled.div`
	color: #8b4513;
	font-weight: bold;
`;

export const StyledPrimeValue = styled.div`
	font-size: 1.4rem;
	font-weight: bold;
	color: #8b4513;
`;

export const StyledSkillRow = styled.div`
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 0.3rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	background: white;
	margin-bottom: 0.3rem;
`;

export const StyledSkillName = styled.span`
	font-size: 0.9rem;
	color: #8b4513;
`;

export const StyledAttributeSection = styled.div`
	margin-bottom: 1rem;
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
`;

export const StyledAttributeHeader = styled.div`
	display: flex;
	align-items: center;
	margin-bottom: 0.5rem;
`;

export const StyledAttributeBox = styled.div`
	width: 60px;
	height: 60px;
	border: 2px solid #8b4513;
	border-radius: 8px;
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	background: #f5f5dc;
	margin-right: 1rem;
`;

export const StyledAttributeAbbr = styled.div`
	font-size: 0.8rem;
	font-weight: bold;
	color: #8b4513;
`;

export const StyledAttributeValue = styled.div`
	font-size: 1.4rem;
	font-weight: bold;
	color: #8b4513;
`;

export const StyledAttributeInfo = styled.div`
	flex: 1;
`;

export const StyledAttributeName = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.2rem;
`;

export const StyledAttributeSave = styled.div`
	font-size: 0.9rem;
	color: #8b4513;
`;

export const StyledAttributeSkillRow = styled.div`
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 0.3rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	background: #f9f9f9;
	margin-bottom: 0.3rem;
`;

export const StyledKnowledgeTradesSection = styled.div`
	margin-bottom: 1rem;
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
`;

export const StyledSectionTitle = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.5rem;
	text-align: center;
`;

export const StyledSectionSubtitle = styled.div`
	font-size: 0.8rem;
	color: #8b4513;
	margin-bottom: 0.5rem;
	text-align: center;
`;

export const StyledLanguageRow = styled.div`
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 0.3rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	background: #f9f9f9;
	margin-bottom: 0.3rem;
`;

export const StyledLanguageName = styled.span`
	font-size: 0.9rem;
	color: #8b4513;
`;

export const StyledFluencyControls = styled.div`
	display: flex;
	gap: 0.2rem;
`;

export const StyledFluencyBox = styled.div<{ active: boolean }>`
	width: 15px;
	height: 15px;
	border: 1px solid #8b4513;
	background: ${(props) => (props.active ? '#8b4513' : 'white')};
	border-radius: 2px;
`;

export const StyledFluencyLabel = styled.span`
	font-size: 0.8rem;
	color: #8b4513;
	margin-left: ${(props) => (props.children === 'FLUENT' ? '0.5rem' : '0')};
`;

export const StyledNoItemsMessage = styled.div`
	font-size: 0.9rem;
	color: #8b4513;
	text-align: center;
	font-style: italic;
	padding: 1rem;
`;
````

## File: src/routes/character-sheet/styles/Currency.ts
````typescript
import styled from 'styled-components';

export const CurrencyContainer = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
`;

export const CurrencyTitle = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 1rem;
	text-align: center;
`;

export const CurrencyRow = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 0.5rem;

	&:last-child {
		margin-bottom: 0;
	}
`;

export const CurrencyIconContainer = styled.div`
	display: flex;
	align-items: center;
	gap: 0.3rem;
`;

export const CurrencyIcon = styled.div<{ color: string; borderColor: string }>`
	width: 16px;
	height: 16px;
	border-radius: 50%;
	background: ${(props) => props.color};
	border: 1px solid ${(props) => props.borderColor};
`;

export const CurrencyLabel = styled.span`
	font-size: 0.9rem;
	color: #8b4513;
	font-weight: bold;
`;

export const CurrencyInput = styled.input`
	width: 60px;
	padding: 0.2rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	text-align: center;
	font-size: 0.8rem;
	background-color: white;

	&:focus {
		outline: none;
		border-color: #6d3410;
		box-shadow: 0 0 0 2px rgba(139, 69, 19, 0.2);
	}
`;
````

## File: src/routes/character-sheet/styles/Death.ts
````typescript
import styled from 'styled-components';

export const StyledDeathContainer = styled.div`
	flex: 1;
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
	text-align: center;
`;

export const StyledDeathTitle = styled.div`
	font-size: 0.9rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.5rem;
`;

export const StyledHealthStatus = styled.div<{
	status: 'healthy' | 'bloodied' | 'well-bloodied' | 'deaths-door' | 'dead';
}>`
	font-size: 0.8rem;
	font-weight: bold;
	margin-bottom: 0.3rem;
	padding: 0.2rem 0.4rem;
	border-radius: 4px;
	color: ${(props) => {
		switch (props.status) {
			case 'healthy':
				return '#22c55e';
			case 'bloodied':
				return '#f59e0b';
			case 'well-bloodied':
				return '#f97316';
			case 'deaths-door':
				return '#dc2626';
			case 'dead':
				return '#7f1d1d';
			default:
				return '#8b4513';
		}
	}};
	background: ${(props) => {
		switch (props.status) {
			case 'healthy':
				return '#dcfce7';
			case 'bloodied':
				return '#fef3c7';
			case 'well-bloodied':
				return '#fed7aa';
			case 'deaths-door':
				return '#fecaca';
			case 'dead':
				return '#fca5a5';
			default:
				return 'transparent';
		}
	}};
`;

export const StyledDeathThreshold = styled.div`
	font-size: 1.5rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.5rem;
`;

export const StyledDeathStepsContainer = styled.div`
	margin-top: 0.5rem;
`;

export const StyledDeathStepsTitle = styled.div`
	font-size: 0.8rem;
	font-weight: bold;
	color: #dc2626;
	margin-bottom: 0.3rem;
`;

export const StyledDeathStepsGrid = styled.div`
	display: flex;
	justify-content: center;
	gap: 0.2rem;
	flex-wrap: wrap;
`;

export const StyledDeathStep = styled.div<{ filled: boolean; isDead: boolean }>`
	position: relative;
	width: 20px;
	height: 20px;
	border: 2px solid ${(props) => (props.isDead ? '#7f1d1d' : '#dc2626')};
	background: ${(props) => {
		if (props.isDead) return '#7f1d1d';
		return props.filled ? '#dc2626' : 'white';
	}};
	color: ${(props) => {
		if (props.isDead) return 'white';
		return props.filled ? 'white' : '#dc2626';
	}};
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 0.7rem;
	font-weight: bold;
	cursor: pointer;
	border-radius: 3px;
	transition: all 0.2s ease;

	&:hover {
		background: ${(props) => {
			if (props.isDead) return '#991b1b';
			return props.filled ? '#b91c1c' : '#fecaca';
		}};
		transform: scale(1.1);
	}

	${(props) =>
		props.isDead &&
		`
    &::after {
      content: '☠';
      font-size: 0.8rem;
    }
  `}
`;

export const StyledDeathStepTooltip = styled.div`
	position: absolute;
	bottom: 100%;
	left: 50%;
	transform: translateX(-50%);
	background: #333;
	color: white;
	padding: 0.3rem 0.5rem;
	border-radius: 4px;
	font-size: 0.7rem;
	white-space: nowrap;
	z-index: 1000;
	margin-bottom: 5px;
	box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
	opacity: 0;
	visibility: hidden;
	transition:
		opacity 0.2s ease,
		visibility 0.2s ease;

	&::after {
		content: '';
		position: absolute;
		top: 100%;
		left: 50%;
		transform: translateX(-50%);
		border: 5px solid transparent;
		border-top-color: #333;
	}

	${StyledDeathStep}:hover & {
		opacity: 1;
		visibility: visible;
	}
`;

export const StyledHealthStatusTooltip = styled.div`
	position: relative;
	cursor: help;

	&::after {
		content: attr(data-tooltip);
		position: absolute;
		bottom: 100%;
		left: 50%;
		transform: translateX(-50%);
		background: #333;
		color: white;
		padding: 0.5rem;
		border-radius: 4px;
		font-size: 0.7rem;
		white-space: pre-line;
		z-index: 1000;
		margin-bottom: 5px;
		box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
		opacity: 0;
		visibility: hidden;
		transition:
			opacity 0.2s ease,
			visibility 0.2s ease;
		max-width: 200px;
		text-align: left;
	}

	&:hover::after {
		opacity: 1;
		visibility: visible;
	}
`;
````

## File: src/routes/character-sheet/styles/DeathExhaustion.styles.ts
````typescript
import styled from 'styled-components';

export const StyledDeathExhaustionContainer = styled.div`
	display: flex;
	gap: 1rem;
	margin-bottom: 1.5rem;
`;

export const StyledExhaustionOnlyContainer = styled.div`
	flex: 1;
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
	text-align: center;
`;

export const StyledExhaustionOnlyTitle = styled.div`
	font-size: 0.9rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.5rem;
`;
````

## File: src/routes/character-sheet/styles/Exhaustion.ts
````typescript
import styled from 'styled-components';

export const StyledExhaustionContainer = styled.div`
	display: flex;
	justify-content: center;
	gap: 0.3rem;
	margin-top: 0.5rem;
`;

export const StyledExhaustionLevel = styled.div<{ filled: boolean }>`
	position: relative;
	width: 24px;
	height: 24px;
	border: 2px solid #8b4513;
	background: ${(props) => (props.filled ? '#8b4513' : 'white')};
	color: ${(props) => (props.filled ? 'white' : '#8b4513')};
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 0.8rem;
	font-weight: bold;
	cursor: pointer;
	border-radius: 3px;
	transition: all 0.2s ease;

	&:hover {
		background: ${(props) => (props.filled ? '#654321' : '#f5f5dc')};
		transform: scale(1.1);
	}
`;

export const StyledExhaustionTooltip = styled.div`
	position: absolute;
	bottom: 100%;
	left: 50%;
	transform: translateX(-50%);
	background: #333;
	color: white;
	padding: 0.5rem 0.75rem;
	border-radius: 4px;
	font-size: 0.8rem;
	white-space: nowrap;
	z-index: 1000;
	margin-bottom: 5px;
	box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
	opacity: 0;
	visibility: hidden;
	transition:
		opacity 0.2s ease,
		visibility 0.2s ease;

	&::after {
		content: '';
		position: absolute;
		top: 100%;
		left: 50%;
		transform: translateX(-50%);
		border: 5px solid transparent;
		border-top-color: #333;
	}

	${StyledExhaustionLevel}:hover & {
		opacity: 1;
		visibility: visible;
	}
`;
````

## File: src/routes/character-sheet/styles/FeaturePopup.ts
````typescript
import styled from 'styled-components';

export const StyledFeaturePopupOverlay = styled.div`
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background: rgba(0, 0, 0, 0.5);
	display: flex;
	align-items: center;
	justify-content: center;
	z-index: 1000;
`;

export const StyledFeaturePopupContent = styled.div`
	background: white;
	border: 3px solid #8b4513;
	border-radius: 12px;
	padding: 2rem;
	max-width: 600px;
	max-height: 80vh;
	overflow-y: auto;
	margin: 1rem;
	box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
`;

export const StyledFeaturePopupHeader = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 1.5rem;
	border-bottom: 2px solid #8b4513;
	padding-bottom: 1rem;
`;

export const StyledFeaturePopupTitle = styled.h2`
	margin: 0;
	color: #8b4513;
	font-size: 1.5rem;
	font-weight: bold;
`;

export const StyledFeaturePopupClose = styled.button`
	background: #8b4513;
	color: white;
	border: none;
	border-radius: 50%;
	width: 30px;
	height: 30px;
	cursor: pointer;
	font-size: 1.2rem;
	display: flex;
	align-items: center;
	justify-content: center;

	&:hover {
		background: #654321;
	}
`;

export const StyledFeaturePopupDescription = styled.div`
	color: #333;
	line-height: 1.6;
	font-size: 1rem;
`;

export const StyledFeaturePopupSourceInfo = styled.div`
	margin-top: 1rem;
	padding-top: 1rem;
	border-top: 1px solid #e5e5e5;
	font-size: 0.9rem;
	color: #666;
	font-style: italic;
`;
````

## File: src/routes/character-sheet/styles/Features.ts
````typescript
import styled from 'styled-components';

export const StyledFeatureGrid = styled.div`
	display: flex;
	flex-direction: column;
	gap: 0.3rem;
	margin-bottom: 1rem;
`;

export const StyledFeatureItem = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0.4rem 0.5rem;
	border: 1px solid #e5e5e5;
	border-radius: 4px;
	background: #f9f9f9;
	min-height: 36px;
`;

export const StyledFeatureName = styled.span`
	font-size: 0.9rem;
	color: #8b4513;
	font-weight: 500;
	flex: 1;
	line-height: 1.2;
	margin-right: 0.5rem;
`;

export const StyledFeatureReadMore = styled.button`
	background: #8b4513;
	color: white;
	border: none;
	border-radius: 3px;
	padding: 0.2rem 0.4rem;
	font-size: 0.75rem;
	cursor: pointer;
	margin-left: 0.5rem;
	white-space: nowrap;
	flex-shrink: 0;

	&:hover {
		background: #654321;
	}
`;

export const StyledFeatureCategory = styled.div`
	margin-bottom: 1rem;
`;

export const StyledFeatureCategoryTitle = styled.h4`
	margin: 0 0 0.5rem 0;
	color: #8b4513;
	font-size: 1rem;
	font-weight: bold;
	border-bottom: 1px solid #8b4513;
	padding-bottom: 0.2rem;
`;
````

## File: src/routes/character-sheet/styles/Info.ts
````typescript
import styled from 'styled-components';

export const StyledInfoSection = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: rgba(245, 243, 240, 0.5);
`;

export const StyledSectionTitle = styled.h3`
	font-size: 0.9rem;
	font-weight: bold;
	text-transform: uppercase;
	color: #8b4513;
	margin: 0 0 0.8rem 0;
	text-align: center;
	border-bottom: 1px solid #8b4513;
	padding-bottom: 0.3rem;
`;

export const StyledStatRow = styled.div`
	display: flex;
	justify-content: space-between;
	margin-bottom: 0.4rem;
	font-size: 0.8rem;
`;

export const StyledStatLabel = styled.span`
	color: #666;
`;

export const StyledStatValue = styled.span`
	font-weight: bold;
	color: #2d2d2d;
`;
````

## File: src/routes/character-sheet/styles/KnowledgeTrades.ts
````typescript
import styled from 'styled-components';

export const KnowledgeTradesSection = styled.div`
	margin-bottom: 1rem;
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
`;

export const SectionTitle = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.5rem;
	text-align: center;
`;

export const SectionDescription = styled.div`
	font-size: 0.8rem;
	color: #8b4513;
	margin-bottom: 0.5rem;
	text-align: center;
`;

export const EmptyMessage = styled.div`
	font-size: 0.9rem;
	color: #8b4513;
	text-align: center;
	font-style: italic;
	padding: 1rem;
`;
````

## File: src/routes/character-sheet/styles/Movement.styles.ts
````typescript
import styled from 'styled-components';

export const StyledMovementContainer = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
	margin-bottom: 1rem;
`;

export const StyledMovementGrid = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 1rem;
`;

export const StyledMovementStat = styled.div`
	text-align: center;
`;

export const StyledMovementLabel = styled.div`
	font-size: 0.8rem;
	font-weight: bold;
	color: #8b4513;
`;

export const StyledMovementValue = styled.div`
	font-size: 1.5rem;
	font-weight: bold;
	color: #8b4513;
`;
````

## File: src/routes/character-sheet/styles/Movement.ts
````typescript
import styled from 'styled-components';

export const MovementContainer = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
	margin-bottom: 1rem;
`;

export const MovementStats = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 1rem;
`;

export const MovementStat = styled.div`
	text-align: center;
`;

export const StatLabel = styled.div`
	font-size: 0.8rem;
	font-weight: bold;
	color: #8b4513;
`;

export const StatValue = styled.div`
	font-size: 1.5rem;
	font-weight: bold;
	color: #8b4513;
`;
````

## File: src/routes/character-sheet/styles/PlayerNotes.styles.ts
````typescript
import styled from 'styled-components';

export const StyledPlayerNotesContainer = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
	margin-bottom: 1rem;
`;

export const StyledPlayerNotesTitle = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	text-align: center;
	margin-bottom: 1rem;
`;

export const StyledNotesContent = styled.div`
	display: flex;
	flex-direction: column;
	gap: 0.75rem;
`;

export const StyledNotesList = styled.div`
	display: flex;
	flex-direction: column;
	gap: 0.5rem;
`;

export const StyledNoteItem = styled.div`
	border: 1px solid #8b4513;
	border-radius: 4px;
	padding: 0.75rem;
	background: #f9f9f9;
	transition: all 0.2s ease;

	&:hover {
		background: #f5f5f5;
	}
`;

export const StyledNoteText = styled.p`
	color: #2d2d2d;
	font-size: 0.9rem;
	line-height: 1.4;
	margin: 0 0 0.5rem 0;
	word-wrap: break-word;
`;

export const StyledNoteActions = styled.div`
	display: flex;
	gap: 0.5rem;
	margin-top: 0.5rem;
`;

export const StyledNoteInput = styled.textarea`
	background: white;
	border: 1px solid #8b4513;
	border-radius: 4px;
	color: #2d2d2d;
	font-size: 0.9rem;
	padding: 0.5rem;
	width: 100%;
	min-height: 60px;
	resize: vertical;
	font-family: 'Georgia', serif;

	&:focus {
		outline: none;
		border-color: #8b4513;
		box-shadow: 0 0 0 1px #8b4513;
	}

	&::placeholder {
		color: #999;
	}
`;

export const StyledAddButton = styled.button`
	background: #8b4513;
	border: 1px solid #8b4513;
	border-radius: 4px;
	color: white;
	font-size: 0.85rem;
	font-weight: bold;
	padding: 0.5rem 0.75rem;
	cursor: pointer;
	transition: all 0.2s ease;

	&:hover {
		background-color: #6d3410;
	}

	&:active {
		transform: translateY(1px);
	}
`;

export const StyledDeleteButton = styled.button`
	width: 24px;
	height: 24px;
	border: 1px solid #dc2626;
	background-color: #fee2e2;
	color: #dc2626;
	border-radius: 4px;
	font-size: 14px;
	cursor: pointer;
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 0;
	font-weight: bold;

	&:hover {
		background-color: #fecaca;
	}

	&:active {
		transform: translateY(1px);
	}
`;

export const StyledEditButton = styled.button`
	background: #f9f9f9;
	border: 1px solid #8b4513;
	border-radius: 4px;
	color: #8b4513;
	font-size: 1rem;
	cursor: pointer;
	transition: all 0.2s ease;
	width: 24px;
	height: 24px;
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 0;

	&:hover {
		background: #8b4513;
		color: white;
	}

	&:active {
		transform: translateY(1px);
	}
`;

export const StyledSaveButton = styled.button`
	background: #f9f9f9;
	border: 1px solid #8b4513;
	border-radius: 4px;
	color: #8b4513;
	font-size: 0.85rem;
	font-weight: bold;
	padding: 0.4rem 0.6rem;
	cursor: pointer;
	transition: all 0.2s ease;

	&:hover {
		background: #8b4513;
		color: white;
	}

	&:active {
		transform: translateY(1px);
	}
`;

export const StyledCancelButton = styled.button`
	background: #f9f9f9;
	border: 1px solid #8b4513;
	border-radius: 4px;
	color: #8b4513;
	font-size: 0.85rem;
	font-weight: bold;
	padding: 0.4rem 0.6rem;
	cursor: pointer;
	transition: all 0.2s ease;

	&:hover {
		background: #8b4513;
		color: white;
	}

	&:active {
		transform: translateY(1px);
	}
`;

export const StyledAddNoteSection = styled.div`
	border-top: 1px solid #8b4513;
	padding-top: 0.75rem;
`;

export const StyledEmptyNotesMessage = styled.div`
	color: #8b4513;
	font-style: italic;
	text-align: center;
	padding: 1.5rem 1rem;
	border: 1px dashed #8b4513;
	border-radius: 4px;
	background: #f9f9f9;
	font-size: 0.9rem;
`;
````

## File: src/routes/character-sheet/styles/RightColumnResources.styles.ts
````typescript
import styled from 'styled-components';

export const StyledRightResourcesContainer = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
	margin-bottom: 1rem;
`;

export const StyledRightResourcesTitle = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	text-align: center;
	margin-bottom: 1rem;
`;

export const StyledRightResourceRow = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 0.8rem;

	&:last-child {
		margin-bottom: 0;
	}
`;

export const StyledRightResourceLabel = styled.span`
	font-size: 0.9rem;
	color: #8b4513;
`;

export const StyledRightResourceControls = styled.div`
	display: flex;
	align-items: center;
	gap: 0.3rem;
`;

export const StyledRightResourceInput = styled.input`
	width: 40px;
	text-align: center;
	border: 1px solid #8b4513;
	border-radius: 4px;
	padding: 0.2rem;
	font-size: 0.9rem;
	color: #8b4513;

	&:focus {
		outline: none;
		border-color: #654321;
		box-shadow: 0 0 0 2px rgba(139, 69, 19, 0.2);
	}
`;

export const StyledRightResourceMax = styled.span`
	font-size: 0.9rem;
	color: #8b4513;
`;
````

## File: src/routes/character-sheet/styles/Skills.ts
````typescript
import styled from 'styled-components';

export const StyledSkillsSection = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: rgba(245, 243, 240, 0.5);
	flex: 1;
`;

export const StyledSkillItem = styled.div`
	display: grid;
	grid-template-columns: auto 1fr auto;
	gap: 0.5rem;
	align-items: center;
	margin-bottom: 0.3rem;
	font-size: 0.8rem;
`;

export const StyledProficiencyDots = styled.div`
	display: flex;
	gap: 2px;
`;

export const StyledDot = styled.div<{ filled: boolean }>`
	width: 8px;
	height: 8px;
	border-radius: 50%;
	border: 1px solid #8b4513;
	background: ${(props) => (props.filled ? '#8b4513' : 'white')};
`;
````

## File: src/styles/App.styles.ts
````typescript
// Styled components for App component
import styled from 'styled-components';

export const StyledApp = styled.div`
	min-height: 100vh;
	position: relative;
	display: flex;
	flex-direction: column;
`;

export const StyledHeader = styled.header`
	position: absolute;
	top: 1rem;
	right: 1rem;
	color: #fbbf24;
	font-size: 0.9rem;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	z-index: 10;
	display: flex;
	align-items: center;
	gap: 1rem;
`;

export const StyledBackButton = styled.button`
	padding: 0.5rem 1rem;
	border: 2px solid #fbbf24;
	border-radius: 6px;
	background: transparent;
	color: #fbbf24;
	cursor: pointer;
	transition: all 0.3s ease;
	font-size: 0.9rem;
	font-weight: bold;

	&:hover {
		background: #fbbf24;
		color: #1e1b4b;
		transform: translateY(-2px);
	}
`;

export const StyledMain = styled.main`
	flex: 1;
`;

export const StyledFooter = styled.footer`
	padding: 1rem;
	text-align: center;
	color: #9ca3af;
	font-size: 0.8rem;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	border-top: 1px solid rgba(139, 92, 246, 0.3);
	background: rgba(30, 27, 75, 0.5);
`;
````

## File: CLASS_REFACTOR_PLAN.md
````markdown
# Refactoring Plan: Externalizing Class Data

**Date:** July 21, 2025

## 1. Task Prompt

Refactor the monolithic `src/lib/rulesdata/classes.ts` file to improve scalability and maintainability. The primary motivation is to support the future growth of class data, specifically the addition of complex nested data like level progression tables and expanded feature choices. The current implementation in a single file is becoming unwieldy.

## 2. Context & Problem Statement

### Current State

- All 13 class definitions are stored as exported `const` objects within a single TypeScript file: `src/lib/rulesdata/classes.ts`.
- The file is already large (~1000 lines) and contains only Level 1 data.
- As more data is added (e.g., progression tables from level 2-20, subclass features), this file will become extremely difficult to manage, navigate, and edit.
- This structure increases the risk of merge conflicts in a collaborative environment and makes it hard to focus on a single class's data without the cognitive overhead of all other classes being present.

### Proposed Solution: JSON Data with Schema Validation

The chosen solution is to externalize the class definitions from TypeScript code into individual JSON files. A validation layer using the Zod library will be introduced to ensure data integrity.

This architecture involves:

1.  **One JSON file per class:** e.g., `barbarian.json`, `sorcerer.json`.
2.  **A Zod Schema:** A single source of truth (`class.schema.ts`) that defines the valid structure of a class object.
3.  **A Data Loader:** A TypeScript module (`class.loader.ts`) responsible for importing all JSON files, validating them against the schema, and exporting them as a single, typed array for the application to consume.

### Key Benefits

- **Scalability:** Easily supports adding deep, complex data structures (like progression tables) to each class file without cluttering the global scope.
- **Maintainability:** Developers can edit a single class's data in a focused, isolated file (`barbarian.json`).
- **Data Integrity:** The Zod schema acts as a contract, preventing malformed or incomplete data from entering the application and causing runtime errors.
- **Reduced Merge Conflicts:** Team members working on different classes will be editing different files, minimizing Git conflicts.
- **Separation of Concerns:** Clearly separates the application's data (the "what") from its logic (the "how").

## 3. Detailed Implementation Plan

### Step 1: Project Setup

- **Install Zod:** Add the Zod library as a project dependency.
  ```bash
  npm install zod
  ```
- **Create Directory Structure:** Create the necessary directories to house the new files.
  ```
  /src/lib/rulesdata/
  ├── classes/
  ├── schemas/
  └── loaders/
  ```

### Step 2: Define the Validation Schema

- Create `src/lib/rulesdata/schemas/class.schema.ts`.
- Inside this file, use Zod to define a schema that precisely matches the `IClassDefinition` interface from `src/lib/rulesdata/types.ts`. This will involve creating schemas for nested objects like `level1Features` and `featureChoicesLvl1`.
- Export the main `classSchema` and a `classesDataSchema` (an array of `classSchema`).

### Step 3: Migrate Class Data to JSON

- For each of the 13 classes currently in `classes.ts`:
  1. Create a new file, e.g., `src/lib/rulesdata/classes/barbarian.json`.
  2. Copy the JavaScript object for that class from `classes.ts`.
  3. Paste it into the new `.json` file and convert it to valid JSON syntax (e.g., double quotes on all keys, remove trailing commas).

### Step 4: Create the Data Loader

- Create `src/lib/rulesdata/loaders/class.loader.ts`.
- This file will perform the following actions:
  1. Use Vite's `import.meta.glob` to dynamically and synchronously import all `*.json` files from the `../classes/` directory.
  2. Extract the data from the imported modules into a single array.
  3. Use the `classesDataSchema.parse()` method from the Zod schema to validate the entire data array.
  4. If validation is successful, export the validated data as a `const classesData: IClassDefinition[]`.
  5. If validation fails, throw a descriptive error to halt the build/runtime and alert the developer to the data inconsistency.

### Step 5: Update Application Imports

- Conduct a project-wide search for the import path `lib/rulesdata/classes`.
- In every file that uses this import, update the path to point to the new data loader: `lib/rulesdata/loaders/class.loader`.
- The variable name (`classesData`) will remain the same, so no other logic changes are required in the consuming components.

### Step 6: Cleanup

- After verifying that the application runs correctly with the new data structure, delete the now-obsolete `src/lib/rulesdata/classes.ts` file.

## 4. UI Impact Analysis

- **Minimal.** The only required change in the UI components is updating the import path for `classesData`.
- The data structure and type (`IClassDefinition[]`) provided to the components will be identical to the current implementation.
- All existing UI logic for rendering class lists, features, and descriptions will function without modification. This makes the refactor low-risk from a UI perspective.

## 5. Validation & Testing

- **Static Validation:** The build process (Vite) will fail if the Zod schema validation in the loader fails, providing an immediate check.
- **Runtime Validation:** Run the application and navigate to the character creation screen.
- **Verification Steps:**
  1. Confirm that the list of all 13 classes is displayed correctly.
  2. Select a class and verify that its description, features, and choices are rendered accurately.
  3. Test a few different classes to ensure all JSON files were loaded and parsed correctly.
````

## File: SESSION_CONTEXT.md
````markdown
# DC20 Character Sheet Development Session Context

## Project Overview

- **Repository**: YasafVol/dc20clean
- **Branch**: converting-to-react
- **Main Focus**: React-based DC20 character creation and character sheet system
- **Primary File**: `/src/routes/character-sheet/CharacterSheetClean.tsx`

## Recent Issues Fixed

### 1. Character Creation Background Step Validation Bug

**Problem**: Background step completion validation was using hardcoded values instead of dynamic calculations based on Intelligence modifier and point conversions.

**Location**: `/src/routes/character-creation/CharacterCreation.tsx`

**Solution**: Updated step 3 validation logic to use flexible validation that accounts for:

- Intelligence modifier affecting skill points (5 + Int modifier)
- Point conversion system between skills/trades/languages
- Variable amounts instead of fixed values (5 skill, 5 trade, 3 language)

### 2. PDR (Physical Damage Reduction) Styling Alignment

**Problem**: PDR had square design while PD and MD had shield-like circular design, causing visual inconsistency and alignment issues.

**Location**: `/src/routes/character-sheet/CharacterSheetClean.tsx` (lines ~1390-1430)

**Final Solution Applied**:

```tsx
{
	/* Defenses - Shield-like design */
}
<div
	style={{
		display: 'flex',
		justifyContent: 'space-around',
		alignItems: 'center',
		marginBottom: '1.5rem'
	}}
>
	<div style={{ textAlign: 'center', width: '120px' }}>
		<div
			style={{
				height: '32px',
				display: 'flex',
				flexDirection: 'column',
				justifyContent: 'center',
				marginBottom: '0.3rem'
			}}
		>
			<div style={{ fontSize: '0.8rem', fontWeight: 'bold', color: '#8b4513', lineHeight: '1' }}>
				PHYSICAL
			</div>
			<div style={{ fontSize: '0.8rem', fontWeight: 'bold', color: '#8b4513', lineHeight: '1' }}>
				DEFENSE
			</div>
		</div>
		<div
			style={{
				width: '80px',
				height: '90px',
				border: '3px solid #8b4513',
				borderRadius: '50% 50% 50% 50% / 60% 60% 40% 40%',
				display: 'flex',
				alignItems: 'center',
				justifyContent: 'center',
				background: 'white',
				margin: '0 auto'
			}}
		>
			<div style={{ fontSize: '2rem', fontWeight: 'bold', color: '#8b4513' }}>
				{characterData.finalPD}
			</div>
		</div>
		<div style={{ height: '20px', marginTop: '0.2rem' }}></div>
	</div>

	{/* PDR - Shield-like design */}
	<div style={{ textAlign: 'center', width: '120px' }}>
		<div
			style={{
				height: '32px',
				display: 'flex',
				flexDirection: 'column',
				justifyContent: 'center',
				marginBottom: '0.3rem'
			}}
		>
			<div style={{ fontSize: '0.8rem', fontWeight: 'bold', color: '#8b4513', lineHeight: '1' }}>
				PHYSICAL
			</div>
			<div style={{ fontSize: '0.8rem', fontWeight: 'bold', color: '#8b4513', lineHeight: '1' }}>
				DMG REDUCTION
			</div>
		</div>
		<div
			style={{
				width: '80px',
				height: '90px',
				border: '3px solid #8b4513',
				borderRadius: '50% 50% 50% 50% / 60% 60% 40% 40%',
				display: 'flex',
				alignItems: 'center',
				justifyContent: 'center',
				background: 'white',
				margin: '0 auto'
			}}
		>
			<div style={{ fontSize: '2rem', fontWeight: 'bold', color: '#8b4513' }}>
				{characterData.finalPDR || 0}
			</div>
		</div>
		<div
			style={{
				height: '20px',
				marginTop: '0.2rem',
				display: 'flex',
				alignItems: 'center',
				justifyContent: 'center'
			}}
		>
			{characterData.finalPDR > 0 && (
				<div style={{ fontSize: '0.6rem', color: '#8b4513' }}>Auto-calculated</div>
			)}
		</div>
	</div>

	<div style={{ textAlign: 'center', width: '120px' }}>
		<div
			style={{
				height: '32px',
				display: 'flex',
				flexDirection: 'column',
				justifyContent: 'center',
				marginBottom: '0.3rem'
			}}
		>
			<div style={{ fontSize: '0.8rem', fontWeight: 'bold', color: '#8b4513', lineHeight: '1' }}>
				MYSTICAL
			</div>
			<div style={{ fontSize: '0.8rem', fontWeight: 'bold', color: '#8b4513', lineHeight: '1' }}>
				DEFENSE
			</div>
		</div>
		<div
			style={{
				width: '80px',
				height: '90px',
				border: '3px solid #8b4513',
				borderRadius: '50% 50% 50% 50% / 60% 60% 40% 40%',
				display: 'flex',
				alignItems: 'center',
				justifyContent: 'center',
				background: 'white',
				margin: '0 auto'
			}}
		>
			<div style={{ fontSize: '2rem', fontWeight: 'bold', color: '#8b4513' }}>
				{characterData.finalAD}
			</div>
		</div>
		<div style={{ height: '20px', marginTop: '0.2rem' }}></div>
	</div>
</div>;
```

**Key Changes Made**:

- Changed PDR from square (`borderRadius: '8px'`) to shield-like (`borderRadius: '50% 50% 50% 50% / 60% 60% 40% 40%'`)
- Increased PDR size from 60x60px to 80x90px to match PD and MD
- Consistent 120px width containers for all three sections
- Fixed 32px height for label areas with flexbox centering
- Consistent 20px bottom spacing for all sections
- Font size increased from 1.5rem to 2rem for PDR value
- Changed labels from "PDR" + "Physical Damage Reduction" to "PHYSICAL" + "DMG REDUCTION"
- Added `margin: '0 auto'` to center shields within containers
- Set `lineHeight: '1'` to prevent text spacing variations

## Design System & Style Standards

### Color Scheme

- **Primary Brown**: `#8b4513` (borders, text, UI elements)
- **Background**: `white` for content areas
- **Light Background**: `#f5f5dc` and `#f9f9f9` for highlighting
- **Resource Colors**:
  - Stamina Points: `#22c55e` (green)
  - Mana Points: `#3b82f6` (blue)
  - Hit Points: `#dc2626` (red)

### Shield Design Pattern

**Shield-like Elements** (PD, PDR, MD):

- Dimensions: `80px` width × `90px` height
- Border: `3px solid #8b4513`
- Border Radius: `50% 50% 50% 50% / 60% 60% 40% 40%` (creates shield shape)
- Background: `white`
- Text: `2rem` font size, bold, `#8b4513` color
- Container: `120px` width with centered content

### Typography Standards

- **Section Titles**: `1.1rem`, bold, `#8b4513`
- **Shield Labels**: `0.8rem`, bold, `#8b4513`, `lineHeight: '1'`
- **Shield Values**: `2rem`, bold, `#8b4513`
- **Small Text**: `0.6rem` for secondary info like "Auto-calculated"

### Layout Patterns

- **Flex Containers**: Use `justifyContent: 'space-around'` and `alignItems: 'center'` for shield rows
- **Consistent Spacing**: `marginBottom: '1.5rem'` for major sections
- **Fixed Heights**: Use consistent heights for label areas (32px) and spacing (20px) to ensure alignment

## Key Components & Files

### Character Sheet (`CharacterSheetClean.tsx`)

- **Left Column**: Attributes with skills (Prime, Might, Agility, Charisma, Intelligence)
- **Middle Column**: Resources (SP/MP/HP), Defenses (PD/PDR/MD), Combat, Death/Exhaustion, Attacks, Inventory
- **Right Column**: Movement, Resources, Features

### Character Creation (`CharacterCreation.tsx`)

- Multi-step wizard with validation
- Step 3 (Background) had validation issues that were fixed
- Uses dynamic point allocation based on Intelligence modifier

### Inventory System (`inventoryItems.ts`)

- Weapons, Armor, Shields, Adventuring Supplies, Healing Potions
- Comprehensive weapon properties and damage calculations
- Enums for categorization and type safety

## Technical Patterns

### Styled Components Usage

- Uses styled-components for complex styling
- Inline styles for simple, one-off styling
- Consistent naming pattern: `Styled[ComponentName]`

### State Management

- React useState for local component state
- Context for character data sharing
- Real-time updates for resource tracking (HP, SP, MP)

### Validation Patterns

- Step-based validation in character creation
- Dynamic calculations based on character attributes
- Flexible point allocation systems

## Development Best Practices Applied

### Code Organization

- Separate files for different data types (weapons, armor, etc.)
- Clear component hierarchy
- Consistent naming conventions

### User Experience

- Visual feedback for interactions
- Tooltips for complex game mechanics
- Responsive design elements
- Auto-calculated values where appropriate

### Data Integrity

- Type safety with TypeScript enums and interfaces
- Validation at multiple levels
- Consistent data structures

## Next Steps & Known Areas for Improvement

1. **Performance Optimization**: Large component could benefit from memoization
2. **Component Splitting**: CharacterSheetClean.tsx is quite large and could be broken down
3. **Accessibility**: Add proper ARIA labels and keyboard navigation
4. **Mobile Responsiveness**: Current design is desktop-focused
5. **Testing**: Add unit tests for validation logic and calculations

## File Locations Summary

- **Main Character Sheet**: `/src/routes/character-sheet/CharacterSheetClean.tsx`
- **Character Creation**: `/src/routes/character-creation/CharacterCreation.tsx`
- **Inventory Data**: `/src/lib/rulesdata/inventoryItems.ts`
- **Character Context**: `/src/lib/stores/characterContext.tsx`
- **Schema**: `/src/lib/server/db/schema.ts`

## Git Workflow

- Use local repository configuration for commits
- Ensure commits are attributed to nzinger1983 account
- Branch: converting-to-react (current working branch)

---

**Session Summary**: Fixed character creation validation bug and completely redesigned PDR to match shield aesthetic with perfect alignment. All three defense shields (PD, PDR, MD) now have consistent appearance and spacing. Git configuration properly set for correct commit attribution.
````

## File: src/lib/rulesdata/classes/spellblade_table.json
````json
{
	"className": "Spellblade",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 2,
			"techniquesKnown": 0,
			"manaPoints": 3,
			"cantripsKnown": 1,
			"spellsKnown": 1,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 1,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 1,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 1,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 1,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
````

## File: src/lib/rulesdata/classes/wizard_features.json
````json
{
	"className": "Wizard",
	"startingEquipment": {
		"weaponsOrShields": ["1 Weapon"],
		"armor": "1 set of Light Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"spellcastingPath": {
		"combatTraining": {
			"armor": ["Light Armor"]
		},
		"spellList": {
			"type": "specific",
			"listName": "Arcane Spell List",
			"betaNote": "You get access to the following \"Premade List\" that have had their Spells pre-selected for you: Fire & Flames, Ice & Illusions, Lightning & Teleportation, or Psychic & Enchantment"
		},
		"cantrips": {
			"knownIncreasesBy": "Cantrips Known column of the Wizard Class Table",
			"description": "Cantrips are Spells with the Cantrip Spell Tag."
		},
		"spells": {
			"knownIncreasesBy": "Spells Known column of the Wizard Class Table",
			"description": "These can be Spells with or without the Cantrip Spell Tag."
		},
		"manaPoints": {
			"maximumIncreasesBy": "Mana Points column of the Wizard Class Table"
		}
	},
	"coreFeatures": [
		{
			"featureName": "Spell School Initiate",
			"levelGained": 1,
			"description": "You've completed training in a specialized School of Magic. Choose a Spell School. You gain the following benefits:",
			"benefits": [
				{
					"name": "School Magic",
					"description": "You learn 1 Arcane Cantrip and 1 Arcane Spell from this Spell School."
				},
				{
					"name": "Signature School",
					"description": "When you cast a Spell from the chosen School, you can reduce its MP cost by 1. Its total MP cost before the reduction still can't exceed your Mana Spend Limit. You can use this Feature once per Long Rest, but regain the ability to use it again when you roll for Initiative."
				}
			]
		},
		{
			"featureName": "Arcane Sigil",
			"levelGained": 1,
			"description": "You can spend 1 AP and 1 MP to create a 1 Space diameter Arcane Sigil on the ground beneath you that lasts for 1 minute. When you create an Arcane Sigil choose 1 Spell School (Enchantment, Necromancy, Protection, etc.) or 1 Spell Tag (Fire, Cold, Teleportation, etc.). The Arcane Sigil radiates magic of the chosen type.\nUsing a Sigil: While a creature is within the area of your Arcane Sigil, it has ADV on Spell Checks to cast or produce the effects of Spells with the chosen Spell School or Spell Tag.\nMoving a Sigil: You can spend 1 AP to teleport one of your Sigils within 10 spaces to your current space, but multiple Sigils can't coexist in the same Space."
		},
		{
			"featureName": "Ritual Caster (Flavor Feature)",
			"levelGained": 1,
			"description": "You learn 1 Arcane Spell with the Ritual Spell Tag each time you gain a Wizard Class Feature (including this one). You can only gain this benefit once per Level. Additionally, when you encounter an Arcane Spell with the Ritual Spell Tag in a form you can study (such as a spellbook, a spell scroll, or from an instructor), you can spend a number of hours equal to the Spell's base MP cost to learn it. You can only cast Spells you learn with this feature as Rituals, unless you learned it from another source.",
			"isFlavor": true
		},
		{
			"featureName": "Prepared Spell",
			"levelGained": 2,
			"description": "When you complete a Long Rest, choose 1 Spell you know. The chosen Spell becomes your Prepared Spell until your next Long Rest. Your Prepared Spell gains the following benefits:",
			"benefits": [
				{
					"name": "Mana Limit Break",
					"description": "When you cast this Spell, you can increase your Mana Spend Limit by 1. You can use this Feature once per Long Rest, but you regain the ability to use it when you roll for Initiative."
				},
				{
					"name": "Rehearsed Casting",
					"description": "During a Spell Duel, Challengers have DisADV on Spell Checks to stop your Spell."
				}
			]
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Portal Mage",
			"features": [
				{
					"featureName": "Portal Magic",
					"levelGained": 3,
					"description": "When you use your Arcane Sigil Feature, you can spend 1 additional MP to create 1 intangible Arcane Portal in a Space you can see within 10 Spaces that is linked to the Sigil. The Portal disappears when its linked Arcane Sigil ends. It grants the following benefits:\n• Arcane Portal: Creatures of your choice within 1 Space of the Sigil or Portal can spend 1 Space of Movement to teleport to an unoccupied Space within 1 Space of the linked Sigil or Portal.\n• Linked Magic: While within 1 Space of the Sigil or Portal, you can cast a Spell or make an Attack as if you were standing in the Space of the linked Sigil or Portal. When you do, you gain the benefits of the Arcane Sigil, regardless of where you're standing.\n• Teleportation Expert: When you learn a new Spell, you can choose any Spell with the Teleportation Spell Tag."
				},
				{
					"featureName": "Portal Sage (Flavor Feature)",
					"levelGained": 3,
					"description": "You have ADV on Checks to learn about the Astromancy Spell School (such as Teleportation magic or Portals). Additionally, if you spend 1 minute observing a portal or teleportation runes, you can make a DC 10 Spell Check to try to understand the inner mechanism of a Portal within 5 Spaces. Success: You learn where it leads to and for how long it has been open. Success (5): You learn how to activate and deactivate it (such as its passphrase, procedures, or any required special item).",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Witch",
			"features": [
				{
					"featureName": "Coven's Gift",
					"levelGained": 3,
					"description": "You learn 1 Spell of your choice with the Curse Spell Tag. When you learn a new Spell, you can choose any Spell with the Curse Spell Tag. Spells with the Curse Spell Tag count as being part of your chosen Spell School for the purposes of your Spell School Initiate Feature.\nBeta Note: DC20 will receive an overhaul of its Spellcasting (and Maneuvers/Techniques) systems in Beta 0.10. Until then, the following Spells are considered to have the Curse Spell Tag: Bane, Befriend, Death Bolt, and Poison Bolt."
				},
				{
					"featureName": "Hex Enhancements",
					"levelGained": 3,
					"description": "You gain the Spell Enhancements listed below, which you can add to any Spell you cast. You can only use 1 of these Spell Enhancements per Spell you cast. MP spent on these Spell Enhancements doesn't count against your Mana Spend Limit. When you use one of these Spell Enhancements, 1 creature of your choice that's targeted by the Spell must make a Repeated Charisma Save against your Spell Check. If the Spell doesn't normally require a Spell Check, you must make one when using one of these Spell Enhancements. Save Failure: The target is subjected to the chosen Hex effects for 1 minute:",
					"choices": [
						{
							"prompt": "Choose a Hex Enhancement to add to a spell.",
							"count": 1,
							"options": [
								{
									"name": "Bewitching Hex (1 MP)",
									"description": "The target becomes Charmed by you for the duration."
								},
								{
									"name": "Reaping/Life Hex (1 MP)",
									"description": "The target takes 1 True damage and you regain 1 HP. This effect repeats at the end of each of its turns for the duration."
								},
								{
									"name": "Vermin Hex (1 MP)",
									"description": "The target can't speak and if its Size is Large or smaller its Size decreases by 1. Its Size decreases by 1 again at the end of each of its turns for the duration until it's tiny."
								}
							]
						}
					]
				},
				{
					"featureName": "Curse Expert (Flavor Feature)",
					"levelGained": 3,
					"description": "You can spend 1 minute focusing your mind to detect the presence of Curses within 20 Spaces. You learn the location of any Cursed creature or Cursed object within range. If you spend 10 minutes in contact with a Cursed creature or object, you learn the nature of the Curse but not the knowledge of how to remove it.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/loaders/class-features.loader.ts
````typescript
/**
 * @file class-features.loader.ts
 * @description Loader for the new class features JSON structure
 */

import { SpellSchool, SpellList } from '../spells-data/types/spell.types';

// Define interfaces for the new class features structure
export interface ClassFeatureChoice {
	prompt: string;
	count: number;
	options?: {
		name: string;
		description: string;
	}[];
}

export interface ClassFeatureBenefit {
	name: string;
	description: string;
	effects?: {
		type: string;
		target?: string;
		value?: any;
		condition?: string;
	}[];
}

export interface ClassFeature {
	featureName: string;
	levelGained: number;
	description: string;
	isFlavor?: boolean;
	choices?: ClassFeatureChoice[];
	benefits?: ClassFeatureBenefit[];
}

export interface ClassSubclass {
	subclassName: string;
	description?: string;
	features: ClassFeature[];
}

export interface ClassDefinition {
	className: string;
	startingEquipment?: {
		weaponsOrShields?: string[];
		rangedWeapon?: string;
		alternativeWeapons?: string;
		armor?: string;
		packs?: string;
	};
	martialPath?: {
		combatTraining?: {
			weapons?: string[];
			armor?: string[];
			shields?: string[];
		};
		maneuvers?: {
			learnsAllAttack?: boolean;
			additionalKnown?: string;
		};
		techniques?: {
			additionalKnown?: string;
		};
		staminaPoints?: {
			maximumIncreasesBy?: string;
		};
		staminaRegen?: {
			description?: string;
			conditions?: string[];
		};
	};
	spellcastingPath?: {
		combatTraining?: {
			armor?: string[];
			shields?: string[];
		};
		spellList?: {
			type?: 'specific' | 'schools' | 'any' | 'all_schools';
			listName?: string;
			specificSchools?: SpellSchool[];
			spellTags?: string[];
			schoolCount?: number; // For classes that choose X schools
			description?: string;
			betaNote?: string;
		};
		cantrips?: {
			knownIncreasesBy?: string;
			description?: string;
		};
		spells?: {
			knownIncreasesBy?: string;
			description?: string;
		};
		manaPoints?: {
			maximumIncreasesBy?: string;
		};
	};
	coreFeatures: ClassFeature[];
	subclasses: ClassSubclass[];
}

// Use Vite's import.meta.glob to import all the class feature JSON files
const classFeatureModules = import.meta.glob('../classes/*_features.json', { eager: true });

// Extract the default export (the class features object) from each module
const rawClassFeatures = Object.values(classFeatureModules).map((module: any) => module.default);

// Export the class features data
export const classFeaturesData: ClassDefinition[] = rawClassFeatures;

// Helper function to get available spell schools for a class
export function getAvailableSpellSchools(classData: ClassDefinition): SpellSchool[] {
	const spellList = classData.spellcastingPath?.spellList;
	if (!spellList) return [];

	switch (spellList.type) {
		case 'all_schools':
			// Return all schools from the enum
			return Object.values(SpellSchool);
		case 'schools':
			// Return specific schools
			return spellList.specificSchools || [];
		default:
			return [];
	}
}

// Helper function to find a class by name
export function findClassByName(className: string): ClassDefinition | undefined {
	return classFeaturesData.find((cls) => cls.className === className);
}

// Helper function to find a specific feature in a class
export function findFeatureInClass(
	className: string,
	featureName: string
): ClassFeature | undefined {
	const classData = findClassByName(className);
	if (!classData) return undefined;

	return classData.coreFeatures.find((feature) => feature.featureName === featureName);
}

// Helper function to find a choice option in a feature
export function findChoiceOption(
	className: string,
	featureName: string,
	choiceIndex: number,
	optionName: string
): { name: string; description: string } | undefined {
	const feature = findFeatureInClass(className, featureName);
	if (!feature?.choices?.[choiceIndex]?.options) return undefined;

	return feature.choices[choiceIndex].options.find((option) => option.name === optionName);
}

// Generic function to extract class-specific display information
export function getClassSpecificInfo(
	className: string,
	selectedFeatureChoices?: string
): { displayInfo: { label: string; value: string }[] } {
	const displayInfo: { label: string; value: string }[] = [];

	if (!selectedFeatureChoices) {
		return { displayInfo };
	}

	try {
		const selectedChoices: { [key: string]: string } = JSON.parse(selectedFeatureChoices);
		const classData = findClassByName(className);

		if (!classData) {
			return { displayInfo };
		}

		// Process each core feature that has choices
		classData.coreFeatures.forEach((feature) => {
			if (feature.choices) {
				feature.choices.forEach((choice, choiceIndex) => {
					// Create a mapping for legacy choice IDs based on class and feature
					const legacyChoiceId = getLegacyChoiceId(className, feature.featureName, choiceIndex);
					const selectedValue = selectedChoices[legacyChoiceId];

					if (selectedValue && choice.options) {
						if (choice.count > 1) {
							// Handle multiple selections
							try {
								const selectedValues: string[] = JSON.parse(selectedValue);
								if (selectedValues.length > 0) {
									const label = getDisplayLabel(className, feature.featureName, choiceIndex);
									displayInfo.push({
										label,
										value: selectedValues.join(', ')
									});
								}
							} catch (error) {
								console.error('Error parsing multiple selection:', error);
							}
						} else {
							// Handle single selections
							const label = getDisplayLabel(className, feature.featureName, choiceIndex);
							displayInfo.push({
								label,
								value: selectedValue.charAt(0).toUpperCase() + selectedValue.slice(1)
							});
						}
					}
				});
			}

			// Also check for benefits that might have user choices (like Divine Damage)
			if (feature.benefits) {
				feature.benefits.forEach((benefit) => {
					const legacyBenefitId = getLegacyBenefitId(className, feature.featureName, benefit.name);
					const selectedValue = selectedChoices[legacyBenefitId];

					if (selectedValue) {
						displayInfo.push({
							label: benefit.name,
							value: selectedValue.charAt(0).toUpperCase() + selectedValue.slice(1)
						});
					}
				});
			}
		});
	} catch (error) {
		console.error('Error parsing selected feature choices:', error);
	}

	return { displayInfo };
}

// Helper function to map class/feature combinations to legacy choice IDs
export function getLegacyChoiceId(
	className: string,
	featureName: string,
	choiceIndex: number
): string {
	// Generic mapping: className_featureName_choiceIndex
	return `${className.toLowerCase()}_${featureName.toLowerCase().replace(/\s+/g, '_')}_${choiceIndex}`;
}

// Helper function to map class/feature combinations to legacy benefit IDs
export function getLegacyBenefitId(
	className: string,
	featureName: string,
	benefitName: string
): string {
	// Generic mapping: className_featureName_benefitName
	return `${className.toLowerCase()}_${featureName.toLowerCase().replace(/\s+/g, '_')}_${benefitName.toLowerCase().replace(/\s+/g, '_')}`;
}

// Helper function to get display labels for different choice types
export function getDisplayLabel(
	_className: string,
	featureName: string,
	_choiceIndex: number
): string {
	// Generic: just use the feature name as the label
	return featureName;
}
````

## File: src/lib/rulesdata/schemas/class.schema.ts
````typescript
import { z } from 'zod';

// Schema for IEffect
const effectSchema = z.object({
	type: z.string(),
	target: z.string().optional(),
	value: z.any().optional(),
	condition: z.string().optional(),
	userChoiceRequired: z
		.object({
			prompt: z.string(),
			options: z.array(z.string()).optional()
		})
		.optional(),
	descriptionOverride: z.string().optional(),
	subFeature: z.string().optional(),
	schools: z.array(z.string()).optional()
});

// Schema for IClassFeatureChoiceOption
const classFeatureChoiceOptionSchema = z.object({
	value: z.string(),
	label: z.string(),
	description: z.string().optional(),
	effectsOnChoice: z.array(effectSchema).optional()
});

// Schema for IClassFeatureChoice
const classFeatureChoiceSchema = z.object({
	id: z.string(),
	prompt: z.string(),
	type: z.enum(['select_one', 'select_multiple']),
	maxSelections: z.number().optional(),
	options: z.array(classFeatureChoiceOptionSchema)
});

// Schema for IBenefit
const benefitSchema = z.object({
	name: z.string(),
	description: z.string(),
	effects: z.array(effectSchema).optional()
});

// Schema for IClassFeature
const classFeatureSchema = z.object({
	id: z.string(),
	name: z.string(),
	description: z.string(),
	level: z.number(),
	effects: z.array(effectSchema).optional(),
	benefits: z.array(benefitSchema).optional()
});

// Schema for IClassDefinition
export const classSchema = z.object({
	id: z.string(),
	name: z.string(),
	description: z.string(),
	baseHpContribution: z.number(),
	startingSP: z.number(),
	startingMP: z.number(),
	skillPointGrantLvl1: z.number().optional(),
	tradePointGrantLvl1: z.number().optional(),
	combatTraining: z.array(z.string()).optional(),
	maneuversKnownLvl1: z.union([z.string(), z.number()]).optional(),
	techniquesKnownLvl1: z.number().optional(),
	saveDCBase: z.number(),
	deathThresholdBase: z.number(),
	moveSpeedBase: z.number(),
	restPointsBase: z.number(),
	gritPointsBase: z.number(),
	initiativeBonusBase: z.number(),
	cantripsKnownLvl1: z.number().optional(),
	spellsKnownLvl1: z.number().optional(),
	// Level progression data for future level gaining
	levelProgression: z.array(z.object({
		level: z.number(),
		healthPoints: z.number(),
		attributePoints: z.number(),
		skillPoints: z.number(),
		tradePoints: z.number(),
		staminaPoints: z.number(),
		maneuversKnown: z.number(),
		techniquesKnown: z.number(),
		manaPoints: z.number(),
		cantripsKnown: z.number(),
		spellsKnown: z.number(),
		features: z.string() // Description of features gained at this level
	})),
	// Features should be handled by class-features.loader.ts, but keeping for schema compatibility
	level1Features: z.array(classFeatureSchema).optional(),
	featureChoicesLvl1: z.array(classFeatureChoiceSchema).optional()
});

// Schema for an array of class definitions
export const classesDataSchema = z.array(classSchema);

// Infer the TypeScript type from the schema
export type IClassDefinition = z.infer<typeof classSchema>;
````

## File: src/lib/rulesdata/spells-data/spells/additional-spells/find-familiar.ts
````typescript
import { Spell, SpellSchool, PremadeSpellList } from '../../types/spell.types';

export const findFamiliar: Spell = {
	name: 'Find Familiar',
	premadeList: PremadeSpellList.Additional,
	school: SpellSchool.Conjuration,
	isCantrip: false,
	isRitual: true,
	cost: { ap: 1, mp: 1 },
	range: '2 Spaces',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Summon Familiar',
			description:
				'You summon a friendly spirit that enters your service. It takes the form of a Tiny creature of your choice, but with a Creature Type of your choice (except Giant and Humanoid). Your Familiar uses the statblock below: Familiar Level 1/8, Tiny (Chosen Type) HP Shared Prime & CM Shared PD 8+CM PDR 0 AD 8+CM MDR 0 MIG 0 CHA 0 AGI 0 INT 0 Check Shared Save DC Shared AP Shared Speed 5 Recasting the Spell: You can’t have more than 1 Familiar at a time. If you cast this Spell while you already have a Familiar, your Familiar can retain its form, adopt a new form of your choice, or it disappears and a new one takes its place. The new Familiar can be a previous one you summoned in the past or a new one altogether. In either case, you can reassign its Familiar Traits. Base Familiar Traits: Your Familiar has the following Familiar Traits: Familiar Bond: Your Familiar shares your HP and Death’s Door Threshold. If you both take damage from the same source, you only take 1 instance of that damage. While your Familiar occupies the same Space as you, it can’t be targeted by Attacks. Shared Telepathy: While within 20 Spaces, you and your Familiar can speak Telepathically with each other. Spell Delivery: While within 10 Spaces of your Familiar, you can cast a Spell with a range of Touch as if you were standing in your Familiar’s Space. Additional Traits: When you cast this Spell, you can spend additional MP (up to your Mana Spend Limit) to grant your Familiar 2 additional Traits per MP spent. You can choose Traits from the Familiar Traits or Beast Traits (you can’t choose Negative Traits). Spell Actions: Pocket Dimension: You can spend a Minor Action to dismiss the Familiar into a pocket dimension, summon it from that pocket dimension, or summon it from anywhere on the same plane of existence. When dismissed, any items it was carrying are left behind. When summoned, it appears in the nearest unoccupied Space of your choice. Shared Senses: While your Familiar is within 20 Spaces, you can spend 1 AP to connect your senses to the Familiar’s senses until the end of your next turn. For the duration, you’re Deafened and Blinded to your own senses but you can see what your Familiar sees and hear what it hears. The connection ends early if either of you moves farther than 20 Spaces from each other. Managing the Familiar: Combat: The Familiar shares your Initiative, acting on your turn. You can spend 1 AP to command the Familiar to use an Action. It can’t take the Attack Action or Spell Action unless it has a Familiar Feature that allows it to. When you take an Action, your Familiar can move up to its Speed immediately before or after the Action. If you don’t command it, it takes the Dodge Action. Shared MCP: When the Familiar makes a Check, it shares your Multiple Check Penalty. Death & Resurrection: Your Familiar dies when you die. When it does, its body disappears and its spirit returns from which it came. If you’re resurrected, the Familiar doesn’t return to life until the next time you cast this Spell. When it does, you follow the normal rules for recasting the Spell.'
		}
	],
	enhancements: [] // No enhancements specified in PDF
};
````

## File: src/lib/rulesdata/spells-data/spells/additional-spells/shield.ts
````typescript
import { Spell, SpellSchool, PremadeSpellList } from '../../types/spell.types';

export const shield: Spell = {
	name: 'Shield',
	premadeList: PremadeSpellList.Additional,
	school: SpellSchool.Protection,
	isCantrip: true,
	cost: { ap: 1 },
	range: '1 Space',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Create Barrier',
			description:
				'You create a barrier of magic to protect yourself or another creature nearby. Trigger: When a creature you can see within range (including yourself) is targeted by an Attack. Reaction: You grant the target a +5 bonus to its PD and AD against the Attack.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Increase Range',
			description: 'The range increases to 5 Spaces.'
		},
		{
			type: 'MP',
			cost: 1,
			name: 'Multiple Targets',
			description:
				'You can target 1 additional creature in range from the same triggering Attack (such as an Area of Effect).'
		},
		{
			type: 'MP',
			cost: 2,
			name: 'Increase Duration',
			description: 'The PD and AD bonus lasts until the start of your next turn.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/fire-and-flames/fire-bolt.ts
````typescript
import { Spell, SpellSchool, SpellList, ClassName, PremadeSpellList } from '../../types/spell.types';

export const fireBolt: Spell = {
	name: 'Fire Bolt',
	premadeList: PremadeSpellList.FireAndFlames,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [SpellList.Arcane, SpellList.Primal],
	availableClasses: [ClassName.Wizard, ClassName.Sorcerer],
	effects: [
		{
			title: 'Spell Attack',
			description:
				'You can make a Spell Check against the PD of a target within range. Hit: The target takes 2 Fire damage.'
		},
		{
			title: 'Fire Orb',
			description:
				'A flickering flame appears in your hand. The flame can remain there for 10 minutes and harms neither you nor your equipment. The flame sheds Bright Light in a 5 Space radius. The Spell ends early if you dismiss it for free, if you cast it again, or spend 1 AP to make a Spell Attack with it.'
		}
	],
	cantripPassive: 'You deal +1 damage against creatures that are Burning.',
	enhancements: [
		{ type: 'AP', cost: 1, name: 'Damage', description: 'You deal +1 Fire damage.' },
		{ type: 'AP', cost: 1, name: 'Range', description: 'You increase the range by +5 Spaces.' },
		{
			type: 'AP',
			cost: 1,
			name: 'Burning',
			description: 'The target makes a Physical Save. Failure: Target begins Burning.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/holy-and-restoration/sacred-bolt.ts
````typescript
import { Spell, SpellSchool, SpellList, ClassName, PremadeSpellList } from '../../types/spell.types';

export const sacredBolt: Spell = {
	name: 'Sacred Bolt',
	premadeList: PremadeSpellList.HolyAndRestoration,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [SpellList.Divine],
	availableClasses: [ClassName.Cleric],
	effects: [
		{
			title: 'Spell Attack',
			description:
				'You can make a Spell Check against the PD of a target within range. Hit: The target takes 2 Radiant damage.'
		},
		{
			title: 'Sacred Glow',
			description:
				'A beam of Bright Light illuminates a creature that you can see within range, or you can make a creature within range glow with a subtle Dim Light for 10 minutes.'
		}
	],
	cantripPassive: 'You deal +1 Radiant damage against Undead and Exposed creatures.',
	enhancements: [
		{ type: 'AP', cost: 1, name: 'Damage', description: 'You deal +1 Radiant damage.' },
		{ type: 'AP', cost: 1, name: 'Range', description: 'You increase the range by 5 Spaces.' },
		{
			type: 'AP',
			cost: 1,
			name: 'Holy Bolt',
			description:
				'The target makes a Mental Save. Failure: Target becomes Exposed (Attack Checks against it have ADV) against the next Attack Check made against it before the end of your next turn.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/ice-and-illusions/frost-bolt.ts
````typescript
import { Spell, SpellSchool, SpellList, ClassName, PremadeSpellList } from '../../types/spell.types';

export const frostBolt: Spell = {
	name: 'Frost Bolt',
	premadeList: PremadeSpellList.IceAndIllusions,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [SpellList.Arcane, SpellList.Primal],
	availableClasses: [ClassName.Wizard, ClassName.Sorcerer],
	effects: [
		{
			title: 'Spell Attack',
			description:
				'You can make a Spell Check against the PD of a target within range. Hit: The target takes 2 Cold damage.'
		},
		{
			title: 'Ice Orb',
			description:
				'A flurry of ice appears in your hand. The ice can remain there for 10 minutes and harms neither you nor your equipment, cooling the area within 5 Spaces. The Spell ends early if you dismiss it for free, if you cast it again, or spend 1 AP to make a Spell Attack with it.'
		}
	],
	cantripPassive: 'You deal +1 damage against creatures that are Slowed.',
	enhancements: [
		{ type: 'AP', cost: 1, name: 'Damage', description: 'You deal +1 Cold damage.' },
		{ type: 'AP', cost: 1, name: 'Range', description: 'You increase the range by 5 Spaces.' },
		{
			type: 'AP',
			cost: 1,
			name: 'Slow',
			description:
				'The target makes a Physical Save. Failure: Target becomes Slowed until the end of your next turn.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/ice-and-illusions/mage-hand.ts
````typescript
import { Spell, SpellSchool, PremadeSpellList } from '../../types/spell.types';

export const mageHand: Spell = {
	name: 'Mage Hand',
	premadeList: PremadeSpellList.IceAndIllusions,
	school: SpellSchool.Conjuration,
	isCantrip: true,
	cost: { ap: 1 },
	range: '5 Spaces',
	duration: '1 min',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Spectral Hand',
			description:
				'A spectral, floating hand appears at a point you choose within range. The hand lasts for the duration or until you dismiss it as a Free Action. The hand vanishes if it ever moves outside of the Spell’s range or if you cast this Spell again. When you cast the Spell, and by spending 1 AP while the Spell is active, you can control the hand. You can use the hand to manipulate an object, open an unlocked door or container, stow or retrieve an item from an open container, or pour the contents out of a container. You can move the hand up to 5 Spaces each time you use it, but it must stay within range. The hand can’t Attack, activate magic items, or carry more than 10 pounds.'
		}
	],
	enhancements: [
		{ type: 'MP', cost: 1, name: 'Range Hand', description: 'The range increases to 20 Spaces.' },
		{ type: 'MP', cost: 1, name: 'Lasting Hand', description: 'The duration increases to 1 hour.' }
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/lightning-and-teleportation/lightning-bolt.ts
````typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList, ClassName } from '../../types/spell.types';

export const lightningBolt: Spell = {
	name: 'Lightning Bolt',
	premadeList: PremadeSpellList.LightningAndTeleportation,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [SpellList.Arcane, SpellList.Primal],
	availableClasses: [ClassName.Wizard, ClassName.Sorcerer],
	effects: [
		{
			title: 'Spell Attack',
			description:
				'You can make a Spell Check against the PD of a target within range. Hit: The target takes 2 Lightning damage.'
		},
		{
			title: 'Lightning Orb',
			description:
				'Crackling lightning appears between both of your hands. The electric energy can remain there for 10 minutes and harms neither you nor your equipment. The energy sheds Bright Light in a 10 Space radius. The Spell ends early if you dismiss it for free, if you cast it again, stop using both hands, or spend 1 AP to make a Spell Attack with it.'
		}
	],
	cantripPassive: 'You deal +1 damage against creatures that are wearing metal armor.',
	enhancements: [
		{ type: 'AP', cost: 1, name: 'Damage', description: 'You deal +1 Lightning damage.' },
		{ type: 'AP', cost: 1, name: 'Range', description: 'You increase the range by 5 Spaces.' },
		{
			type: 'AP',
			cost: 1,
			name: 'Chain',
			description:
				'Choose 1 additional target within 2 Spaces of the original target. Compare your Spell Check against the new target’s PD. Hit: The additional target takes 2 Lightning damage and is unaffected by features that allow you to deal more damage, including Heavy Hits and higher (except the Cantrip Passive). You can use this Enhancement multiple times, choosing an additional target within 2 Spaces of the previously chosen target.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/psychic-and-enchantment/psi-bolt.ts
````typescript
import { Spell, SpellSchool, SpellList, ClassName, PremadeSpellList } from '../../types/spell.types';

export const psiBolt: Spell = {
	name: 'Psi Bolt',
	premadeList: PremadeSpellList.PsychicAndEnchantment,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [SpellList.Arcane],
	availableClasses: [ClassName.Wizard, ClassName.Sorcerer],
	effects: [
		{
			title: 'Spell Attack',
			description:
				'You can make a Spell Check against the PD of a target within range. Hit: The target takes 2 Psychic damage.'
		},
		{
			title: 'Headache',
			description:
				'You tear into the mind of a creature you can see within range and give them a mild headache for 1 minute.'
		}
	],
	cantripPassive: 'You deal +1 damage against creatures that are Dazed.',
	enhancements: [
		{ type: 'AP', cost: 1, name: 'Damage', description: 'You deal +1 Psychic damage.' },
		{ type: 'AP', cost: 1, name: 'Range', description: 'You increase the range by 5 Spaces.' },
		{
			type: 'AP',
			cost: 1,
			name: 'Dazed',
			description:
				'The target makes a Mental Save. Failure: Target becomes Dazed (DisADV on Mental Checks) on the next Mental Check it makes before the end of your next turn.'
		}
	]
};
````

## File: src/lib/rulesdata/spells-data/spells/special-class-spells/sorcery.ts
````typescript
import { Spell, SpellSchool, ClassName, PremadeSpellList } from '../../types/spell.types';

export const sorcery: Spell = {
	name: 'Sorcery',
	premadeList: PremadeSpellList.SpecialClass,
	school: SpellSchool.Transmutation,
	isCantrip: true,
	cost: { ap: 1 },
	range: '1 Space',
	duration: '1 min',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [ClassName.Sorcerer],
	effects: [
		{
			title: 'Minor Wonder',
			description:
				'You manifest a minor wonder (Divine), a sign of supernatural power (Primal), or arcane prowess (Arcane) depending on which Spell List you have access to. When you gain this Spell, choose from the following types of energy: Fire, Water, Lightning, Earth, Holy, Unholy, or Arcane (which manifests as energy of a specific color). This chosen type will be the form this Spell’s energy takes. You create one of the following magical effects of your chosen energy type within range and can dismiss it by spending 1 AP: Your voice booms up to 3 times louder than normal. You summon harmless magic of your chosen energy type to swirl around you in a visual display. Your eyes glow with your chosen energy type.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Multiple Effects',
			description: 'You can have up to all 3 of the effects going at once.'
		}
	]
};
````

## File: src/lib/rulesdata/death.ts
````typescript
/**
 * DC20 Death & Health Threshold Rules
 * Based on official DC20 rulebook pages for Health Points & Death's Door
 */

export interface HealthStatus {
	status: 'healthy' | 'bloodied' | 'well-bloodied' | 'deaths-door' | 'dead';
	description: string;
	effects: string[];
}

export interface DeathSaveResult {
	success: boolean;
	effect: string;
}

/**
 * Calculate current health status based on HP
 */
export function getHealthStatus(
	currentHP: number,
	maxHP: number,
	deathThreshold: number
): HealthStatus {
	const halfHP = Math.floor(maxHP / 2);
	const quarterHP = Math.floor(maxHP / 4);

	if (currentHP <= deathThreshold) {
		return {
			status: 'dead',
			description: 'Dead',
			effects: ['Character is dead']
		};
	}

	if (currentHP <= 0) {
		return {
			status: 'deaths-door',
			description: "Death's Door",
			effects: [
				'Immediately gain Exhaustion 1',
				'Action Point Limit: 1 AP until end of next turn or restored to 1 HP',
				"Can't Concentrate",
				'Death Saves at end of turns (d20, 10+ succeeds)',
				'Failure: 1 True damage, Critical Failure: Unconscious until 1 HP',
				'Critical Success: Restored to 1 HP'
			]
		};
	}

	if (currentHP <= quarterHP) {
		return {
			status: 'well-bloodied',
			description: 'Well-Bloodied',
			effects: ['HP is 1/4 or lower of maximum', 'Subject to Well-Bloodied effects from abilities']
		};
	}

	if (currentHP <= halfHP) {
		return {
			status: 'bloodied',
			description: 'Bloodied',
			effects: ['HP is 1/2 or lower of maximum', 'Subject to Bloodied effects from abilities']
		};
	}

	return {
		status: 'healthy',
		description: 'Healthy',
		effects: ['No health penalties']
	};
}

/**
 * Calculate Death Threshold
 * Death Threshold = 0 HP minus Prime Modifier + Combat Mastery
 */
export function calculateDeathThreshold(primeModifier: number, combatMastery: number): number {
	return -(primeModifier + combatMastery);
}

/**
 * Death Save mechanics
 */
export function processDeathSave(roll: number): DeathSaveResult {
	if (roll === 1) {
		return {
			success: false,
			effect:
				'Critical Failure: Take 1 True damage and become Unconscious until restored to 1 HP or higher'
		};
	}

	if (roll === 20) {
		return {
			success: true,
			effect: 'Critical Success: Restored to 1 HP'
		};
	}

	if (roll >= 10) {
		return {
			success: true,
			effect: 'Success: Become Stabilized'
		};
	}

	return {
		success: false,
		effect: 'Failure: Take 1 True damage'
	};
}

/**
 * Death's Door After Combat rules
 */
export function getDeathsDoorAfterCombat(): string[] {
	return [
		"When Combat ends, any creature on Death's Door must immediately make a Death Save",
		'They repeat this Death Save every 12 seconds until they become Stabilized, are restored to 1 HP or higher, or die',
		'Failure: Take 1 True damage and fall Unconscious until Stabilized',
		'Success: Become Stabilized'
	];
}

/**
 * Stabilization rules
 */
export function getStabilizationRules(): string[] {
	return [
		"A creature that takes the Medicine Action and succeeds on a DC 10 Medicine Check can Stabilize a creature on Death's Door",
		"A Stabilized creature doesn't make Death Saves while on Death's Door",
		"A creature remains Stabilized until it's restored to 1 HP or takes damage"
	];
}

/**
 * Continuous damage rules (Bleeding, Burning)
 */
export function getContinuousDamageRules(): string[] {
	return [
		"Continuous damage (such as Bleeding and Burning) does not affect you while on Death's Door",
		"You still have these conditions on you, but they don't deal damage unless you're above 0 HP"
	];
}

/**
 * Death's Door threshold tracking for UI
 * Returns how many "steps" until death based on current HP and death threshold
 */
export function getDeathSteps(
	currentHP: number,
	deathThreshold: number
): {
	currentStep: number;
	maxSteps: number;
	isDead: boolean;
} {
	if (currentHP > 0) {
		return { currentStep: 0, maxSteps: 0, isDead: false };
	}

	const maxSteps = Math.abs(deathThreshold);
	const currentStep = Math.abs(currentHP);
	const isDead = currentHP <= deathThreshold;

	return { currentStep, maxSteps, isDead };
}
````

## File: src/lib/index.ts
````typescript
// Reexport your entry components here

// Rules data exports
// TODO: weapons.ts deleted - refactor attack system to use inventoryItems.ts
````

## File: src/routes/api/character/[characterId]/+server.ts
````typescript
// src/routes/api/character/[characterId]/+server.ts

import { json } from '@sveltejs/kit';
import { PrismaClient } from '@prisma/client';
import type { RequestHandler } from './$types';

const prisma = new PrismaClient();

export const GET: RequestHandler = async ({ params }) => {
	const { characterId } = params;

	if (!characterId) {
		return json({ error: 'Character ID is required' }, { status: 400 });
	}

	try {
		// First try to get the finalized character sheet data
		const finalizedCharacter = await prisma.characterSheetData.findUnique({
			where: { id: characterId }
		});

		if (finalizedCharacter) {
			return json(finalizedCharacter);
		}

		// If not found in finalized data, check if it's in progress
		const progressCharacter = await prisma.characterInProgress.findUnique({
			where: { id: characterId }
		});

		if (!progressCharacter) {
			return json({ error: 'Character not found' }, { status: 404 });
		}

		// For now, return an error indicating the character isn't finalized
		// In the future, we could calculate stats on-the-fly from progress data
		return json(
			{
				error: 'Character creation not yet complete. Please finish character creation first.'
			},
			{ status: 400 }
		);
	} catch (error) {
		console.error('Error fetching character:', error);
		return json({ error: 'Internal server error' }, { status: 500 });
	}
};
````

## File: src/routes/api/character/progress/complete/+server.ts
````typescript
// src/routes/api/character/progress/complete/+server.ts

import { json } from '@sveltejs/kit';
import { PrismaClient } from '@prisma/client';
import { classesData } from '$lib/rulesdata/loaders/class.loader';
import { findClassByName, getLegacyChoiceId } from '$lib/rulesdata/loaders/class-features.loader';
import { traitsData } from '$lib/rulesdata/traits';
import { processTraitEffects } from '$lib/services/traitEffectProcessor';
import type { RequestHandler } from './$types';

const prisma = new PrismaClient();

function validateFeatureChoices(classId: string, selectedChoicesJson: string) {
	const classData = classesData.find((c) => c.id === classId);
	if (!classData) throw new Error(`Invalid class ID: ${classId}`);

	const choices = JSON.parse(selectedChoicesJson || '{}');

	// Use the new class features structure for validation
	const classFeatures = findClassByName(classData.name);
	if (!classFeatures) return; // No class features to validate

	// Get level 1 features that have choices
	const level1Features = classFeatures.coreFeatures.filter(feature => feature.levelGained === 1);
	
	level1Features.forEach((feature) => {
		if (feature.choices) {
			feature.choices.forEach((choice, choiceIndex) => {
				// Create the same legacy choice ID mapping used in the UI
				const choiceId = getLegacyChoiceId(classFeatures.className, feature.featureName, choiceIndex);
				
				if (choice.options && choice.options.length > 0) {
					const selectedValue = choices[choiceId];
					if (selectedValue === undefined) {
						throw new Error(`Missing required choice for ${classData.name}: ${choice.prompt}`);
					}
					
					// Validate the selected option(s)
					if (choice.count > 1) {
						// Multiple selections - should be a JSON array
						try {
							const selectedValues: string[] = JSON.parse(selectedValue);
							const validOptions = choice.options.map((o) => o.name);
							for (const value of selectedValues) {
								if (!validOptions.includes(value)) {
									throw new Error(`Invalid selected option for ${choiceId} in class ${classData.name}`);
								}
							}
							if (selectedValues.length !== choice.count) {
								throw new Error(`Must select exactly ${choice.count} options for ${choiceId} in class ${classData.name}`);
							}
						} catch (error) {
							throw new Error(`Invalid selection format for ${choiceId} in class ${classData.name}`);
						}
					} else {
						// Single selection
						const validOptions = choice.options.map((o) => o.name);
						if (!validOptions.includes(selectedValue)) {
							throw new Error(`Invalid selected option for ${choiceId} in class ${classData.name}`);
						}
					}
				}
			});
		}
	});
}

function validateAttributeCapsAfterTraits(
	attributes: any, 
	selectedTraitIdsJson: string, 
	ancestry1Id: string | null, 
	ancestry2Id: string | null
) {
	const selectedTraitIds = JSON.parse(selectedTraitIdsJson || '[]');
	
	// Use the same trait processing logic as the calculator
	const processedEffects = processTraitEffects(selectedTraitIds, ancestry1Id, ancestry2Id);

	// Apply attribute modifiers
	const finalAttributes = {
		attribute_might: attributes.attribute_might + processedEffects.attributeModifiers.might,
		attribute_agility: attributes.attribute_agility + processedEffects.attributeModifiers.agility,
		attribute_charisma: attributes.attribute_charisma + processedEffects.attributeModifiers.charisma,
		attribute_intelligence: attributes.attribute_intelligence + processedEffects.attributeModifiers.intelligence
	};

	const ATTRIBUTE_MAX_L1 = 3;
	for (const [attrName, finalValue] of Object.entries(finalAttributes)) {
		if (finalValue > ATTRIBUTE_MAX_L1) {
			throw new Error(
				`Final attribute ${attrName.replace('attribute_', '')} exceeds Level 1 cap (+3) after applying traits.`
			);
		}
	}
}

export const POST: RequestHandler = async ({ request }) => {
	try {
		const data = await request.json();

		// Basic validation
		if (
			!data.finalName ||
			typeof data.finalName !== 'string' ||
			data.finalName.trim().length === 0
		) {
			return json({ error: 'Character name is required.' }, { status: 400 });
		}

		// Validate attributes and point buy (Stage A)
		const attributes = {
			attribute_might: data.attribute_might,
			attribute_agility: data.attribute_agility,
			attribute_charisma: data.attribute_charisma,
			attribute_intelligence: data.attribute_intelligence
		};
		const totalPoints = Object.values(attributes).reduce(
			(sum, v) => sum + (typeof v === 'number' ? v : 0),
			0
		);
		if (totalPoints !== 0) {
			return json({ error: 'Attribute points must sum to 0 (point buy).' }, { status: 400 });
		}

		// Validate ancestry selections (Stage B)
		if (!data.ancestry1Id) {
			return json({ error: 'At least one ancestry must be selected.' }, { status: 400 });
		}
		if (data.ancestry2Id && data.ancestry1Id === data.ancestry2Id) {
			return json({ error: 'Cannot select the same ancestry twice.' }, { status: 400 });
		}

		// Validate selected trait IDs (Stage B)
		try {
			const selectedTraitIds = JSON.parse(data.selectedTraitIds || '[]');
			if (!Array.isArray(selectedTraitIds)) throw new Error();
			// Additional trait validation can be added here
		} catch {
			return json({ error: 'Invalid selectedTraitIds format.' }, { status: 400 });
		}

		// Validate class selection (Stage C)
		if (!data.classId || !classesData.find((c) => c.id === data.classId)) {
			return json({ error: 'A valid class must be selected.' }, { status: 400 });
		}

		// Validate feature choices (Stage C)
		try {
			validateFeatureChoices(data.classId, data.selectedFeatureChoices);
		} catch (err: any) {
			return json({ error: err.message }, { status: 400 });
		}

		// Cross-stage validation: attribute caps after traits
		try {
			validateAttributeCapsAfterTraits(attributes, data.selectedTraitIds, data.ancestry1Id, data.ancestry2Id);
		} catch (err: any) {
			return json({ error: err.message }, { status: 400 });
		}

		// Save to DB in a transaction
		const result = await prisma.$transaction(async (tx) => {
			// Upsert CharacterInProgress by id if provided, else create new
			let character;
			if (data.id) {
				character = await tx.characterInProgress.update({
					where: { id: data.id },
					data: {
						...data,
						updatedAt: new Date()
					}
				});
			} else {
				character = await tx.characterInProgress.create({
					data: {
						...data,
						createdAt: new Date(),
						updatedAt: new Date()
					}
				});
			}
			return character;
		});

		return json({ success: true, id: result.id });
	} catch (err: any) {
		return json({ error: err.message || 'Unknown error' }, { status: 500 });
	}
};
````

## File: src/routes/character-creation/components/BackgroundPointsManager.tsx
````typescript
import React from 'react';

// Mastery system interfaces and data
export interface MasteryInfo {
	level: number;
	name: string;
	bonus: number;
	available: boolean;
}

export interface MasteryValidation {
	valid: boolean;
	adeptCount: number;
	message?: string;
}

export interface MasteryLimits {
	maxSkillMastery: number;
	maxTradeMastery: number;
	level1Validation: MasteryValidation;
}

export const MASTERY_TABLE = [
	{ level: 0, name: 'Untrained', bonus: 0 },
	{ level: 1, name: 'Novice', bonus: 2 },
	{ level: 2, name: 'Adept', bonus: 4 },
	{ level: 3, name: 'Expert', bonus: 6 },
	{ level: 4, name: 'Master', bonus: 8 },
	{ level: 5, name: 'Grandmaster', bonus: 10 }
];

export interface BackgroundPointsData {
	skillPointsUsed: number;
	tradePointsUsed: number;
	languagePointsUsed: number;
	baseSkillPoints: number;
	baseTradePoints: number;
	baseLanguagePoints: number;
	availableSkillPoints: number;
	availableTradePoints: number;
	availableLanguagePoints: number;
}

export interface PointConversions {
	skillToTradeConversions: number;
	tradeToSkillConversions: number;
	tradeToLanguageConversions: number;
}

export interface ConversionActions {
	convertSkillToTrade: () => void;
	convertTradeToSkill: () => void;
	convertTradeToLanguage: () => void;
	resetConversions: () => void;
}

// Mastery utility functions
export const getBaseMasteryLimit = (characterLevel: number): number => {
	if (characterLevel >= 20) return 5; // Grandmaster
	if (characterLevel >= 15) return 4; // Master
	if (characterLevel >= 10) return 3; // Expert
	if (characterLevel >= 5) return 2; // Adept
	return 1; // Novice
};

export const getClassMasteryBonuses = (
	classFeatures: any,
	selectedFeatureChoices: string,
	type: 'skill' | 'trade'
): number => {
	if (!classFeatures || !selectedFeatureChoices) return 0;

	let bonus = 0;
	try {
		const selectedChoices: { [key: string]: string } = JSON.parse(selectedFeatureChoices);
		const level1Features = classFeatures.coreFeatures?.filter(
			(feature: any) => feature.levelGained === 1
		);

		level1Features?.forEach((feature: any) => {
			if (feature.choices) {
				feature.choices.forEach((choice: any, choiceIndex: number) => {
					const choiceId = `${classFeatures.className.toLowerCase()}_${feature.featureName
						.toLowerCase()
						.replace(/\s+/g, '_')}_${choiceIndex}`;
					const selectedOptions = selectedChoices[choiceId];

					if (selectedOptions) {
						let optionsToProcess: string[] = [];
						try {
							optionsToProcess = JSON.parse(selectedOptions);
							if (!Array.isArray(optionsToProcess)) {
								optionsToProcess = [selectedOptions];
							}
						} catch {
							optionsToProcess = [selectedOptions];
						}

						optionsToProcess.forEach((optionName) => {
							const selectedOption = choice.options?.find(
								(opt: any) => opt.name === optionName
							);
							if (selectedOption) {
								const description = selectedOption.description.toLowerCase();

								if (type === 'skill') {
									if (
										description.includes('skill mastery limit') ||
										description.includes('skill mastery cap')
									) {
										const masteryMatch = description.match(/increases? by (\d+)/i);
										if (masteryMatch) {
											bonus += parseInt(masteryMatch[1]);
										}
									}
								} else if (type === 'trade') {
									if (
										description.includes('mastery limit') &&
										(description.includes('trade') || description.includes('knowledge'))
									) {
										const masteryMatch = description.match(/increases? by (\d+)/i);
										if (masteryMatch) {
											bonus += parseInt(masteryMatch[1]);
										}
									}
								}
							}
						});
					}
				});
			}
		});
	} catch (error) {
		console.warn('Error calculating class mastery bonuses:', error);
	}
	return bonus;
};

export const validateLevel1MasteryRule = (
	skills: Record<string, number>,
	trades: Record<string, number>
): MasteryValidation => {
	const allMasteries = { ...skills, ...trades };
	const adeptCount = Object.values(allMasteries).filter((level) => level === 2).length;

	return {
		valid: adeptCount <= 1,
		adeptCount,
		message:
			adeptCount > 1
				? `Level 1 characters can only have ONE Adept skill/trade (currently: ${adeptCount})`
				: undefined
	};
};

export const getMasteryInfo = (level: number, maxMastery: number): MasteryInfo => {
	const masteryData = MASTERY_TABLE[level] || MASTERY_TABLE[0];
	return {
		level,
		name: masteryData.name,
		bonus: masteryData.bonus,
		available: level <= maxMastery
	};
};

export const useBackgroundPoints = (
	skillPointsUsed: number,
	tradePointsUsed: number,
	languagePointsUsed: number,
	intelligenceModifier: number,
	characterLevel: number = 1,
	classFeatures: any = null,
	selectedFeatureChoices: string = '{}',
	currentSkills: Record<string, number> = {},
	currentTrades: Record<string, number> = {}
) => {
	const [skillToTradeConversions, setSkillToTradeConversions] = React.useState(0);
	const [tradeToSkillConversions, setTradeToSkillConversions] = React.useState(0);
	const [tradeToLanguageConversions, setTradeToLanguageConversions] = React.useState(0);

	// Base points according to DC20 rules
	const baseSkillPoints = 5 + intelligenceModifier;
	const baseTradePoints = 3;
	const baseLanguagePoints = 2;

	// Calculate available points after conversions
	const availableSkillPoints =
		baseSkillPoints - skillToTradeConversions + Math.floor(tradeToSkillConversions / 2);
	const availableTradePoints =
		baseTradePoints -
		tradeToSkillConversions +
		skillToTradeConversions * 2 -
		tradeToLanguageConversions;
	const availableLanguagePoints = baseLanguagePoints + tradeToLanguageConversions * 2;

	// Conversion functions
	const convertSkillToTrade = () => {
		if (skillPointsUsed + 1 <= availableSkillPoints) {
			setSkillToTradeConversions((prev) => prev + 1);
		}
	};

	const convertTradeToSkill = () => {
		if (
			tradeToSkillConversions + 2 <= baseTradePoints + skillToTradeConversions * 2 &&
			tradePointsUsed + 2 <= availableTradePoints
		) {
			setTradeToSkillConversions((prev) => prev + 2);
		}
	};

	const convertTradeToLanguage = () => {
		if (availableTradePoints - tradePointsUsed >= 1) {
			setTradeToLanguageConversions((prev) => prev + 1);
		}
	};

	const resetConversions = () => {
		setSkillToTradeConversions(0);
		setTradeToSkillConversions(0);
		setTradeToLanguageConversions(0);
	};

	// Calculate mastery limits
	const baseMasteryLimit = getBaseMasteryLimit(characterLevel);
	const skillMasteryBonus = getClassMasteryBonuses(classFeatures, selectedFeatureChoices, 'skill');
	const tradeMasteryBonus = getClassMasteryBonuses(classFeatures, selectedFeatureChoices, 'trade');
	
	const maxSkillMastery = Math.min(5, baseMasteryLimit + skillMasteryBonus);
	const maxTradeMastery = Math.min(5, baseMasteryLimit + tradeMasteryBonus);
	
	const level1Validation = characterLevel === 1 
		? validateLevel1MasteryRule(currentSkills, currentTrades)
		: { valid: true, adeptCount: 0 };

	const masteryLimits: MasteryLimits = {
		maxSkillMastery,
		maxTradeMastery,
		level1Validation
	};

	const pointsData: BackgroundPointsData = {
		skillPointsUsed,
		tradePointsUsed,
		languagePointsUsed,
		baseSkillPoints,
		baseTradePoints,
		baseLanguagePoints,
		availableSkillPoints,
		availableTradePoints,
		availableLanguagePoints
	};

	const conversions: PointConversions = {
		skillToTradeConversions,
		tradeToSkillConversions,
		tradeToLanguageConversions
	};

	const actions: ConversionActions = {
		convertSkillToTrade,
		convertTradeToSkill,
		convertTradeToLanguage,
		resetConversions
	};

	return { pointsData, conversions, actions, masteryLimits };
};
````

## File: src/routes/character-creation/components/SkillsTab.tsx
````typescript
import React from 'react';
import { skillsData } from '../../../lib/rulesdata/skills';
import type {
	BackgroundPointsData,
	PointConversions,
	ConversionActions,
	MasteryLimits,
	MasteryInfo
} from './BackgroundPointsManager';
import {
	getMasteryInfo,
	MASTERY_TABLE
} from './BackgroundPointsManager';
import {
	StyledTabContent,
	StyledSelectionGrid,
	StyledSelectionItem,
	StyledSelectionHeader,
	StyledSelectionName,
	StyledProficiencySelector,
	StyledProficiencyButton,
	StyledPointsRemaining
} from '../styles/Background.styles';

interface SkillsTabProps {
	currentSkills: Record<string, number>;
	currentTrades: Record<string, number>;
	pointsData: BackgroundPointsData;
	conversions: PointConversions;
	actions: ConversionActions;
	masteryLimits: MasteryLimits;
	onSkillChange: (skillId: string, newLevel: number) => void;
}

const SkillsTab: React.FC<SkillsTabProps> = ({
	currentSkills,
	currentTrades,
	pointsData,
	conversions,
	actions,
	masteryLimits,
	onSkillChange
}) => {
	const canIncreaseProficiency = (
		pointCost: number,
		pointsUsed: number,
		availablePoints: number
	) => {
		return pointsUsed + pointCost <= availablePoints;
	};

	// Enhanced validation including mastery limits
	const canSelectMastery = (skillId: string, targetLevel: number): boolean => {
		// Check mastery limit
		if (targetLevel > masteryLimits.maxSkillMastery) return false;
		
		// Check Level 1 special rule for Adept (level 2)
		if (targetLevel === 2) {
			const currentlyAdept = currentSkills[skillId] === 2;
			if (!currentlyAdept && masteryLimits.level1Validation.adeptCount >= 1) {
				return false; // Already have one Adept skill/trade
			}
		}
		
		// Check point availability
		const pointCost = targetLevel - (currentSkills[skillId] || 0);
		return canIncreaseProficiency(pointCost, pointsData.skillPointsUsed, pointsData.availableSkillPoints);
	};

	// Helper function for consistent button styling
	const getButtonStyle = (enabled: boolean, variant: 'primary' | 'danger' = 'primary') => ({
		padding: '0.5rem 1rem',
		backgroundColor: enabled ? (variant === 'primary' ? '#3b82f6' : '#ef4444') : '#6b7280',
		color: 'white',
		border: 'none',
		borderRadius: '6px',
		fontSize: '0.875rem',
		fontWeight: '500',
		cursor: enabled ? 'pointer' : 'not-allowed',
		transition: 'all 0.2s ease',
		opacity: enabled ? 1 : 0.6,
		':hover': enabled
			? {
					backgroundColor: variant === 'primary' ? '#2563eb' : '#dc2626',
					transform: 'translateY(-1px)',
					boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)'
				}
			: {}
	});

	const hasConversions =
		conversions.skillToTradeConversions > 0 ||
		conversions.tradeToSkillConversions > 0 ||
		conversions.tradeToLanguageConversions > 0;

	return (
		<StyledTabContent>
			{/* Level 1 Validation Warning */}
			{!masteryLimits.level1Validation.valid && (
				<div style={{
					background: '#fee2e2',
					border: '1px solid #fecaca',
					color: '#991b1b',
					padding: '0.75rem',
					borderRadius: '0.5rem',
					marginBottom: '1rem'
				}}>
					⚠️ Level 1 characters can only have ONE Adept (level 2) skill or trade total.
					Currently: {masteryLimits.level1Validation.adeptCount} Adept selections.
				</div>
			)}
			
			{/* Mastery Limits Info */}
			<div style={{
				background: '#f3f4f6',
				border: '1px solid #d1d5db',
				padding: '0.5rem',
				borderRadius: '0.375rem',
				marginBottom: '1rem',
				fontSize: '0.875rem'
			}}>
				<strong>Mastery Limits:</strong> Max level {masteryLimits.maxSkillMastery} 
				({MASTERY_TABLE[masteryLimits.maxSkillMastery]?.name})
			</div>

			<StyledPointsRemaining>
				Skill Points: {pointsData.availableSkillPoints - pointsData.skillPointsUsed} /{' '}
				{pointsData.availableSkillPoints} remaining
				{pointsData.baseSkillPoints !== 5 && (
					<div
						style={{
							fontSize: '0.9rem',
							color: pointsData.baseSkillPoints > 5 ? '#10b981' : '#ef4444',
							marginTop: '0.5rem',
							padding: '0.25rem 0.5rem',
							backgroundColor: pointsData.baseSkillPoints > 5 ? '#065f461a' : '#dc26261a',
							borderRadius: '4px',
							border: `1px solid ${pointsData.baseSkillPoints > 5 ? '#10b981' : '#ef4444'}33`
						}}
					>
						Intelligence modifier: {pointsData.baseSkillPoints > 5 ? '+' : ''}
						{pointsData.baseSkillPoints - 5}
					</div>
				)}
				{hasConversions && (
					<div
						style={{
							fontSize: '0.9rem',
							color: '#6366f1',
							marginTop: '0.5rem',
							padding: '0.25rem 0.5rem',
							backgroundColor: '#6366f11a',
							borderRadius: '4px',
							border: '1px solid #6366f133'
						}}
					>
						Active conversions:{' '}
						{conversions.skillToTradeConversions > 0
							? `${conversions.skillToTradeConversions} skill → ${conversions.skillToTradeConversions * 2} trade`
							: ''}
						{conversions.skillToTradeConversions > 0 &&
						(conversions.tradeToSkillConversions > 0 || conversions.tradeToLanguageConversions > 0)
							? ', '
							: ''}
						{conversions.tradeToSkillConversions > 0
							? `${conversions.tradeToSkillConversions} trade → ${Math.floor(conversions.tradeToSkillConversions / 2)} skill`
							: ''}
						{conversions.tradeToSkillConversions > 0 && conversions.tradeToLanguageConversions > 0
							? ', '
							: ''}
						{conversions.tradeToLanguageConversions > 0
							? `${conversions.tradeToLanguageConversions} trade → ${conversions.tradeToLanguageConversions * 2} language`
							: ''}
					</div>
				)}
				<div
					style={{
						marginTop: '0.75rem',
						display: 'flex',
						gap: '0.5rem',
						flexWrap: 'wrap'
					}}
				>
					<button
						onClick={actions.convertSkillToTrade}
						disabled={pointsData.availableSkillPoints - pointsData.skillPointsUsed < 1}
						style={getButtonStyle(
							pointsData.availableSkillPoints - pointsData.skillPointsUsed >= 1
						)}
						onMouseEnter={(e) => {
							if (pointsData.availableSkillPoints - pointsData.skillPointsUsed >= 1) {
								e.currentTarget.style.backgroundColor = '#2563eb';
								e.currentTarget.style.transform = 'translateY(-1px)';
								e.currentTarget.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
							}
						}}
						onMouseLeave={(e) => {
							if (pointsData.availableSkillPoints - pointsData.skillPointsUsed >= 1) {
								e.currentTarget.style.backgroundColor = '#3b82f6';
								e.currentTarget.style.transform = 'translateY(0)';
								e.currentTarget.style.boxShadow = 'none';
							}
						}}
					>
						Convert 1 Skill → 2 Trade Points
					</button>
					<button
						onClick={actions.resetConversions}
						disabled={!hasConversions}
						style={getButtonStyle(hasConversions, 'danger')}
						onMouseEnter={(e) => {
							if (hasConversions) {
								e.currentTarget.style.backgroundColor = '#dc2626';
								e.currentTarget.style.transform = 'translateY(-1px)';
								e.currentTarget.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
							}
						}}
						onMouseLeave={(e) => {
							if (hasConversions) {
								e.currentTarget.style.backgroundColor = '#ef4444';
								e.currentTarget.style.transform = 'translateY(0)';
								e.currentTarget.style.boxShadow = 'none';
							}
						}}
					>
						Reset Conversions
					</button>
				</div>
			</StyledPointsRemaining>
			<StyledSelectionGrid>
							{skillsData.map((skill) => {
				const currentLevel = currentSkills[skill.id] || 0;
				const masteryInfo = getMasteryInfo(currentLevel, masteryLimits.maxSkillMastery);
				
				return (
					<StyledSelectionItem key={skill.id}>
						<StyledSelectionHeader>
							<StyledSelectionName>{skill.name}</StyledSelectionName>
							<div style={{ fontSize: '0.75rem', color: '#6b7280' }}>
								{masteryInfo.name} (+{masteryInfo.bonus}) • {skill.attributeAssociation}
							</div>
						</StyledSelectionHeader>
						<div style={{ fontSize: '0.9rem', color: '#cbd5e1', marginBottom: '0.5rem' }}>
							{skill.description}
						</div>
						<StyledProficiencySelector>
							{[0, 1, 2, 3, 4, 5].map((level) => {
								const masteryDisplay = getMasteryInfo(level, masteryLimits.maxSkillMastery);
								const canSelect = canSelectMastery(skill.id, level);
								
								return (
									<StyledProficiencyButton
										key={level}
										$active={currentLevel === level}
										$disabled={!canSelect && level !== currentLevel}
										title={`${masteryDisplay.name} (+${masteryDisplay.bonus})`}
										onClick={() => {
											if (canSelect || level === currentLevel) {
												onSkillChange(skill.id, level);
											}
										}}
									>
										{level}
									</StyledProficiencyButton>
								);
							})}
						</StyledProficiencySelector>
					</StyledSelectionItem>
				);
			})}
			</StyledSelectionGrid>
		</StyledTabContent>
	);
};

export default SkillsTab;
````

## File: src/routes/character-creation/components/TradesTab.tsx
````typescript
import React from 'react';
import { tradesData } from '../../../lib/rulesdata/trades';
import { knowledgeData } from '../../../lib/rulesdata/knowledge';
import type {
	BackgroundPointsData,
	PointConversions,
	ConversionActions,
	MasteryLimits,
	MasteryInfo
} from './BackgroundPointsManager';
import {
	getMasteryInfo,
	MASTERY_TABLE
} from './BackgroundPointsManager';
import {
	StyledTabContent,
	StyledSelectionGrid,
	StyledSelectionItem,
	StyledSelectionHeader,
	StyledSelectionName,
	StyledProficiencySelector,
	StyledProficiencyButton,
	StyledPointsRemaining
} from '../styles/Background.styles';

// Combine trades and knowledge for selection
const allTradesAndKnowledge = [...tradesData, ...knowledgeData];

interface TradesTabProps {
	currentTrades: Record<string, number>;
	currentSkills: Record<string, number>;
	pointsData: BackgroundPointsData;
	conversions: PointConversions;
	actions: ConversionActions;
	masteryLimits: MasteryLimits;
	onTradeChange: (tradeId: string, newLevel: number) => void;
}

const TradesTab: React.FC<TradesTabProps> = ({
	currentTrades,
	currentSkills,
	pointsData,
	conversions,
	actions,
	masteryLimits,
	onTradeChange
}) => {
	const canIncreaseProficiency = (
		pointCost: number,
		pointsUsed: number,
		availablePoints: number
	) => {
		return pointsUsed + pointCost <= availablePoints;
	};

	// Enhanced validation including mastery limits
	const canSelectMastery = (tradeId: string, targetLevel: number): boolean => {
		// Check mastery limit
		if (targetLevel > masteryLimits.maxTradeMastery) return false;
		
		// Check Level 1 special rule for Adept (level 2)
		if (targetLevel === 2) {
			const currentlyAdept = currentTrades[tradeId] === 2;
			if (!currentlyAdept && masteryLimits.level1Validation.adeptCount >= 1) {
				return false; // Already have one Adept skill/trade
			}
		}
		
		// Check point availability
		const pointCost = targetLevel - (currentTrades[tradeId] || 0);
		return canIncreaseProficiency(pointCost, pointsData.tradePointsUsed, pointsData.availableTradePoints);
	};

	// Helper function for consistent button styling
	const getButtonStyle = (enabled: boolean, variant: 'primary' | 'danger' = 'primary') => ({
		padding: '0.5rem 1rem',
		backgroundColor: enabled ? (variant === 'primary' ? '#3b82f6' : '#ef4444') : '#6b7280',
		color: 'white',
		border: 'none',
		borderRadius: '6px',
		fontSize: '0.875rem',
		fontWeight: '500',
		cursor: enabled ? 'pointer' : 'not-allowed',
		transition: 'all 0.2s ease',
		opacity: enabled ? 1 : 0.6,
		':hover': enabled
			? {
					backgroundColor: variant === 'primary' ? '#2563eb' : '#dc2626',
					transform: 'translateY(-1px)',
					boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)'
				}
			: {}
	});

	const hasConversions =
		conversions.skillToTradeConversions > 0 ||
		conversions.tradeToSkillConversions > 0 ||
		conversions.tradeToLanguageConversions > 0;

	return (
		<StyledTabContent>
			{/* Level 1 Validation Warning */}
			{!masteryLimits.level1Validation.valid && (
				<div style={{
					background: '#fee2e2',
					border: '1px solid #fecaca',
					color: '#991b1b',
					padding: '0.75rem',
					borderRadius: '0.5rem',
					marginBottom: '1rem'
				}}>
					⚠️ Level 1 characters can only have ONE Adept (level 2) skill or trade total.
					Currently: {masteryLimits.level1Validation.adeptCount} Adept selections.
				</div>
			)}
			
			{/* Mastery Limits Info */}
			<div style={{
				background: '#f3f4f6',
				border: '1px solid #d1d5db',
				padding: '0.5rem',
				borderRadius: '0.375rem',
				marginBottom: '1rem',
				fontSize: '0.875rem'
			}}>
				<strong>Mastery Limits:</strong> Max level {masteryLimits.maxTradeMastery} 
				({MASTERY_TABLE[masteryLimits.maxTradeMastery]?.name})
			</div>

			<StyledPointsRemaining>
				Trade Points: {pointsData.availableTradePoints - pointsData.tradePointsUsed} /{' '}
				{pointsData.availableTradePoints} remaining
				{hasConversions && (
					<div
						style={{
							fontSize: '0.9rem',
							color: '#6366f1',
							marginTop: '0.5rem',
							padding: '0.25rem 0.5rem',
							backgroundColor: '#6366f11a',
							borderRadius: '4px',
							border: '1px solid #6366f133'
						}}
					>
						Active conversions:{' '}
						{conversions.skillToTradeConversions > 0
							? `${conversions.skillToTradeConversions} skill → ${conversions.skillToTradeConversions * 2} trade`
							: ''}
						{conversions.skillToTradeConversions > 0 &&
						(conversions.tradeToSkillConversions > 0 || conversions.tradeToLanguageConversions > 0)
							? ', '
							: ''}
						{conversions.tradeToSkillConversions > 0
							? `${conversions.tradeToSkillConversions} trade → ${Math.floor(conversions.tradeToSkillConversions / 2)} skill`
							: ''}
						{conversions.tradeToSkillConversions > 0 && conversions.tradeToLanguageConversions > 0
							? ', '
							: ''}
						{conversions.tradeToLanguageConversions > 0
							? `${conversions.tradeToLanguageConversions} trade → ${conversions.tradeToLanguageConversions * 2} language`
							: ''}
					</div>
				)}
				<div
					style={{
						marginTop: '0.75rem',
						display: 'flex',
						gap: '0.5rem',
						flexWrap: 'wrap'
					}}
				>
					<button
						onClick={actions.convertTradeToSkill}
						disabled={pointsData.availableTradePoints - pointsData.tradePointsUsed < 2}
						style={getButtonStyle(
							pointsData.availableTradePoints - pointsData.tradePointsUsed >= 2
						)}
						onMouseEnter={(e) => {
							if (pointsData.availableTradePoints - pointsData.tradePointsUsed >= 2) {
								e.currentTarget.style.backgroundColor = '#2563eb';
								e.currentTarget.style.transform = 'translateY(-1px)';
								e.currentTarget.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
							}
						}}
						onMouseLeave={(e) => {
							if (pointsData.availableTradePoints - pointsData.tradePointsUsed >= 2) {
								e.currentTarget.style.backgroundColor = '#3b82f6';
								e.currentTarget.style.transform = 'translateY(0)';
								e.currentTarget.style.boxShadow = 'none';
							}
						}}
					>
						Convert 2 Trade → 1 Skill Point
					</button>
					<button
						onClick={actions.convertTradeToLanguage}
						disabled={pointsData.availableTradePoints - pointsData.tradePointsUsed < 1}
						style={getButtonStyle(
							pointsData.availableTradePoints - pointsData.tradePointsUsed >= 1
						)}
						onMouseEnter={(e) => {
							if (pointsData.availableTradePoints - pointsData.tradePointsUsed >= 1) {
								e.currentTarget.style.backgroundColor = '#2563eb';
								e.currentTarget.style.transform = 'translateY(-1px)';
								e.currentTarget.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
							}
						}}
						onMouseLeave={(e) => {
							if (pointsData.availableTradePoints - pointsData.tradePointsUsed >= 1) {
								e.currentTarget.style.backgroundColor = '#3b82f6';
								e.currentTarget.style.transform = 'translateY(0)';
								e.currentTarget.style.boxShadow = 'none';
							}
						}}
					>
						Convert 1 Trade → 2 Language Points
					</button>
					<button
						onClick={actions.resetConversions}
						disabled={!hasConversions}
						style={getButtonStyle(hasConversions, 'danger')}
						onMouseEnter={(e) => {
							if (hasConversions) {
								e.currentTarget.style.backgroundColor = '#dc2626';
								e.currentTarget.style.transform = 'translateY(-1px)';
								e.currentTarget.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
							}
						}}
						onMouseLeave={(e) => {
							if (hasConversions) {
								e.currentTarget.style.backgroundColor = '#ef4444';
								e.currentTarget.style.transform = 'translateY(0)';
								e.currentTarget.style.boxShadow = 'none';
							}
						}}
					>
						Reset Conversions
					</button>
				</div>
			</StyledPointsRemaining>
			<StyledSelectionGrid>
							{allTradesAndKnowledge.map((trade) => {
				const currentLevel = currentTrades[trade.id] || 0;
				const masteryInfo = getMasteryInfo(currentLevel, masteryLimits.maxTradeMastery);
				
				return (
					<StyledSelectionItem key={trade.id}>
						<StyledSelectionHeader>
							<StyledSelectionName>{trade.name}</StyledSelectionName>
							<div style={{ fontSize: '0.75rem', color: '#6b7280' }}>
								{masteryInfo.name} (+{masteryInfo.bonus}) • {trade.attributeAssociation}
							</div>
						</StyledSelectionHeader>
						<div style={{ fontSize: '0.9rem', color: '#cbd5e1', marginBottom: '0.5rem' }}>
							{trade.description}
						</div>
						{(trade as any).tools && (
							<div
								style={{
									fontSize: '0.8rem',
									color: '#fbbf24',
									marginBottom: '0.5rem',
									fontStyle: 'italic'
								}}
							>
								Tools: {(trade as any).tools}
							</div>
						)}
						<StyledProficiencySelector>
							{[0, 1, 2, 3, 4, 5].map((level) => {
								const masteryDisplay = getMasteryInfo(level, masteryLimits.maxTradeMastery);
								const canSelect = canSelectMastery(trade.id, level);
								
								return (
									<StyledProficiencyButton
										key={level}
										$active={currentLevel === level}
										$disabled={!canSelect && level !== currentLevel}
										title={`${masteryDisplay.name} (+${masteryDisplay.bonus})`}
										onClick={() => {
											if (canSelect || level === currentLevel) {
												onTradeChange(trade.id, level);
											}
										}}
									>
										{level}
									</StyledProficiencyButton>
								);
							})}
						</StyledProficiencySelector>
					</StyledSelectionItem>
				);
			})}
		</StyledSelectionGrid>
		</StyledTabContent>
	);
};

export default TradesTab;
````

## File: src/routes/character-creation/styles/AncestryPointsCounter.styles.ts
````typescript
import styled from 'styled-components';

export const StyledContainer = styled.div`
	padding: 1.5rem;
	border: 2px solid #8b5cf6;
	border-radius: 12px;
	background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
	margin-bottom: 1rem;
	box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3);
	text-align: center;
`;

export const StyledTitle = styled.h2`
	margin: 0;
	color: #fbbf24;
	font-size: 1.3rem;
	font-weight: bold;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	letter-spacing: 1px;
	border-bottom: 2px solid #ef4444;
	padding-bottom: 0.5rem;
`;

export const StyledDetails = styled.div`
	margin-top: 0.5rem;
	color: #d1d5db;
	font-size: 0.9rem;
	font-weight: normal;
`;
````

## File: src/routes/character-creation/styles/AncestrySelector.styles.ts
````typescript
import styled from 'styled-components';

export const StyledContainer = styled.div`
	border: 2px solid #8b5cf6;
	padding: 1.5rem;
	border-radius: 12px;
	background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
	margin-top: 2rem;
	box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3);
`;

export const StyledTitle = styled.h2`
	margin-top: 0;
	color: #fbbf24;
	font-size: 1.3rem;
	font-weight: bold;
	text-align: center;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	letter-spacing: 1px;
	border-bottom: 2px solid #ef4444;
	padding-bottom: 0.5rem;
	margin-bottom: 1rem;
`;

export const StyledGrid = styled.div`
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
	gap: 1rem;
	margin-top: 1rem;
`;

export const StyledCard = styled.div<{ $selected: boolean }>`
	border: 2px solid #a855f7;
	padding: 1.5rem;
	border-radius: 10px;
	background: linear-gradient(145deg, #2d1b69 0%, #4c1d95 100%);
	cursor: pointer;
	transition: all 0.3s ease;
	text-align: left;
	box-shadow: 0 4px 15px rgba(168, 85, 247, 0.2);
	height: 200px;
	display: flex;
	flex-direction: column;
	overflow: hidden;
	position: relative;

	&:hover {
		transform: translateY(-2px);
		box-shadow: 0 8px 25px rgba(168, 85, 247, 0.4);
		border-color: #fbbf24;
	}

	${(props) =>
		props.$selected &&
		`
    border-color: #ef4444;
    background: linear-gradient(145deg, #991b1b 0%, #dc2626 100%);
    box-shadow: 0 8px 25px rgba(239, 68, 68, 0.5);
    transform: translateY(-2px);
  `}
`;

export const StyledCardHeader = styled.div`
	display: flex;
	align-items: center;
	gap: 1rem;
	margin-bottom: 1rem;
`;

export const StyledAncestryIcon = styled.div`
	font-size: 2rem;
	flex-shrink: 0;
	background: linear-gradient(145deg, #8b5cf6 0%, #a855f7 100%);
	border-radius: 50%;
	width: 50px;
	height: 50px;
	display: flex;
	align-items: center;
	justify-content: center;
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
`;

export const StyledCardTitle = styled.h3`
	margin: 0;
	color: #fbbf24;
	font-size: 1.4rem;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledCardDescription = styled.p`
	margin: 0;
	color: #e5e7eb;
	font-size: 0.9rem;
	line-height: 1.4;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	flex: 1;
	overflow: hidden;
	display: -webkit-box;
	-webkit-line-clamp: 3;
	-webkit-box-orient: vertical;
	position: relative;
`;

export const StyledCardFooter = styled.div`
	margin-top: 0.5rem;
	display: flex;
	justify-content: flex-end;
`;

export const StyledReadMore = styled.span`
	color: #fbbf24;
	font-size: 0.85rem;
	font-weight: bold;
	cursor: pointer;
	text-decoration: underline;
	padding: 0.5rem 0.75rem;
	border-radius: 4px;
	transition: all 0.2s ease;
	display: inline-block;

	&:hover {
		color: #f59e0b;
		background: rgba(251, 191, 36, 0.1);
	}

	&:active {
		transform: scale(0.95);
	}
`;

export const StyledTooltip = styled.div<{ $show: boolean }>`
	position: fixed;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	background: linear-gradient(145deg, #1e1b4b 0%, #312e81 100%);
	color: #e5e7eb;
	padding: 2rem;
	border-radius: 12px;
	border: 3px solid #8b5cf6;
	box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
	z-index: 2000;
	width: 90vw;
	max-width: 500px;
	max-height: 80vh;
	overflow-y: auto;
	font-size: 1rem;
	line-height: 1.6;
	opacity: ${(props) => (props.$show ? 1 : 0)};
	pointer-events: ${(props) => (props.$show ? 'auto' : 'none')};
	transition: opacity 0.3s ease;

	/* Custom scrollbar for popup */
	::-webkit-scrollbar {
		width: 8px;
	}

	::-webkit-scrollbar-track {
		background: #1e1b4b;
		border-radius: 4px;
	}

	::-webkit-scrollbar-thumb {
		background: #8b5cf6;
		border-radius: 4px;
	}

	::-webkit-scrollbar-thumb:hover {
		background: #a855f7;
	}
`;

export const StyledTooltipOverlay = styled.div<{ $show: boolean }>`
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background: rgba(0, 0, 0, 0.7);
	z-index: 1999;
	opacity: ${(props) => (props.$show ? 1 : 0)};
	pointer-events: ${(props) => (props.$show ? 'auto' : 'none')};
	transition: opacity 0.3s ease;
`;

export const StyledTooltipHeader = styled.div`
	display: flex;
	align-items: center;
	gap: 1rem;
	margin-bottom: 1.5rem;
	padding-bottom: 1rem;
	border-bottom: 2px solid #8b5cf6;
`;

export const StyledTooltipIcon = styled.div`
	font-size: 3rem;
	background: linear-gradient(145deg, #8b5cf6 0%, #a855f7 100%);
	border-radius: 50%;
	width: 70px;
	height: 70px;
	display: flex;
	align-items: center;
	justify-content: center;
	box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
`;

export const StyledTooltipTitle = styled.h3`
	margin: 0;
	color: #fbbf24;
	font-size: 1.8rem;
	font-weight: bold;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
`;

export const StyledTooltipContent = styled.p`
	margin: 0;
	color: #e5e7eb;
	font-size: 1.1rem;
	line-height: 1.6;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledCloseHint = styled.div`
	margin-top: 1.5rem;
	padding-top: 1rem;
	border-top: 1px solid #8b5cf6;
	text-align: center;
	color: #9ca3af;
	font-size: 0.9rem;
	font-style: italic;
`;
````

## File: src/routes/character-creation/styles/CharacterName.styles.ts
````typescript
import styled from 'styled-components';

export const StyledContainer = styled.div`
	border: 2px solid #8b5cf6;
	padding: 2rem;
	border-radius: 12px;
	background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
	margin-top: 2rem;
	box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3);
	max-width: 600px;
	margin: 2rem auto;
`;

export const StyledTitle = styled.h2`
	margin-top: 0;
	color: #fbbf24;
	font-size: 1.3rem;
	font-weight: bold;
	text-align: center;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	letter-spacing: 1px;
	border-bottom: 2px solid #ef4444;
	padding-bottom: 0.5rem;
	margin-bottom: 2rem;
`;

export const StyledInputGroup = styled.div`
	margin-bottom: 1.5rem;
`;

export const StyledLabel = styled.label`
	display: block;
	margin-bottom: 0.5rem;
	color: #fbbf24;
	font-weight: bold;
	font-size: 1rem;
`;

export const StyledInput = styled.input`
	width: 100%;
	padding: 0.75rem;
	border: 2px solid #a855f7;
	border-radius: 8px;
	background: rgba(45, 27, 105, 0.8);
	color: #e5e7eb;
	font-size: 1rem;
	transition: all 0.3s ease;

	&:focus {
		outline: none;
		border-color: #fbbf24;
		box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.2);
	}

	&::placeholder {
		color: #9ca3af;
	}
`;

export const StyledSuggestionSection = styled.div`
	margin-top: 1.5rem;
	padding: 1.5rem;
	border: 2px solid #a855f7;
	border-radius: 8px;
	background: rgba(45, 27, 105, 0.4);
`;

export const StyledSuggestionTitle = styled.h3`
	margin: 0 0 1rem 0;
	color: #fbbf24;
	font-size: 1.1rem;
	font-weight: bold;
`;

export const StyledSuggestionGrid = styled.div`
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
	gap: 0.5rem;
	margin-bottom: 1rem;
	max-height: 200px;
	overflow-y: auto;
`;

export const StyledSuggestionButton = styled.button`
	padding: 0.5rem 1rem;
	border: 2px solid #a855f7;
	border-radius: 6px;
	background: transparent;
	color: #e5e7eb;
	cursor: pointer;
	transition: all 0.3s ease;
	font-size: 0.9rem;

	&:hover {
		background: #a855f7;
		color: #1e1b4b;
		transform: translateY(-2px);
	}
`;

export const StyledGenerateButton = styled.button`
	padding: 0.75rem 1.5rem;
	border: none;
	border-radius: 8px;
	background: linear-gradient(145deg, #fbbf24 0%, #f59e0b 100%);
	color: #1e1b4b;
	font-weight: bold;
	cursor: pointer;
	transition: all 0.3s ease;
	width: 100%;

	&:hover {
		background: linear-gradient(145deg, #f59e0b 0%, #d97706 100%);
		transform: translateY(-2px);
		box-shadow: 0 4px 12px rgba(251, 191, 36, 0.4);
	}

	&:disabled {
		opacity: 0.5;
		cursor: not-allowed;
		transform: none;
	}
`;

export const StyledCharacterInfo = styled.div`
	margin-bottom: 1.5rem;
	padding: 1rem;
	border: 2px solid #ef4444;
	border-radius: 8px;
	background: rgba(239, 68, 68, 0.1);
	text-align: center;
`;

export const StyledCharacterDetails = styled.p`
	margin: 0;
	color: #e5e7eb;
	font-size: 1rem;
	line-height: 1.6;
`;
````

## File: src/routes/character-creation/styles/ClassFeatures.styles.ts
````typescript
import styled from 'styled-components';

export const StyledContainer = styled.div`
	border: 2px solid #8b5cf6;
	padding: 1.5rem;
	border-radius: 12px;
	background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
	margin-top: 2rem;
	box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3);
`;

export const StyledTitle = styled.h2`
	margin-top: 0;
	color: #fbbf24;
	font-size: 1.3rem;
	font-weight: bold;
	text-align: center;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	letter-spacing: 1px;
	border-bottom: 2px solid #ef4444;
	padding-bottom: 0.5rem;
	margin-bottom: 1rem;
`;

export const StyledSection = styled.div`
	margin-top: 1rem;
`;

export const StyledSectionTitle = styled.h3`
	margin: 0 0 1rem 0;
	color: #ef4444;
	font-size: 1.5rem;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	border-bottom: 2px solid #ef4444;
	padding-bottom: 0.5rem;
`;

export const StyledCard = styled.div`
	border: 2px solid #a855f7;
	padding: 1.5rem;
	border-radius: 10px;
	margin-bottom: 1rem;
	background: linear-gradient(145deg, #2d1b69 0%, #4c1d95 100%);
	box-shadow: 0 4px 15px rgba(168, 85, 247, 0.2);
`;

export const StyledCardTitle = styled.h4`
	margin: 0 0 0.5rem 0;
	color: #fbbf24;
	font-size: 1.3rem;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledCardDescription = styled.p`
	margin: 0;
	color: #e5e7eb;
	line-height: 1.4;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledChoiceOptions = styled.div`
	display: flex;
	flex-direction: column;
	gap: 0.5rem;
`;

export const StyledLabel = styled.label`
	display: flex;
	align-items: flex-start;
	gap: 0.8rem;
	cursor: pointer;
	color: #e5e7eb;
	font-size: 0.95rem;
	line-height: 1.4;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	padding: 0.5rem;
	border-radius: 5px;
	transition: all 0.2s ease;

	&:hover {
		color: #fbbf24;
		background: rgba(139, 92, 246, 0.1);
	}
`;

export const StyledRadio = styled.input`
	margin-top: 0.25rem;
	flex-shrink: 0;
	width: 18px;
	height: 18px;
	accent-color: #ef4444;
	cursor: pointer;
`;

export const StyledOptionDescription = styled.span`
	font-size: 0.9em;
	color: #9ca3af;
	margin-left: 0.5rem;
	font-style: italic;
`;

export const StyledNoSelection = styled.p`
	color: #9ca3af;
	font-style: italic;
	text-align: center;
	font-size: 1.1rem;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledBenefitsList = styled.div`
	margin-top: 1rem;
	padding-left: 0.5rem;
`;

export const StyledBenefit = styled.div`
	margin-bottom: 0.75rem;
	padding: 0.5rem;
	border-left: 3px solid #ef4444;
	background: rgba(139, 92, 246, 0.1);
	border-radius: 0 5px 5px 0;
`;

export const StyledBenefitName = styled.h5`
	margin: 0 0 0.25rem 0;
	color: #fbbf24;
	font-size: 1rem;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledBenefitDescription = styled.p`
	margin: 0;
	color: #e5e7eb;
	font-size: 0.9rem;
	line-height: 1.4;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;
````

## File: src/routes/character-creation/AncestrySelector.tsx
````typescript
import { useState } from 'react';
import { useCharacter } from '../../lib/stores/characterContext';
import { ancestriesData } from '../../lib/rulesdata/ancestries';
import type { IAncestry } from '../../lib/rulesdata/types';
import {
	StyledContainer,
	StyledTitle,
	StyledGrid,
	StyledCard,
	StyledCardHeader,
	StyledAncestryIcon,
	StyledCardTitle,
	StyledCardDescription,
	StyledCardFooter,
	StyledReadMore,
	StyledTooltip,
	StyledTooltipOverlay,
	StyledTooltipHeader,
	StyledTooltipIcon,
	StyledTooltipTitle,
	StyledTooltipContent,
	StyledCloseHint
} from './styles/AncestrySelector.styles';

// Ancestry-specific icons using Unicode symbols and emojis
const ancestryIcons: { [key: string]: string } = {
	human: '👤',
	elf: '🧝‍♂️',
	dwarf: '🧔',
	halfling: '🧙‍♂️',
	dragonborn: '🐉',
	gnome: '🎭',
	'half-elf': '🧝‍♀️',
	'half-orc': '👹',
	tiefling: '😈',
	orc: '🗡️',
	goblin: '👺',
	kobold: '🦎',
	default: '🌟'
};

function AncestrySelector() {
	const { state, dispatch } = useCharacter();
	const [popupAncestry, setPopupAncestry] = useState<string | null>(null);

	const selectedAncestries: string[] = [];
	if (state.ancestry1Id) selectedAncestries.push(state.ancestry1Id);
	if (state.ancestry2Id) selectedAncestries.push(state.ancestry2Id);

	function handleSelectAncestry(ancestryId: string) {
		const isSelected = selectedAncestries.includes(ancestryId);

		if (isSelected) {
			// Deselect
			let newAncestry1Id = state.ancestry1Id;
			let newAncestry2Id = state.ancestry2Id;

			if (state.ancestry1Id === ancestryId) {
				newAncestry1Id = null;
			} else if (state.ancestry2Id === ancestryId) {
				newAncestry2Id = null;
			}

			dispatch({ type: 'SET_ANCESTRY', ancestry1Id: newAncestry1Id, ancestry2Id: newAncestry2Id });
		} else {
			// Select
			if (!state.ancestry1Id) {
				dispatch({ type: 'SET_ANCESTRY', ancestry1Id: ancestryId, ancestry2Id: state.ancestry2Id });
			} else if (!state.ancestry2Id) {
				dispatch({ type: 'SET_ANCESTRY', ancestry1Id: state.ancestry1Id, ancestry2Id: ancestryId });
			}
		}
	}

	function getAncestryIcon(ancestryId: string): string {
		return ancestryIcons[ancestryId.toLowerCase()] || ancestryIcons.default;
	}

	function truncateText(text: string, maxLength: number): string {
		if (text.length <= maxLength) return text;
		return text.substring(0, maxLength) + '...';
	}

	function needsReadMore(text: string, maxLength: number): boolean {
		return text.length > maxLength;
	}

	function openPopup(ancestryId: string) {
		setPopupAncestry(ancestryId);
	}

	function closePopup() {
		setPopupAncestry(null);
	}

	return (
		<StyledContainer>
			<StyledTitle>Choose Your Ancestry</StyledTitle>
			<StyledGrid>
				{ancestriesData.map((ancestry: IAncestry) => (
					<StyledCard
						key={ancestry.id}
						$selected={selectedAncestries.includes(ancestry.id)}
						onClick={() => handleSelectAncestry(ancestry.id)}
					>
						<StyledCardHeader>
							<StyledAncestryIcon>{getAncestryIcon(ancestry.id)}</StyledAncestryIcon>
							<StyledCardTitle>{ancestry.name}</StyledCardTitle>
						</StyledCardHeader>
						<StyledCardDescription>{truncateText(ancestry.description, 80)}</StyledCardDescription>
						{needsReadMore(ancestry.description, 80) && (
							<StyledCardFooter>
								<StyledReadMore
									onClick={(e) => {
										e.stopPropagation();
										openPopup(ancestry.id);
									}}
								>
									read more...
								</StyledReadMore>
							</StyledCardFooter>
						)}
					</StyledCard>
				))}
			</StyledGrid>

			{/* Popup overlay and content */}
			<StyledTooltipOverlay $show={popupAncestry !== null} onClick={closePopup} />
			{popupAncestry && (
				<StyledTooltip $show={popupAncestry !== null}>
					<StyledTooltipHeader>
						<StyledTooltipIcon>{getAncestryIcon(popupAncestry)}</StyledTooltipIcon>
						<StyledTooltipTitle>
							{ancestriesData.find((a) => a.id === popupAncestry)?.name}
						</StyledTooltipTitle>
					</StyledTooltipHeader>
					<StyledTooltipContent>
						{ancestriesData.find((a) => a.id === popupAncestry)?.description}
					</StyledTooltipContent>
					<StyledCloseHint>Click anywhere to close</StyledCloseHint>
				</StyledTooltip>
			)}
		</StyledContainer>
	);
}

export default AncestrySelector;
````

## File: src/routes/character-creation/ClassSelector.tsx
````typescript
import { useState } from 'react';
import { useCharacter } from '../../lib/stores/characterContext';
import { classesData } from '../../lib/rulesdata/loaders/class.loader';
import type { IClassDefinition } from '../../lib/rulesdata/types';
import {
	StyledContainer,
	StyledTitle,
	StyledGrid,
	StyledCard,
	StyledCardHeader,
	StyledClassIcon,
	StyledCardTitle,
	StyledCardDescription,
	StyledCardFooter,
	StyledReadMore,
	StyledTooltip,
	StyledTooltipOverlay,
	StyledTooltipHeader,
	StyledTooltipIcon,
	StyledTooltipTitle,
	StyledTooltipContent,
	StyledCloseHint
} from './styles/ClassSelector.styles';

// Class-specific icons using Unicode symbols and emojis
const classIcons: { [key: string]: string } = {
	fighter: '⚔️',
	wizard: '🧙‍♂️',
	rogue: '🗡️',
	cleric: '✨',
	ranger: '🏹',
	barbarian: '🪓',
	bard: '🎭',
	druid: '🌿',
	monk: '👊',
	paladin: '🛡️',
	sorcerer: '🔥',
	warlock: '👹',
	default: '⚡'
};

function ClassSelector() {
	const { state, dispatch } = useCharacter();
	const selectedClassId = state.classId;
	const [popupClass, setPopupClass] = useState<string | null>(null);

	function handleSelectClass(classId: string) {
		if (state.classId === classId) {
			dispatch({ type: 'SET_CLASS', classId: null }); // Deselect if already selected
		} else {
			dispatch({ type: 'SET_CLASS', classId }); // Select new class
		}
	}

	function getClassIcon(classId: string): string {
		return classIcons[classId.toLowerCase()] || classIcons.default;
	}

	function truncateText(text: string, maxLength: number): string {
		if (text.length <= maxLength) return text;
		return text.substring(0, maxLength) + '...';
	}

	function needsReadMore(text: string, maxLength: number): boolean {
		return text.length > maxLength;
	}

	function openPopup(classId: string) {
		setPopupClass(classId);
	}

	function closePopup() {
		setPopupClass(null);
	}

	return (
		<StyledContainer>
			<StyledTitle>Choose Your Class</StyledTitle>
			<StyledGrid>
				{classesData.map((classDef: IClassDefinition) => (
					<StyledCard
						key={classDef.id}
						type="button"
						$selected={selectedClassId === classDef.id}
						onClick={() => handleSelectClass(classDef.id)}
					>
						<StyledCardHeader>
							<StyledClassIcon>{getClassIcon(classDef.id)}</StyledClassIcon>
							<StyledCardTitle>{classDef.name}</StyledCardTitle>
						</StyledCardHeader>
						<StyledCardDescription>{truncateText(classDef.description, 80)}</StyledCardDescription>
						{needsReadMore(classDef.description, 80) && (
							<StyledCardFooter>
								<StyledReadMore
									onClick={(e) => {
										e.stopPropagation();
										openPopup(classDef.id);
									}}
								>
									read more...
								</StyledReadMore>
							</StyledCardFooter>
						)}
					</StyledCard>
				))}
			</StyledGrid>

			{/* Popup overlay and content */}
			<StyledTooltipOverlay $show={popupClass !== null} onClick={closePopup} />
			{popupClass && (
				<StyledTooltip $show={popupClass !== null}>
					<StyledTooltipHeader>
						<StyledTooltipIcon>{getClassIcon(popupClass)}</StyledTooltipIcon>
						<StyledTooltipTitle>
							{classesData.find((c) => c.id === popupClass)?.name}
						</StyledTooltipTitle>
					</StyledTooltipHeader>
					<StyledTooltipContent>
						{classesData.find((c) => c.id === popupClass)?.description}
					</StyledTooltipContent>
					<StyledCloseHint>Click anywhere to close</StyledCloseHint>
				</StyledTooltip>
			)}
		</StyledContainer>
	);
}

export default ClassSelector;
````

## File: src/routes/character-sheet/components/Attacks.tsx
````typescript
import React from 'react';
import type { AttackData, CharacterSheetData } from '../../../types';
import { weapons, type Weapon, WeaponType } from '../../../lib/rulesdata/inventoryItems';
import {
	parseDamage,
	getDamageType,
	isRangedWeapon,
	calculateAttackBonus,
	calculateDamage,
	getVersatileDamage,
	getWeaponFeatures,
	createEmptyAttackData
} from '../../../lib/utils/weaponUtils';
import {
	StyledAttacksSection,
	StyledAttacksHeader,
	StyledAttacksTitle,
	StyledAddWeaponButton,
	StyledAttacksContainer,
	StyledAttacksHeaderRow,
	StyledHeaderColumn,
	StyledEmptyState,
	StyledAttackRow,
	StyledRemoveButton,
	StyledWeaponSelect,
	StyledDamageCell,
	StyledInfoIcon,
	StyledDamageTypeCell
} from '../styles/Attacks';

export interface AttacksProps {
	attacks: AttackData[];
	setAttacks: React.Dispatch<React.SetStateAction<AttackData[]>>;
	characterData: CharacterSheetData;
	onAttackClick: (attack: AttackData, weapon: Weapon | null) => void;
}

const Attacks: React.FC<AttacksProps> = ({ attacks, setAttacks, characterData, onAttackClick }) => {
	const addWeaponSlot = () => {
		const newAttack: AttackData = {
			id: `attack_${Date.now()}`,
			weaponName: '',
			name: '',
			attackBonus: 0,
			damage: '',
			damageType: 'slashing',
			critRange: '20',
			critDamage: '',
			brutalDamage: '',
			heavyHitEffect: ''
		};
		setAttacks((prev) => [...prev, newAttack]);
	};

	const removeWeaponSlot = (attackIndex: number) => {
		setAttacks((prev) => prev.filter((_, index) => index !== attackIndex));
	};

	const handleWeaponSelect = (attackIndex: number, weaponName: string) => {
		console.log('Selecting weapon:', weaponName);
		const weapon = weapons.find((w) => w.name === weaponName);
		if (!weapon) {
			console.error('Weapon not found:', weaponName);
			return;
		}
		console.log('Found weapon:', weapon);

		const newAttackData = calculateAttackData(weapon);

		setAttacks((prev) =>
			prev.map((attack, index) =>
				index === attackIndex ? { ...newAttackData, id: attack.id } : attack
			)
		);
	};

	const calculateAttackData = (weapon: Weapon): AttackData => {
		if (!weapon || !characterData) {
			return createEmptyAttackData(weapon?.name);
		}

		const mightMod = Math.floor((characterData.finalMight - 10) / 2);
		const agilityMod = Math.floor((characterData.finalAgility - 10) / 2);

		const attackBonus = calculateAttackBonus(
			weapon,
			characterData.finalCombatMastery,
			mightMod,
			agilityMod
		);

		const damageType = getDamageType(weapon.damage);
		const versatileInfo = getVersatileDamage(weapon);
		const damageString = versatileInfo
			? `${versatileInfo.oneHanded} (${versatileInfo.twoHanded} two-handed)`
			: weapon.damage;

		const critRange = '20'; // Default crit range
		const critDamage = calculateDamage(weapon, 'normal');
		const brutalDamage = calculateDamage(weapon, 'brutal');
		const heavyHitEffect = weapon.properties.includes('Impact') ? '+1 damage on Heavy Hit' : '';

		return {
			id: '',
			weaponName: weapon.name,
			name: weapon.name,
			attackBonus,
			damage: damageString,
			damageType,
			critRange,
			critDamage,
			brutalDamage,
			heavyHitEffect
		};
	};

	return (
		<StyledAttacksSection>
			<StyledAttacksHeader>
				<StyledAttacksTitle>ATTACKS</StyledAttacksTitle>
				<StyledAddWeaponButton onClick={addWeaponSlot}>+ Add Weapon</StyledAddWeaponButton>
			</StyledAttacksHeader>

			<StyledAttacksContainer>
				<StyledAttacksHeaderRow>
					<span></span> {/* Empty column for remove button */}
					<StyledHeaderColumn>Weapon</StyledHeaderColumn>
					<StyledHeaderColumn align="center">
						Base
						<br />
						Dmg
					</StyledHeaderColumn>
					<StyledHeaderColumn align="center">
						Heavy
						<br />
						Dmg
					</StyledHeaderColumn>
					<StyledHeaderColumn align="center">
						Brutal
						<br />
						Dmg
					</StyledHeaderColumn>
					<StyledHeaderColumn align="center">Type</StyledHeaderColumn>
					<StyledHeaderColumn align="center">
						<StyledInfoIcon>i</StyledInfoIcon>
					</StyledHeaderColumn>
				</StyledAttacksHeaderRow>

				{attacks.length === 0 ? (
					<StyledEmptyState>
						No weapons added. Click "Add Weapon" to add your first weapon.
					</StyledEmptyState>
				) : (
					attacks.map((attack, index) => {
						const weapon = attack.weaponName
							? weapons.find((w) => w.name === attack.weaponName)
							: null;

						return (
							<StyledAttackRow key={attack.id}>
								{/* Remove Button */}
								<StyledRemoveButton onClick={() => removeWeaponSlot(index)} title="Remove weapon">
									×
								</StyledRemoveButton>

								{/* Weapon Selection */}
								<StyledWeaponSelect
									value={attack.weaponName}
									onChange={(e: any) => handleWeaponSelect(index, e.target.value)}
								>
									<option value="">Select Weapon...</option>
									{weapons.map((weapon) => (
										<option key={weapon.name} value={weapon.name}>
											{weapon.name} ({weapon.handedness})
										</option>
									))}
								</StyledWeaponSelect>

								{/* Base Damage */}
								<StyledDamageCell
									title={
										weapon
											? `Base weapon damage: ${weapon.damage}${getVersatileDamage(weapon) ? ` (${getVersatileDamage(weapon)?.twoHanded} when two-handed)` : ''}`
											: ''
									}
								>
									{weapon ? attack.damage || weapon.damage : '-'}
								</StyledDamageCell>

								{/* Heavy Damage */}
								<StyledDamageCell
									color="#d2691e"
									title={
										weapon
											? weapon.properties.includes('Impact')
												? `Heavy Hit: ${calculateDamage(weapon, 'heavy')} damage (base ${weapon.damage} + 1 heavy + 1 impact) + Target must make Might Save or be knocked Prone and pushed 5 feet`
												: `Heavy Hit: ${calculateDamage(weapon, 'heavy')} damage (base ${weapon.damage} + 1 heavy)`
											: ''
									}
								>
									{weapon ? (
										<>
											{calculateDamage(weapon, 'heavy')}
											{weapon.properties.includes('Impact') && (
												<div style={{ fontSize: '0.6rem' }}>+Prone/Push</div>
											)}
										</>
									) : (
										'-'
									)}
								</StyledDamageCell>

								{/* Brutal Damage */}
								<StyledDamageCell
									color="#dc143c"
									title={
										weapon
											? weapon.properties.includes('Impact')
												? `Brutal Hit: ${calculateDamage(weapon, 'brutal')} damage (base ${weapon.damage} + 2 brutal + 1 impact)`
												: `Brutal Hit: ${calculateDamage(weapon, 'brutal')} damage (base ${weapon.damage} + 2 brutal)`
											: ''
									}
								>
									{weapon ? calculateDamage(weapon, 'brutal') : '-'}
								</StyledDamageCell>

								{/* Damage Type */}
								<StyledDamageTypeCell
									title={weapon ? `${getDamageType(weapon.damage)} damage` : ''}
								>
									{weapon ? parseDamage(weapon.damage).type : '-'}
								</StyledDamageTypeCell>

								{/* Damage Calculation Info */}
								<div style={{ textAlign: 'center', fontSize: '1.1rem' }}>
									{weapon ? (
										<StyledInfoIcon onClick={() => onAttackClick(attack, weapon)}>i</StyledInfoIcon>
									) : (
										'-'
									)}
								</div>
							</StyledAttackRow>
						);
					})
				)}
			</StyledAttacksContainer>
		</StyledAttacksSection>
	);
};

export default Attacks;
````

## File: src/routes/character-sheet/components/Inventory.tsx
````typescript
import React from 'react';
import type { InventoryItemData } from '../../../types';
import { allItems, type InventoryItem } from '../../../lib/rulesdata/inventoryItems';
import {
	StyledInventorySection,
	StyledInventoryTitle,
	StyledAddItemButton,
	StyledInventoryContainer,
	StyledInventoryHeaderRow,
	StyledInventoryHeaderColumn,
	StyledInventoryRow,
	StyledRemoveItemButton,
	StyledInventorySelect,
	StyledInventoryInput,
	StyledInventoryInfoIcon,
	StyledInventoryCost,
	StyledEmptyInventory
} from '../styles/Inventory';

export interface InventoryProps {
	inventory: InventoryItemData[];
	setInventory: React.Dispatch<React.SetStateAction<InventoryItemData[]>>;
	onItemClick: (inventoryData: InventoryItemData, item: InventoryItem | null) => void;
}

const Inventory: React.FC<InventoryProps> = ({ inventory, setInventory, onItemClick }) => {
	const addInventorySlot = () => {
		const newInventoryItem: InventoryItemData = {
			id: `inventory_${Date.now()}`,
			itemType: '',
			itemName: '',
			count: 1,
			cost: '-'
		};
		setInventory((prev) => [...prev, newInventoryItem]);
	};

	const removeInventorySlot = (inventoryIndex: number) => {
		setInventory((prev) => prev.filter((_, index) => index !== inventoryIndex));
	};

	const handleInventoryItemSelect = (
		inventoryIndex: number,
		itemTypeOrName: string,
		isItemName: boolean = false
	) => {
		if (!isItemName) {
			// Selecting item type
			const itemType = itemTypeOrName as InventoryItemData['itemType'];
			setInventory((prev) =>
				prev.map((item, index) =>
					index === inventoryIndex ? { ...item, itemType, itemName: '', cost: '-' } : item
				)
			);
		} else {
			// Selecting item name
			const selectedItem = allItems.find((i: any) => i.name === itemTypeOrName);
			setInventory((prev) =>
				prev.map((item, index) =>
					index === inventoryIndex
						? {
								...item,
								itemName: itemTypeOrName,
								itemType: selectedItem?.itemType || item.itemType,
								cost: getItemCost(selectedItem)
							}
						: item
				)
			);
		}
	};

	const handleInventoryCountChange = (inventoryIndex: number, count: number) => {
		setInventory((prev) =>
			prev.map((item, index) =>
				index === inventoryIndex ? { ...item, count: Math.max(1, count) } : item
			)
		);
	};

	const getItemCost = (item: InventoryItem | undefined | null, count: number = 1): string => {
		if (!item || !('price' in item)) return '-';

		let basePrice = 0;
		let currency = 'g';

		if (typeof item.price === 'string') {
			// Parse string prices like "10g", "5s", etc.
			const match = item.price.match(/(\d+)([gs]?)/);
			if (match) {
				basePrice = parseInt(match[1]);
				currency = match[2] || 'g';
			}
		} else if (typeof item.price === 'number') {
			basePrice = item.price;
		}

		if (basePrice === 0) return '-';

		const totalPrice = basePrice * count;
		return `${totalPrice}${currency}`;
	};

	return (
		<StyledInventorySection>
			<StyledInventoryTitle>INVENTORY</StyledInventoryTitle>

			{/* Add Item Button */}
			<StyledAddItemButton onClick={addInventorySlot}>+ Add Item</StyledAddItemButton>

			<StyledInventoryContainer>
				<StyledInventoryHeaderRow>
					<span></span> {/* Empty column for remove button */}
					<StyledInventoryHeaderColumn>Type</StyledInventoryHeaderColumn>
					<StyledInventoryHeaderColumn>Item</StyledInventoryHeaderColumn>
					<StyledInventoryHeaderColumn align="center">Count</StyledInventoryHeaderColumn>
					<StyledInventoryHeaderColumn align="center">
						<StyledInventoryInfoIcon>i</StyledInventoryInfoIcon>
					</StyledInventoryHeaderColumn>
					<StyledInventoryHeaderColumn align="center">Cost</StyledInventoryHeaderColumn>
				</StyledInventoryHeaderRow>

				{inventory.length === 0 ? (
					<StyledEmptyInventory>
						No items added. Click "Add Item" to add your first item.
					</StyledEmptyInventory>
				) : (
					inventory.map((item, index) => {
						const selectedItem = item.itemName
							? allItems.find((i) => i.name === item.itemName)
							: null;

						return (
							<StyledInventoryRow key={item.id}>
								{/* Remove Button */}
								<StyledRemoveItemButton
									onClick={() => removeInventorySlot(index)}
									title="Remove item"
								>
									×
								</StyledRemoveItemButton>

								{/* Item Type */}
								<StyledInventorySelect
									value={item.itemType}
									onChange={(e) => handleInventoryItemSelect(index, e.target.value, false)}
								>
									<option value="">Select Type</option>
									<option value="Weapon">Weapon</option>
									<option value="Armor">Armor</option>
									<option value="Shield">Shield</option>
									<option value="Adventuring Supply">Adventuring Supply</option>
									<option value="Potion">Healing Potion</option>
								</StyledInventorySelect>

								{/* Item Name */}
								<StyledInventorySelect
									value={item.itemName}
									onChange={(e) => handleInventoryItemSelect(index, e.target.value, true)}
									disabled={!item.itemType}
								>
									<option value="">Select Item</option>
									{item.itemType &&
										allItems
											.filter((i) => i.itemType === item.itemType)
											.map((itemData) => (
												<option key={itemData.name} value={itemData.name}>
													{itemData.name}
												</option>
											))}
								</StyledInventorySelect>

								{/* Count */}
								<StyledInventoryInput
									type="number"
									min="1"
									value={item.count}
									onChange={(e) => handleInventoryCountChange(index, parseInt(e.target.value) || 1)}
								/>

								{/* Info Indicator */}
								<div style={{ textAlign: 'center' }}>
									{selectedItem ? (
										<StyledInventoryInfoIcon
											onClick={() => onItemClick(item, selectedItem)}
										>
											i
										</StyledInventoryInfoIcon>
									) : (
										'-'
									)}
								</div>

								{/* Cost */}
								<StyledInventoryCost>{getItemCost(selectedItem, item.count)}</StyledInventoryCost>
							</StyledInventoryRow>
						);
					})
				)}
			</StyledInventoryContainer>
		</StyledInventorySection>
	);
};

export default Inventory;
````

## File: src/routes/character-sheet/components/LeftColumn.tsx
````typescript
import React from 'react';
import type { SkillData, TradeData, LanguageData, CharacterSheetData } from '../../../types';
import { StyledLeftColumn } from '../styles/Layout';
import Attributes from './Attributes';
import KnowledgeTrades from './KnowledgeTrades';
import Languages from './Languages';

interface LeftColumnProps {
	characterData: CharacterSheetData;
	skillsByAttribute: {
		prime: SkillData[];
		might: SkillData[];
		agility: SkillData[];
		charisma: SkillData[];
		intelligence: SkillData[];
	};
	knowledge: TradeData[];
	trades: TradeData[];
	languages: LanguageData[];
}

const LeftColumn: React.FC<LeftColumnProps> = ({
	characterData,
	skillsByAttribute,
	knowledge,
	trades,
	languages
}) => {
	return (
		<StyledLeftColumn>
			<Attributes characterData={characterData} skillsByAttribute={skillsByAttribute} />
			<KnowledgeTrades knowledge={knowledge} trades={trades} />
			<Languages languages={languages} />
		</StyledLeftColumn>
	);
};

export default LeftColumn;
````

## File: src/routes/character-sheet/styles/Attributes.ts
````typescript
import styled from 'styled-components';

export const StyledAttributeSection = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: rgba(245, 243, 240, 0.5);
`;

export const StyledAttributeItem = styled.div`
	display: grid;
	grid-template-columns: 60px 1fr;
	gap: 0.5rem;
	margin-bottom: 1rem;
	align-items: center;
`;

export const StyledAttributeBox = styled.div`
	width: 50px;
	height: 50px;
	border: 2px solid #8b4513;
	border-radius: 8px;
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	background: white;
	position: relative;
`;

export const StyledAttributeAbbr = styled.div`
	font-size: 0.7rem;
	font-weight: bold;
	text-transform: uppercase;
	color: #8b4513;
`;

export const StyledAttributeValue = styled.div`
	font-size: 1.2rem;
	font-weight: bold;
	color: #2d2d2d;
`;

export const StyledAttributeDetails = styled.div`
	display: flex;
	flex-direction: column;
`;

export const StyledAttributeName = styled.div`
	font-size: 0.9rem;
	font-weight: bold;
	text-transform: uppercase;
	color: #8b4513;
`;

export const StyledSaveBonus = styled.div`
	font-size: 0.8rem;
	color: #666;
`;

// New components for refactored layout
export const AttributeSection = styled.div`
	margin-bottom: 1rem;
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
`;

export const AttributeHeader = styled.div`
	display: flex;
	align-items: center;
	margin-bottom: 0.5rem;
`;

export const AttributeBox = styled.div`
	width: 60px;
	height: 60px;
	border: 2px solid #8b4513;
	border-radius: 8px;
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	background: #f5f5dc;
	margin-right: 1rem;
`;

export const AttributeAbbreviation = styled.div`
	font-size: 0.8rem;
	font-weight: bold;
	color: #8b4513;
`;

export const AttributeValue = styled.div`
	font-size: 1.4rem;
	font-weight: bold;
	color: #8b4513;
`;

export const AttributeInfo = styled.div`
	flex: 1;
`;

export const AttributeName = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.2rem;
`;

export const AttributeSave = styled.div`
	font-size: 0.9rem;
	color: #8b4513;
`;

export const SkillRow = styled.div`
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 0.3rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	background: #f9f9f9;
	margin-bottom: 0.3rem;

	&:last-child {
		margin-bottom: 0;
	}
`;

export const SkillName = styled.span`
	font-size: 0.9rem;
	color: #8b4513;
`;

export const PrimeSection = styled.div`
	text-align: center;
	padding: 0.5rem;
	border: 2px solid #8b4513;
	border-radius: 8px;
	background: #f5f5dc;
	margin-bottom: 0.5rem;
`;

export const PrimeLabel = styled.div`
	color: #8b4513;
	font-weight: bold;
	font-size: 1rem;
`;

export const PrimeValue = styled.div`
	font-size: 1.4rem;
	font-weight: bold;
	color: #8b4513;
`;
````

## File: src/routes/character-sheet/styles/Features.styles.ts
````typescript
import styled from 'styled-components';

export const StyledFeaturesContainer = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
	margin-bottom: 1rem;
	height: 762px;
	overflow-y: auto;
`;

export const StyledFeaturesTitle = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	text-align: center;
	margin-bottom: 1rem;
`;

export const StyledFeatureCategory = styled.div`
	margin-bottom: 1rem;
`;

export const StyledFeatureCategoryTitle = styled.div`
	font-size: 0.9rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.5rem;
	padding-bottom: 0.3rem;
	border-bottom: 1px solid #8b4513;
`;

export const StyledFeatureGrid = styled.div`
	display: flex;
	flex-direction: column;
	gap: 0.3rem;
`;

export const StyledFeatureItem = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0.5rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	background: #f9f9f9;
`;

export const StyledFeatureName = styled.span`
	font-size: 0.85rem;
	color: #8b4513;
	font-weight: 500;
	flex: 1;
`;

export const StyledFeatureReadMore = styled.button`
	background: #8b4513;
	color: white;
	border: none;
	border-radius: 3px;
	padding: 0.2rem 0.5rem;
	font-size: 0.7rem;
	cursor: pointer;
	font-weight: bold;

	&:hover {
		background: #654321;
	}
`;

export const StyledNoFeaturesMessage = styled.div`
	text-align: center;
	font-style: italic;
	padding: 1rem;
	color: #666;
`;

export const StyledFeaturesContent = styled.div`
	font-size: 0.9rem;
	color: #8b4513;
`;
````

## File: src/routes/character-sheet/styles/Header.ts
````typescript
import styled from 'styled-components';

export const StyledHeader = styled.div`
	display: grid;
	grid-template-columns: 2fr 1fr 1fr 1fr;
	gap: 1rem;
	margin-bottom: 1.5rem;
	border-bottom: 2px solid #8b4513;
	padding-bottom: 1rem;

	@media (max-width: 768px) {
		display: none;
	}
`;

export const StyledHeaderSection = styled.div`
	display: flex;
	flex-direction: column;
`;

export const StyledLabel = styled.label`
	font-size: 0.7rem;
	font-weight: bold;
	text-transform: uppercase;
	color: #8b4513;
	margin-bottom: 0.2rem;
`;

export const StyledValue = styled.div`
	font-size: 1rem;
	font-weight: bold;
	border-bottom: 1px solid #ccc;
	padding: 0.2rem 0;
	min-height: 1.5rem;
`;
````

## File: src/routes/character-sheet/styles/Inventory.ts
````typescript
import styled from 'styled-components';

export const StyledInventorySection = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
	margin-bottom: 1rem;
`;

export const StyledInventoryTitle = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	text-align: center;
	margin-bottom: 1rem;
`;

export const StyledAddItemButton = styled.button`
	padding: 0.5rem 1rem;
	background-color: #8b4513;
	color: white;
	border: none;
	border-radius: 4px;
	font-size: 0.9rem;
	cursor: pointer;
	transition: background-color 0.2s;
	margin-bottom: 1rem;

	&:hover {
		background-color: #6d3410;
	}
`;

export const StyledInventoryContainer = styled.div`
	font-size: 0.8rem;
	color: #8b4513;
`;

export const StyledInventoryHeaderRow = styled.div`
	display: grid;
	grid-template-columns: 30px 100px 2fr 60px 30px 70px;
	gap: 0.5rem;
	margin-bottom: 0.5rem;
	border-bottom: 1px solid #e5e5e5;
	padding-bottom: 0.3rem;
	align-items: center;
`;

export const StyledInventoryHeaderColumn = styled.span<{ align?: string }>`
	font-weight: bold;
	text-align: ${(props) => props.align || 'left'};
`;

export const StyledInventoryRow = styled.div`
	display: grid;
	grid-template-columns: 30px 100px 2fr 60px 30px 70px;
	gap: 0.5rem;
	margin-bottom: 0.5rem;
	align-items: center;
`;

export const StyledRemoveItemButton = styled.button`
	width: 24px;
	height: 24px;
	border: 1px solid #dc2626;
	background-color: #fee2e2;
	color: #dc2626;
	border-radius: 4px;
	font-size: 14px;
	cursor: pointer;
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 0;

	&:hover {
		background-color: #fecaca;
	}
`;

export const StyledInventorySelect = styled.select`
	padding: 0.3rem;
	border: 1px solid #ccc;
	border-radius: 4px;
	font-size: 0.8rem;
	background-color: white;

	&:disabled {
		background-color: #f5f5f5;
		color: #999;
	}
`;

export const StyledInventoryInput = styled.input`
	padding: 0.3rem;
	border: 1px solid #ccc;
	border-radius: 4px;
	font-size: 0.8rem;
	text-align: center;
	background-color: white;
`;

export const StyledInventoryInfoIcon = styled.span`
	display: inline-flex;
	align-items: center;
	justify-content: center;
	width: 14px;
	height: 14px;
	border-radius: 50%;
	background-color: #8b4513;
	color: white;
	font-size: 10px;
	font-weight: bold;
	cursor: pointer;
	position: relative;
`;

export const StyledInventoryCost = styled.div`
	text-align: center;
	font-size: 0.8rem;
	font-weight: bold;
`;

export const StyledEmptyInventory = styled.div`
	text-align: center;
	font-style: italic;
	padding: 2rem;
	color: #666;
`;
````

## File: src/routes/character-sheet/styles/Languages.ts
````typescript
import styled from 'styled-components';

export const LanguagesSection = styled.div`
	margin-bottom: 1rem;
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
`;

export const LanguageRow = styled.div`
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 0.3rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	background: #f9f9f9;
	margin-bottom: 0.3rem;

	&:last-child {
		margin-bottom: 0;
	}
`;

export const LanguageName = styled.span`
	font-size: 0.9rem;
	color: #8b4513;
	flex: 1;
	margin-right: 1rem;
	overflow: hidden;
	text-overflow: ellipsis;
	white-space: nowrap;
	min-width: 0;
`;

export const FluencyContainer = styled.div`
	display: flex;
	gap: 0.2rem;
	flex-shrink: 0;
`;

export const FluencyBox = styled.div<{ filled: boolean }>`
	width: 15px;
	height: 15px;
	border: 1px solid #8b4513;
	background: ${(props) => (props.filled ? '#8b4513' : 'white')};
	border-radius: 2px;
`;

export const FluencyLabel = styled.span`
	font-size: 0.7rem;
	color: #8b4513;
	font-weight: bold;
	margin-right: 0.3rem;
`;

export const FluencyItem = styled.div`
	display: flex;
	align-items: center;
	gap: 0.2rem;
	flex-shrink: 0;
	min-width: fit-content;
`;

export const FluencyHeader = styled.div`
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 0.3rem;
	background: #f0f0f0;
	border: 1px solid #8b4513;
	border-radius: 4px;
	margin-bottom: 0.3rem;
	font-weight: bold;
	font-size: 0.85rem;
	color: #8b4513;
`;

export const LanguageNameHeader = styled.span`
	font-size: 0.85rem;
	color: #8b4513;
	font-weight: bold;
	flex: 1;
	margin-right: 1rem;
`;

export const FluencyHeaderContainer = styled.div`
	display: flex;
	gap: 0.2rem;
	flex-shrink: 0;
`;

export const FluencyHeaderLabel = styled.span`
	font-size: 0.75rem;
	color: #8b4513;
	font-weight: bold;
	text-align: center;
	min-width: 15px;
	cursor: help;
`;
````

## File: src/routes/character-sheet/styles/Layout.ts
````typescript
import styled from 'styled-components';

export const StyledContainer = styled.div`
	min-height: 100vh;
	background: #f5f3f0;
	padding: 1rem;
	font-family: 'Georgia', serif;
	color: #2d2d2d;

	@media (max-width: 768px) {
		padding: 0.5rem;
	}
`;

export const StyledBackButton = styled.button`
	position: fixed;
	top: 1rem;
	left: 1rem;
	padding: 0.5rem 1rem;
	border: 2px solid #8b4513;
	border-radius: 4px;
	background: #f5f3f0;
	color: #8b4513;
	cursor: pointer;
	font-weight: bold;
	z-index: 100;

	@media (max-width: 768px) {
		top: 0.5rem;
		left: 0.5rem;
		padding: 0.4rem 0.8rem;
		font-size: 0.9rem;
		z-index: 1001; /* Above mobile nav */
	}

	&:hover {
		background: #8b4513;
		color: #f5f3f0;
	}
`;

export const StyledCharacterSheet = styled.div`
	max-width: 1200px;
	margin: 0 auto;
	background: #ffffff;
	border: 3px solid #8b4513;
	border-radius: 8px;
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
	padding: 1.5rem;
	position: relative;

	/* Desktop/Mobile Layout Control */
	.desktop-only {
		display: block !important;

		@media (max-width: 768px) {
			display: none !important;
		}
	}

	.mobile-only {
		display: none !important;

		@media (max-width: 768px) {
			display: block !important;
		}

		> div {
			display: flex;
			flex-direction: column;
			gap: 1rem;
		}
	}

	@media (max-width: 768px) {
		padding: 1rem;
		border-width: 2px;
		margin: 0;
		border-radius: 4px;
		overflow-x: hidden;
		width: 100%;
		box-sizing: border-box;
	}

	&::before {
		content: '';
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		background:
			radial-gradient(circle at 20% 20%, rgba(139, 69, 19, 0.05) 0%, transparent 50%),
			radial-gradient(circle at 80% 80%, rgba(139, 69, 19, 0.05) 0%, transparent 50%);
		pointer-events: none;
		border-radius: 5px;
	}
`;

export const StyledMainGrid = styled.div`
	display: grid;
	grid-template-columns: 300px 1fr 250px;
	gap: 1.5rem;
	height: auto;
	width: 100%;
`;

export const StyledLeftColumn = styled.div`
	display: flex;
	flex-direction: column;
	gap: 1rem;
`;

export const StyledMiddleColumn = styled.div`
	display: flex;
	flex-direction: column;
	gap: 1rem;
`;

export const StyledRightColumn = styled.div`
	display: flex;
	flex-direction: column;
	gap: 1rem;
`;

// Mobile Navigation
export const StyledMobileNav = styled.div`
	display: flex;
	background: #8b4513;
	border-radius: 8px;
	margin-bottom: 1rem;
	overflow: hidden;
	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
`;

export const StyledMobileNavButton = styled.button<{ $isActive: boolean }>`
	flex: 1;
	padding: 0.75rem 0.25rem;
	border: none;
	background: ${(props) => (props.$isActive ? '#f5f3f0' : 'transparent')};
	color: ${(props) => (props.$isActive ? '#8b4513' : '#f5f3f0')};
	font-weight: bold;
	font-size: 0.7rem;
	cursor: pointer;
	transition: all 0.2s ease;

	&:hover {
		background: ${(props) => (props.$isActive ? '#f5f3f0' : 'rgba(245, 243, 240, 0.1)')};
	}

	&:active {
		transform: translateY(1px);
	}
`;

// Action buttons (Revert/Copy)
export const StyledActionButtons = styled.div`
	position: absolute;
	top: 1rem;
	right: 1rem;
	display: flex;
	gap: 0.5rem;
	z-index: 1000;

	@media (max-width: 768px) {
		display: none;
	}
`;

export const StyledActionButton = styled.button<{ $variant?: 'danger' | 'primary' }>`
	padding: 8px 12px;
	font-size: 0.8rem;
	background-color: ${(props) => (props.$variant === 'danger' ? '#c53030' : '#8b4513')};
	color: white;
	border: none;
	border-radius: 6px;
	cursor: pointer;
	white-space: nowrap;
	font-weight: bold;
	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
	transition: all 0.2s ease;

	&:hover {
		background-color: ${(props) => (props.$variant === 'danger' ? '#b32c2c' : '#7a3e11')};
		transform: translateY(-1px);
	}

	&:active {
		transform: translateY(0);
	}
`;
````

## File: src/routes/character-sheet/styles/Potions.ts
````typescript
import styled from 'styled-components';

interface PotionCircleProps {
	fillPercentage: number;
	color: string;
}

export const StyledPotionContainer = styled.div`
	position: relative;
	width: 80px;
	height: 80px;
	border: 3px solid;
	border-radius: 50%;
	background: white;
	overflow: hidden;
	display: flex;
	align-items: center;
	justify-content: center;
`;

export const StyledPotionFill = styled.div<PotionCircleProps>`
	position: absolute;
	bottom: 0;
	left: 0;
	right: 0;
	height: ${(props) => Math.max(0, props.fillPercentage)}%;
	background: linear-gradient(to top, ${(props) => props.color}dd, ${(props) => props.color}aa);
	border-radius: 0 0 50px 50px;
	transition: height 0.3s ease-in-out;
`;

export const StyledPotionBubbles = styled.div<{ color: string; fillPercentage: number }>`
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	pointer-events: none;
	opacity: ${(props) => (props.fillPercentage > 20 ? 0.3 : 0)};
	transition: opacity 0.3s ease-in-out;

	&::before {
		content: '';
		position: absolute;
		top: 60%;
		left: 20%;
		width: 8px;
		height: 8px;
		background: rgba(255, 255, 255, 0.8);
		border-radius: 50%;
		animation: bubble1 2s infinite ease-in-out;
	}

	&::after {
		content: '';
		position: absolute;
		top: 30%;
		right: 25%;
		width: 6px;
		height: 6px;
		background: rgba(255, 255, 255, 0.6);
		border-radius: 50%;
		animation: bubble2 2.5s infinite ease-in-out;
	}

	@keyframes bubble1 {
		0%,
		100% {
			transform: translateY(0px) scale(1);
			opacity: 0.3;
		}
		50% {
			transform: translateY(-10px) scale(1.1);
			opacity: 0.8;
		}
	}

	@keyframes bubble2 {
		0%,
		100% {
			transform: translateY(0px) scale(1);
			opacity: 0.2;
		}
		50% {
			transform: translateY(-8px) scale(1.2);
			opacity: 0.6;
		}
	}
`;

export const StyledPotionValue = styled.div`
	position: relative;
	z-index: 10;
	font-size: 1.4rem;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
	color: #333;
`;

export const StyledLargePotionContainer = styled.div`
	position: relative;
	width: 100px;
	height: 100px;
	border: 3px solid;
	border-radius: 50%;
	background: white;
	overflow: hidden;
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
`;

export const StyledLargePotionValue = styled.div`
	position: relative;
	z-index: 10;
	font-size: 1.6rem;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
	color: #333;
`;

export const StyledTempHPDisplay = styled.div`
	position: relative;
	z-index: 10;
	font-size: 0.7rem;
	color: #333;
	display: flex;
	align-items: center;
	gap: 0.2rem;
	text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
`;
````

## File: src/lib/rulesdata/classes/bard_features.json
````json
{
	"className": "Bard",
	"startingEquipment": {
		"weaponsOrShields": ["2 Weapons"],
		"kits": "1 Musical Instrument, Theatre Kit, or Art Kit (coming in future update)",
		"armor": "1 set of Light Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"spellcastingPath": {
		"combatTraining": {
			"armor": ["Light Armor"],
			"shields": ["Light Shields"]
		},
		"spellList": {
			"type": "schools",
			"specificSchools": ["Conjuration", "Divination", "Enchantment", "Illusion", "Restoration"],
			"spellTags": ["Charm"],
			"betaNote": "This means that the following Spells are what you would have access to:\nCantrips: Befriend, Close Wounds, Guidance, Light, Mage Hand, Message, Minor Illusion\n1 MP Spells: Bane, Bless, Command, Find Familiar, Fog Cloud, Grease, Heal, Psychic Fear, Silent Image, Sleep, Tethering Vines"
		},
		"cantrips": {
			"knownIncreasesBy": "Cantrips Known column of the Bard Class Table",
			"description": "Cantrips are Spells with the Cantrip Spell Tag."
		},
		"spells": {
			"knownIncreasesBy": "Spells Known column of the Bard Class Table",
			"description": "These can be Spells with or without the Cantrip Spell Tag."
		},
		"manaPoints": {
			"maximumIncreasesBy": "Mana Points column of the Bard Class Table"
		}
	},
	"coreFeatures": [
		{
			"featureName": "Font of Inspiration",
			"levelGained": 1,
			"description": "You are an ever present source of aid for your allies. You gain the following benefits:",
			"benefits": [
				{
					"name": "Ranged Help Attack",
					"description": "The range of your Help Action when aiding an Attack increases to 10 Spaces."
				},
				{
					"name": "Help Reaction",
					"description": "When a creature you can see makes a Check, you can take the Help Action as a Reaction to aid them with their Check, provided you're within range to do so."
				}
			]
		},
		{
			"featureName": "Remarkable Repertoire",
			"levelGained": 1,
			"description": "You've picked up a few tricks along your travels, granting you the following benefits:",
			"benefits": [
				{
					"name": "Jack of All Trades",
					"description": "You gain 2 Skill Points."
				},
				{
					"name": "Magical Secrets",
					"description": "You learn any 2 Spells of your choice from any Spell List."
				},
				{
					"name": "Magical Expression",
					"description": "You learn to express your art in a unique manner, granting you the ability to alter how you cast Spells. Choose the manner of your expression: Visual or Auditory.\n• Visual: Through acrobatics, dancing, juggling, painting, drawing, or miming, you can ignore the Verbal Components of a Spell you cast, but you must provide a Somatic Component instead.\n• Auditory: Through singing, playing music, poetry, comedy, or storytelling, you can ignore the Somatic Components of a Spell you cast, but you must provide a Verbal Component instead."
				}
			]
		},
		{
			"featureName": "Crowd Pleaser (Flavor Feature)",
			"levelGained": 1,
			"description": "When you spend at least 5 minutes performing an Artistry Trade for one or more people who are actively watching or listening to your performance, you can make an Artistry Trade Check Contested by the targets' Charisma Save. Success: You gain ADV on Charisma Checks against the target for 1 hour or until you become hostile. Creatures have ADV on the Save if they're considered hostile toward you.",
			"isFlavor": true
		},
		{
			"featureName": "Bardic Performance",
			"levelGained": 2,
			"description": "You can spend 1 AP and 1 MP to start a performance that grants you a 10 Space Aura for 1 minute. Choose 1 of the performances below. While creatures of your choice are within your Aura (and can see or hear you) they benefit from your performance. A creature can only benefit from one instance of each performance at a time. Changing Performances: Once on each of your turns, you can spend 1 AP to change your performance to a different one. Ending Early: The performance ends early if you become Incapacitated, you die, or choose to end it for free.",
			"choices": [
				{
					"prompt": "Choose a performance.",
					"count": 1,
					"options": [
						{
							"name": "Battle Ballad",
							"description": "The chosen creatures deal +1 damage against 1 target of their choice on an Attack they make once on each of their turns."
						},
						{
							"name": "Fast Tempo",
							"description": "The chosen creatures gain +1 Speed."
						},
						{
							"name": "Inspiring",
							"description": "The chosen creatures gain 1 Temp HP at the start of each of their turns."
						},
						{
							"name": "Emotional",
							"description": "Choose 1 of the following Conditions: Charmed, Frightened, Intimidated, or Taunted. The chosen creatures have Resistance against the chosen Condition. If a target is effected by the chosen Condition at the start of its turn, it can immediately attempt to end the Condition on itself by Repeating its Save."
						}
					]
				}
			]
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Eloquence",
			"features": [
				{
					"featureName": "Beguiling Presence",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Enthrall: You learn the Befriend Spell, and it doesn't end as a result of the target taking damage. If you already know it, you instead learn another spell with the Charm Tag.\n• Misleading Muse: When a creature within your Bardic Performance targets only you with an Attack, you can spend 1 AP as a Reaction to make a Spell Check against the target's Attack Check. Success: The creature becomes Charmed by you until the end of your next turn. It must target a different creature of its choice (other than itself) within range, or the Attack fails.\n• Mind Games: When the Charmed Condition ends on a creature Charmed by you, you can choose to immediately deal 1 Psychic damage to them."
				},
				{
					"featureName": "Eloquent Orator (Flavor Feature)",
					"levelGained": 3,
					"description": "Your speech is magically enchanted. Creatures can always understand the words you speak, provided they speak at least 1 Language.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Jester",
			"features": [
				{
					"featureName": "Antagonizing Act",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Heckle: Once per Round when a creature of your choice within your Bardic Performance fails a Save, they're Taunted by you on the next Attack they make before the end of their next turn.\n• Distraction: When a hostile creature within 10 Spaces of you makes an Attack, you can spend 1 AP as a Reaction to roll a Help Die and subtract the result from the target's Check.\n• Pratfall: When you fail a Save imposed by a hostile creature, you can grant a creature within your Bardic Performance ADV on a Check of their choice before the end of their next turn."
				},
				{
					"featureName": "Comedian (Flavor Feature)",
					"levelGained": 3,
					"description": "You have ADV on Checks to make other creatures laugh.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/classes/spellblade_features.json
````json
{
	"className": "Spellblade",
	"startingEquipment": {
		"weaponsOrShields": [
			"2 Weapons or Light Shields (or Heavy Shields if you choose the Warrior Discipline, see below)"
		],
		"rangedWeapon": "1 Ranged Weapon with 20 Ammo OR 3 Weapons with the Toss or Thrown Property",
		"armor": "1 set of Light Armor (or Heavy Armor if you choose the Warrior Discipline)",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"martialPath": {
		"combatTraining": {
			"weapons": ["Weapons"],
			"armor": ["Light Armor"],
			"shields": ["Light Shields"]
		},
		"maneuvers": {
			"learnsAllAttack": true,
			"additionalKnown": "Maneuvers Known column of the Spellblade Class Table"
		},
		"techniques": {
			"additionalKnown": "Techniques Known column of the Spellblade Class Table"
		},
		"staminaPoints": {
			"maximumIncreasesBy": "Stamina Points column of the Spellblade Class Table"
		},
		"staminaRegen": {
			"description": "Once per round, you can regain up to half your maximum SP when you Hit with a Spell Attack or succeed on a Spell Check.",
			"conditions": []
		}
	},
	"spellcastingPath": {
		"combatTraining": {
			"armor": [],
			"shields": []
		},
		"spellList": {
			"type": "schools",
			"specificSchools": ["Destruction", "Protection"],
			"schoolCount": 1,
			"description": "You gain access to Destruction and Protection schools, plus 1 other School of your choice",
			"betaNote": "Until the Spell update in Beta 0.10 the Spellblade can pick between all currently available Spells from the Premade Spell Lists (within the available Schools of course)."
		},
		"cantrips": {
			"knownIncreasesBy": "Cantrips Known column of the Spellblade Class Table",
			"description": "Cantrips are Spells with the Cantrip Spell Tag."
		},
		"spells": {
			"knownIncreasesBy": "Spells Known column of the Spellblade Class Table",
			"description": "These can be Spells with or without the Cantrip Spell Tag."
		},
		"manaPoints": {
			"maximumIncreasesBy": "Mana Points column of the Spellblade Class Table"
		}
	},
	"coreFeatures": [
		{
			"featureName": "Bound Weapon",
			"levelGained": 1,
			"description": "During a Quick Rest, you can magically bond with 1 Weapon and choose an Elemental or Mystical damage type to become your Bound Damage type. This bond lasts until you end it for free or use this feature again. Your Bound Weapon gains the following properties:\n• Smite: When you make a Martial Attack with the Weapon, you can spend 1 or more SP to deal +2 Bound Damage per SP spent. When you do, you also gain the benefits of 1 Attack Maneuver of your choice for free.\n• Illuminate: You can cause the Weapon to emit a 5 Spaces of Dim or Bright Light (you choose the light's appearance). You can extinguish, produce, or adjust the level of this illumination at any time for free.\n• Recall: While the Weapon is within 20 Spaces and isn't being held or secured, you can call your Weapon back to you for free, causing it to fly to you. If you don't have a free hand when you call it, or you choose not to grab it, it falls in your Space at your feet.\nEnding Early: Your bond with the Weapon ends early if you use this Feature again, or you choose to end it for free."
		},
		{
			"featureName": "Spellblade Disciplines",
			"levelGained": 1,
			"description": "You learn 2 Spellblade Disciplines from the list below.",
			"choices": [
				{
					"prompt": "Choose 2 Spellblade Disciplines.",
					"count": 2,
					"options": [
						{
							"name": "Magus",
							"description": "You gain the following benefits: • Your Maximum MP increases by 1. • You learn 1 additional Spell."
						},
						{
							"name": "Warrior",
							"description": "You gain the following benefits: • You gain Heavy Armor and Heavy Shield Training. • You learn 2 Maneuvers."
						},
						{
							"name": "Acolyte",
							"description": "You can spend 1 AP and 1 MP to produce 1 of the following effects:\n• Heal: You gain a pool of healing that you can use to restore HP to any number of creatures within 5 Spaces of you, distributing the HP among them (minimum of 1 HP each). Make a DC 10 Spell Check. Success: You can restore up to 3 HP. Success (each 5): +1 HP. Failure: You only restore up to 2 HP.\n• Cure: You can attempt to remove 1 Poison or Disease from a creature of your choice within 1 Space of you. Make a Spell Check against the DC of the Poison or Disease. Success: The chosen Poison or Disease ends on the target."
						},
						{
							"name": "Hex Warrior",
							"description": "You can spend 1 AP and 1 MP to Curse a creature within 10 Spaces for 1 minute. You make a Spell Check against the target's Repeated Physical Save. Save Failure: The target is Dazed or Impaired (your choice) and takes 1 Umbral damage at the start of each of their turns. Additionally, they're prevented from regaining HP."
						},
						{
							"name": "Spell Breaker",
							"description": "You can spend 2 AP to initiate a Spell Duel against a Spell Attack using a Weapon instead of casting a Spell, provided the Initiator or a target of the Spell is within the range of your Weapon. When you do, you make an Attack Check and you can spend SP and MP (for a total up to your Mana Spend Limit) to gain a bonus on your Check equal to the SP and MP spent. You have ADV on your Check if you are within 1 Space of the Initiator."
						},
						{
							"name": "Spell Warder",
							"description": "When you deal Elemental or Mystical damage with an Attack, you gain Resistance (1) to that damage type until the start of your next turn. If you deal Elemental or Mystical damage again while this is already active, you can choose to keep the current Resistance or switch it out for the new one instead."
						},
						{
							"name": "Blink Blade",
							"description": "Once per turn, when you make an Attack, you can choose to teleport to a Space you can see within 1 Space immediately before or after making the Attack (your choice)."
						}
					]
				}
			]
		},
		{
			"featureName": "Sense Magic (Flavor Feature)",
			"levelGained": 1,
			"description": "You can spend 1 minute focusing your mind to detect the following creature types within 20 Spaces: Aberration, Celestial, Elemental, Fey, Fiend, or Undead. Make a Spell Check against each creature's Mental Save. Check Success: You learn the target's creature type and know its location until the end of your next turn. Check Failure: You learn nothing and can't use this Feature against the target again until you complete a Long Rest.",
			"isFlavor": true
		},
		{
			"featureName": "Spellstrike",
			"levelGained": 2,
			"description": "Once on each of your turns when you make a Martial Attack, you can also cast a Spell as part of the same Action, spending 1 AP less than normal.\nConverged Action: When you do, the Spell can only target 1 creature who must be a target of the Attack, and the range of the Attack can't exceed the range of the Spell. The Spell uses the Attack Check as its Spell Check for any of its requirements, and any Saves you force the target to make are made against your Save DC.\nHarmonic Strike: The Attack and Spell from a Spellstrike are treated as 1 Attack, and can benefit from Maneuvers and Spell Enhancements. The Spell doesn't require Somatic Components."
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Paladin",
			"features": [
				{
					"featureName": "Holy Warrior",
					"levelGained": 3,
					"description": "You gain the following benefits:\n• Aura of Protection: Creatures of your choice within 2 Spaces of you have ADV on Mental Saves.\n• Divine Strike: When you deal damage with Spellstrike, you can change the Spell's damage to Radiant or Umbral (choose when you gain this Feature).\n• Lay on Hands: You gain the Acolyte Spellblade Discipline. If you already know that Discipline, you gain another one of your choice. Once per Long Rest, you can use the Acolyte Discipline without spending MP and gain a +5 bonus on your Spell Check."
				},
				{
					"featureName": "Oathsworn (Flavor Feature)",
					"levelGained": 3,
					"description": "You make an oath to uphold the tenets of your choice below (or create your own with GM approval). While you're following your oath, you have ADV on Checks made to convince non-hostile creatures to join you in doing so.\nTENETS\n• Heart of Bravery: You must be courageous in all things and fight for what is right, whether on the battlefield or within oneself.\n• Light in the Darkness: You must be a beacon of hope for others and bring hope to the hopeless when all seems lost.\n• Instill Pain: Teach your enemies the meaning of pain so they may experience it for themselves and learn to never do it to others again.\n• Peacekeeper: You must always seek peace with your enemies first.\n• Protect the Weak: You must protect those that cannot protect themselves.\n• Unrelenting Effort: You must try your best in all things, never carelessly doing anything.\n• Vengeance: You must seek revenge on those who have harmed you, your loved ones, or the innocent.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Rune Knight",
			"features": [
				{
					"featureName": "Rune Weapon",
					"levelGained": 3,
					"description": "You can inscribe a magical Rune as you bond with your Bound Weapon, which can only bear 1 Rune at a time and lasts until the bond ends. When you complete a Quick Rest, you can change the Rune to another Rune you know. You learn 2 Runes from the following list.",
					"choices": [
						{
							"prompt": "Learn 2 Runes from the list.",
							"count": 2,
							"options": [
								{
									"name": "Earth Rune",
									"description": "Earthquake: When you Smite a target, you can create an area of Difficult Terrain on the ground in a 1 Space Radius Sphere centered on the target. Unmovable: You have ADV on Checks and Saves against being knocked Prone or moved against your will."
								},
								{
									"name": "Flame Rune",
									"description": "Scorching: When you Smite a creature with the Weapon, they must make a Physical Save. Save Failure: The target begins Burning. Hearth: You regain 2 Rest Points when you complete a Short Rest, provided you engaged in Combat since applying this Rune."
								},
								{
									"name": "Frost Rune",
									"description": "Frostbite: When you Smite a creature with the Weapon, they must make a Physical Save. Save Failure: The target is Grappled by ice until the end of your next turn. The creature can attempt to free itself by spend 1 AP to make an Athletics Check against your Save DC. Glacier: When you roll Initiative, you gain 2 Temp HP."
								},
								{
									"name": "Lightning Rune",
									"description": "Charged: When you Smite a creature with the Weapon, they must make a Physical Save. Save Failure: The target is Stunned 1 until the end of your next turn. Quickness: You gain +1 Speed."
								},
								{
									"name": "Water Rune",
									"description": "Wave: When you Smite a creature with the Weapon, you can spend 1 AP to force the target to make a Physical Save. Save Failure: The target is knocked Prone. Healing Waters: When an MP Effect restores your HP, you regain 1 additional HP."
								},
								{
									"name": "Wind Rune",
									"description": "Hurricane: When you Smite a creature with the Weapon, they must make a Physical Save. Save Failure: The target is pushed 1 Space horizontally in a direction of your choice. Wind Swept: You gain +3 Jump Distance and you no longer need to move 2 Spaces before performing a running Jump."
								}
							]
						}
					]
				},
				{
					"featureName": "Rune Expert (Flavor Feature)",
					"levelGained": 3,
					"description": "You have ADV on Checks made to understand the purpose and meaning of any magical rune you can see.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/rulesdata/classes/warlock_features.json
````json
{
	"className": "Warlock",
	"startingEquipment": {
		"weaponsOrShields": ["1 Weapon"],
		"armor": "1 set of Light Armor",
		"packs": "X or Y “Packs” (Adventuring Packs Coming Soon)"
	},
	"spellcastingPath": {
		"combatTraining": {
			"armor": ["Light Armor"]
		},
		"spellList": {
			"type": "all_schools",
			"schoolCount": 4,
			"description": "You choose 4 Spell Schools. When you learn a new Spell, you can choose any Spell from the chosen Spell Schools.",
			"betaNote": "The Warlock works in a unique way with Spell Schools, so until more Spells are released in future updates you just get access to any of the \"Premade Lists\" that have been released. You could pick 4 Spell Schools and then grab Spells from across all the Prepared Lists if you want to, but it will be difficult without with the current number of Spells."
		},
		"cantrips": {
			"knownIncreasesBy": "Cantrips Known column of the Warlock Class Table",
			"description": "Cantrips are Spells with the Cantrip Spell Tag."
		},
		"spells": {
			"knownIncreasesBy": "Spells Known column of the Warlock Class Table",
			"description": "These can be Spells with or without the Cantrip Spell Tag."
		},
		"manaPoints": {
			"maximumIncreasesBy": "Mana Points column of the Warlock Class Table"
		}
	},
	"coreFeatures": [
		{
			"featureName": "Warlock Contract",
			"levelGained": 1,
			"description": "You have a binding agreement with your patron that allows you to make sacrifices in exchange for boons.",
			"benefits": [
				{
					"name": "Hasty Bargain",
					"description": "Once per turn when you make a Check, you can spend 1 HP to gain ADV on the Check."
				},
				{
					"name": "Desperate Bargain",
					"description": "Once per Combat, you can spend 1 AP to regain an amount of HP equal to your Prime Modifier. When you do, you become Exposed until the end of your next turn."
				}
			]
		},
		{
			"featureName": "Pact Boon",
			"levelGained": 1,
			"description": "You gain a Pact Boon from your Patron. Choose 1 of the following options: Weapon, Armor, Cantrip, or Familiar.",
			"choices": [
				{
					"prompt": "Choose your Pact Boon.",
					"count": 1,
					"options": [
						{
							"name": "Pact Weapon",
							"description": "You can choose a Weapon in your possession and bond with it, making it your Pact Weapon. You can only have 1 Pact Weapon at a time. If the Weapon has the Ammo property, it manifests its own Ammo when you load it, which immediately vanishes once the Attack is resolved. You gain the following benefits while wielding the Weapon:\n• Weapon Mastery: You're considered to have Training with your Pact Weapon.\n• Maneuvers: You gain access to Attack Maneuvers, and learn 2 additional Save Maneuvers of your choice.\n• Weapon Style Passive: While wielding your Pact Weapon, you benefit from that Weapon Style Passive.\n• Pocket Dimension: Using a Minor Action, you can dismiss the Weapon into a pocket dimension, summon it from that pocket dimension, or summon it from anywhere on the same plane of existence. If you don't have a free hand when you summon it, or you choose not to grab it, it appears in your Space at your feet.\n• New Pact Weapon: Over the course of a Quick Rest, you can touch a Weapon in your possession, bond with it, and make it your new Pact Weapon, ending your bond with your previous Pact Weapon."
						},
						{
							"name": "Pact Armor",
							"description": "You can choose an Armor in your possession and bond with it, making it your Pact Armor. You can only have 1 Pact Armor at a time. You gain the following benefits while wearing the Armor:\n• Armor Mastery: You're considered to have Training with your Pact Armor.\n• Maneuvers: You learn 3 Defensive Maneuvers of your choice.\n• Mystical Armor: You gain MDR.\n• Pocket Dimension: Using a Minor Action, you can dismiss the Armor into a pocket dimension, summon it from that pocket dimension, or summon it from anywhere on the same plane of existence. If you aren't able to wear the Armor when you summon it, or you choose not to wear it, it appears in your Space at your feet.\n• New Pact Armor: Over the course of a Quick Rest, you can touch an Armor in your possession, bond with it, and make it your new Pact Armor, ending your bond with your previous Pact Armor."
						},
						{
							"name": "Pact Cantrip",
							"description": "Choose a Spell you know with the Cantrip Spell Tag. The chosen Spell becomes your Pact Cantrip. When you cast your Pact Cantrip, you gain the following benefits:\n• If the Spell deals damage, it deals an extra +1 damage to Bloodied targets.\n• If the Spell's range is Touch, it becomes 3 Spaces. Otherwise it increases by 5 Spaces.\n• Once per Round, when you cast your Pact Cantrip you can grant your self ADV on the Spell Check.\nChoosing a New Pact Cantrip: When you complete a Long Rest, you can choose a different Spell following the same restrictions. When you do, the new Spell becomes your new Pact Cantrip. You can only have 1 Pact Cantrip at a time."
						},
						{
							"name": "Pact Familiar",
							"description": "You learn the Find Familiar Spell. When you cast the Spell, your Familiar gains 3 additional Familiar Traits of your choice for free."
						}
					]
				}
			]
		},
		{
			"featureName": "Beseech Patron (Flavor Feature)",
			"levelGained": 1,
			"description": "During a Long Rest, while sleeping or meditating, you can access an Inner Sanctum within your mind. Its appearance is influenced by your psyche and is subject to change. While inside your Inner Sanctum, you can attempt to contact your Patron. If they choose to respond, they enter your mind and you might possibly be able to see or hear them. While connected to your Patron in this way, you're aware of your surroundings but you can't take actions or move. Your Patron chooses when to end the connection, or you can make a Mental Save against your own Save DC to force the connection to end.",
			"isFlavor": true
		},
		{
			"featureName": "Life Tap",
			"levelGained": 2,
			"description": "When you produce an MP Effect, you can spend HP in place of MP. The total amount of HP and MP spent can't exceed your Mana Spend Limit. You can use this Feature once per Long Rest, and regain the ability to use it again when you roll for Initiative."
		},
		{
			"featureName": "Talent",
			"levelGained": 2,
			"description": "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent."
		}
	],
	"subclasses": [
		{
			"subclassName": "Eldritch",
			"features": [
				{
					"featureName": "Otherworldly Gift",
					"levelGained": 3,
					"description": "Your patron grants you the following benefits:\n• Psychic Spellcasting: You learn 1 Spell of your choice with the Psychic Spell Tag. When you learn a new Spell, you can choose any Spell that has the Psychic Spell Tag.\n• Forbidden Knowledge: When you complete a Short or Long Rest, you temporarily learn any Spell of your choice. When you cast that Spell, its MP cost is reduced by 1 (minimum of 0). Its total MP cost before the reduction can't exceed your Mana Spend Limit. You forget the Spell immediately after you cast it or complete a Short or Long Rest.\nYou gain the following Warlock Contract option:\n• Eldritch Bargain: When you make an Attack against the PD or AD of a creature, you can spend 1 HP to target its other Defense instead."
				},
				{
					"featureName": "Alien Comprehension (Flavor Feature)",
					"levelGained": 3,
					"description": "You become Fluent in Deep Speech, and you understand the writings and ramblings of lunatics.",
					"isFlavor": true
				}
			]
		},
		{
			"subclassName": "Fey",
			"features": [
				{
					"featureName": "Fey Aspect",
					"levelGained": 3,
					"description": "Choose 1 of the following Conditions: Charmed or Intimidated. The chosen Condition becomes your Fey Aspect Condition. You gain the following Benefits:\n• Can't Trick a Trickster: You have ADV on Saves against your Fey Aspect Condition.\n• Fey Step: When you're Hit by an Attack, you can spend 1 AP as a Reaction to teleport up to 3 Spaces to an unoccupied Space you can see. When you do so, you become Invisible until the start of your next turn. You can use this Feature once per Long Rest, and regain the ability to use it again when you roll for Initiative.\nYou gain the following Warlock Contract option:\n• Beguiling Bargain: Once on each of your turns when you cast a Spell or make an Attack that targets at least 1 creature, you can spend 1 HP to force 1 target of your choice to make a Charisma Save against your Save DC. Failure: You subject the target to your Fey Aspect Condition until the end of your next turn."
				},
				{
					"featureName": "Dream Walker (Flavor Feature)",
					"levelGained": 3,
					"description": "While sleeping, you are lucid and can manipulate what appears in your dreams. Additionally, while you're in contact with a sleeping creature you can make a Spell Check against the target's Intelligence Save. Success: You can witness their dream. You choose if the creature notices that you're watching their dream or not. Failure: You can't use this Feature again on that creature until it wakes up.",
					"isFlavor": true
				}
			]
		}
	]
}
````

## File: src/lib/stores/characterInProgressStore.ts
````typescript
// src/lib/stores/characterInProgressStore.ts

import { writable, derived } from 'svelte/store';
import type { Writable } from 'svelte/store';
import type { CharacterInProgress } from '@prisma/client'; // Assuming Prisma client is generated
import { classesData } from '../rulesdata/loaders/class.loader';

// Define the shape of the data stored in the characterInProgressStore
// This should mirror the CharacterInProgress Prisma model, plus any UI state
export interface CharacterInProgressStoreData extends CharacterInProgress {
	// Add any UI-specific state here if needed, e.g., current step in wizard
	currentStep: number;
	// Add temporary state for trait selection overflow
	overflowTraitId: string | null;
	overflowAttributeName: string | null;
	// Add Level and Combat Mastery
	level: number;
	combatMastery: number; // Derived, but included in interface for clarity
}

// Initial state for the store, matching Prisma defaults and adding UI state
const initialCharacterInProgressState: CharacterInProgressStoreData = {
	id: '', // Will be set when a new character is started/loaded
	attribute_might: -2,
	attribute_agility: -2,
	attribute_charisma: -2,
	attribute_intelligence: -2,
	pointsSpent: 0,

	// Core Stats
	level: 1, // Default to Level 1 for MVP
	combatMastery: 1, // Calculated: Math.ceil(level / 2)

	ancestry1Id: null,
	ancestry2Id: null,
	selectedTraitIds: '', // JSON string of selected trait IDs
	ancestryPointsSpent: 0,

	classId: null,
	selectedFeatureChoices: '', // JSON string of selected feature choice IDs/values

	// Skills, Equipment, Details fields will be added/updated later
	finalName: null,
	finalPlayerName: null,

	createdAt: new Date(), // Placeholder, will be set by DB
	updatedAt: new Date(), // Placeholder, will be set by DB

	// UI State
	currentStep: 1, // Start at Stage A (Attributes)
	overflowTraitId: null,
	overflowAttributeName: null
};

// Create the writable store
export const characterInProgressStore: Writable<CharacterInProgressStoreData> = writable(
	initialCharacterInProgressState
);

// Helper function to get an attribute's modifier
// In DC20, the attribute score itself is the modifier.
// Handles null or undefined scores by returning 0.
export function getModifier(attributeScore: number | null | undefined): number {
	return attributeScore ?? 0;
}

// Constant for Level 1 Combat Mastery (DC20 p.22)
export const L1_COMBAT_MASTERY = 1; // Keep for reference, but use derived store

// --- Derived Stores ---

// Derived store for Combat Mastery (half level rounded up)
export const combatMastery = derived(characterInProgressStore, ($store) => {
	return Math.ceil(($store.level ?? 1) / 2); // Default to level 1 if store.level is null/undefined
});

// Derived store for the Prime Modifier Value and Attribute
export const primeModifier = derived(characterInProgressStore, ($store) => {
	const attributes = [
		{ name: 'Might', value: $store.attribute_might },
		{ name: 'Agility', value: $store.attribute_agility },
		{ name: 'Charisma', value: $store.attribute_charisma },
		{ name: 'Intelligence', value: $store.attribute_intelligence }
	];

	// Find the highest attribute score
	let highestAttribute = attributes[0];
	for (let i = 1; i < attributes.length; i++) {
		if (attributes[i].value > highestAttribute.value) {
			highestAttribute = attributes[i];
		}
	}

	// Handle ties: If there's a tie, the player chooses.
	// For now, we'll just pick the first one in case of a tie.
	// A more complex implementation might require user input on tie-breaking.
	// Add a defensive check for highestAttribute
	if (!highestAttribute) {
		console.error('Error calculating primeModifier: highestAttribute is undefined.');
		return { value: 0, attribute: 'Unknown' }; // Return a default safe value
	}

	const primeModifierValue = highestAttribute.value;
	const primeModifierAttribute = highestAttribute.name;

	return { value: primeModifierValue, attribute: primeModifierAttribute };
});

// Derived store for Grit Points (Base + Charisma Modifier)
export const gritPoints = derived(characterInProgressStore, ($store) => {
	// Assuming base Grit Points are defined in class data, but for now use a placeholder
	const baseGrit = 2; // Placeholder, should come from class data
	return baseGrit + getModifier($store.attribute_charisma);
});

// Derived store for Jump Distance (Agility Modifier, min 1)
export const jumpDistance = derived(characterInProgressStore, ($store) => {
	const agilityModifier = getModifier($store.attribute_agility);
	return agilityModifier < 1 ? 1 : agilityModifier;
});

/**
 * Derived store for Starting SP (from class)
 */
export const startingSP = derived(characterInProgressStore, ($store) => {
	if (!$store.classId) return 0;
	const classData = classesData.find((c: { id: string }) => c.id === $store.classId);
	return classData?.startingSP ?? 0;
});

/**
 * Derived store for Starting MP (from class)
 */
export const startingMP = derived(characterInProgressStore, ($store) => {
	if (!$store.classId) return 0;
	const classData = classesData.find((c: { id: string }) => c.id === $store.classId);
	return classData?.startingMP ?? 0;
});

// Derived store for Provisional Skill Points (5 + Intelligence Modifier + Class Bonus)
export const provisionalSkillPoints = derived(characterInProgressStore, ($store) => {
	const intelligenceModifier = getModifier($store.attribute_intelligence);
	// Assuming class data is available to get skillPointGrantLvl1
	// For now, use a placeholder of 0 if classId is not set
	const classSkillBonus = 0; // Placeholder, should come from class data based on $store.classId
	return 5 + intelligenceModifier + classSkillBonus;
});

import { traitsData } from '../rulesdata/traits.ts';
import type { ITrait } from '../rulesdata/types.ts';

// ... (rest of the file)

// Derived store for Ancestry Points Remaining (Base 5 - Spent)
export const ancestryPointsRemaining = derived(characterInProgressStore, ($store) => {
	const basePoints = 5;
	const selectedTraitIds = JSON.parse($store.selectedTraitIds || '[]');

	const traits = selectedTraitIds.map((id: string) =>
		traitsData.find((t: ITrait) => t.id === id)
	) as (ITrait | undefined)[];

	const totalCost = traits
		.filter((t): t is ITrait => t !== undefined)
		.reduce((acc: number, t: ITrait) => acc + t.cost, 0);

	return basePoints - totalCost;
});

/**
 * Derived store for Max HP (Class HP + Might Modifier + Ancestry HP)
 * Uses selected class's baseHpContribution, defaults to 8 if not set.
 */
export const maxHP = derived(characterInProgressStore, ($store) => {
	const classData = classesData.find((c: { id: string }) => c.id === $store.classId);
	const classHP = classData?.baseHpContribution ?? 8;
	const mightModifier = getModifier($store.attribute_might);
	const ancestryHP = 0; // Assuming 0 for MVP until Ancestry HP is implemented
	return classHP + mightModifier + ancestryHP;
});

// Derived store for Area Defense (8 + CM + Might Modifier + Charisma Modifier + Bonuses)
export const areaDefense = derived(
	[characterInProgressStore, combatMastery],
	([$store, $combatMastery]) => {
		const mightModifier = getModifier($store.attribute_might);
		const charismaModifier = getModifier($store.attribute_charisma);
		const bonuses = 0; // Assuming 0 for MVP until bonuses are implemented
		return 8 + $combatMastery + mightModifier + charismaModifier + bonuses;
	}
);

// Derived store for Precision Defense (8 + CM + Agility Modifier + Intelligence Modifier + Bonuses)
export const precisionDefense = derived(
	[characterInProgressStore, combatMastery],
	([$store, $combatMastery]) => {
		const agilityModifier = getModifier($store.attribute_agility);
		const intelligenceModifier = getModifier($store.attribute_intelligence);
		const bonuses = 0; // Assuming 0 for MVP until bonuses are implemented
		return 8 + $combatMastery + agilityModifier + intelligenceModifier + bonuses;
	}
);

// Derived store for Initiative (CM + Agility Modifier)
export const initiative = derived(
	[characterInProgressStore, combatMastery],
	([$store, $combatMastery]) => {
		const agilityModifier = getModifier($store.attribute_agility);
		return $combatMastery + agilityModifier;
	}
);
````

## File: src/routes/character-creation/Attributes.tsx
````typescript
import React from 'react';
import { useCharacter } from '../../lib/stores/characterContext';
import { useEnhancedCharacterCalculation } from '../../lib/hooks/useEnhancedCharacterCalculation';
import { attributesData } from '../../lib/rulesdata/attributes';
import styled from '@emotion/styled';
import {
	StyledContainer,
	StyledTitle,
	StyledPointsRemaining,
	StyledGrid,
	StyledCard,
	StyledCardTitle,
	StyledControls,
	StyledButton,
	StyledValue,
	StyledDescription
} from './styles/Attributes.styles';

// Additional styled components for enhanced display
const AttributeHeader = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 0.5rem;
`;

const AttributeTotal = styled.div<{ $exceeded: boolean }>`
	font-size: 1.1rem;
	font-weight: bold;
	color: ${props => props.$exceeded ? '#dc2626' : '#059669'};
`;

const AttributeBreakdown = styled.div`
	background-color: #f8fafc;
	border: 1px solid #e2e8f0;
	border-radius: 6px;
	padding: 0.75rem;
	margin-top: 0.75rem;
	font-size: 0.875rem;
`;

const BreakdownLine = styled.div`
	display: flex;
	justify-content: space-between;
	margin-bottom: 0.25rem;
	
	&:last-child {
		margin-bottom: 0;
		padding-top: 0.25rem;
		border-top: 1px solid #d1d5db;
		font-weight: 600;
	}
`;

const ValidationMessage = styled.div<{ $type: 'error' | 'warning' }>`
	margin-top: 0.5rem;
	padding: 0.5rem;
	border-radius: 4px;
	font-size: 0.75rem;
	background-color: ${props => props.$type === 'error' ? '#fef2f2' : '#fffbeb'};
	border: 1px solid ${props => props.$type === 'error' ? '#fecaca' : '#fed7aa'};
	color: ${props => props.$type === 'error' ? '#dc2626' : '#d97706'};
	
	&:before {
		content: ${props => props.$type === 'error' ? "'⚠️ '" : "'💡 '"};
		margin-right: 0.25rem;
	}
`;

type AttributeState = Record<string, number>;

function Attributes() {
	const { state, dispatch, attributePointsRemaining } = useCharacter();
	const { 
		getAttributeLimit, 
		canIncreaseAttribute, 
		canDecreaseAttribute,
		validateAttributeChange,
		getStatBreakdown
	} = useEnhancedCharacterCalculation();
	const typedState = state as unknown as AttributeState;

	function increaseAttribute(attribute: string) {
		if (attributePointsRemaining > 0) {
			const currentValue = typedState[attribute];
			const validation = validateAttributeChange(attribute.replace('attribute_', ''), currentValue + 1);
			
			if (validation.isValid) {
				dispatch({ type: 'UPDATE_ATTRIBUTE', attribute, value: currentValue + 1 });
			}
		}
	}

	function decreaseAttribute(attribute: string) {
		const currentValue = typedState[attribute];
		const validation = validateAttributeChange(attribute.replace('attribute_', ''), currentValue - 1);
		
		if (validation.isValid) {
			dispatch({ type: 'UPDATE_ATTRIBUTE', attribute, value: currentValue - 1 });
		}
	}

	return (
		<StyledContainer>
			<StyledTitle>Attributes</StyledTitle>
			<StyledPointsRemaining>Points Remaining: {attributePointsRemaining}</StyledPointsRemaining>
			<StyledGrid>
				{attributesData.map((attribute) => {
					const attributeKey = `attribute_${attribute.id}`;
					const currentValue = typedState[attributeKey] || 0;
					const limit = getAttributeLimit(attribute.id);
					const breakdown = getStatBreakdown(attribute.id);
					
					// Enhanced validation
					const canIncrease = attributePointsRemaining > 0 && canIncreaseAttribute(attribute.id);
					const canDecrease = canDecreaseAttribute(attribute.id);
					
					return (
						<StyledCard key={attribute.id}>
							<AttributeHeader>
								<StyledCardTitle>{attribute.name}</StyledCardTitle>
								<AttributeTotal $exceeded={limit.exceeded}>
									{limit.current}/{limit.max}
								</AttributeTotal>
							</AttributeHeader>
							
							<StyledDescription>{attribute.description}</StyledDescription>
							
							<StyledControls>
								<StyledButton
									onClick={() => decreaseAttribute(attributeKey)}
									disabled={!canDecrease}
									title={!canDecrease ? "Cannot decrease below -2" : ""}
								>
									-
								</StyledButton>
								<StyledValue>{currentValue}</StyledValue>
								<StyledButton
									onClick={() => increaseAttribute(attributeKey)}
									disabled={!canIncrease}
									title={!canIncrease ? (
										attributePointsRemaining <= 0 ? "No points remaining" : 
										"Would exceed maximum with trait bonuses"
									) : ""}
								>
									+
								</StyledButton>
							</StyledControls>
							
							{/* Enhanced breakdown display */}
							{(limit.traitBonuses > 0 || breakdown) && (
								<AttributeBreakdown>
									<BreakdownLine>
										<span>Base Points:</span>
										<span>{limit.base}</span>
									</BreakdownLine>
									{limit.traitBonuses > 0 && (
										<BreakdownLine>
											<span>Trait Bonuses:</span>
											<span>+{limit.traitBonuses}</span>
										</BreakdownLine>
									)}
									<BreakdownLine>
										<span>Total:</span>
										<span>{limit.current}</span>
									</BreakdownLine>
								</AttributeBreakdown>
							)}
							
							{/* Validation messages */}
							{limit.exceeded && (
								<ValidationMessage $type="error">
									Exceeds maximum limit of +{limit.max}
								</ValidationMessage>
							)}
							
							{!limit.exceeded && !canIncrease && attributePointsRemaining > 0 && (
								<ValidationMessage $type="warning">
									Cannot increase further due to trait bonuses
								</ValidationMessage>
							)}
						</StyledCard>
					);
				})}
			</StyledGrid>
		</StyledContainer>
	);
}

export default Attributes;
````

## File: src/routes/character-creation/CharacterName.tsx
````typescript
import { useState } from 'react';
import { useCharacter } from '../../lib/stores/characterContext';
import { nameByRace } from 'fantasy-name-generator';
import {
	StyledContainer,
	StyledTitle,
	StyledInputGroup,
	StyledLabel,
	StyledInput,
	StyledSuggestionSection,
	StyledSuggestionTitle,
	StyledSuggestionGrid,
	StyledSuggestionButton,
	StyledGenerateButton,
	StyledCharacterInfo,
	StyledCharacterDetails
} from './styles/CharacterName.styles';

// Name generation using fantasy-name-generator npm package
const generateNamesFromNPM = (race: string): string[] => {
	try {
		const names: string[] = [];

		// Generate 6 different names (3 male, 3 female)
		for (let i = 0; i < 3; i++) {
			const maleName = nameByRace(race, { gender: 'male' });
			const femaleName = nameByRace(race, { gender: 'female' });

			if (maleName && typeof maleName === 'string') {
				names.push(maleName);
			}
			if (femaleName && typeof femaleName === 'string') {
				names.push(femaleName);
			}
		}

		return names.filter((name) => name.length > 0);
	} catch (error) {
		console.error('Error generating names from npm package:', error);
		return [];
	}
};

function CharacterName() {
	const { state, dispatch } = useCharacter();
	const [characterName, setCharacterName] = useState(state.finalName || '');
	const [playerName, setPlayerName] = useState(state.finalPlayerName || '');
	const [suggestions, setSuggestions] = useState<string[]>([]);
	const [isGenerating, setIsGenerating] = useState(false);

	const getFallbackNames = (ancestry: string) => {
		const fallbackNames: { [key: string]: string[] } = {
			human: ['Aiden', 'Brianna', 'Connor', 'Diana', 'Ethan', 'Fiona'],
			elf: ['Aerdrie', 'Berrian', 'Caelynn', 'Dayereth', 'Enna', 'Galinndan'],
			dwarf: ['Adrik', 'Baern', 'Cathra', 'Darrak', 'Eberk', 'Falkrunn'],
			halfling: ['Alton', 'Bree', 'Cora', 'Daisy', 'Eldon', 'Finnan'],
			dragonborn: ['Arjhan', 'Balasar', 'Bharash', 'Donaar', 'Ghesh', 'Heskan'],
			gnome: ['Alston', 'Boddynock', 'Brocc', 'Burgell', 'Dimble', 'Eldon'],
			'half-elf': ['Aramil', 'Berrian', 'Carric', 'Dayereth', 'Enna', 'Galinndan'],
			'half-orc': ['Dench', 'Feng', 'Gell', 'Henk', 'Holg', 'Imsh'],
			tiefling: ['Akmenos', 'Amnon', 'Barakas', 'Damakos', 'Ekemon', 'Iados']
		};

		return fallbackNames[ancestry] || fallbackNames.human;
	};

	const generateNames = () => {
		// No need for rate limiting with npm package, but keep generating state for UX
		if (isGenerating) {
			return;
		}

		setIsGenerating(true);

		try {
			// Get character details
			const ancestry1 = state.ancestry1Id?.toLowerCase() || 'human';
			const ancestry2 = state.ancestry2Id?.toLowerCase();

			// Map ancestry names to npm package race names
			const raceMapping: { [key: string]: string } = {
				human: 'human',
				elf: 'elf',
				dwarf: 'dwarf',
				halfling: 'halfling',
				dragonborn: 'dragon',
				gnome: 'gnome',
				'half-elf': 'elf',
				'half-orc': 'orc',
				tiefling: 'demon',
				default: 'human'
			};

			// Always generate names from first ancestry
			const mappedRace1 = raceMapping[ancestry1] || 'human';
			const npmNames1 = generateNamesFromNPM(mappedRace1);
			const fallbackNames1 = getFallbackNames(ancestry1);
			let allNames = [...npmNames1, ...fallbackNames1].slice(0, 6);

			// If second ancestry exists, append 6 more names from it
			if (ancestry2) {
				const mappedRace2 = raceMapping[ancestry2] || 'human';
				const npmNames2 = generateNamesFromNPM(mappedRace2);
				const fallbackNames2 = getFallbackNames(ancestry2);
				const names2 = [...npmNames2, ...fallbackNames2].slice(0, 6);
				allNames = [...allNames, ...names2];
			}

			// Remove duplicates and limit appropriately
			const uniqueNames = [...new Set(allNames)];

			// Add a small delay for better UX (simulate processing)
			setTimeout(() => {
				setSuggestions(uniqueNames);
				setIsGenerating(false);
			}, 500);
		} catch (error) {
			console.error('Error generating names:', error);
			// Fallback to local names
			const fallbackNames = getFallbackNames(state.ancestry1Id?.toLowerCase() || 'human');
			setSuggestions(fallbackNames);
			setIsGenerating(false);
		}
	};

	const selectSuggestion = (name: string) => {
		setCharacterName(name);
		// Update the context immediately
		dispatch({
			type: 'UPDATE_STORE',
			updates: {
				finalName: name
			}
		});
	};

	const getCharacterDescription = () => {
		const ancestry1 = state.ancestry1Id;
		const ancestry2 = state.ancestry2Id;
		const classId = state.classId;

		let ancestryDescription = 'Your Character';

		if (ancestry1 && ancestry2) {
			// Both ancestries exist
			ancestryDescription = `${ancestry1.charAt(0).toUpperCase() + ancestry1.slice(1)}/${ancestry2.charAt(0).toUpperCase() + ancestry2.slice(1)}`;
		} else if (ancestry1) {
			// Only first ancestry
			ancestryDescription = `${ancestry1.charAt(0).toUpperCase() + ancestry1.slice(1)}`;
		}

		if (classId) {
			return `${ancestryDescription} ${classId.charAt(0).toUpperCase() + classId.slice(1)}`;
		}

		return ancestryDescription;
	};

	return (
		<StyledContainer>
			<StyledTitle>Name Your Character</StyledTitle>

			<StyledCharacterInfo>
				<StyledCharacterDetails>Creating: {getCharacterDescription()}</StyledCharacterDetails>
			</StyledCharacterInfo>

			<StyledInputGroup>
				<StyledLabel htmlFor="characterName">Character Name</StyledLabel>
				<StyledInput
					id="characterName"
					type="text"
					value={characterName}
					onChange={(e) => {
						const value = e.target.value;
						setCharacterName(value);
						// Update the context immediately
						dispatch({
							type: 'UPDATE_STORE',
							updates: {
								finalName: value.trim() || null
							}
						});
					}}
					placeholder="Enter your character's name"
				/>
			</StyledInputGroup>

			<StyledInputGroup>
				<StyledLabel htmlFor="playerName">Player Name</StyledLabel>
				<StyledInput
					id="playerName"
					type="text"
					value={playerName}
					onChange={(e) => {
						const value = e.target.value;
						setPlayerName(value);
						// Update the context immediately
						dispatch({
							type: 'UPDATE_STORE',
							updates: {
								finalPlayerName: value.trim() || null
							}
						});
					}}
					placeholder="Enter your name"
				/>
			</StyledInputGroup>

			<StyledSuggestionSection>
				<StyledSuggestionTitle>Name Suggestions</StyledSuggestionTitle>
				{suggestions.length > 0 && (
					<StyledSuggestionGrid>
						{suggestions.map((name, index) => (
							<StyledSuggestionButton key={index} onClick={() => selectSuggestion(name)}>
								{name}
							</StyledSuggestionButton>
						))}
					</StyledSuggestionGrid>
				)}
				<StyledGenerateButton onClick={generateNames} disabled={isGenerating}>
					{isGenerating ? 'Generating...' : 'Generate Names'}
				</StyledGenerateButton>
			</StyledSuggestionSection>
		</StyledContainer>
	);
}

export default CharacterName;
````

## File: src/routes/character-creation/LoadCharacter.tsx
````typescript
import { useState, useEffect } from 'react';
import type { SavedCharacter } from '../../lib/utils/characterEdit';
import {
	StyledContainer,
	StyledTitle,
	StyledCharacterGrid,
	StyledCharacterCard,
	StyledCardActions,
	StyledActionButton,
	StyledCharacterName,
	StyledPlayerName,
	StyledCharacterDetails,
	StyledDetailItem,
	StyledDetailLabel,
	StyledDetailValue,
	StyledCompletedDate,
	StyledEmptyState,
	StyledEmptyTitle,
	StyledEmptyText,
	StyledBackButton
} from './styles/LoadCharacter.styles';

interface LoadCharacterProps {
	onBack: () => void;
	onLoadCharacter?: (character: SavedCharacter) => void;
	onSelectCharacter?: (characterId: string) => void;
	onEditCharacter?: (character: SavedCharacter) => void;
}

function LoadCharacter({
	onBack,
	onLoadCharacter,
	onSelectCharacter,
	onEditCharacter
}: LoadCharacterProps) {
	const [savedCharacters, setSavedCharacters] = useState<SavedCharacter[]>([]);

	useEffect(() => {
		const characters = JSON.parse(localStorage.getItem('savedCharacters') || '[]');
		setSavedCharacters(characters);
	}, []);

	const handleCharacterClick = (character: SavedCharacter) => {
		if (onEditCharacter) {
			onEditCharacter(character);
		} else if (onLoadCharacter) {
			onLoadCharacter(character);
		} else {
			console.log('Loading character:', character);
			// TODO: Implement character loading logic
		}
	};

	const handleViewCharacterSheet = (character: SavedCharacter, event: React.MouseEvent) => {
		event.stopPropagation();
		if (onSelectCharacter) {
			onSelectCharacter(character.id);
		}
	};

	const formatDate = (dateString: string) => {
		return new Date(dateString).toLocaleDateString('en-US', {
			year: 'numeric',
			month: 'short',
			day: 'numeric',
			hour: '2-digit',
			minute: '2-digit'
		});
	};

	const formatAncestry = (ancestry1: string, ancestry2?: string) => {
		if (ancestry2) {
			return `${ancestry1}/${ancestry2}`;
		}
		return ancestry1;
	};

	return (
		<StyledContainer>
			<StyledBackButton onClick={onBack}>← Back to Menu</StyledBackButton>

			<StyledTitle>Load Character</StyledTitle>

			{savedCharacters.length === 0 ? (
				<StyledEmptyState>
					<StyledEmptyTitle>No Saved Characters</StyledEmptyTitle>
					<StyledEmptyText>
						You haven't created any characters yet.
						<br />
						Go back to the menu and create your first character!
					</StyledEmptyText>
				</StyledEmptyState>
			) : (
				<StyledCharacterGrid>
					{savedCharacters.map((character) => (
						<StyledCharacterCard key={character.id}>
							<StyledCharacterName>
								{character.finalName || 'Unnamed Character'}
							</StyledCharacterName>

							<StyledPlayerName>Player: {character.finalPlayerName || 'Unknown'}</StyledPlayerName>

							<StyledCharacterDetails>
								<StyledDetailItem>
									<StyledDetailLabel>Race</StyledDetailLabel>
									<StyledDetailValue>
										{formatAncestry(
											character.ancestry1Name || character.ancestry1Id || 'Unknown',
											character.ancestry2Name || character.ancestry2Id
										)}
									</StyledDetailValue>
								</StyledDetailItem>

								<StyledDetailItem>
									<StyledDetailLabel>Class</StyledDetailLabel>
									<StyledDetailValue>
										{character.className || character.classId || 'Unknown'}
									</StyledDetailValue>
								</StyledDetailItem>
							</StyledCharacterDetails>

							<StyledCompletedDate>
								Created: {formatDate(character.createdAt || character.completedAt)}
							</StyledCompletedDate>

							<StyledCardActions>
								<StyledActionButton
									variant="primary"
									onClick={(e) => handleViewCharacterSheet(character, e)}
								>
									View Sheet
								</StyledActionButton>
								<StyledActionButton
									variant="secondary"
									onClick={() => handleCharacterClick(character)}
								>
									Edit
								</StyledActionButton>
							</StyledCardActions>
						</StyledCharacterCard>
					))}
				</StyledCharacterGrid>
			)}
		</StyledContainer>
	);
}

export default LoadCharacter;
````

## File: src/routes/character-sheet/components/Attributes.tsx
````typescript
import React from 'react';
import type { SkillData, CharacterSheetData } from '../../../types';
import {
	AttributeSection,
	AttributeHeader,
	AttributeBox,
	AttributeAbbreviation,
	AttributeValue,
	AttributeInfo,
	AttributeName,
	AttributeSave,
	SkillRow,
	SkillName,
	PrimeSection,
	PrimeLabel,
	PrimeValue
} from '../styles/Attributes';
import { StyledProficiencyDots, StyledDot } from '../styles/Skills';

interface AttributesProps {
	characterData: CharacterSheetData;
	skillsByAttribute: {
		prime: SkillData[];
		might: SkillData[];
		agility: SkillData[];
		charisma: SkillData[];
		intelligence: SkillData[];
	};
}

const Attributes: React.FC<AttributesProps> = ({ characterData, skillsByAttribute }) => {
	const renderSkills = (skills: SkillData[]) => {
		return skills.map((skill) => (
			<SkillRow key={skill.id}>
				<SkillName>{skill.name.toUpperCase()}</SkillName>
				<div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
					<StyledProficiencyDots>
						{[1, 2, 3, 4, 5].map((level) => (
							<StyledDot key={level} filled={level <= skill.proficiency} />
						))}
					</StyledProficiencyDots>
					{skill.bonus !== undefined && (
						<span style={{
							fontSize: '0.875rem',
							fontWeight: '600',
							color: skill.bonus >= 0 ? '#059669' : '#dc2626',
							minWidth: '2rem',
							textAlign: 'center'
						}}>
							{skill.bonus >= 0 ? '+' : ''}{skill.bonus}
						</span>
					)}
				</div>
			</SkillRow>
		));
	};

	return (
		<>
			{/* Prime Modifier & Awareness */}
			<PrimeSection>
				<PrimeLabel>Prime</PrimeLabel>
				<PrimeValue>
					{characterData.finalPrimeModifierAttribute} +{characterData.finalPrimeModifierValue}
				</PrimeValue>
			</PrimeSection>

			{/* Awareness (Prime skill) */}
			{renderSkills(skillsByAttribute.prime)}

			{/* Might Section */}
			<AttributeSection>
				<AttributeHeader>
					<AttributeBox>
						<AttributeAbbreviation>MIG</AttributeAbbreviation>
						<AttributeValue>{characterData.finalMight}</AttributeValue>
					</AttributeBox>
					<AttributeInfo>
						<AttributeName>MIGHT</AttributeName>
						<AttributeSave>SAVE +{characterData.finalSaveMight}</AttributeSave>
					</AttributeInfo>
				</AttributeHeader>

				{renderSkills(skillsByAttribute.might)}
			</AttributeSection>

			{/* Agility Section */}
			<AttributeSection>
				<AttributeHeader>
					<AttributeBox>
						<AttributeAbbreviation>AGI</AttributeAbbreviation>
						<AttributeValue>{characterData.finalAgility}</AttributeValue>
					</AttributeBox>
					<AttributeInfo>
						<AttributeName>AGILITY</AttributeName>
						<AttributeSave>SAVE +{characterData.finalSaveAgility}</AttributeSave>
					</AttributeInfo>
				</AttributeHeader>

				{renderSkills(skillsByAttribute.agility)}
			</AttributeSection>

			{/* Charisma Section */}
			<AttributeSection>
				<AttributeHeader>
					<AttributeBox>
						<AttributeAbbreviation>CHA</AttributeAbbreviation>
						<AttributeValue>{characterData.finalCharisma}</AttributeValue>
					</AttributeBox>
					<AttributeInfo>
						<AttributeName>CHARISMA</AttributeName>
						<AttributeSave>SAVE +{characterData.finalSaveCharisma}</AttributeSave>
					</AttributeInfo>
				</AttributeHeader>

				{renderSkills(skillsByAttribute.charisma)}
			</AttributeSection>

			{/* Intelligence Section */}
			<AttributeSection>
				<AttributeHeader>
					<AttributeBox>
						<AttributeAbbreviation>INT</AttributeAbbreviation>
						<AttributeValue>{characterData.finalIntelligence}</AttributeValue>
					</AttributeBox>
					<AttributeInfo>
						<AttributeName>INTELLIGENCE</AttributeName>
						<AttributeSave>SAVE +{characterData.finalSaveIntelligence}</AttributeSave>
					</AttributeInfo>
				</AttributeHeader>

				{renderSkills(skillsByAttribute.intelligence)}
			</AttributeSection>
		</>
	);
};

export default Attributes;
````

## File: src/routes/character-sheet/components/KnowledgeTrades.tsx
````typescript
import React from 'react';
import type { TradeData } from '../../../types';
import {
	KnowledgeTradesSection,
	SectionTitle,
	SectionDescription,
	EmptyMessage
} from '../styles/KnowledgeTrades';
import { SkillRow, SkillName } from '../styles/Attributes';
import { StyledProficiencyDots, StyledDot } from '../styles/Skills';

interface KnowledgeTradesProps {
	knowledge: TradeData[];
	trades: TradeData[];
}

const KnowledgeTrades: React.FC<KnowledgeTradesProps> = ({ knowledge, trades }) => {
	return (
		<>
			{/* Knowledge Section */}
			<KnowledgeTradesSection>
				<SectionTitle>KNOWLEDGE</SectionTitle>
				<SectionDescription>Intelligence-based knowledge trades</SectionDescription>
							{knowledge.map((knowledgeItem) => (
				<SkillRow key={knowledgeItem.id}>
					<SkillName>{knowledgeItem.name.toUpperCase()}</SkillName>
					<div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
						<StyledProficiencyDots>
							{[1, 2, 3, 4, 5].map((level) => (
								<StyledDot key={level} filled={level <= knowledgeItem.proficiency} />
							))}
						</StyledProficiencyDots>
						{knowledgeItem.bonus !== undefined && (
							<span style={{
								fontSize: '0.875rem',
								fontWeight: '600',
								color: knowledgeItem.bonus >= 0 ? '#059669' : '#dc2626',
								minWidth: '2rem',
								textAlign: 'center'
							}}>
								{knowledgeItem.bonus >= 0 ? '+' : ''}{knowledgeItem.bonus}
							</span>
						)}
					</div>
				</SkillRow>
			))}
		</KnowledgeTradesSection>

			{/* Trades Section */}
			<KnowledgeTradesSection>
				<SectionTitle>TRADES</SectionTitle>
				<SectionDescription>Selected practical trades & crafts</SectionDescription>
				{trades.length > 0 ? (
									trades.map((trade) => (
					<SkillRow key={trade.id}>
						<SkillName>{trade.name.toUpperCase()}</SkillName>
						<div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
							<StyledProficiencyDots>
								{[1, 2, 3, 4, 5].map((level) => (
									<StyledDot key={level} filled={level <= trade.proficiency} />
								))}
							</StyledProficiencyDots>
							{trade.bonus !== undefined && (
								<span style={{
									fontSize: '0.875rem',
									fontWeight: '600',
									color: trade.bonus >= 0 ? '#059669' : '#dc2626',
									minWidth: '2rem',
									textAlign: 'center'
								}}>
									{trade.bonus >= 0 ? '+' : ''}{trade.bonus}
								</span>
							)}
						</div>
					</SkillRow>
				))
				) : (
					<EmptyMessage>No trades selected</EmptyMessage>
				)}
			</KnowledgeTradesSection>
		</>
	);
};

export default KnowledgeTrades;
````

## File: src/routes/character-sheet/components/Movement.tsx
````typescript
import React from 'react';
import type { CharacterSheetData } from '../../../types';
import {
	StyledMovementContainer,
	StyledMovementGrid,
	StyledMovementStat,
	StyledMovementLabel,
	StyledMovementValue
} from '../styles/Movement.styles';
import Tooltip from './Tooltip';
import { createSpeedTooltip, createJumpTooltip } from './StatTooltips';

interface MovementProps {
	characterData: CharacterSheetData;
}

const Movement: React.FC<MovementProps> = ({ characterData }) => {
	return (
		<StyledMovementContainer>
			<StyledMovementGrid>
				<StyledMovementStat>
					<StyledMovementLabel>MOVE SPEED</StyledMovementLabel>
					<Tooltip content={createSpeedTooltip(characterData)} position="top">
						<StyledMovementValue>{characterData.finalMoveSpeed}</StyledMovementValue>
					</Tooltip>
				</StyledMovementStat>
				<StyledMovementStat>
					<StyledMovementLabel>JUMP DISTANCE</StyledMovementLabel>
					<Tooltip content={createJumpTooltip(characterData)} position="top">
						<StyledMovementValue>{characterData.finalJumpDistance}</StyledMovementValue>
					</Tooltip>
				</StyledMovementStat>
			</StyledMovementGrid>
		</StyledMovementContainer>
	);
};

export default Movement;
````

## File: src/routes/character-sheet/components/Resources.tsx
````typescript
import React from 'react';
import Tooltip from './Tooltip';
import { createHPTooltip, createMPTooltip, createSPTooltip } from './StatTooltips';
import {
	ResourcesContainer,
	ResourceColumn,
	ResourceLabel,
	ResourceControls,
	TempHPControls,
	TempHPLabel,
	TempHPInputSmall
} from '../styles/Resources';
import { StyledResourceButton } from '../styles/Resources';
import {
	StyledPotionContainer,
	StyledPotionFill,
	StyledPotionBubbles,
	StyledPotionValue,
	StyledLargePotionContainer,
	StyledLargePotionValue
} from '../styles/Potions';

interface ResourcesProps {
	characterData: {
		finalSPMax: number;
		finalMPMax: number;
		finalHPMax: number;
	};
	currentValues: {
		currentSP: number;
		currentMP: number;
		currentHP: number;
		tempHP: number;
	};
	onAdjustResource: (
		resource: 'currentSP' | 'currentMP' | 'currentHP' | 'tempHP',
		amount: number
	) => void;
	onResourceInputChange: (resource: 'tempHP', value: string) => void;
	getFillPercentage: (current: number, max: number) => number;
	getHPFillPercentage: (current: number, max: number, tempHP: number) => number;
	isMobile?: boolean;
}

const Resources: React.FC<ResourcesProps> = ({
	characterData,
	currentValues,
	onAdjustResource,
	onResourceInputChange,
	getFillPercentage,
	getHPFillPercentage,
	isMobile = false
}) => {
	return (
		<ResourcesContainer $isMobile={isMobile}>
			{/* Stamina Points */}
			<ResourceColumn $isMobile={isMobile}>
				<ResourceLabel>STAMINA POINTS</ResourceLabel>
				<ResourceControls>
					<StyledResourceButton onClick={() => onAdjustResource('currentSP', -1)}>
						-
					</StyledResourceButton>
					<StyledPotionContainer style={{ borderColor: '#22c55e' }}>
						<StyledPotionFill
							fillPercentage={getFillPercentage(currentValues.currentSP, characterData.finalSPMax)}
							color="#22c55e"
						/>
						<StyledPotionBubbles
							color="#22c55e"
							fillPercentage={getFillPercentage(currentValues.currentSP, characterData.finalSPMax)}
						/>
						<StyledPotionValue>{currentValues.currentSP}</StyledPotionValue>
					</StyledPotionContainer>
					<StyledResourceButton onClick={() => onAdjustResource('currentSP', 1)}>
						+
					</StyledResourceButton>
				</ResourceControls>
				<div
					style={{
						fontSize: '1.1rem',
						fontWeight: '300',
						color: '#666',
						marginTop: '0.3rem',
						fontStyle: 'italic'
					}}
				>
					<Tooltip content={createSPTooltip(characterData)} position="top">
						<span style={{ cursor: 'help' }}>{characterData.finalSPMax}</span>
					</Tooltip>
				</div>
			</ResourceColumn>

			{/* Mana Points */}
			<ResourceColumn $isMobile={isMobile}>
				<ResourceLabel>MANA POINTS</ResourceLabel>
				<ResourceControls>
					<StyledResourceButton onClick={() => onAdjustResource('currentMP', -1)}>
						-
					</StyledResourceButton>
					<StyledPotionContainer style={{ borderColor: '#3b82f6' }}>
						<StyledPotionFill
							fillPercentage={getFillPercentage(currentValues.currentMP, characterData.finalMPMax)}
							color="#3b82f6"
						/>
						<StyledPotionBubbles
							color="#3b82f6"
							fillPercentage={getFillPercentage(currentValues.currentMP, characterData.finalMPMax)}
						/>
						<StyledPotionValue>{currentValues.currentMP}</StyledPotionValue>
					</StyledPotionContainer>
					<StyledResourceButton onClick={() => onAdjustResource('currentMP', 1)}>
						+
					</StyledResourceButton>
				</ResourceControls>
				<div
					style={{
						fontSize: '1.1rem',
						fontWeight: '300',
						color: '#666',
						marginTop: '0.3rem',
						fontStyle: 'italic'
					}}
				>
					<Tooltip content={createMPTooltip(characterData)} position="top">
						<span style={{ cursor: 'help' }}>{characterData.finalMPMax}</span>
					</Tooltip>
				</div>
			</ResourceColumn>

			{/* Hit Points */}
			<ResourceColumn $isMobile={isMobile}>
				<ResourceLabel>HIT POINTS</ResourceLabel>
				<ResourceControls>
					<StyledResourceButton onClick={() => onAdjustResource('currentHP', -1)}>
						-
					</StyledResourceButton>
					<StyledLargePotionContainer style={{ borderColor: '#dc2626' }}>
						<StyledPotionFill
							fillPercentage={getHPFillPercentage(
								currentValues.currentHP,
								characterData.finalHPMax,
								currentValues.tempHP
							)}
							color="#dc2626"
						/>
						<StyledPotionBubbles
							color="#dc2626"
							fillPercentage={getHPFillPercentage(
								currentValues.currentHP,
								characterData.finalHPMax,
								currentValues.tempHP
							)}
						/>
						<StyledLargePotionValue>{currentValues.currentHP}</StyledLargePotionValue>
					</StyledLargePotionContainer>
					<StyledResourceButton onClick={() => onAdjustResource('currentHP', 1)}>
						+
					</StyledResourceButton>
				</ResourceControls>
				<div
					style={{
						fontSize: '1.1rem',
						fontWeight: '300',
						color: '#666',
						marginTop: '0.3rem',
						fontStyle: 'italic',
						display: 'flex',
						alignItems: 'center',
						justifyContent: 'center',
						gap: '0.5rem'
					}}
				>
					<Tooltip content={createHPTooltip(characterData)} position="top">
						<span style={{ cursor: 'help' }}>{characterData.finalHPMax}</span>
					</Tooltip>
					{currentValues.tempHP > 0 && (
						<span style={{ color: '#dc2626', fontWeight: 'bold', fontSize: '0.9rem' }}>
							(+{currentValues.tempHP} temp)
						</span>
					)}
				</div>

				{/* Temp HP Controls */}
				<TempHPControls>
					<TempHPLabel>TEMP HP:</TempHPLabel>
					<StyledResourceButton
						onClick={() => onAdjustResource('tempHP', -1)}
						style={{ fontSize: '0.7rem', width: '20px', height: '20px', padding: '0' }}
					>
						-
					</StyledResourceButton>
					<TempHPInputSmall
						type="number"
						value={currentValues.tempHP}
						onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
							onResourceInputChange('tempHP', e.target.value)
						}
					/>
					<StyledResourceButton
						onClick={() => onAdjustResource('tempHP', 1)}
						style={{ fontSize: '0.7rem', width: '20px', height: '20px', padding: '0' }}
					>
						+
					</StyledResourceButton>
				</TempHPControls>
			</ResourceColumn>
		</ResourcesContainer>
	);
};

export default Resources;
````

## File: src/routes/character-sheet/styles/Combat.ts
````typescript
import styled from 'styled-components';

export const StyledCombatSection = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: rgba(245, 243, 240, 0.5);
`;

export const StyledDefenseGrid = styled.div`
	display: grid;
	grid-template-columns: 1fr 1fr;
	gap: 1rem;
	margin-bottom: 1rem;

	@media (max-width: 768px) {
		grid-template-columns: 1fr;
		gap: 0.5rem;
	}
`;

export const StyledDefenseBox = styled.div`
	text-align: center;
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 0.8rem;
	background: white;
`;

export const StyledDefenseValue = styled.div`
	font-size: 1.8rem;
	font-weight: bold;
	color: #8b4513;
`;

export const StyledDefenseLabel = styled.div`
	font-size: 0.7rem;
	font-weight: bold;
	text-transform: uppercase;
	color: #666;
	margin-top: 0.2rem;
`;

export const StyledActionPoints = styled.div`
	display: flex;
	justify-content: center;
	gap: 0.5rem;
	margin: 1rem 0;

	@media (max-width: 768px) {
		gap: 0.3rem;
		flex-wrap: wrap;
	}
`;

export const StyledActionPoint = styled.div<{ used: boolean }>`
	width: 40px;
	height: 40px;
	border: 2px solid #8b4513;
	border-radius: 50%;
	display: flex;
	align-items: center;
	justify-content: center;
	background: ${(props) => (props.used ? '#8b4513' : 'white')};
	color: ${(props) => (props.used ? 'white' : '#8b4513')};
	cursor: pointer;
	font-weight: bold;

	&:hover {
		background: ${(props) => (props.used ? '#6b3410' : '#f0f0f0')};
	}
`;

export const StyledCombatStats = styled.div`
	display: flex;
	justify-content: space-between;
	gap: 1rem;
	margin: 1rem 0;

	@media (max-width: 768px) {
		flex-direction: column;
		gap: 0.5rem;
	}
`;

export const StyledCombatStatBox = styled.div`
	border: 1px solid #ccc;
	border-radius: 4px;
	padding: 0.5rem;
	text-align: center;
	background: white;
	flex: 1;
`;

export const StyledCombatStatValue = styled.div`
	font-size: 1.5rem;
	font-weight: bold;
	color: #333;
`;

export const StyledCombatStatLabel = styled.div`
	font-size: 0.7rem;
	font-weight: bold;
	text-transform: uppercase;
	color: #666;
	margin-top: 0.2rem;
`;
````

## File: src/routes/character-creation/AncestryPointsCounter.tsx
````typescript
import React from 'react';
import { useCharacter } from '../../lib/stores/characterContext';
import { StyledContainer, StyledTitle, StyledDetails } from './styles/AncestryPointsCounter.styles';

function AncestryPointsCounter() {
	const { ancestryPointsRemaining, ancestryPointsSpent } = useCharacter();

	const isOverBudget = ancestryPointsRemaining < 0;

	return (
		<StyledContainer>
			<StyledTitle style={{ color: isOverBudget ? '#ff4444' : undefined }}>
				Ancestry Points: {ancestryPointsRemaining}/{ancestryPointsSpent + ancestryPointsRemaining}
			</StyledTitle>
			<StyledDetails>
				Spent: {ancestryPointsSpent} | Remaining: {ancestryPointsRemaining}
				{isOverBudget && <span style={{ color: '#ff4444' }}> (Over budget!)</span>}
			</StyledDetails>
		</StyledContainer>
	);
}

export default AncestryPointsCounter;
````

## File: src/routes/character-sheet/components/Defenses.tsx
````typescript
import React, { useState } from 'react';
import {
	DefensesContainer,
	DefenseItem,
	DefenseLabelContainer,
	DefenseLabel,
	ShieldContainer,
	ShieldValue,
	ShieldInput,
	DefenseFooter,
	AutoCalculatedNote,
	RevertButton
} from '../styles/Defenses';
import DefenseChangeModal from './DefenseChangeModal';
import {
	addDefenseNote,
	getDefenseTooltipWithNotes,
	getDefenseDisplayName,
	clearDefenseNotesForField
} from '../../../lib/utils/defenseNotes';

interface DefensesProps {
	characterData: {
		id: string;
		finalPD: number;
		finalPDR: number;
		finalAD: number;
		manualPD?: number;
		manualPDR?: number;
		manualAD?: number;
	};
	calculatedDefenses?: {
		calculatedPD: number;
		calculatedPDR: number;
		calculatedAD: number;
		pdBreakdown: string;
		adBreakdown: string;
		pdrBreakdown: string;
	};
	onUpdateManualDefense?: (
		field: 'manualPD' | 'manualPDR' | 'manualAD',
		value: number | undefined
	) => void;
	isMobile?: boolean;
}

const Defenses: React.FC<DefensesProps> = ({
	characterData,
	calculatedDefenses,
	onUpdateManualDefense,
	isMobile = false
}) => {
	const [pendingChange, setPendingChange] = useState<{
		field: 'manualPD' | 'manualPDR' | 'manualAD';
		oldValue: number;
		newValue: number;
	} | null>(null);

	const [originalValue, setOriginalValue] = useState<number | null>(null);

	const getCurrentValue = (field: 'manualPD' | 'manualPDR' | 'manualAD'): number => {
		switch (field) {
			case 'manualPD':
				return characterData.manualPD !== undefined
					? characterData.manualPD
					: characterData.finalPD;
			case 'manualPDR':
				return characterData.manualPDR !== undefined
					? characterData.manualPDR
					: characterData.finalPDR || 0;
			case 'manualAD':
				return characterData.manualAD !== undefined
					? characterData.manualAD
					: characterData.finalAD;
		}
	};

	const handleNoteConfirm = (reason: string) => {
		if (!pendingChange || !onUpdateManualDefense) return;

		// Add the note to storage
		addDefenseNote(
			characterData.id,
			pendingChange.field,
			pendingChange.oldValue,
			pendingChange.newValue,
			reason
		);

		// Apply the defense change
		onUpdateManualDefense(pendingChange.field, pendingChange.newValue);

		// Clear pending change
		setPendingChange(null);
	};

	const handleNoteCancel = () => {
		// Revert the value back to the original when canceling
		if (pendingChange && onUpdateManualDefense) {
			// If the original value was different from the auto-calculated value,
			// it means it was a manual override, so we need to restore it
			const autoValue =
				pendingChange.field === 'manualPD'
					? characterData.finalPD
					: pendingChange.field === 'manualPDR'
						? characterData.finalPDR || 0
						: characterData.finalAD;

			const valueToRestore =
				pendingChange.oldValue === autoValue ? undefined : pendingChange.oldValue;
			onUpdateManualDefense(pendingChange.field, valueToRestore);
		}
		setPendingChange(null);
	};
	const handleInputChange = (field: 'manualPD' | 'manualPDR' | 'manualAD', value: string) => {
		// Only validate the input, don't trigger the modal yet
		const numValue = value === '' ? undefined : parseInt(value, 10);
		if (value !== '' && (isNaN(numValue!) || numValue! < 0)) return;

		// For now, just update the value directly without the modal
		// The modal will be triggered on blur
		if (!onUpdateManualDefense) return;
		onUpdateManualDefense(field, numValue);
	};

	const handleInputBlur = (field: 'manualPD' | 'manualPDR' | 'manualAD', value: string) => {
		const numValue = value === '' ? undefined : parseInt(value, 10);

		// Get the current value after all changes
		const currentValue = getCurrentValue(field);

		// Use the original value we captured on focus for comparison
		if (originalValue !== null && originalValue !== currentValue && numValue !== undefined) {
			setPendingChange({
				field,
				oldValue: originalValue,
				newValue: currentValue
			});
		}

		// Clear the original value
		setOriginalValue(null);
	};

	const handleInputFocus = (e: React.FocusEvent<HTMLInputElement>) => {
		// Capture the original value for comparison on blur
		const field = e.target.getAttribute('data-field') as 'manualPD' | 'manualPDR' | 'manualAD';
		if (field) {
			setOriginalValue(getCurrentValue(field));
		}

		// Select all text when clicking into the input field
		// Use setTimeout to ensure the selection happens after the focus event
		setTimeout(() => {
			e.target.select();
		}, 0);
	};

	const handleInputClick = (e: React.MouseEvent<HTMLInputElement>) => {
		// Also handle click events to ensure text selection works properly
		const target = e.target as HTMLInputElement;
		setTimeout(() => {
			target.select();
		}, 0);
	};

	const handleRevert = (field: 'manualPD' | 'manualPDR' | 'manualAD') => {
		// Clear all notes for this defense field when reverting to auto
		clearDefenseNotesForField(characterData.id, field);

		// Reverts don't need notes as they're returning to auto-calculated values
		if (!onUpdateManualDefense) return;
		onUpdateManualDefense(field, undefined);
	};

	const getTooltip = (field: 'PD' | 'PDR' | 'AD'): string => {
		if (!calculatedDefenses) return '';

		const isManual =
			field === 'PD'
				? characterData.manualPD !== undefined
				: field === 'PDR'
					? characterData.manualPDR !== undefined
					: characterData.manualAD !== undefined;

		let baseTooltip = '';

		if (isManual) {
			const originalBreakdown =
				field === 'PD'
					? calculatedDefenses.pdBreakdown
					: field === 'PDR'
						? calculatedDefenses.pdrBreakdown
						: calculatedDefenses.adBreakdown;
			baseTooltip = `Manual Override (Original calculation: ${originalBreakdown})`;
		} else {
			baseTooltip =
				field === 'PD'
					? calculatedDefenses.pdBreakdown
					: field === 'PDR'
						? calculatedDefenses.pdrBreakdown
						: calculatedDefenses.adBreakdown;
		}

		// Add defense notes to tooltip
		const defenseField = field === 'PD' ? 'manualPD' : field === 'PDR' ? 'manualPDR' : 'manualAD';
		return getDefenseTooltipWithNotes(characterData.id, defenseField, baseTooltip);
	};

	return (
		<>
			<DefensesContainer $isMobile={isMobile}>
				{/* Precision Defense */}
				<DefenseItem>
					<DefenseLabelContainer>
						<DefenseLabel>PRECISION</DefenseLabel>
						<DefenseLabel>DEFENSE</DefenseLabel>
					</DefenseLabelContainer>
					<ShieldContainer>
						{onUpdateManualDefense ? (
							<ShieldInput
								type="number"
								data-field="manualPD"
								value={
									characterData.manualPD !== undefined
										? characterData.manualPD
										: characterData.finalPD
								}
								onChange={(e) => handleInputChange('manualPD', e.target.value)}
								onBlur={(e) => handleInputBlur('manualPD', e.target.value)}
								onFocus={handleInputFocus}
								onClick={handleInputClick}
								placeholder={characterData.finalPD.toString()}
								title={getTooltip('PD')}
							/>
						) : (
							<ShieldValue title={getTooltip('PD')}>{characterData.finalPD}</ShieldValue>
						)}
					</ShieldContainer>
					<DefenseFooter>
						{characterData.manualPD !== undefined ? (
							<>
								<AutoCalculatedNote>Manual override</AutoCalculatedNote>
								<RevertButton onClick={() => handleRevert('manualPD')}>
									Revert to auto ({calculatedDefenses?.calculatedPD || characterData.finalPD})
								</RevertButton>
							</>
						) : null}
					</DefenseFooter>
				</DefenseItem>

				{/* Precision Damage Reduction */}
				<DefenseItem>
					<DefenseLabelContainer>
						<DefenseLabel>PRECISION</DefenseLabel>
						<DefenseLabel>DMG REDUCTION</DefenseLabel>
					</DefenseLabelContainer>
					<ShieldContainer>
						{onUpdateManualDefense ? (
							<ShieldInput
								type="number"
								data-field="manualPDR"
								value={
									characterData.manualPDR !== undefined
										? characterData.manualPDR
										: characterData.finalPDR || 0
								}
								onChange={(e) => handleInputChange('manualPDR', e.target.value)}
								onBlur={(e) => handleInputBlur('manualPDR', e.target.value)}
								onFocus={handleInputFocus}
								onClick={handleInputClick}
								placeholder={(characterData.finalPDR || 0).toString()}
								title={getTooltip('PDR')}
							/>
						) : (
							<ShieldValue title={getTooltip('PDR')}>{characterData.finalPDR || 0}</ShieldValue>
						)}
					</ShieldContainer>
					<DefenseFooter>
						{characterData.manualPDR !== undefined ? (
							<>
								<AutoCalculatedNote>Manual override</AutoCalculatedNote>
								<RevertButton onClick={() => handleRevert('manualPDR')}>
									Revert to auto ({calculatedDefenses?.calculatedPDR || characterData.finalPDR || 0}
									)
								</RevertButton>
							</>
						) : (
							characterData.finalPDR > 0 && <AutoCalculatedNote>Auto-calculated</AutoCalculatedNote>
						)}
					</DefenseFooter>
				</DefenseItem>

				{/* Area Defense */}
				<DefenseItem>
					<DefenseLabelContainer>
						<DefenseLabel>AREA</DefenseLabel>
						<DefenseLabel>DEFENSE</DefenseLabel>
					</DefenseLabelContainer>
					<ShieldContainer>
						{onUpdateManualDefense ? (
							<ShieldInput
								type="number"
								data-field="manualAD"
								value={
									characterData.manualAD !== undefined
										? characterData.manualAD
										: characterData.finalAD
								}
								onChange={(e) => handleInputChange('manualAD', e.target.value)}
								onBlur={(e) => handleInputBlur('manualAD', e.target.value)}
								onFocus={handleInputFocus}
								onClick={handleInputClick}
								placeholder={characterData.finalAD.toString()}
								title={getTooltip('AD')}
							/>
						) : (
							<ShieldValue title={getTooltip('AD')}>{characterData.finalAD}</ShieldValue>
						)}
					</ShieldContainer>
					<DefenseFooter>
						{characterData.manualAD !== undefined ? (
							<>
								<AutoCalculatedNote>Manual override</AutoCalculatedNote>
								<RevertButton onClick={() => handleRevert('manualAD')}>
									Revert to auto ({calculatedDefenses?.calculatedAD || characterData.finalAD})
								</RevertButton>
							</>
						) : null}
					</DefenseFooter>
				</DefenseItem>
			</DefensesContainer>

			{/* Defense Change Modal */}
			{pendingChange && (
				<DefenseChangeModal
					isOpen={true}
					defenseType={getDefenseDisplayName(pendingChange.field)}
					oldValue={pendingChange.oldValue}
					newValue={pendingChange.newValue}
					onConfirm={handleNoteConfirm}
					onCancel={handleNoteCancel}
				/>
			)}
		</>
	);
};

export default Defenses;
````

## File: src/routes/character-sheet/components/Languages.tsx
````typescript
import React from 'react';
import type { LanguageData } from '../../../types';
import { SectionTitle, SectionDescription } from '../styles/KnowledgeTrades';
import {
	LanguagesSection,
	LanguageRow,
	LanguageName,
	FluencyContainer,
	FluencyBox,
	FluencyHeader,
	LanguageNameHeader,
	FluencyHeaderContainer,
	FluencyHeaderLabel
} from '../styles/Languages';

interface LanguagesProps {
	languages: LanguageData[];
}

const Languages: React.FC<LanguagesProps> = ({ languages }) => {
	return (
		<LanguagesSection>
			<SectionTitle>LANGUAGES</SectionTitle>
			<SectionDescription>LANGUAGE CHECK = d20 + Intelligence or Charisma</SectionDescription>

			{/* Header with L and F labels */}
			<FluencyHeader>
				<LanguageNameHeader>LANGUAGE</LanguageNameHeader>
				<FluencyHeaderContainer>
					<FluencyHeaderLabel title="Limited">L</FluencyHeaderLabel>
					<FluencyHeaderLabel title="Fluent">F</FluencyHeaderLabel>
				</FluencyHeaderContainer>
			</FluencyHeader>

			{languages.map((language) => (
				<LanguageRow key={language.id}>
					<LanguageName>{language.name.toUpperCase()}</LanguageName>
					<FluencyContainer>
						<FluencyBox filled={language.fluency === 'limited'} />
						<FluencyBox filled={language.fluency === 'fluent'} />
					</FluencyContainer>
				</LanguageRow>
			))}
		</LanguagesSection>
	);
};

export default Languages;
````

## File: src/routes/character-sheet/styles/Defenses.ts
````typescript
import styled from 'styled-components';

export const DefensesContainer = styled.div<{ $isMobile?: boolean }>`
	display: flex;
	flex-direction: ${(props) => (props.$isMobile ? 'column' : 'row')};
	justify-content: space-around;
	align-items: center;
	gap: ${(props) => (props.$isMobile ? '1rem' : '0')};
	margin-bottom: 1.5rem;
`;

export const DefenseItem = styled.div`
	text-align: center;
	width: 120px;
	margin: 0 auto;
`;

export const DefenseLabelContainer = styled.div`
	height: 32px;
	display: flex;
	flex-direction: column;
	justify-content: center;
	margin-bottom: 0.3rem;
`;

export const DefenseLabel = styled.div`
	font-size: 0.8rem;
	font-weight: bold;
	color: #8b4513;
	line-height: 1;
`;

export const ShieldContainer = styled.div`
	width: 80px;
	height: 90px;
	border: 3px solid #8b4513;
	border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
	display: flex;
	align-items: center;
	justify-content: center;
	background: white;
	margin: 0 auto;
`;

export const ShieldValue = styled.div`
	font-size: 2rem;
	font-weight: bold;
	color: #8b4513;
	cursor: help;
`;

export const ShieldInput = styled.input`
	font-size: 2rem;
	font-weight: bold;
	color: #8b4513;
	background: transparent;
	border: none;
	text-align: center;
	width: 100%;
	max-width: 60px;
	outline: none;
	cursor: help;

	&:focus {
		background: rgba(139, 69, 19, 0.1);
		border-radius: 4px;
		cursor: text;
	}

	&::-webkit-outer-spin-button,
	&::-webkit-inner-spin-button {
		-webkit-appearance: none;
		margin: 0;
	}

	&[type='number'] {
		-moz-appearance: textfield;
	}
`;

export const DefenseFooter = styled.div`
	min-height: 30px;
	margin-top: 0.2rem;
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	gap: 2px;
`;

export const AutoCalculatedNote = styled.div`
	font-size: 0.6rem;
	color: #8b4513;
`;

export const RevertButton = styled.button`
	font-size: 0.6rem;
	color: #8b4513;
	background: transparent;
	border: 1px solid #8b4513;
	border-radius: 3px;
	padding: 2px 6px;
	cursor: pointer;
	margin-top: 2px;

	&:hover {
		background: rgba(139, 69, 19, 0.1);
	}

	&:active {
		background: rgba(139, 69, 19, 0.2);
	}
`;
````

## File: src/routes/character-sheet/styles/Resources.ts
````typescript
import styled from 'styled-components';

export const StyledResourcesSection = styled.div`
	display: grid;
	grid-template-columns: 1fr 1fr 1fr;
	gap: 1rem;
`;

export const StyledResourceBox = styled.div`
	border: 2px solid #8b4513;
	border-radius: 12px;
	padding: 1rem;
	text-align: center;
	background: white;
	position: relative;
`;

export const StyledResourceIcon = styled.div<{ bgColor: string }>`
	width: 60px;
	height: 60px;
	border-radius: 50%;
	background: ${(props) => props.bgColor};
	border: 3px solid #8b4513;
	display: flex;
	align-items: center;
	justify-content: center;
	margin: 0 auto 0.5rem;
	font-size: 1.5rem;
	font-weight: bold;
	color: white;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledResourceControls = styled.div`
	display: flex;
	gap: 0.3rem;
	justify-content: center;
	margin-top: 0.5rem;
`;

export const StyledResourceButton = styled.button<{ variant?: 'damage' | 'heal' }>`
	width: 25px;
	height: 25px;
	border: 1px solid
		${(props) =>
			props.variant === 'damage' ? '#d32f2f' : props.variant === 'heal' ? '#388e3c' : '#8b4513'};
	border-radius: 3px;
	background: ${(props) =>
		props.variant === 'damage' ? '#ffebee' : props.variant === 'heal' ? '#e8f5e8' : 'white'};
	color: ${(props) =>
		props.variant === 'damage' ? '#d32f2f' : props.variant === 'heal' ? '#388e3c' : '#8b4513'};
	cursor: pointer;
	font-size: 0.7rem;
	font-weight: bold;
	display: flex;
	align-items: center;
	justify-content: center;

	&:hover {
		background: ${(props) =>
			props.variant === 'damage' ? '#d32f2f' : props.variant === 'heal' ? '#388e3c' : '#8b4513'};
		color: white;
	}

	&:disabled {
		opacity: 0.5;
		cursor: not-allowed;
	}
`;

export const StyledResourceInput = styled.input<{ variant?: 'circle' | 'standard' }>`
	width: ${(props) => (props.variant === 'circle' ? '50px' : '40px')};
	text-align: center;
	border: ${(props) => (props.variant === 'circle' ? 'none' : '1px solid #8b4513')};
	border-radius: ${(props) => (props.variant === 'circle' ? '0' : '3px')};
	background: ${(props) => (props.variant === 'circle' ? 'transparent' : 'white')};
	font-size: ${(props) => (props.variant === 'circle' ? '1.4rem' : '0.9rem')};
	font-weight: bold;
	padding: 0;
	margin: 0;
	outline: none;

	/* Remove number input spinner arrows completely */
	-webkit-appearance: textfield;
	-moz-appearance: textfield;
	appearance: textfield;

	&::-webkit-outer-spin-button,
	&::-webkit-inner-spin-button {
		-webkit-appearance: none;
		margin: 0;
		display: none;
	}

	&[type='number'] {
		-moz-appearance: textfield;
	}

	/* Force center alignment and remove any browser default styling */
	${(props) =>
		props.variant === 'circle' &&
		`
    line-height: 1;
    vertical-align: baseline;
    box-sizing: border-box;
  `}
`;

export const StyledTempHPInput = styled(StyledResourceInput)`
	width: 25px;
	font-size: 0.7rem;
`;

// New components for refactored layout
export const ResourcesContainer = styled.div<{ $isMobile?: boolean }>`
	display: flex;
	flex-direction: ${(props) => (props.$isMobile ? 'column' : 'row')};
	justify-content: space-around;
	align-items: ${(props) => (props.$isMobile ? 'center' : 'stretch')};
	gap: ${(props) => (props.$isMobile ? '1rem' : '0')};
	margin-bottom: 1.5rem;
`;

export const ResourceColumn = styled.div<{ $isMobile?: boolean }>`
	text-align: center;
	width: ${(props) => (props.$isMobile ? '100%' : 'auto')};
	max-width: ${(props) => (props.$isMobile ? '200px' : 'none')};
`;

export const ResourceLabel = styled.div`
	font-size: 0.8rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.3rem;
`;

export const ResourceControls = styled.div`
	display: flex;
	align-items: center;
	gap: 5px;
`;

export const TempHPControls = styled.div`
	font-size: 0.8rem;
	color: #dc2626;
	margin-top: 0.3rem;
	display: flex;
	align-items: center;
	justify-content: center;
	gap: 0.3rem;
`;

export const TempHPLabel = styled.span`
	font-weight: normal;
`;

export const TempHPInputSmall = styled.input`
	color: #dc2626;
	background: white;
	border: 1px solid #dc2626;
	border-radius: 3px;
	width: 35px;
	text-align: center;
	font-size: 0.8rem;
	padding: 2px;

	&:focus {
		outline: none;
		border-color: #b91c1c;
		box-shadow: 0 0 0 2px rgba(220, 38, 38, 0.2);
	}
`;
````

## File: src/App.tsx
````typescript
import React, { useState } from 'react';
import { createGlobalStyle } from 'styled-components';
import { CharacterProvider } from './lib/stores/characterContext';
import CharacterCreation from './routes/character-creation/CharacterCreation.tsx';
import LoadCharacter from './routes/character-creation/LoadCharacter.tsx';
import CharacterSheet from './routes/character-sheet/CharacterSheetClean.tsx';
import Menu from './components/Menu.tsx';
import type { SavedCharacter } from './lib/utils/characterEdit';
import {
	StyledApp,
	StyledHeader,
	StyledBackButton,
	StyledMain,
	StyledFooter
} from './styles/App.styles';

const GlobalStyle = createGlobalStyle`
  * {
    box-sizing: border-box;
  }
  
  html, body {
    margin: 0;
    padding: 0;
    font-family: 'Georgia', 'Times New Roman', serif;
    background: linear-gradient(135deg, #0f0f23 0%, #1e1b4b 50%, #312e81 100%);
    color: #e5e7eb;
    min-height: 100vh;
  }
  
  #root {
    min-height: 100vh;
  }
  
  /* Custom scrollbar */
  ::-webkit-scrollbar {
    width: 12px;
  }
  
  ::-webkit-scrollbar-track {
    background: #1e1b4b;
  }
  
  ::-webkit-scrollbar-thumb {
    background: #8b5cf6;
    border-radius: 6px;
  }
  
  ::-webkit-scrollbar-thumb:hover {
    background: #a855f7;
  }
  
  /* Selection colors */
  ::selection {
    background: #fbbf24;
    color: #1e1b4b;
  }
  
  ::-moz-selection {
    background: #fbbf24;
    color: #1e1b4b;
  }
`;

function App() {
	const [currentView, setCurrentView] = useState<'menu' | 'create' | 'load' | 'sheet' | 'edit'>(
		'menu'
	);
	const [selectedCharacterId, setSelectedCharacterId] = useState<string | null>(null);
	const [editCharacter, setEditCharacter] = useState<SavedCharacter | null>(null);

	const handleCreateCharacter = () => {
		setEditCharacter(null); // Clear edit mode
		setCurrentView('create');
	};

	const handleLoadCharacter = () => {
		setCurrentView('load');
	};

	const handleEditCharacter = (character: SavedCharacter) => {
		setEditCharacter(character);
		setCurrentView('edit');
	};

	const handleViewCharacterSheet = (characterId: string) => {
		setSelectedCharacterId(characterId);
		setCurrentView('sheet');
	};

	const handleBackToMenu = () => {
		setCurrentView('menu');
		setSelectedCharacterId(null);
		setEditCharacter(null);
	};

	const renderCurrentView = () => {
		switch (currentView) {
			case 'menu':
				return (
					<Menu onCreateCharacter={handleCreateCharacter} onLoadCharacter={handleLoadCharacter} />
				);
			case 'create':
				return (
					<CharacterProvider>
						<StyledHeader>
							<StyledBackButton onClick={handleBackToMenu}>← Back to Menu</StyledBackButton>
							<span>Created by TBD Group</span>
						</StyledHeader>
						<StyledMain>
							<CharacterCreation onNavigateToLoad={handleLoadCharacter} />
						</StyledMain>
					</CharacterProvider>
				);
			case 'edit':
				return (
					<CharacterProvider>
						<StyledHeader>
							<StyledBackButton onClick={handleBackToMenu}>← Back to Menu</StyledBackButton>
							<span>Created by TBD Group</span>
						</StyledHeader>
						<StyledMain>
							<CharacterCreation
								onNavigateToLoad={handleLoadCharacter}
								editCharacter={editCharacter || undefined}
							/>
						</StyledMain>
					</CharacterProvider>
				);
			case 'load':
				return (
					<LoadCharacter
						onBack={handleBackToMenu}
						onSelectCharacter={handleViewCharacterSheet}
						onEditCharacter={handleEditCharacter}
					/>
				);
			case 'sheet':
				return selectedCharacterId ? (
					<CharacterSheet characterId={selectedCharacterId} onBack={handleBackToMenu} />
				) : null;
			default:
				return null;
		}
	};

	return (
		<>
			<GlobalStyle />
			<StyledApp>
				{renderCurrentView()}
				<StyledFooter>All rights reserved to TBD Group, 2025</StyledFooter>
			</StyledApp>
		</>
	);
}

export default App;
````

## File: README.md
````markdown
# DC20 Clean Character Sheet

A comprehensive character creation and management system for the DC20 tabletop RPG system.

## ✨ Recent Updates

### Mastery System Implementation (Latest)
- **Complete skill/trade mastery system** with level-based limits (Untrained → Grandmaster)
- **Level 1 special rule**: Only ONE Adept skill/trade allowed for Level 1 characters
- **Class feature mastery bonuses** automatically parsed and applied
- **Real-time validation** with visual warnings for mastery violations
- **Calculated bonuses display**: Shows Attribute + Mastery*2 bonuses on character sheet
- **Enhanced UI** with mastery names, tooltips, and bonus calculations

### Character Creation Features
- **Ancestry point calculation** with class feature bonuses (e.g., Cleric Ancestral Domain +2)
- **Background selection** with skills, trades, and languages
- **Point conversion system**: Skills ↔ Trades, Trades → Languages
- **Class feature selection** with dynamic choices and validation
- **Real-time character preview** with calculated stats

### Character Sheet Features
- **Live bonus calculations** for all skills, trades, and knowledge
- **Mastery system display** with proficiency dots and calculated bonuses
- **Complete stat management** with attribute modifiers and derived values
- **Save/load to browser** for persistent character storage

## 🛠️ TODO

### Critical Issues
- **Fix weapon selection crash**: The attack system currently crashes when selecting weapons on the character sheet page. The weapons.ts file has been deleted in favor of consolidating to inventoryItems.ts, but the attack system needs to be properly refactored to work with the inventory weapon structure. This requires updating the Attacks component to use the correct weapon properties and interfaces from inventoryItems.ts.

### Enhancements
- **Server-side mastery validation**: Add endpoint validation for mastery limits in character completion
- **Advanced class features**: Implement remaining class-specific features and progressions
- **Combat system**: Enhance attack calculations and combat mechanics
````

## File: src/lib/services/characterCompletion.ts
````typescript
// Shared character completion service
// Handles the completion flow with proper stat calculation, snackbar, and navigation

import type { CharacterInProgressData } from './characterCalculator';
import { convertToEnhancedBuildData, calculateCharacterWithBreakdowns } from './enhancedCharacterCalculator';

export interface CharacterCompletionCallbacks {
	onShowSnackbar: (message: string) => void;
	onNavigateToLoad: () => void;
}

export const completeCharacter = async (
	characterState: any,
	callbacks: CharacterCompletionCallbacks
): Promise<void> => {
	try {
		// Character is complete, prepare the data for calculation
		const characterInProgress: CharacterInProgressData = {
			id: Date.now().toString(),
			attribute_might: characterState.attribute_might,
			attribute_agility: characterState.attribute_agility,
			attribute_charisma: characterState.attribute_charisma,
			attribute_intelligence: characterState.attribute_intelligence,
			level: characterState.level || 1,
			combatMastery: characterState.combatMastery || 1,
			classId: characterState.classId,
			ancestry1Id: characterState.ancestry1Id,
			ancestry2Id: characterState.ancestry2Id,
			selectedTraitIds: characterState.selectedTraitIds || '',
			selectedFeatureChoices: characterState.selectedFeatureChoices || '',
			finalName: characterState.finalName,
			finalPlayerName: characterState.finalPlayerName,
			skillsJson: characterState.skillsJson || '', // Default empty for now
			tradesJson: characterState.tradesJson || '', // Default empty for now
			languagesJson: characterState.languagesJson || '', // Default empty for now
			createdAt: new Date(),
			completedAt: new Date().toISOString()
		};

		console.log('Calculating stats for character:', characterInProgress);

		// Check if we should use the enhanced calculator for supported classes
		const supportedClasses = ['barbarian', 'cleric', 'hunter', 'champion', 'wizard', 'monk', 'rogue', 'sorcerer', 'spellblade', 'warlock'];
	const useEnhancedCalculator = supportedClasses.includes(characterInProgress.classId || '');

		let completedCharacterData;
		if (useEnhancedCalculator) {
			console.log('Using enhanced calculator for class:', characterInProgress.classId);
			// Convert to enhanced build data and calculate
			const enhancedBuildData = convertToEnhancedBuildData(characterInProgress);
			const enhancedResult = calculateCharacterWithBreakdowns(enhancedBuildData);
			
			// Convert enhanced result back to the expected format
			completedCharacterData = {
				...characterInProgress,
				// Core stats from enhanced calculator
				finalMight: enhancedResult.stats.finalMight,
				finalAgility: enhancedResult.stats.finalAgility,
				finalCharisma: enhancedResult.stats.finalCharisma,
				finalIntelligence: enhancedResult.stats.finalIntelligence,
				finalHPMax: enhancedResult.stats.finalHPMax,
				finalSPMax: enhancedResult.stats.finalSPMax,
				finalMPMax: enhancedResult.stats.finalMPMax,
				finalPD: enhancedResult.stats.finalPD,
				finalAD: enhancedResult.stats.finalAD,
				finalPDR: enhancedResult.stats.finalPDR,
				finalMoveSpeed: enhancedResult.stats.finalMoveSpeed,  // This will now include Grassland +1
				finalJumpDistance: enhancedResult.stats.finalJumpDistance, // This will now include Grassland +1
				finalDeathThreshold: enhancedResult.stats.finalDeathThreshold,
				finalGritPoints: enhancedResult.stats.finalGritPoints,
				finalRestPoints: enhancedResult.stats.finalRestPoints,
				finalInitiativeBonus: enhancedResult.stats.finalInitiativeBonus,
				finalSaveDC: enhancedResult.stats.finalSaveDC,
				finalSaveMight: enhancedResult.stats.finalSaveMight,
				finalSaveAgility: enhancedResult.stats.finalSaveAgility,
				finalSaveCharisma: enhancedResult.stats.finalSaveCharisma,
				finalSaveIntelligence: enhancedResult.stats.finalSaveIntelligence,
				// Add granted abilities and effects for display
				grantedAbilities: enhancedResult.grantedAbilities,
				conditionalModifiers: enhancedResult.conditionalModifiers,
				className: enhancedResult.stats.className || 'Unknown',
				ancestry1Name: 'Human', // TODO: Get from enhanced data  
				ancestry2Name: enhancedResult.stats.ancestry2Name || null
			};
		} else {
			// All classes are now migrated, this should not happen anymore
			throw new Error(`Class "${characterInProgress.classId}" is not supported in the enhanced calculator. All classes should be migrated.`);
		}
		console.log('Character stats calculated:', completedCharacterData);
		console.log('Class info saved:', {
			classId: completedCharacterData.classId,
			className: completedCharacterData.className
		});
		console.log('Ancestry info saved:', {
			ancestry1Id: completedCharacterData.ancestry1Id,
			ancestry1Name: completedCharacterData.ancestry1Name,
			ancestry2Id: completedCharacterData.ancestry2Id,
			ancestry2Name: completedCharacterData.ancestry2Name
		});

		// Save to local storage
		const existingCharacters = JSON.parse(localStorage.getItem('savedCharacters') || '[]');
		existingCharacters.push(completedCharacterData);
		localStorage.setItem('savedCharacters', JSON.stringify(existingCharacters));
		console.log('Character saved to localStorage. Total characters:', existingCharacters.length);

		// Show success snackbar
		callbacks.onShowSnackbar('Character created successfully!');

		// Navigate to load characters page after a short delay
		setTimeout(() => {
			console.log('Navigating to character load page...');
			callbacks.onNavigateToLoad();
		}, 1500);

		console.log('Character completed with calculated stats:', completedCharacterData);
	} catch (error) {
		console.error('Error completing character:', error);
		callbacks.onShowSnackbar('Error creating character. Please try again.');
	}
};
````

## File: src/routes/character-sheet/styles/Attacks.ts
````typescript
import styled from 'styled-components';

export const StyledAttacksSection = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
`;

export const StyledAttacksHeader = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 1rem;
`;

export const StyledAttacksTitle = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	text-align: center;
	flex: 1;
`;

export const StyledAddWeaponButton = styled.button`
	padding: 0.3rem 0.8rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	background: #8b4513;
	color: white;
	font-size: 0.8rem;
	font-weight: bold;
	cursor: pointer;
	transition: background-color 0.2s;

	&:hover {
		background-color: #6d3410;
	}
`;

export const StyledAttacksContainer = styled.div`
	font-size: 0.8rem;
	color: #8b4513;
	overflow-x: auto;

	@media (max-width: 768px) {
		overflow-x: visible;
	}
`;

export const StyledAttacksHeaderRow = styled.div`
	display: grid;
	grid-template-columns: 0.5fr 2fr 1fr 1fr 1fr 0.7fr 0.8fr;
	gap: 0.5rem;
	margin-bottom: 0.5rem;
	border-bottom: 1px solid #e5e5e5;
	padding-bottom: 0.3rem;
	align-items: center;

	@media (max-width: 768px) {
		grid-template-columns: 25px 1fr 45px 40px;
		gap: 0.2rem;
		font-size: 0.7rem;
		
		& > *:nth-child(4),
		& > *:nth-child(5),
		& > *:nth-child(7) {
			display: none;
		}
	}
`;

export const StyledHeaderColumn = styled.span<{ align?: string }>`
	font-weight: bold;
	text-align: ${(props) => props.align || 'left'};
	font-size: 0.8rem;
	line-height: 1.1;

	@media (max-width: 768px) {
		font-size: 0.7rem;
		&:nth-child(4),
		&:nth-child(5),
		&:nth-child(7) {
			display: none;
		}
	}
`;

export const StyledEmptyState = styled.div`
	text-align: center;
	font-style: italic;
	padding: 2rem;
	color: #666;
`;

export const StyledAttackRow = styled.div`
	display: grid;
	grid-template-columns: 0.5fr 2fr 1fr 1fr 1fr 0.7fr 0.8fr;
	gap: 0.5rem;
	margin-bottom: 0.5rem;
	align-items: center;

	@media (max-width: 768px) {
		grid-template-columns: 25px 1fr 45px 40px;
		gap: 0.2rem;
		font-size: 0.7rem;
		
		& > *:nth-child(4),
		& > *:nth-child(5),
		& > *:nth-child(7) {
			display: none;
		}
	}
`;

export const StyledRemoveButton = styled.button`
	width: 24px;
	height: 24px;
	border: 1px solid #dc2626;
	border-radius: 4px;
	background-color: #fee2e2;
	color: #dc2626;
	font-size: 0.8rem;
	font-weight: bold;
	cursor: pointer;
	display: flex;
	align-items: center;
	justify-content: center;
	transition: background-color 0.2s;

	&:hover {
		background-color: #fecaca;
	}
`;

export const StyledWeaponSelect = styled.select`
	padding: 0.2rem;
	border: 1px solid #8b4513;
	border-radius: 3px;
	font-size: 0.7rem;
	background: white;
	width: 100%;
	max-width: 100%;
	overflow: hidden;
	text-overflow: ellipsis;

	@media (max-width: 768px) {
		font-size: 0.6rem;
		padding: 0.1rem;
	}
`;

export const StyledDamageCell = styled.div<{ color?: string }>`
	text-align: center;
	font-weight: bold;
	color: ${(props) => props.color || 'inherit'};
	cursor: pointer;
`;

export const StyledInfoIcon = styled.span`
	display: inline-flex;
	align-items: center;
	justify-content: center;
	width: 14px;
	height: 14px;
	border-radius: 50%;
	background-color: #8b4513;
	color: white;
	font-size: 10px;
	font-weight: bold;
	cursor: pointer;
`;

export const StyledDamageTypeCell = styled.div`
	text-align: center;
	font-size: 1rem;
	font-weight: bold;
	cursor: pointer;
`;
````

## File: package.json
````json
{
	"name": "dc20clean",
	"version": "0.0.1",
	"scripts": {
		"dev": "vite dev",
		"build": "vite build",
		"preview": "vite preview",
		"prepare": "npx prisma generate --no-engine",
		"format": "prettier --write .",
		"lint": "prettier --check . && eslint .",
		"test:unit": "vitest",
		"test": "npm run test:unit -- --run && npm run test:e2e",
		"test:e2e": "playwright test",
		"db:start": "docker compose up"
	},
	"files": [
		"dist",
		"!dist/**/*.test.*",
		"!dist/**/*.spec.*"
	],
	"sideEffects": [
		"**/*.css"
	],
	"type": "module",
	"devDependencies": {
		"@eslint/compat": "^1.2.5",
		"@eslint/js": "^9.18.0",
		"@playwright/test": "^1.49.1",
		"@tailwindcss/forms": "^0.5.9",
		"@tailwindcss/typography": "^0.5.15",
		"@tailwindcss/vite": "^4.0.0",
		"@types/node": "^22.16.5",
		"@types/react": "^19.1.8",
		"@types/react-dom": "^19.1.6",
		"@vitejs/plugin-react": "^4.7.0",
		"@vitest/browser": "^3.2.3",

		"eslint": "^9.18.0",
		"eslint-config-prettier": "^10.0.1",
		"eslint-plugin-react": "^7.37.5",
		"eslint-plugin-react-hooks": "^5.2.0",
		"globals": "^16.0.0",
		"playwright": "^1.53.0",
		"prettier": "^3.4.2",
		"publint": "^0.3.2",
		"tailwindcss": "^4.0.0",
		"typescript": "^5.0.0",
		"typescript-eslint": "^8.20.0",
		"vite": "^6.2.6",
		"vite-plugin-devtools-json": "^0.2.0"
	},
	"keywords": [
		"react"
	],
	"dependencies": {
		"@emotion/react": "^11.14.0",
		"@emotion/styled": "^11.14.1",
		"@mui/icons-material": "^7.2.0",
		"@mui/material": "^7.2.0",
		"@node-rs/argon2": "^2.0.2",
		"@oslojs/crypto": "^1.0.1",
		"@oslojs/encoding": "^1.1.0",
		"@prisma/client": "^6.10.1",
		"@prisma/extension-accelerate": "^2.0.1",
		"@types/styled-components": "^5.1.34",

		"fantasy-name-generator": "^2.0.0",

		"prettier-plugin-tailwindcss": "^0.6.14",
		"prisma": "^6.10.1",
		"react": "^19.1.0",
		"react-dom": "^19.1.0",
		"repomix": "^1.2.1",
		"styled-components": "^6.1.19",
		"ts-node": "^10.9.2",
		"zod": "^4.0.5"
	}
}
````

## File: src/routes/character-creation/Background.tsx
````typescript
import React from 'react';
import { useCharacter } from '../../lib/stores/characterContext';
import { useBackgroundPoints } from './components/BackgroundPointsManager';
import { findClassByName } from '../../lib/rulesdata/loaders/class-features.loader';
import { classesData } from '../../lib/rulesdata/loaders/class.loader';
import SkillsTab from './components/SkillsTab';
import TradesTab from './components/TradesTab';
import LanguagesTab from './components/LanguagesTab';
import {
	StyledContainer,
	StyledSubheading,
	StyledDescription,
	StyledTabContainer,
	StyledTab
} from './styles/Background.styles.ts';

type TabType = 'skills' | 'trades' | 'languages';

const Background: React.FC = () => {
	const { state, dispatch } = useCharacter();
	const [activeTab, setActiveTab] = React.useState<TabType>('skills');

	// Parse current selections
	const currentSkills = state.skillsJson ? JSON.parse(state.skillsJson) : {};
	const currentTrades = state.tradesJson ? JSON.parse(state.tradesJson) : {};
	const currentLanguages = state.languagesJson
		? JSON.parse(state.languagesJson)
		: { common: { fluency: 'fluent' } };

	// Calculate points used
	const skillPointsUsed = Object.values(currentSkills).reduce(
		(sum: number, level: any) => sum + level,
		0
	);
	const tradePointsUsed = Object.values(currentTrades).reduce(
		(sum: number, level: any) => sum + level,
		0
	);
	const languagePointsUsed = Object.entries(currentLanguages).reduce(
		(sum, [langId, data]: [string, any]) => {
			if (langId === 'common') return sum; // Common is free
			return sum + (data.fluency === 'limited' ? 1 : data.fluency === 'fluent' ? 2 : 0);
		},
		0
	);

	// Get class features for mastery calculations
	const classData = state.classId ? classesData.find(c => c.id === state.classId) : null;
	const classFeatures = classData ? findClassByName(classData.name) : null;

	// Use the background points manager hook
	const { pointsData, conversions, actions, masteryLimits } = useBackgroundPoints(
		skillPointsUsed,
		tradePointsUsed,
		languagePointsUsed,
		state.attribute_intelligence,
		state.level,
		classFeatures,
		state.selectedFeatureChoices,
		currentSkills,
		currentTrades
	);

	// Handler functions
	const handleSkillChange = (skillId: string, newLevel: number) => {
		const updatedSkills = { ...currentSkills };
		if (newLevel === 0) {
			delete updatedSkills[skillId];
		} else {
			updatedSkills[skillId] = newLevel;
		}

		dispatch({
			type: 'UPDATE_SKILLS',
			skillsJson: JSON.stringify(updatedSkills)
		});
	};

	const handleTradeChange = (tradeId: string, newLevel: number) => {
		const updatedTrades = { ...currentTrades };
		if (newLevel === 0) {
			delete updatedTrades[tradeId];
		} else {
			updatedTrades[tradeId] = newLevel;
		}

		dispatch({
			type: 'UPDATE_TRADES',
			tradesJson: JSON.stringify(updatedTrades)
		});
	};

	const handleLanguageChange = (languageId: string, fluency: 'limited' | 'fluent' | null) => {
		const updatedLanguages = { ...currentLanguages };
		if (fluency === null) {
			delete updatedLanguages[languageId];
		} else {
			updatedLanguages[languageId] = { fluency };
		}

		dispatch({
			type: 'UPDATE_LANGUAGES',
			languagesJson: JSON.stringify(updatedLanguages)
		});
	};

	const renderCurrentTab = () => {
		switch (activeTab) {
			case 'skills':
				return (
					<SkillsTab
						currentSkills={currentSkills}
						currentTrades={currentTrades}
						pointsData={pointsData}
						conversions={conversions}
						actions={actions}
						masteryLimits={masteryLimits}
						onSkillChange={handleSkillChange}
					/>
				);
			case 'trades':
				return (
					<TradesTab
						currentTrades={currentTrades}
						currentSkills={currentSkills}
						pointsData={pointsData}
						conversions={conversions}
						actions={actions}
						masteryLimits={masteryLimits}
						onTradeChange={handleTradeChange}
					/>
				);
			case 'languages':
				return (
					<LanguagesTab
						currentLanguages={currentLanguages}
						pointsData={pointsData}
						conversions={conversions}
						actions={actions}
						onLanguageChange={handleLanguageChange}
					/>
				);
			default:
				return null;
		}
	};

	return (
		<StyledContainer>
			<StyledSubheading>Background (Skills, Trades & Languages)</StyledSubheading>
			<StyledDescription>
				Choose your character's background skills, trades, and languages. You have{' '}
				<span style={{ fontWeight: 'bold', color: '#3b82f6' }}>{pointsData.baseSkillPoints}</span>{' '}
				skill points{' '}
				<span style={{ fontSize: '0.9rem', color: '#6b7280' }}>(5 + Intelligence modifier)</span>,{' '}
				<span style={{ fontWeight: 'bold', color: '#3b82f6' }}>{pointsData.baseTradePoints}</span>{' '}
				trade points, and{' '}
				<span style={{ fontWeight: 'bold', color: '#3b82f6' }}>
					{pointsData.baseLanguagePoints}
				</span>{' '}
				language points. <br />
				<span
					style={{
						marginTop: '0.5rem',
						display: 'inline-block',
						padding: '0.25rem 0.5rem',
						backgroundColor: '#f3f4f6',
						borderRadius: '4px',
						fontSize: '0.9rem',
						color: '#374151'
					}}
				>
					💡 Conversions: 1 skill ↔ 2 trade • 1 trade → 2 language
				</span>
				<br />
				All characters start fluent in Common for free.
			</StyledDescription>

			<StyledTabContainer>
				<StyledTab $active={activeTab === 'skills'} onClick={() => setActiveTab('skills')}>
					Skills ({pointsData.availableSkillPoints - pointsData.skillPointsUsed} left)
				</StyledTab>
				<StyledTab $active={activeTab === 'trades'} onClick={() => setActiveTab('trades')}>
					Trades ({pointsData.availableTradePoints - pointsData.tradePointsUsed} left)
				</StyledTab>
				<StyledTab $active={activeTab === 'languages'} onClick={() => setActiveTab('languages')}>
					Languages ({pointsData.availableLanguagePoints - pointsData.languagePointsUsed} left)
				</StyledTab>
			</StyledTabContainer>

			{renderCurrentTab()}
		</StyledContainer>
	);
};

export default Background;
````

## File: src/routes/character-creation/SelectedAncestries.tsx
````typescript
import React from 'react';
import { useCharacter } from '../../lib/stores/characterContext';
import { ancestriesData } from '../../lib/rulesdata/ancestries';
import { traitsData } from '../../lib/rulesdata/traits';
import TraitChoiceSelector from './components/TraitChoiceSelector';
import type { IAncestry, ITrait, ITraitEffect } from '../../lib/rulesdata/types';
import {
	StyledOuterContainer,
	StyledMainTitle,
	StyledContainer,
	StyledAncestryDetails,
	StyledTitle,
	StyledSubtitle,
	StyledList,
	StyledListItem,
	StyledLabel,
	StyledCheckbox
} from './styles/SelectedAncestries.styles';

function SelectedAncestries() {
	const { state, dispatch, ancestryPointsRemaining, ancestryPointsSpent, totalAncestryPoints } = useCharacter();

	const selectedAncestry1 = ancestriesData.find((a) => a.id === state.ancestry1Id);
	const selectedAncestry2 = ancestriesData.find((a) => a.id === state.ancestry2Id);
	const selectedTraits: string[] = JSON.parse(state.selectedTraitIds || '[]');

	function getTrait(traitId: string): ITrait | undefined {
		return traitsData.find((t) => t.id === traitId);
	}

	function handleToggleTrait(traitId: string) {
		const trait = getTrait(traitId);
		if (!trait) return;

		let currentTraits = [...selectedTraits];
		const isCurrentlySelected = currentTraits.includes(traitId);

		if (isCurrentlySelected) {
			// Deselect - always allowed
			currentTraits = currentTraits.filter((id) => id !== traitId);
		} else {
			// Select - check if we have enough points
			const newPointsSpent = ancestryPointsSpent + trait.cost;
			if (newPointsSpent > totalAncestryPoints) {
				// Would exceed budget, don't allow selection
				return;
			}
			currentTraits.push(traitId);
		}

		dispatch({ type: 'SET_TRAITS', selectedTraitIds: JSON.stringify(currentTraits) });
	}

	function renderAncestryTraits(ancestry: IAncestry) {
		return (
			<StyledAncestryDetails>
				<StyledTitle>{ancestry.name}</StyledTitle>

				<StyledSubtitle>Default Traits</StyledSubtitle>
				<StyledList>
					{(ancestry.defaultTraitIds || []).map((traitId) => {
						const trait = getTrait(traitId);
						if (!trait) return null;
						const isSelected = selectedTraits.includes(traitId);
						const wouldExceedBudget = !isSelected && ancestryPointsSpent + trait.cost > totalAncestryPoints;

						return (
							<StyledListItem key={traitId}>
								<StyledLabel style={{ opacity: wouldExceedBudget ? 0.5 : 1 }}>
									<StyledCheckbox
										type="checkbox"
										checked={isSelected}
										disabled={wouldExceedBudget}
										onChange={() => handleToggleTrait(traitId)}
									/>
									{trait.name} ({trait.cost} pts) - {trait.description}
									{wouldExceedBudget && (
										<span style={{ color: '#ff4444' }}> (Not enough points)</span>
									)}
								</StyledLabel>
								
								{/* NEW: Render choice selectors if trait is selected and has user choices */}
								{isSelected && trait.effects?.map((effect: ITraitEffect, effectIndex: number) => {
									if (effect.userChoiceRequired) {
										return (
											<TraitChoiceSelector
												key={`${traitId}-${effectIndex}`}
												trait={trait}
												effect={effect}
												effectIndex={effectIndex}
											/>
										);
									}
									return null;
								})}
							</StyledListItem>
						);
					})}
				</StyledList>

				<StyledSubtitle>Expanded Traits</StyledSubtitle>
				<StyledList>
					{(ancestry.expandedTraitIds || []).map((traitId) => {
						const trait = getTrait(traitId);
						if (!trait) return null;
						const isSelected = selectedTraits.includes(traitId);
						const wouldExceedBudget = !isSelected && ancestryPointsSpent + trait.cost > totalAncestryPoints;

						return (
							<StyledListItem key={traitId}>
								<StyledLabel style={{ opacity: wouldExceedBudget ? 0.5 : 1 }}>
									<StyledCheckbox
										type="checkbox"
										checked={isSelected}
										disabled={wouldExceedBudget}
										onChange={() => handleToggleTrait(traitId)}
									/>
									{trait.name} ({trait.cost} pts) - {trait.description}
									{wouldExceedBudget && (
										<span style={{ color: '#ff4444' }}> (Not enough points)</span>
									)}
								</StyledLabel>
								
								{/* NEW: Render choice selectors if trait is selected and has user choices */}
								{isSelected && trait.effects?.map((effect: ITraitEffect, effectIndex: number) => {
									if (effect.userChoiceRequired) {
										return (
											<TraitChoiceSelector
												key={`${traitId}-${effectIndex}`}
												trait={trait}
												effect={effect}
												effectIndex={effectIndex}
											/>
										);
									}
									return null;
								})}
							</StyledListItem>
						);
					})}
				</StyledList>
			</StyledAncestryDetails>
		);
	}

	return (
		<StyledOuterContainer>
			<StyledMainTitle>
				Ancestry Traits
				<div
					style={{
						fontSize: '0.9rem',
						fontWeight: 'normal',
						marginTop: '0.5rem',
						color: ancestryPointsRemaining < 0 ? '#ff4444' : '#d1d5db'
					}}
				>
					Spent: {ancestryPointsSpent} | Remaining: {ancestryPointsRemaining}/
					{ancestryPointsSpent + ancestryPointsRemaining}
					{ancestryPointsRemaining < 0 && <span style={{ color: '#ff4444' }}> (Over budget!)</span>}
				</div>
			</StyledMainTitle>
			<StyledContainer>
				{selectedAncestry1 && renderAncestryTraits(selectedAncestry1)}
				{selectedAncestry2 && renderAncestryTraits(selectedAncestry2)}
			</StyledContainer>
		</StyledOuterContainer>
	);
}

export default SelectedAncestries;
````

## File: src/types/character.ts
````typescript
// Character Sheet Types and Interfaces

export interface CharacterSheetProps {
	characterId: string;
	onBack: () => void;
}

export interface CharacterSheetData {
	// Basic Info
	id: string;
	finalName: string;
	finalPlayerName?: string;
	finalLevel: number;

	// Attributes
	finalMight: number;
	finalAgility: number;
	finalCharisma: number;
	finalIntelligence: number;

	// Calculated Stats
	finalPrimeModifierValue: number;
	finalPrimeModifierAttribute: string;
	finalCombatMastery: number;

	// Saves (Attribute + Combat Mastery)
	finalSaveMight: number;
	finalSaveAgility: number;
	finalSaveCharisma: number;
	finalSaveIntelligence: number;

	// Health & Resources
	finalHPMax: number;
	finalSPMax: number;
	finalMPMax: number;

	// Defenses
	finalPD: number; // Precision Defense
	finalAD: number; // Area Defense

	// Manual Defense Overrides (optional)
	manualPD?: number;
	manualAD?: number;
	manualPDR?: number;

	// PDR (Precision Damage Reduction)
	finalPDR: number;

	// Other Stats
	finalSaveDC: number;
	finalDeathThreshold: number;
	finalMoveSpeed: number;
	finalJumpDistance: number;
	finalRestPoints: number;
	finalGritPoints: number;
	finalInitiativeBonus: number;

	// Class & Ancestry Info
	className: string;
	ancestry1Name?: string;
	ancestry2Name?: string;

	// JSON data fields
	skillsJson?: string;
	tradesJson?: string;
	languagesJson?: string;
	selectedTraitIds?: string; // JSON string of selected trait IDs
	selectedFeatureChoices?: string; // JSON string of selected feature choices

	// Current values (optional, may not exist on first load)
	currentHP?: number;
	currentSP?: number;
	currentMP?: number;
	currentGritPoints?: number;
	currentRestPoints?: number;
	tempHP?: number;
	actionPointsUsed?: number;
	exhaustionLevel?: number;
}

export interface SkillData {
	id: string;
	name: string;
	attribute: string;
	proficiency: number; // 0-5
	bonus?: number; // Calculated bonus: Attribute + Mastery*2
}

export interface TradeData {
	id: string;
	name: string;
	proficiency: number; // 0-5
	bonus?: number; // Calculated bonus: Attribute + Mastery*2
}

export interface LanguageData {
	id: string;
	name: string;
	fluency: 'limited' | 'fluent';
}

export interface FeatureData {
	id: string;
	name: string;
	description: string;
	source: 'ancestry' | 'class' | 'choice';
	sourceDetail?: string; // e.g., "Human (Default)", "Barbarian Lvl 1", etc.
}

export interface CurrentValues {
	currentHP: number;
	currentSP: number;
	currentMP: number;
	currentGritPoints: number;
	currentRestPoints: number;
	tempHP: number;
	actionPointsUsed: number;
	exhaustionLevel: number; // 0-5
	// Currency
	goldPieces: number;
	silverPieces: number;
	copperPieces: number;
	electrumPieces: number;
	platinumPieces: number;
}

// Comprehensive character state that includes both original (calculated) and current (modified) values
export interface CharacterState {
	// Core resource values
	resources: {
		original: {
			maxHP: number;
			maxSP: number;
			maxMP: number;
			maxGritPoints: number;
			maxRestPoints: number;
		};
		current: {
			currentHP: number;
			currentSP: number;
			currentMP: number;
			currentGritPoints: number;
			currentRestPoints: number;
			tempHP: number;
			actionPointsUsed: number;
			exhaustionLevel: number;
		};
	};

	// Currency with original and current values
	currency: {
		original: {
			goldPieces: number;
			silverPieces: number;
			copperPieces: number;
			electrumPieces: number;
			platinumPieces: number;
		};
		current: {
			goldPieces: number;
			silverPieces: number;
			copperPieces: number;
			electrumPieces: number;
			platinumPieces: number;
		};
	};

	// Attacks - original is calculated from character build, current is user-modified
	attacks: {
		original: AttackData[];
		current: AttackData[];
	};

	// Spells - original is empty/default, current is user-selected
	spells: {
		original: SpellData[];
		current: SpellData[];
	};

	// Inventory - original is empty/default, current is user-modified
	inventory: {
		original: InventoryItemData[];
		current: InventoryItemData[];
	};

	// Defense notes (already integrated)
	defenseNotes?: {
		manualPD?: { value: number; reason: string; timestamp: string };
		manualPDR?: { value: number; reason: string; timestamp: string };
		manualAD?: { value: number; reason: string; timestamp: string };
	};
}

export interface AttackData {
	id: string;
	weaponName: string; // Changed from weaponId to weaponName to match inventory system
	name: string;
	attackBonus: number;
	damage: string;
	damageType: string;
	critRange: string;
	critDamage: string;
	brutalDamage: string;
	heavyHitEffect: string;
}

export interface SpellData {
	id: string;
	spellName: string;
	school: string;
	isCantrip: boolean;
	cost: {
		ap: number;
		mp?: number;
	};
	range: string;
	duration: string;
	isPrepared?: boolean;
	notes?: string;
}

export interface InventoryItemData {
	id: string;
	itemType: 'Weapon' | 'Armor' | 'Shield' | 'Adventuring Supply' | 'Potion' | '';
	itemName: string;
	count: number;
	cost?: string;
}
````

## File: src/lib/stores/characterContext.tsx
````typescript
import React, { createContext, useContext, useReducer, ReactNode } from 'react';
import type { CharacterInProgress } from '@prisma/client';
import { traitsData } from '../rulesdata/traits';
import { findClassByName } from '../rulesdata/loaders/class-features.loader';
import { classesData } from '../rulesdata/loaders/class.loader';
import { calculateTraitCosts } from '../services/traitEffectProcessor';

// Define the shape of the data stored in the character store
export interface CharacterInProgressStoreData extends CharacterInProgress {
	currentStep: number;
	overflowTraitId: string | null;
	overflowAttributeName: string | null;
	level: number;
	combatMastery: number;
	// Background selections (Step 3: Skills, Trades, Languages)
	skillsJson: string;
	tradesJson: string;
	languagesJson: string;
	
	// NEW: Enhanced effect system support
	selectedTraitChoices: string; // JSON string of trait choices
	cachedEffectResults?: string; // JSON string of cached calculation results
	cacheTimestamp?: number;
}

// Initial state for the store
const initialCharacterInProgressState: CharacterInProgressStoreData = {
	id: '',
	attribute_might: -2,
	attribute_agility: -2,
	attribute_charisma: -2,
	attribute_intelligence: -2,
	pointsSpent: 0,
	level: 1,
	combatMastery: 1,
	ancestry1Id: null,
	ancestry2Id: null,
	selectedTraitIds: '',
	ancestryPointsSpent: 0,
	classId: null,
	selectedFeatureChoices: '',
	finalName: null,
	finalPlayerName: null,
	createdAt: new Date(),
	updatedAt: new Date(),
	currentStep: 1,
	overflowTraitId: null,
	overflowAttributeName: null,
	// Background selections (Step 3: Skills, Trades, Languages)
	skillsJson: '{}',
	tradesJson: '{}',
	languagesJson: '{"common": {"fluency": "fluent"}}',
	
	// NEW: Enhanced effect system support
	selectedTraitChoices: '{}',
	cachedEffectResults: undefined,
	cacheTimestamp: undefined
};

// Action types
type CharacterAction =
	| { type: 'UPDATE_ATTRIBUTE'; attribute: string; value: number }
	| { type: 'UPDATE_SKILLS'; skillsJson: string }
	| { type: 'UPDATE_TRADES'; tradesJson: string }
	| { type: 'UPDATE_LANGUAGES'; languagesJson: string }
	| { type: 'SET_CLASS'; classId: string | null }
	| { type: 'SET_ANCESTRY'; ancestry1Id: string | null; ancestry2Id: string | null }
	| { type: 'SET_TRAITS'; selectedTraitIds: string }
	| { type: 'SET_FEATURE_CHOICES'; selectedFeatureChoices: string }
	| { type: 'SET_TRAIT_CHOICES'; selectedTraitChoices: string }
	| { type: 'UPDATE_TRAIT_CHOICE'; traitId: string; effectIndex: number; choice: string }
	| { type: 'INVALIDATE_CACHE' }
	| { type: 'UPDATE_STORE'; updates: Partial<CharacterInProgressStoreData> }
	| { type: 'INITIALIZE_FROM_SAVED'; character: CharacterInProgressStoreData }
	| { type: 'NEXT_STEP' }
	| { type: 'PREVIOUS_STEP' }
	| { type: 'SET_STEP'; step: number };

// Reducer function
function characterReducer(
	state: CharacterInProgressStoreData,
	action: CharacterAction
): CharacterInProgressStoreData {
	switch (action.type) {
		case 'UPDATE_ATTRIBUTE':
			return {
				...state,
				[action.attribute]: action.value
			};
		case 'UPDATE_SKILLS':
			return {
				...state,
				skillsJson: action.skillsJson
			};
		case 'UPDATE_TRADES':
			return {
				...state,
				tradesJson: action.tradesJson
			};
		case 'UPDATE_LANGUAGES':
			return {
				...state,
				languagesJson: action.languagesJson
			};
		case 'SET_CLASS':
			return {
				...state,
				classId: action.classId
			};
		case 'SET_ANCESTRY':
			return {
				...state,
				ancestry1Id: action.ancestry1Id,
				ancestry2Id: action.ancestry2Id
			};
		case 'SET_TRAITS':
			return {
				...state,
				selectedTraitIds: action.selectedTraitIds
			};
		case 'SET_FEATURE_CHOICES':
			return {
				...state,
				selectedFeatureChoices: action.selectedFeatureChoices
			};
		case 'SET_TRAIT_CHOICES':
			return {
				...state,
				selectedTraitChoices: action.selectedTraitChoices,
				cachedEffectResults: undefined, // Invalidate cache
				cacheTimestamp: undefined
			};
		case 'UPDATE_TRAIT_CHOICE':
			const currentChoices = JSON.parse(state.selectedTraitChoices || '{}');
			const choiceKey = `${action.traitId}-${action.effectIndex}`;
			if (action.choice === '') {
				delete currentChoices[choiceKey];
			} else {
				currentChoices[choiceKey] = action.choice;
			}
			return {
				...state,
				selectedTraitChoices: JSON.stringify(currentChoices),
				cachedEffectResults: undefined, // Invalidate cache
				cacheTimestamp: undefined
			};
		case 'INVALIDATE_CACHE':
			return {
				...state,
				cachedEffectResults: undefined,
				cacheTimestamp: undefined
			};
		case 'UPDATE_STORE':
			return {
				...state,
				...action.updates
			};
		case 'INITIALIZE_FROM_SAVED':
			return {
				...action.character
			};
		case 'NEXT_STEP':
			return {
				...state,
				currentStep: Math.min(state.currentStep + 1, 6)
			};
		case 'PREVIOUS_STEP':
			return {
				...state,
				currentStep: Math.max(state.currentStep - 1, 1)
			};
		case 'SET_STEP':
			return {
				...state,
				currentStep: Math.max(1, Math.min(action.step, 6))
			};
		default:
			return state;
	}
}

// Context type
interface CharacterContextType {
	state: CharacterInProgressStoreData;
	dispatch: React.Dispatch<CharacterAction>;
	// Derived values
	attributePointsRemaining: number;
	ancestryPointsRemaining: number;
	ancestryPointsSpent: number;
	totalAncestryPoints: number;
	combatMastery: number;
	primeModifier: { name: string; value: number };
}

// Create context
const CharacterContext = createContext<CharacterContextType | undefined>(undefined);

// Provider component
export function CharacterProvider({ children }: { children: ReactNode }) {
	const [state, dispatch] = useReducer(characterReducer, initialCharacterInProgressState);

	// Derived values
	const attributePointsRemaining =
		12 -
		(state.attribute_might +
			2 +
			(state.attribute_agility + 2) +
			(state.attribute_charisma + 2) +
			(state.attribute_intelligence + 2));

	// Calculate ancestry points spent based on selected traits (default traits are free)
	const calculateAncestryPointsSpent = (): number => {
		if (!state.selectedTraitIds) return 0;

		try {
			const selectedTraitIds: string[] = JSON.parse(state.selectedTraitIds);
			return calculateTraitCosts(selectedTraitIds);
		} catch (error) {
			console.warn('Error calculating ancestry points:', error);
			return 0;
		}
	};

	// Calculate total ancestry points available (base + feature bonuses)
	const calculateTotalAncestryPoints = (): number => {
		let totalPoints = 5; // Base ancestry points

		// Add bonus ancestry points from feature choices
		if (state.classId && state.selectedFeatureChoices) {
			try {
				const selectedClass = classesData.find((c) => c.id === state.classId);
				const classFeatures = selectedClass ? findClassByName(selectedClass.name) : null;

				if (classFeatures) {
					const selectedChoices: { [key: string]: string } = JSON.parse(
						state.selectedFeatureChoices
					);
					const level1Features = classFeatures.coreFeatures.filter(
						(feature) => feature.levelGained === 1
					);

					level1Features.forEach((feature) => {
						if (feature.choices) {
							feature.choices.forEach((choice, choiceIndex) => {
								const choiceId = `${classFeatures.className.toLowerCase()}_${feature.featureName.toLowerCase().replace(/\s+/g, '_')}_${choiceIndex}`;
								const selectedOptions = selectedChoices[choiceId];

								if (selectedOptions) {
									let optionsToProcess: string[] = [];

									// Handle both single selection and multiple selection
									try {
										optionsToProcess = JSON.parse(selectedOptions);
										if (!Array.isArray(optionsToProcess)) {
											optionsToProcess = [selectedOptions];
										}
									} catch {
										optionsToProcess = [selectedOptions];
									}

									// Process each selected option for ancestry point bonuses
									optionsToProcess.forEach((optionName) => {
										const selectedOption = choice.options?.find((opt) => opt.name === optionName);
										if (selectedOption) {
											const description = selectedOption.description.toLowerCase();

											// Parse ancestry point bonuses: "you get X ancestry points"
											const ancestryMatch = description.match(
												/(?:you get|gain)\s*(\d+)\s*ancestry points?/i
											);
											if (ancestryMatch) {
												totalPoints += parseInt(ancestryMatch[1]);
											}
										}
									});
								}
							});
						}
					});
				}
			} catch (error) {
				console.warn('Error calculating ancestry point bonuses:', error);
			}
		}

		return totalPoints;
	};

	const ancestryPointsSpent = calculateAncestryPointsSpent();
	const totalAncestryPoints = calculateTotalAncestryPoints();
	const ancestryPointsRemaining = totalAncestryPoints - ancestryPointsSpent;

	const combatMastery = Math.ceil((state.level ?? 1) / 2);

	const primeModifier = (() => {
		const attributes = [
			{ name: 'Might', value: state.attribute_might },
			{ name: 'Agility', value: state.attribute_agility },
			{ name: 'Charisma', value: state.attribute_charisma },
			{ name: 'Intelligence', value: state.attribute_intelligence }
		];

		let highestAttribute = attributes[0];
		for (let i = 1; i < attributes.length; i++) {
			if (attributes[i].value > highestAttribute.value) {
				highestAttribute = attributes[i];
			}
		}

		return highestAttribute;
	})();

	const contextValue: CharacterContextType = {
		state,
		dispatch,
		attributePointsRemaining,
		ancestryPointsRemaining,
		ancestryPointsSpent,
		totalAncestryPoints,
		combatMastery,
		primeModifier
	};

	return <CharacterContext.Provider value={contextValue}>{children}</CharacterContext.Provider>;
}

// Custom hook to use the character context
export function useCharacter() {
	const context = useContext(CharacterContext);
	if (context === undefined) {
		throw new Error('useCharacter must be used within a CharacterProvider');
	}
	return context;
}

// Helper function to get an attribute's modifier
export function getModifier(attributeScore: number | null | undefined): number {
	return attributeScore ?? 0;
}
````

## File: src/routes/character-creation/ClassFeatures.tsx
````typescript
import { useCharacter } from '../../lib/stores/characterContext';
import { classesData } from '../../lib/rulesdata/loaders/class.loader';
import {
	findClassByName,
	getLegacyChoiceId,
	getAvailableSpellSchools
} from '../../lib/rulesdata/loaders/class-features.loader';
import { SpellSchool } from '../../lib/rulesdata/spells-data/types/spell.types';
import { getDetailedClassFeatureDescription } from '../../lib/utils/classFeatureDescriptions';
import { maneuvers, ManeuverType } from '../../lib/rulesdata/maneuvers';
import { techniques } from '../../lib/rulesdata/techniques';
import {
	StyledContainer,
	StyledTitle,
	StyledSection,
	StyledSectionTitle,
	StyledCard,
	StyledCardTitle,
	StyledCardDescription,
	StyledChoiceOptions,
	StyledLabel,
	StyledRadio,
	StyledOptionDescription,
	StyledNoSelection,
	StyledBenefitsList,
	StyledBenefit,
	StyledBenefitName,
	StyledBenefitDescription
} from './styles/ClassFeatures.styles';

function ClassFeatures() {
	const { state, dispatch } = useCharacter();

	const selectedClass = classesData.find((c) => c.id === state.classId);
	const selectedClassFeatures = selectedClass ? findClassByName(selectedClass.name) : null;
	const selectedFeatureChoices: { [key: string]: string } = JSON.parse(
		state.selectedFeatureChoices || '{}'
	);

	function handleFeatureChoice(choiceId: string, value: string) {
		const currentChoices = { ...selectedFeatureChoices };
		currentChoices[choiceId] = value;
		dispatch({
			type: 'SET_FEATURE_CHOICES',
			selectedFeatureChoices: JSON.stringify(currentChoices)
		});
	}

	function handleMultipleFeatureChoice(choiceId: string, value: string, isSelected: boolean) {
		const currentChoices = { ...selectedFeatureChoices };
		const currentValues: string[] = currentChoices[choiceId]
			? JSON.parse(currentChoices[choiceId])
			: [];

		if (isSelected) {
			// Add the value if not already present
			if (!currentValues.includes(value)) {
				currentValues.push(value);
			}
		} else {
			// Remove the value
			const index = currentValues.indexOf(value);
			if (index > -1) {
				currentValues.splice(index, 1);
			}
		}

		currentChoices[choiceId] = JSON.stringify(currentValues);
		dispatch({
			type: 'SET_FEATURE_CHOICES',
			selectedFeatureChoices: JSON.stringify(currentChoices)
		});
	}

	if (!selectedClass || !selectedClassFeatures) {
		return (
			<StyledContainer>
				<StyledNoSelection>Select a Class to see its features.</StyledNoSelection>
			</StyledContainer>
		);
	}

	// Get level 1 features
	const level1Features = selectedClassFeatures.coreFeatures.filter(
		(feature) => feature.levelGained === 1
	);

	// Get all feature choices from level 1 features (excluding in-game tactical choices)
	const inGameChoices = ['Divine Blessing', "Commander's Call", 'Debilitating Strike'];
	const featureChoices: any[] = [];
	level1Features.forEach((feature) => {
		// Skip features that are in-game tactical choices, not character creation choices
		if (feature.choices && !inGameChoices.includes(feature.featureName)) {
			feature.choices.forEach((choice, choiceIndex) => {
				const choiceId = getLegacyChoiceId(
					selectedClassFeatures.className,
					feature.featureName,
					choiceIndex
				);
				featureChoices.push({
					id: choiceId,
					prompt: choice.prompt,
					type: choice.count > 1 ? 'select_multiple' : 'select_one',
					maxSelections: choice.count > 1 ? choice.count : undefined,
					options:
						choice.options?.map((option) => ({
							value: option.name,
							label: option.name,
							description: option.description
						})) || []
				});
			});
		}
	});

	// Add martial choices based on class table and features
	const level1Data = selectedClass.levelProgression?.[0]; // Level 1 data from table
	if (level1Data) {
		// Get base maneuvers from table
		let tableManeuvers = level1Data.maneuversKnown || 0;
		let tableTechniques = level1Data.techniquesKnown || 0;

		// Add class-specific feature bonuses
		let featureManeuvers = 0;
		let featureTechniques = 0;

		// Parse feature descriptions to extract maneuver/technique bonuses
		selectedClassFeatures.coreFeatures.forEach((feature) => {
			if (feature.levelGained === 1) {
				// Check main feature description
				const description = feature.description.toLowerCase();

				// Look for "you learn X maneuvers" pattern (handles "you learn 2 maneuvers")
				const maneuverMatch = description.match(/you learn (\d+) (?:defensive )?maneuvers?/);
				if (maneuverMatch) {
					featureManeuvers += parseInt(maneuverMatch[1]);
				}

				// Look for "you learn 1 of the following maneuvers" pattern
				const specificManeuverMatch = description.match(/you learn 1 of the following maneuvers/);
				if (specificManeuverMatch) {
					featureManeuvers += 1;
				}

				// Look for "you learn X techniques" pattern
				const techniqueMatch = description.match(/you learn (\d+) techniques?/);
				if (techniqueMatch) {
					featureTechniques += parseInt(techniqueMatch[1]);
				}

				// Check benefits for maneuver/technique learning
				feature.benefits?.forEach((benefit) => {
					const benefitDescription = benefit.description.toLowerCase();

					// Look for "you learn X maneuvers" pattern in benefits
					const benefitManeuverMatch = benefitDescription.match(
						/you learn (\d+) (?:defensive )?maneuvers?/
					);
					if (benefitManeuverMatch) {
						featureManeuvers += parseInt(benefitManeuverMatch[1]);
					}

					// Look for "you learn 1 of the following maneuvers" pattern in benefits
					const benefitSpecificManeuverMatch = benefitDescription.match(
						/you learn 1 of the following maneuvers/
					);
					if (benefitSpecificManeuverMatch) {
						featureManeuvers += 1;
					}

					// Look for "you learn X techniques" pattern in benefits
					const benefitTechniqueMatch = benefitDescription.match(/you learn (\d+) techniques?/);
					if (benefitTechniqueMatch) {
						featureTechniques += parseInt(benefitTechniqueMatch[1]);
					}
				});
			}
		});

		const totalManeuvers = tableManeuvers + featureManeuvers;
		const totalTechniques = tableTechniques + featureTechniques;

		// Check if class gets all Attack maneuvers automatically
		const getsAllAttackManeuvers =
			selectedClassFeatures.className === 'Champion' ||
			selectedClassFeatures.martialPath?.maneuvers?.learnsAllAttack === true;

		// Add maneuver choices if needed
		if (totalManeuvers > 0) {
			const availableManeuvers = getsAllAttackManeuvers
				? maneuvers.filter((m) => m.type !== ManeuverType.Attack) // Class gets all Attack maneuvers automatically
				: maneuvers; // Other classes choose from all maneuvers

			const promptText = getsAllAttackManeuvers
				? `Choose ${totalManeuvers} Maneuver${totalManeuvers > 1 ? 's' : ''} (Attack maneuvers are automatic)`
				: `Choose ${totalManeuvers} Maneuver${totalManeuvers > 1 ? 's' : ''}`;

			featureChoices.push({
				id: `${selectedClassFeatures.className.toLowerCase()}_maneuvers`,
				prompt: promptText,
				type: 'select_multiple',
				maxSelections: totalManeuvers,
				options: availableManeuvers.map((maneuver) => ({
					value: maneuver.name,
					label: maneuver.name,
					description: `${maneuver.description}${maneuver.isReaction ? ' (Reaction)' : ''}${maneuver.requirement ? ` Requirement: ${maneuver.requirement}` : ''}`
				}))
			});
		}

		// Add technique choices if needed
		if (totalTechniques > 0) {
			featureChoices.push({
				id: `${selectedClassFeatures.className.toLowerCase()}_techniques`,
				prompt: `Choose ${totalTechniques} Technique${totalTechniques > 1 ? 's' : ''}`,
				type: totalTechniques > 1 ? 'select_multiple' : 'select_one',
				maxSelections: totalTechniques > 1 ? totalTechniques : undefined,
				options: techniques.map((technique) => ({
					value: technique.name,
					label: technique.name,
					description: `${technique.description}${technique.isReaction ? ' (Reaction)' : ''}${technique.requirement ? ` Requirement: ${technique.requirement}` : ''} Cost: ${technique.cost.ap ? `${technique.cost.ap} AP` : ''}${technique.cost.sp ? ` ${technique.cost.sp} SP` : ''}`
				}))
			});
		}
	}

	// Add spell school choices if needed
	if (selectedClassFeatures.spellcastingPath?.spellList) {
		const spellList = selectedClassFeatures.spellcastingPath.spellList;

		if (spellList.type === 'all_schools' && spellList.schoolCount) {
			// Warlock-style: choose X schools from all available
			const availableSchools = Object.values(SpellSchool);
			featureChoices.push({
				id: `${selectedClassFeatures.className.toLowerCase()}_spell_schools`,
				prompt: `Choose ${spellList.schoolCount} Spell School${spellList.schoolCount > 1 ? 's' : ''}`,
				type: 'select_multiple',
				maxSelections: spellList.schoolCount,
				options: availableSchools.map((school) => ({
					value: school,
					label: school,
					description: `Access to all spells from the ${school} school`
				}))
			});
		} else if (spellList.type === 'schools' && spellList.schoolCount && spellList.schoolCount > 0) {
			// Spellblade-style: choose X additional schools (already have specificSchools)
			const availableSchools = Object.values(SpellSchool);
			const alreadyHaveSchools = spellList.specificSchools || [];
			const choosableSchools = availableSchools.filter(
				(school) => !alreadyHaveSchools.includes(school)
			);

			featureChoices.push({
				id: `${selectedClassFeatures.className.toLowerCase()}_additional_spell_schools`,
				prompt: `Choose ${spellList.schoolCount} additional Spell School${spellList.schoolCount > 1 ? 's' : ''} (you already have: ${alreadyHaveSchools.join(', ')})`,
				type: spellList.schoolCount > 1 ? 'select_multiple' : 'select_one',
				maxSelections: spellList.schoolCount > 1 ? spellList.schoolCount : undefined,
				options: choosableSchools.map((school) => ({
					value: school,
					label: school,
					description: `Access to all spells from the ${school} school`
				}))
			});
		}

		// Check for level 1 features that require spell school choices (like Wizard's Spell School Initiate)
		level1Features.forEach((feature) => {
			const description = feature.description.toLowerCase();
			// Only include features that are character creation choices, not in-game tactical choices
			const isCharacterCreationChoice =
				(description.includes('choose a spell school') ||
					description.includes('choose 1 spell school')) &&
				// Exclude in-game features like Arcane Sigil
				!description.includes('when you create') &&
				!description.includes('when you cast') &&
				!description.includes('you can spend') &&
				// Include features that are clearly character creation (like training/specialization)
				(description.includes('training') ||
					description.includes('specialize') ||
					description.includes('initiate') ||
					description.includes('you gain the following benefits'));

			if (isCharacterCreationChoice) {
				const choiceId = `${selectedClassFeatures.className.toLowerCase()}_${feature.featureName.toLowerCase().replace(/\s+/g, '_')}_school`;

				// Only add if not already added
				if (!featureChoices.some((choice) => choice.id === choiceId)) {
					const availableSchools = Object.values(SpellSchool);
					featureChoices.push({
						id: choiceId,
						prompt: `${feature.featureName}: Choose a Spell School`,
						type: 'select_one',
						options: availableSchools.map((school) => ({
							value: school,
							label: school,
							description: `Specialize in the ${school} school of magic`
						}))
					});
				}
			}
		});
	}

	return (
		<StyledContainer>
			<StyledTitle>{selectedClass.name} Features</StyledTitle>

			{/* Starting Equipment Section */}
			{selectedClassFeatures.startingEquipment && (
				<StyledSection>
					<StyledSectionTitle>Starting Equipment</StyledSectionTitle>
					<StyledCard>
						<StyledCardTitle>Equipment Package</StyledCardTitle>
						<StyledBenefitsList>
							{selectedClassFeatures.startingEquipment.weaponsOrShields && (
								<StyledBenefit>
									<StyledBenefitName>Weapons/Shields</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.startingEquipment.weaponsOrShields.join(', ')}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
							{selectedClassFeatures.startingEquipment.rangedWeapon && (
								<StyledBenefit>
									<StyledBenefitName>Ranged Weapon</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.startingEquipment.rangedWeapon}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
							{selectedClassFeatures.startingEquipment.armor && (
								<StyledBenefit>
									<StyledBenefitName>Armor</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.startingEquipment.armor}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
							{selectedClassFeatures.startingEquipment.packs && (
								<StyledBenefit>
									<StyledBenefitName>Adventure Packs</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.startingEquipment.packs}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
						</StyledBenefitsList>
					</StyledCard>
				</StyledSection>
			)}

			{/* Martial Path Section */}
			{selectedClassFeatures.martialPath && (
				<StyledSection>
					<StyledSectionTitle>Martial Training</StyledSectionTitle>
					<StyledCard>
						<StyledCardTitle>Combat Proficiencies</StyledCardTitle>
						<StyledBenefitsList>
							{selectedClassFeatures.martialPath.combatTraining?.weapons && (
								<StyledBenefit>
									<StyledBenefitName>Weapon Training</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.martialPath.combatTraining.weapons.join(', ')}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
							{selectedClassFeatures.martialPath.combatTraining?.armor && (
								<StyledBenefit>
									<StyledBenefitName>Armor Training</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.martialPath.combatTraining.armor.join(', ')}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
							{selectedClassFeatures.martialPath.combatTraining?.shields && (
								<StyledBenefit>
									<StyledBenefitName>Shield Training</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.martialPath.combatTraining.shields.join(', ')}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
						</StyledBenefitsList>
					</StyledCard>

					{selectedClassFeatures.martialPath.staminaRegen && (
						<StyledCard>
							<StyledCardTitle>Stamina Regeneration</StyledCardTitle>
							<StyledCardDescription>
								{selectedClassFeatures.martialPath.staminaRegen.description}
							</StyledCardDescription>
							{selectedClassFeatures.martialPath.staminaRegen.conditions && (
								<StyledBenefitsList>
									{selectedClassFeatures.martialPath.staminaRegen.conditions.map(
										(condition, index) => (
											<StyledBenefit key={index}>
												<StyledBenefitDescription>• {condition}</StyledBenefitDescription>
											</StyledBenefit>
										)
									)}
								</StyledBenefitsList>
							)}
						</StyledCard>
					)}
				</StyledSection>
			)}

			{/* Spellcasting Path Section */}
			{selectedClassFeatures.spellcastingPath && (
				<StyledSection>
					<StyledSectionTitle>Spellcasting Training</StyledSectionTitle>

					{/* Combat Training for Spellcasters */}
					{(selectedClassFeatures.spellcastingPath.combatTraining?.armor ||
						selectedClassFeatures.spellcastingPath.combatTraining?.shields) && (
						<StyledCard>
							<StyledCardTitle>Combat Proficiencies</StyledCardTitle>
							<StyledBenefitsList>
								{selectedClassFeatures.spellcastingPath.combatTraining?.armor && (
									<StyledBenefit>
										<StyledBenefitName>Armor Training</StyledBenefitName>
										<StyledBenefitDescription>
											{selectedClassFeatures.spellcastingPath.combatTraining.armor.join(', ')}
										</StyledBenefitDescription>
									</StyledBenefit>
								)}
								{selectedClassFeatures.spellcastingPath.combatTraining?.shields && (
									<StyledBenefit>
										<StyledBenefitName>Shield Training</StyledBenefitName>
										<StyledBenefitDescription>
											{selectedClassFeatures.spellcastingPath.combatTraining.shields.join(', ')}
										</StyledBenefitDescription>
									</StyledBenefit>
								)}
							</StyledBenefitsList>
						</StyledCard>
					)}

					{/* Spell List Information */}
					{selectedClassFeatures.spellcastingPath.spellList && (
						<StyledCard>
							<StyledCardTitle>Spell List Access</StyledCardTitle>
							<StyledBenefitsList>
								{selectedClassFeatures.spellcastingPath.spellList.listName && (
									<StyledBenefit>
										<StyledBenefitName>Spell List</StyledBenefitName>
										<StyledBenefitDescription>
											{selectedClassFeatures.spellcastingPath.spellList.listName}
										</StyledBenefitDescription>
									</StyledBenefit>
								)}
								{(() => {
									const availableSchools = getAvailableSpellSchools(selectedClassFeatures);
									return availableSchools.length > 0 ? (
										<StyledBenefit>
											<StyledBenefitName>Available Schools</StyledBenefitName>
											<StyledBenefitDescription>
												{selectedClassFeatures.spellcastingPath.spellList?.type === 'all_schools'
													? `Choose ${selectedClassFeatures.spellcastingPath.spellList.schoolCount || 'any'} from: ${availableSchools.join(', ')}`
													: availableSchools.join(', ')}
											</StyledBenefitDescription>
										</StyledBenefit>
									) : null;
								})()}
								{selectedClassFeatures.spellcastingPath.spellList.spellTags && (
									<StyledBenefit>
										<StyledBenefitName>Available Spell Tags</StyledBenefitName>
										<StyledBenefitDescription>
											{selectedClassFeatures.spellcastingPath.spellList.spellTags.join(', ')}
										</StyledBenefitDescription>
									</StyledBenefit>
								)}
								{selectedClassFeatures.spellcastingPath.spellList.description && (
									<StyledBenefit>
										<StyledBenefitName>Selection Method</StyledBenefitName>
										<StyledBenefitDescription>
											{selectedClassFeatures.spellcastingPath.spellList.description}
										</StyledBenefitDescription>
									</StyledBenefit>
								)}
							</StyledBenefitsList>
							{selectedClassFeatures.spellcastingPath.spellList.betaNote && (
								<StyledCardDescription>
									<strong>Beta Note:</strong>{' '}
									{selectedClassFeatures.spellcastingPath.spellList.betaNote}
								</StyledCardDescription>
							)}
						</StyledCard>
					)}

					{/* Spellcasting Progression */}
					<StyledCard>
						<StyledCardTitle>Spellcasting Progression</StyledCardTitle>
						<StyledBenefitsList>
							{selectedClassFeatures.spellcastingPath.cantrips && (
								<StyledBenefit>
									<StyledBenefitName>Cantrips Known</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.spellcastingPath.cantrips.knownIncreasesBy}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
							{selectedClassFeatures.spellcastingPath.spells && (
								<StyledBenefit>
									<StyledBenefitName>Spells Known</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.spellcastingPath.spells.knownIncreasesBy}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
							{selectedClassFeatures.spellcastingPath.manaPoints && (
								<StyledBenefit>
									<StyledBenefitName>Mana Points</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.spellcastingPath.manaPoints.maximumIncreasesBy}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
						</StyledBenefitsList>
					</StyledCard>
				</StyledSection>
			)}

			<StyledSection>
				<StyledSectionTitle>Level 1 Features</StyledSectionTitle>
				{level1Features.map((feature, index) => (
					<StyledCard key={index}>
						<StyledCardTitle>{feature.featureName}</StyledCardTitle>
						<StyledCardDescription>{feature.description}</StyledCardDescription>
						{feature.benefits && (
							<StyledBenefitsList>
								{feature.benefits.map((benefit, benefitIndex) => (
									<StyledBenefit key={benefitIndex}>
										<StyledBenefitName>{benefit.name}</StyledBenefitName>
										<StyledBenefitDescription>{benefit.description}</StyledBenefitDescription>
									</StyledBenefit>
								))}
							</StyledBenefitsList>
						)}
					</StyledCard>
				))}
			</StyledSection>

			{/* Automatic Attack Maneuvers Section */}
			{(selectedClassFeatures.className === 'Champion' ||
				selectedClassFeatures.martialPath?.maneuvers?.learnsAllAttack === true) && (
				<StyledSection>
					<StyledSectionTitle>Automatic Maneuvers</StyledSectionTitle>
					<StyledCard>
						<StyledCardTitle>Attack Maneuvers (Automatically Known)</StyledCardTitle>
						<StyledCardDescription>
							{selectedClassFeatures.className === 'Champion'
								? 'As a Champion, you automatically know all Attack maneuvers. You will also choose additional maneuvers and techniques below.'
								: 'This class automatically knows all Attack maneuvers due to their martial training. You will also choose additional maneuvers below.'}
						</StyledCardDescription>
						<StyledBenefitsList>
							{maneuvers
								.filter((m) => m.type === ManeuverType.Attack)
								.map((maneuver, index) => (
									<StyledBenefit key={index}>
										<StyledBenefitName>{maneuver.name}</StyledBenefitName>
										<StyledBenefitDescription>{maneuver.description}</StyledBenefitDescription>
									</StyledBenefit>
								))}
						</StyledBenefitsList>
					</StyledCard>
				</StyledSection>
			)}

			{featureChoices.length > 0 && (
				<StyledSection>
					<StyledSectionTitle>Feature Choices</StyledSectionTitle>
					{featureChoices.map((choice: any) => (
						<StyledCard key={choice.id}>
							<StyledCardTitle>{choice.prompt}</StyledCardTitle>
							{choice.type === 'select_one' && (
								<StyledChoiceOptions>
									{choice.options.map((option: any) => {
										const detailedDescription = getDetailedClassFeatureDescription(
											choice.id,
											option.value
										);
										return (
											<StyledLabel key={option.value}>
												<StyledRadio
													type="radio"
													name={choice.id}
													value={option.value}
													checked={selectedFeatureChoices[choice.id] === option.value}
													onChange={() => handleFeatureChoice(choice.id, option.value)}
												/>
												{option.label}
												{(option.description || detailedDescription) && (
													<StyledOptionDescription>
														{option.description || detailedDescription}
													</StyledOptionDescription>
												)}
											</StyledLabel>
										);
									})}
								</StyledChoiceOptions>
							)}
							{choice.type === 'select_multiple' && (
								<StyledChoiceOptions>
									{choice.options.map((option: any) => {
										const currentValues: string[] = selectedFeatureChoices[choice.id]
											? JSON.parse(selectedFeatureChoices[choice.id])
											: [];
										const isSelected = currentValues.includes(option.value);
										const canSelect = currentValues.length < (choice.maxSelections || 999);
										const isDisabled = !isSelected && !canSelect;
										const detailedDescription = getDetailedClassFeatureDescription(
											choice.id,
											option.value
										);

										return (
											<StyledLabel key={option.value} style={{ opacity: isDisabled ? 0.5 : 1 }}>
												<StyledRadio
													type="checkbox"
													name={choice.id}
													value={option.value}
													checked={isSelected}
													disabled={isDisabled}
													onChange={(e) =>
														handleMultipleFeatureChoice(choice.id, option.value, e.target.checked)
													}
												/>
												{option.label}
												{(option.description || detailedDescription) && (
													<StyledOptionDescription>
														{option.description || detailedDescription}
													</StyledOptionDescription>
												)}
											</StyledLabel>
										);
									})}
									{choice.maxSelections && (
										<StyledOptionDescription style={{ marginTop: '8px', fontStyle: 'italic' }}>
											Select up to {choice.maxSelections} options (
											{selectedFeatureChoices[choice.id]
												? JSON.parse(selectedFeatureChoices[choice.id]).length
												: 0}
											/{choice.maxSelections} selected)
										</StyledOptionDescription>
									)}
								</StyledChoiceOptions>
							)}
						</StyledCard>
					))}
				</StyledSection>
			)}
		</StyledContainer>
	);
}

export default ClassFeatures;
````

## File: src/routes/character-creation/CharacterCreation.tsx
````typescript
import React, { useState, useEffect } from 'react';
import { useCharacter } from '../../lib/stores/characterContext';
import { classesData } from '../../lib/rulesdata/loaders/class.loader';
import { findClassByName } from '../../lib/rulesdata/loaders/class-features.loader';
import AncestrySelector from './AncestrySelector.tsx';
import SelectedAncestries from './SelectedAncestries.tsx';
import Attributes from './Attributes.tsx';
import ClassSelector from './ClassSelector.tsx';
import ClassFeatures from './ClassFeatures.tsx';
import Background from './Background.tsx';
import CharacterName from './CharacterName.tsx';
import Snackbar from '../../components/Snackbar.tsx';
import { completeCharacter } from '../../lib/services/characterCompletion';
import {
	completeCharacterEdit,
	convertCharacterToInProgress,
	type SavedCharacter
} from '../../lib/utils/characterEdit';
import { convertToEnhancedBuildData, calculateCharacterWithBreakdowns } from '../../lib/services/enhancedCharacterCalculator';
import {
	StyledContainer,
	StyledTitle,
	StyledStepIndicator,
	StyledStepsContainer,
	StyledStep,
	StyledStepNumber,
	StyledStepLabel,
	StyledNavigationButtons,
	StyledButton
} from './styles/CharacterCreation.styles';

interface CharacterCreationProps {
	onNavigateToLoad: () => void;
	editCharacter?: SavedCharacter; // If provided, we're in edit mode
}

const CharacterCreation: React.FC<CharacterCreationProps> = ({
	onNavigateToLoad,
	editCharacter
}) => {
	const { state, dispatch, attributePointsRemaining, ancestryPointsRemaining } = useCharacter();
	const [snackbarMessage, setSnackbarMessage] = useState('');
	const [showSnackbar, setShowSnackbar] = useState(false);

	// Initialize character state for edit mode
	useEffect(() => {
		if (editCharacter) {
			console.log('Initializing edit mode for character:', editCharacter);
			const characterInProgress = convertCharacterToInProgress(editCharacter);

			// Initialize the character state with the existing character data
			dispatch({ type: 'INITIALIZE_FROM_SAVED', character: characterInProgress });
		}
	}, [editCharacter, dispatch]);

	const steps = [
		{ number: 1, label: 'Class & Features' },
		{ number: 2, label: 'Attributes' },
		{ number: 3, label: 'Background' },
		{ number: 4, label: 'Ancestry' },
		{ number: 5, label: 'Character Name' }
	];

	const handleStepClick = (step: number) => {
		dispatch({ type: 'SET_STEP', step });
	};

	const handleNext = async () => {
		if (state.currentStep === 5 && areAllStepsCompleted()) {
			// Character is complete - check if we're editing or creating new
			if (editCharacter) {
				// Edit mode: use the enhanced completion that preserves manual modifications
				// Use enhanced calculator for character editing
				const supportedClasses = ['barbarian', 'cleric', 'hunter', 'champion', 'wizard', 'monk', 'rogue', 'sorcerer', 'spellblade', 'warlock'];
				
				if (supportedClasses.includes(state.classId || '')) {
					// Convert to enhanced format and calculate
					const enhancedData = convertToEnhancedBuildData(state);
					const enhancedResult = calculateCharacterWithBreakdowns(enhancedData);
					
					// Create a calculation function that returns the enhanced result
					const enhancedCalculatorFn = async () => ({ 
						...enhancedResult.stats,
						grantedAbilities: enhancedResult.grantedAbilities,
						conditionalModifiers: enhancedResult.conditionalModifiers
					});
					
					await completeCharacterEdit(editCharacter.id, state, enhancedCalculatorFn);
				} else {
					// Fallback to old calculator for non-migrated classes
					await completeCharacterEdit(editCharacter.id, state, calculateCharacterStats);
				}
				setSnackbarMessage('Character updated successfully! Manual modifications preserved.');
				setShowSnackbar(true);
				setTimeout(() => onNavigateToLoad(), 2000);
			} else {
				// Create mode: use standard completion
				await completeCharacter(state, {
					onShowSnackbar: (message: string) => {
						setSnackbarMessage(message);
						setShowSnackbar(true);
					},
					onNavigateToLoad: onNavigateToLoad
				});
			}
			return;
		} else {
			dispatch({ type: 'NEXT_STEP' });
		}
	};

	const handlePrevious = () => {
		dispatch({ type: 'PREVIOUS_STEP' });
	};

	const isStepCompleted = (step: number) => {
		switch (step) {
			case 1: {
				if (state.classId === null) return false;

				// Check if all required feature choices have been made
				const selectedClass = classesData.find((c) => c.id === state.classId);
				if (!selectedClass) return false;

				// Check if all required feature choices have been made
				const selectedClassFeatures = findClassByName(selectedClass.name);
				if (!selectedClassFeatures) return false;

				const selectedFeatureChoices: { [key: string]: string } = JSON.parse(
					state.selectedFeatureChoices || '{}'
				);

				// Check if spell school choices are required and have been made
				const spellList = selectedClassFeatures.spellcastingPath?.spellList;
				if (spellList) {
					// Check Warlock-style spell school selection
					if (spellList.type === 'all_schools' && spellList.schoolCount) {
						const choiceId = `${selectedClassFeatures.className.toLowerCase()}_spell_schools`;
						const choice = selectedFeatureChoices[choiceId];
						if (!choice) return false;
						const selectedSchools = JSON.parse(choice);
						if (selectedSchools.length !== spellList.schoolCount) return false;
					}

					// Check Spellblade-style additional school selection
					if (spellList.type === 'schools' && spellList.schoolCount && spellList.schoolCount > 0) {
						const choiceId = `${selectedClassFeatures.className.toLowerCase()}_additional_spell_schools`;
						const choice = selectedFeatureChoices[choiceId];
						if (!choice) return false;
						if (spellList.schoolCount > 1) {
							const selectedSchools = JSON.parse(choice);
							if (selectedSchools.length !== spellList.schoolCount) return false;
						}
					}

					// Check Wizard-style feature-based spell school choices
					const level1Features = selectedClassFeatures.coreFeatures.filter(
						(feature) => feature.levelGained === 1
					);
					for (const feature of level1Features) {
						const description = feature.description.toLowerCase();
						// Only include features that are character creation choices, not in-game tactical choices
						const isCharacterCreationChoice =
							(description.includes('choose a spell school') ||
								description.includes('choose 1 spell school')) &&
							// Exclude in-game features like Arcane Sigil
							!description.includes('when you create') &&
							!description.includes('when you cast') &&
							!description.includes('you can spend') &&
							// Include features that are clearly character creation (like training/specialization)
							(description.includes('training') ||
								description.includes('specialize') ||
								description.includes('initiate') ||
								description.includes('you gain the following benefits'));

						if (isCharacterCreationChoice) {
							const choiceId = `${selectedClassFeatures.className.toLowerCase()}_${feature.featureName.toLowerCase().replace(/\s+/g, '_')}_school`;
							if (!selectedFeatureChoices[choiceId]) return false;
						}
					}
				}

				return true;
			}
			case 2:
				return attributePointsRemaining === 0;
			case 3: {
				// Background: check if ALL available points have been spent
				// Parse current selections
				let skillPointsUsed = 0;
				let tradePointsUsed = 0;
				let languagePointsUsed = 0;

				try {
					if (state.skillsJson && state.skillsJson !== '{}') {
						const skills = JSON.parse(state.skillsJson) as Record<string, number>;
						skillPointsUsed = Object.values(skills).reduce(
							(sum: number, level: number) => sum + level,
							0
						);
					}
				} catch (e) {
					// Ignore parsing errors
				}

				try {
					if (state.tradesJson && state.tradesJson !== '{}') {
						const trades = JSON.parse(state.tradesJson) as Record<string, number>;
						tradePointsUsed = Object.values(trades).reduce(
							(sum: number, level: number) => sum + level,
							0
						);
					}
				} catch (e) {
					// Ignore parsing errors
				}

				try {
					if (state.languagesJson && state.languagesJson !== '{}') {
						const languages = JSON.parse(state.languagesJson) as Record<
							string,
							{ fluency?: string }
						>;
						languagePointsUsed = Object.entries(languages).reduce(
							(sum, [langId, data]: [string, { fluency?: string }]) => {
								if (langId === 'common') return sum; // Common is free
								return (
									sum +
									(data.fluency === 'basic'
										? 1
										: data.fluency === 'advanced'
											? 2
											: data.fluency === 'fluent'
												? 3
												: 0)
								);
							},
							0
						);
					}
				} catch (e) {
					// Ignore parsing errors
				}

				// Calculate available points based on current Intelligence
				const intelligenceModifier = state.attribute_intelligence;
				const baseSkillPoints = Math.max(1, 5 + intelligenceModifier); // At least 1, even with negative Int

				// For completion, we require that:
				// 1. Skill points are exactly spent (not overspent, not underspent)
				// 2. At least some trade or language points are spent (showing engagement)
				const skillPointsRemaining = baseSkillPoints - skillPointsUsed;
				const hasExactlySpentAllSkillPoints = skillPointsRemaining === 0;
				const hasSpentSomeTradeOrLanguagePoints = tradePointsUsed > 0 || languagePointsUsed > 0;

				return hasExactlySpentAllSkillPoints && hasSpentSomeTradeOrLanguagePoints;
			}
			case 4:
				return state.ancestry1Id !== null && ancestryPointsRemaining >= 0;
			case 5:
				return (
					state.finalName !== null &&
					state.finalName !== '' &&
					state.finalPlayerName !== null &&
					state.finalPlayerName !== ''
				);
			default:
				return false;
		}
	};

	const areAllStepsCompleted = () => {
		return steps.every((step) => isStepCompleted(step.number));
	};

	const renderCurrentStep = () => {
		switch (state.currentStep) {
			case 1:
				return (
					<>
						<ClassSelector />
						<ClassFeatures />
					</>
				);
			case 2:
				return <Attributes />;
			case 3:
				return <Background />;
			case 4:
				return (
					<>
						<AncestrySelector />
						<SelectedAncestries />
					</>
				);
			case 5:
				return <CharacterName />;
			default:
				return null;
		}
	};

	return (
		<div>
			<StyledTitle>
				{editCharacter ? `Edit Character: ${editCharacter.finalName}` : 'Character Creation'}
			</StyledTitle>

			<StyledStepIndicator>
				<StyledNavigationButtons>
					<StyledButton
						$variant="secondary"
						onClick={handlePrevious}
						disabled={state.currentStep === 1}
					>
						← Previous
					</StyledButton>
				</StyledNavigationButtons>

				<StyledStepsContainer>
					{steps.map((step) => (
						<StyledStep
							key={step.number}
							$active={state.currentStep === step.number}
							$completed={isStepCompleted(step.number)}
							onClick={() => handleStepClick(step.number)}
						>
							<StyledStepNumber
								$active={state.currentStep === step.number}
								$completed={isStepCompleted(step.number)}
							>
								{isStepCompleted(step.number) ? '✓' : step.number}
							</StyledStepNumber>
							<StyledStepLabel
								$active={state.currentStep === step.number}
								$completed={isStepCompleted(step.number)}
							>
								{step.label}
							</StyledStepLabel>
						</StyledStep>
					))}
				</StyledStepsContainer>

				<StyledNavigationButtons>
					<StyledButton
						$variant="primary"
						onClick={handleNext}
						disabled={state.currentStep === 5 && !areAllStepsCompleted()}
					>
						{state.currentStep === 5 ? 'Complete' : 'Next →'}
					</StyledButton>
				</StyledNavigationButtons>
			</StyledStepIndicator>

			<StyledContainer>{renderCurrentStep()}</StyledContainer>

			<Snackbar
				message={snackbarMessage}
				isVisible={showSnackbar}
				onClose={() => setShowSnackbar(false)}
				duration={3000}
			/>
		</div>
	);
};

export default CharacterCreation;
````

## File: src/lib/services/characterCalculator.ts
````typescript
// DC20 Character Calculator Service
// Handles calculation of derived stats based on DC20 rules

import { skillsData } from '../rulesdata/skills';
import { ancestriesData } from '../rulesdata/ancestries';
import { findClassByName } from '../rulesdata/loaders/class-features.loader';
import type { IClassDefinition } from '../rulesdata/schemas/class.schema';
import { processTraitEffects, type ProcessedTraitEffects } from './traitEffectProcessor';

export interface CharacterInProgressData {
	id: string;
	// Attributes
	attribute_might: number;
	attribute_agility: number;
	attribute_charisma: number;
	attribute_intelligence: number;

	// Progression
	level: number;
	combatMastery: number;

	// Class & Ancestry
	classId: string | null;
	ancestry1Id: string | null;
	ancestry2Id: string | null;
	selectedTraitIds: string;
	selectedFeatureChoices: string;

	// Character Details
	finalName: string | null;
	finalPlayerName: string | null;

	// Skills (if implemented)
	skillsJson?: string;
	tradesJson?: string;
	languagesJson?: string;

	// Manual Defense Overrides
	manualPD?: number;
	manualAD?: number;
	manualPDR?: number;

	// Timestamps
	createdAt: Date;
	updatedAt?: Date;
	completedAt?: string;
}

export interface CalculatedCharacterStats {
	// Basic Info
	id: string;
	finalName: string;
	finalPlayerName?: string;
	finalLevel: number;

	// Timestamps
	createdAt: Date;
	updatedAt?: Date;
	completedAt?: string;

	// Attributes
	finalMight: number;
	finalAgility: number;
	finalCharisma: number;
	finalIntelligence: number;

	// Calculated Stats
	finalPrimeModifierValue: number;
	finalPrimeModifierAttribute: string;
	finalCombatMastery: number;

	// Saves (Attribute + Combat Mastery)
	finalSaveMight: number;
	finalSaveAgility: number;
	finalSaveCharisma: number;
	finalSaveIntelligence: number;

	// Health & Resources
	finalHPMax: number;
	finalSPMax: number;
	finalMPMax: number;

	// Defenses
	finalPD: number; // Precision Defense
	finalAD: number; // Area Defense

	// Other Stats
	finalSaveDC: number;
	finalDeathThreshold: number;
	finalMoveSpeed: number;
	finalJumpDistance: number;
	finalRestPoints: number;
	finalGritPoints: number;
	finalInitiativeBonus: number;

	// PDR (Precision Damage Reduction)
	finalPDR: number;

	// Class & Ancestry Info
	classId: string | null;
	className: string;
	ancestry1Id: string | null;
	ancestry1Name?: string;
	ancestry2Id: string | null;
	ancestry2Name?: string;
	selectedFeatureChoices?: string;
	selectedTraitIds?: string;

	// JSON data fields
	skillsJson?: string;
	tradesJson?: string;
	languagesJson?: string;
	
	// Calculated bonus data
	skillsWithBonuses?: any[];
	tradesWithBonuses?: any[];
}

// Import class data (we need to create this import based on what's available)
const getClassData = async (classId: string): Promise<IClassDefinition | null> => {
	try {
		// Dynamic import of class data
		const { classesData } = await import('../rulesdata/loaders/class.loader');

		const classData = classesData.find((c) => c.id === classId);
		return classData || null;
	} catch (error) {
		console.warn('Could not load class data:', error);
		return null;
	}
};

// Get ancestry data by ID
const getAncestryData = (ancestryId: string | null): { 
	id: string; 
	name: string; 
	defaultTraitIds: string[];
	expandedTraitIds: string[];
} | null => {
	if (!ancestryId) return null;

	const ancestry = ancestriesData.find((a) => a.id === ancestryId);
	return ancestry ? { 
		id: ancestry.id, 
		name: ancestry.name,
		defaultTraitIds: ancestry.defaultTraitIds || [],
		expandedTraitIds: ancestry.expandedTraitIds
	} : null;
};

const calculatePrimeModifier = (attributes: {
	might: number;
	agility: number;
	charisma: number;
	intelligence: number;
}): { value: number; attribute: string } => {
	// Find the highest attribute
	const { might, agility, charisma, intelligence } = attributes;
	const attrArray = [
		{ value: might, name: 'MIG' },
		{ value: agility, name: 'AGI' },
		{ value: charisma, name: 'CHA' },
		{ value: intelligence, name: 'INT' }
	];

	const highest = attrArray.reduce((prev, curr) => (curr.value > prev.value ? curr : prev));

	return {
		value: highest.value,
		attribute: highest.name
	};
};

export const calculateCharacterStats = async (
	characterData: CharacterInProgressData
): Promise<CalculatedCharacterStats> => {
	console.log('calculateCharacterStats called with:', characterData);

	// Get class data
	const classData = characterData.classId ? await getClassData(characterData.classId) : null;
	console.log('Class data loaded:', classData);

	// Get class features data
	const classFeatures = classData ? findClassByName(classData.name) : null;

	// Get ancestry data
	const ancestry1Data = getAncestryData(characterData.ancestry1Id);
	const ancestry2Data = getAncestryData(characterData.ancestry2Id);
	console.log('Ancestry data loaded:', { ancestry1Data, ancestry2Data });

	// Process trait effects EARLY to get attribute modifiers
	let processedTraitEffects: ProcessedTraitEffects;
	try {
		const selectedTraitIds = characterData.selectedTraitIds ? JSON.parse(characterData.selectedTraitIds) : [];
		processedTraitEffects = processTraitEffects(
			selectedTraitIds, 
			characterData.ancestry1Id, 
			characterData.ancestry2Id
		);
		console.log('Trait effects processed:', processedTraitEffects);
	} catch (error) {
		console.warn('Error processing trait effects:', error);
		// Initialize empty effects if parsing fails
		processedTraitEffects = {
			attributeModifiers: { might: 0, agility: 0, charisma: 0, intelligence: 0 },
			staticBonuses: { hpMax: 0, mpMax: 0, spMax: 0, pd: 0, ad: 0, moveSpeed: 0, deathThreshold: 0, jumpDistance: 0, initiativeBonus: 0 },
			resistances: [],
			vulnerabilities: [],
			abilities: [],
			conditionalEffects: [],
			userChoicesRequired: []
		};
	}

	// Apply attribute modifiers from traits BEFORE other calculations
	const finalMight = characterData.attribute_might + processedTraitEffects.attributeModifiers.might;
	const finalAgility = characterData.attribute_agility + processedTraitEffects.attributeModifiers.agility;
	const finalCharisma = characterData.attribute_charisma + processedTraitEffects.attributeModifiers.charisma;
	const finalIntelligence = characterData.attribute_intelligence + processedTraitEffects.attributeModifiers.intelligence;

	// Combat Mastery (half level rounded up)
	const finalCombatMastery = Math.ceil(characterData.level / 2);

	// Prime Modifier
	const primeModifier = calculatePrimeModifier({
		might: finalMight,
		agility: finalAgility,
		charisma: finalCharisma,
		intelligence: finalIntelligence
	});

	// Defenses (DC20 formulas)
	// PD (Precision Defense) = 8 + CM + Agility + Intelligence + Bonuses from traits/items
	let calculatedPD = 8 + finalCombatMastery + finalAgility + finalIntelligence + processedTraitEffects.staticBonuses.pd;
	

	// AD (Area Defense) = 8 + CM + Might + Charisma + Bonuses from traits/items
	let calculatedAD = 8 + finalCombatMastery + finalMight + finalCharisma + processedTraitEffects.staticBonuses.ad;
	

	// Health & Resources - Calculate from level progression
	let finalHPMax = finalMight; // Base from Might
	let finalSPMax = 0;
	let finalMPMax = 0;
	let finalSaveDC = 10; // Base (correct DC20 base)
	let finalDeathThreshold = primeModifier.value + finalCombatMastery; // Prime + Combat Mastery (usually -4)
	let finalMoveSpeed = 5; // Default base, will be set by class data
	let finalRestPoints = 4; // Will be set to finalHPMax later
	let finalInitiativeBonus = 0; // Base

	// Add class contributions from level progression table
	if (classData && classData.levelProgression) {
		// Sum HP/SP/MP from all levels up to current level
		for (let level = 1; level <= characterData.level; level++) {
			const levelData = classData.levelProgression.find(lp => lp.level === level);
			if (levelData) {
				finalHPMax += levelData.healthPoints || 0;
				finalSPMax += levelData.staminaPoints || 0;
				finalMPMax += levelData.manaPoints || 0;
			}
		}
	} else if (classData) {
		// Fallback to old method if levelProgression not available
		finalHPMax += classData.baseHpContribution;
		finalSPMax = classData.startingSP;
		finalMPMax = classData.startingMP;
		// Note: saveDCBase is not used in correct formula, keeping base at 10
		finalDeathThreshold = classData.deathThresholdBase;
		finalMoveSpeed = classData.moveSpeedBase;
		// finalRestPoints will be set to finalHPMax after all calculations
		finalInitiativeBonus = classData.initiativeBonusBase;

		// Apply effects from class features using the new class features structure
		if (classFeatures) {
			// Get level 1 features
			const level1Features = classFeatures.coreFeatures.filter(
				(feature) => feature.levelGained === 1
			);

			level1Features.forEach((feature) => {
				if (feature.benefits) {
					feature.benefits.forEach((benefit) => {
						if (benefit.effects) {
							benefit.effects.forEach((effect) => {
								if (effect.type === 'MODIFIER') {
									// For now, we'll assume the condition is met.
									// A more robust solution would parse and evaluate the condition string.
									if (effect.target === 'defenses.ad') {
										calculatedAD += effect.value;
									} else if (effect.target === 'defenses.pd') {
										calculatedPD += effect.value;
									} else if (effect.target === 'coreStats.moveSpeed') {
										finalMoveSpeed += effect.value;
									} else if (effect.target === 'resources.mpMax') {
										finalMPMax += effect.value;
									} else if (effect.target === 'coreStats.jumpDistance') {
										finalJumpDistance += effect.value;
									}
									// Add more target cases here as needed
								} else if (effect.type === 'OVERRIDE') {
									if (effect.target === 'coreStats.jumpDistance') {
										// A more robust solution would parse the value string
										finalJumpDistance = finalMight;
									}
								} else if (effect.type === 'GRANT_SKILL_POINTS') {
									// This is a placeholder. A real implementation would need to
									// modify the character's skill points data.
									console.log(`Granting ${effect.value} skill points.`);
								} else if (effect.type === 'GRANT_SPELLS') {
									// This is a placeholder. A real implementation would need to
									// add the spells to the character's spell list.
									console.log(`Granting ${effect.value} spells.`);
								} else if (effect.type === 'GRANT_CANTRIPS') {
									// This is a placeholder. A real implementation would need to
									// add the cantrips to the character's spell list.
									console.log(`Granting ${effect.value} cantrips.`);
								} else if (effect.type === 'GRANT_COMBAT_TRAINING') {
									// This is a placeholder. A real implementation would need to
									// add the combat training to the character's data.
									console.log(`Granting combat training: ${effect.value}`);
								} else if (effect.type === 'GRANT_MANEUVERS') {
									// This is a placeholder. A real implementation would need to
									// add the maneuvers to the character's data.
									console.log(`Granting ${effect.value} maneuvers.`);
								} else if (effect.type === 'GRANT_ANCESTRY_POINTS') {
									// This is a placeholder. A real implementation would need to
									// add the ancestry points to the character's data.
									console.log(`Granting ${effect.value} ancestry points.`);
								} else if (effect.type === 'GRANT_PASSIVE') {
									// This is a placeholder. A real implementation would need to
									// add the passive to the character's data.
									console.log(`Granting passive: ${effect.value}`);
								}
							});
						}
					});
				}
			});
		}
	}

	// Process selected feature choices (robust parsing approach)
	if (characterData.selectedFeatureChoices && classFeatures) {
		try {
			const selectedChoices: { [key: string]: string } = JSON.parse(
				characterData.selectedFeatureChoices
			);

			// Find all level 1 features with choices
			const level1Features = classFeatures.coreFeatures.filter(
				(feature) => feature.levelGained === 1
			);

			level1Features.forEach((feature) => {
				if (feature.choices) {
					feature.choices.forEach((choice, choiceIndex) => {
						const choiceId = `${classFeatures.className.toLowerCase()}_${feature.featureName.toLowerCase().replace(/\s+/g, '_')}_${choiceIndex}`;
						const selectedOptions = selectedChoices[choiceId];

						if (selectedOptions) {
							let optionsToProcess: string[] = [];

							// Handle both single selection and multiple selection
							try {
								optionsToProcess = JSON.parse(selectedOptions);
								if (!Array.isArray(optionsToProcess)) {
									optionsToProcess = [selectedOptions];
								}
							} catch {
								optionsToProcess = [selectedOptions];
							}

							// Process each selected option
							optionsToProcess.forEach((optionName) => {
								const selectedOption = choice.options?.find((opt) => opt.name === optionName);
								if (selectedOption) {
									const description = selectedOption.description.toLowerCase();

									// Parse stat bonuses from descriptions using regex patterns

									// MP bonuses: "your maximum mp increases by X", "mp increases by X", "+X mp"
									const mpMatch =
										description.match(
											/(?:your maximum mp increases by|mp increases by|\+)\s*(\d+)\s*mp/i
										) || description.match(/maximum mp increases by\s*(\d+)/i);
									if (mpMatch) {
										finalMPMax += parseInt(mpMatch[1]);
									}

									// Ancestry Points: "you get X ancestry points", "X ancestry points"
									const ancestryMatch = description.match(
										/(?:you get|gain)\s*(\d+)\s*ancestry points?/i
									);
									if (ancestryMatch) {
										// Note: This would need to be handled in character creation logic, not just stats
										console.log(
											`Feature choice grants ${ancestryMatch[1]} ancestry points: ${optionName}`
										);
									}

									// SP bonuses: "your maximum sp increases by X", "+X sp"
									const spMatch = description.match(
										/(?:your maximum sp increases by|sp increases by|\+)\s*(\d+)\s*sp/i
									);
									if (spMatch) {
										finalSPMax += parseInt(spMatch[1]);
									}

									// HP bonuses: "your maximum hp increases by X", "+X hp"
									const hpMatch = description.match(
										/(?:your maximum hp increases by|hp increases by|\+)\s*(\d+)\s*hp/i
									);
									if (hpMatch) {
										finalHPMax += parseInt(hpMatch[1]);
									}

									// Maneuver learning: "you learn X maneuvers", "learn X defensive maneuvers"
									const maneuverMatch = description.match(
										/you learn\s*(\d+)\s*(?:defensive\s+)?maneuvers?/i
									);
									if (maneuverMatch) {
										// Note: This would be handled in maneuver tracking, not base stats
										console.log(
											`Feature choice grants ${maneuverMatch[1]} maneuvers: ${optionName}`
										);
									}

									// Spell learning: "you learn X additional spell", "you learn X spell"
									const spellMatch = description.match(
										/you learn\s*(\d+)\s*(?:additional\s+)?spells?/i
									);
									if (spellMatch) {
										// Note: This would be handled in spell tracking, not base stats
										console.log(`Feature choice grants ${spellMatch[1]} spells: ${optionName}`);
									}

									// Save DC bonuses: "save dc increases by X", "+X to save dc"
									const saveDCMatch = description.match(
										/(?:save dc increases by|\+)\s*(\d+)(?:\s*to save dc)?/i
									);
									if (saveDCMatch) {
										finalSaveDC += parseInt(saveDCMatch[1]);
									}

									// Movement speed: "move speed increases by X", "+X movement"
									const speedMatch = description.match(
										/(?:move speed increases by|movement.*increases by|\+)\s*(\d+)(?:\s*(?:feet|ft|spaces?))?.*(?:movement|speed)/i
									);
									if (speedMatch) {
										finalMoveSpeed += parseInt(speedMatch[1]);
									}

									// Jump distance: "jump distance increases by X", "+X jump distance"
									const jumpDistanceMatch = description.match(
										/(?:jump distance increases by|jump.*increases by|\+)\s*(\d+)(?:\s*(?:feet|ft|spaces?))?.*(?:jump|distance)/i
									);
									if (jumpDistanceMatch) {
										finalJumpDistance += parseInt(jumpDistanceMatch[1]);
									}
								}
							});
						}
					});
				}
			});
		} catch (error) {
			console.warn('Error processing feature choices:', error);
		}
	}

	// Apply static bonuses from trait effects (after class effects, before manual overrides)
	finalHPMax += processedTraitEffects.staticBonuses.hpMax;
	finalMPMax += processedTraitEffects.staticBonuses.mpMax;
	finalSPMax += processedTraitEffects.staticBonuses.spMax;
	finalMoveSpeed += processedTraitEffects.staticBonuses.moveSpeed;
	finalDeathThreshold += processedTraitEffects.staticBonuses.deathThreshold;
	finalInitiativeBonus += processedTraitEffects.staticBonuses.initiativeBonus;

	// Apply trait bonuses to defenses AFTER class effects
	calculatedPD += processedTraitEffects.staticBonuses.pd;
	calculatedAD += processedTraitEffects.staticBonuses.ad;

	// Apply manual overrides LAST
	const finalPD = characterData.manualPD !== undefined ? characterData.manualPD : calculatedPD;
	const finalAD = characterData.manualAD !== undefined ? characterData.manualAD : calculatedAD;

		// Add attribute bonuses
	finalSaveDC += primeModifier.value + finalCombatMastery; // Save DC = 10 + Prime + Combat Mastery
	finalInitiativeBonus += finalCombatMastery + finalAgility; // Initiative = CM + Agility

	// Calculate Save Values (Updated Formula)
	// Save = Attribute Modifier + Combat Mastery (always)
	const finalSaveMight = finalMight + finalCombatMastery;
	const finalSaveAgility = finalAgility + finalCombatMastery;
	const finalSaveCharisma = finalCharisma + finalCombatMastery;
	const finalSaveIntelligence = finalIntelligence + finalCombatMastery;

	console.log('Save calculations:', {
		combatMastery: finalCombatMastery,
		attributes: {
			might: finalMight,
			agility: finalAgility,
			charisma: finalCharisma,
			intelligence: finalIntelligence
		},
		results: {
			might: finalSaveMight,
			agility: finalSaveAgility,
			charisma: finalSaveCharisma,
			intelligence: finalSaveIntelligence
		}
	});

	// Jump Distance = Agility + modifiers
	let finalJumpDistance = finalAgility + processedTraitEffects.staticBonuses.jumpDistance;

	// Grit Points = 2 + Charisma (minimum 0)
	const finalGritPoints = Math.max(0, 2 + finalCharisma);

	// Calculate PDR (Precision Damage Reduction) with manual override
	const calculatedPDR = calculatePDR(characterData, classData);
	const finalPDR = characterData.manualPDR !== undefined ? characterData.manualPDR : calculatedPDR;

	// Process skills with calculated bonuses
	let skillsJson = characterData.skillsJson;
	if (!skillsJson) {
		// Create default skills with 0 proficiency
		const defaultSkills: Record<string, number> = {};
		skillsData.forEach((skill) => {
			defaultSkills[skill.id] = 0;
		});
		skillsJson = JSON.stringify(defaultSkills);
	}

	// Calculate skill bonuses: Attribute + Mastery*2
	const skillsWithBonuses: any[] = [];
	try {
		const skillProficiencies = JSON.parse(skillsJson);
		skillsData.forEach((skill) => {
			const proficiency = skillProficiencies[skill.id] || 0;
			const masteryBonus = proficiency * 2;
			
			// Get attribute modifier based on skill's attribute association
			let attributeModifier = 0;
			switch (skill.attributeAssociation.toLowerCase()) {
				case 'might':
					attributeModifier = finalMight;
					break;
				case 'agility':
					attributeModifier = finalAgility;
					break;
				case 'charisma':
					attributeModifier = finalCharisma;
					break;
				case 'intelligence':
					attributeModifier = finalIntelligence;
					break;
				default:
					attributeModifier = 0;
			}
			
			const totalBonus = attributeModifier + masteryBonus;
			
			skillsWithBonuses.push({
				id: skill.id,
				name: skill.name,
				attribute: skill.attributeAssociation,
				proficiency,
				bonus: totalBonus
			});
		});
	} catch (error) {
		console.warn('Error calculating skill bonuses:', error);
	}

	// Process trades with calculated bonuses
	const tradesWithBonuses: any[] = [];
	try {
		const tradeProficiencies = JSON.parse(characterData.tradesJson || '{}');
		// Import trades data
		const { tradesData } = await import('../rulesdata/trades');
		const { knowledgeData } = await import('../rulesdata/knowledge');
		const allTradesAndKnowledge = [...tradesData, ...knowledgeData];
		
		allTradesAndKnowledge.forEach((trade) => {
			const proficiency = tradeProficiencies[trade.id] || 0;
			const masteryBonus = proficiency * 2;
			
			// Get attribute modifier based on trade's attribute association
			let attributeModifier = 0;
			switch (trade.attributeAssociation.toLowerCase()) {
				case 'might':
					attributeModifier = finalMight;
					break;
				case 'agility':
					attributeModifier = finalAgility;
					break;
				case 'charisma':
					attributeModifier = finalCharisma;
					break;
				case 'intelligence':
					attributeModifier = finalIntelligence;
					break;
				default:
					attributeModifier = 0;
			}
			
			const totalBonus = attributeModifier + masteryBonus;
			
			tradesWithBonuses.push({
				id: trade.id,
				name: trade.name,
				proficiency,
				bonus: totalBonus
			});
		});
	} catch (error) {
		console.warn('Error calculating trade bonuses:', error);
	}

	// DC20 Rule: Rest Points = HP
	finalRestPoints = finalHPMax;

	return {
		// Basic Info
		id: characterData.id,
		finalName: characterData.finalName || 'Unnamed Character',
		finalPlayerName: characterData.finalPlayerName || undefined,
		finalLevel: characterData.level,

		// Timestamps
		createdAt: characterData.createdAt,
		updatedAt: characterData.updatedAt,
		completedAt: characterData.completedAt,

		// Attributes
		finalMight,
		finalAgility,
		finalCharisma,
		finalIntelligence,

		// Calculated Stats
		finalPrimeModifierValue: primeModifier.value,
		finalPrimeModifierAttribute: primeModifier.attribute,
		finalCombatMastery,

		// Saves (Attribute + Combat Mastery)
		finalSaveMight,
		finalSaveAgility,
		finalSaveCharisma,
		finalSaveIntelligence,

		// Health & Resources
		finalHPMax,
		finalSPMax,
		finalMPMax,

		// Defenses
		finalPD,
		finalAD,

		// Other Stats
		finalSaveDC,
		finalDeathThreshold,
		finalMoveSpeed,
		finalJumpDistance,
		finalRestPoints,
		finalGritPoints,
		finalInitiativeBonus,

		// PDR (Precision Damage Reduction)
		finalPDR,

		// Class & Ancestry Info
		classId: characterData.classId,
		className: classData?.name || 'Unknown',
		ancestry1Id: characterData.ancestry1Id,
		ancestry1Name: ancestry1Data?.name,
		ancestry2Id: characterData.ancestry2Id,
		ancestry2Name: ancestry2Data?.name,
		selectedFeatureChoices: characterData.selectedFeatureChoices,
		selectedTraitIds: characterData.selectedTraitIds,

		// JSON data fields
		skillsJson,
		tradesJson: characterData.tradesJson || '{}',
		languagesJson: characterData.languagesJson || '{"common": {"fluency": "fluent"}}',
		
		// Calculated skill and trade bonuses
		skillsWithBonuses,
		tradesWithBonuses
	};
};

// Helper function to calculate PDR (Precision Damage Reduction)
const calculatePDR = (
	characterData: CharacterInProgressData,
	classData: IClassDefinition | null
): number => {
	let pdr = 0;

	// Check for Beastborn Natural Armor trait
	if (characterData.selectedTraitIds) {
		try {
			const selectedTraits = JSON.parse(characterData.selectedTraitIds);
			if (selectedTraits.includes('beastborn_natural_armor')) {
				// Natural Armor grants PDR when not wearing armor
				// According to DC20 rules, this grants PDR (Precision Damage Reduction)
				pdr += 1;
			}
		} catch (error) {
			console.warn('Error parsing selectedTraitIds for PDR calculation:', error);
		}
	}

	// Check for Barbarian Rage ability
	if (classData?.id === 'barbarian') {
		// Barbarian Rage grants Resistance (Half) to Precision damage
		// This is effectively PDR, but it's a different mechanic
		// For now, we'll note this but not add to base PDR since Rage is conditional
		// TODO: Could add a note or separate field for conditional PDR
	}

	// TODO: Add additional PDR sources:
	// - Heavy Armor with PDR property (requires armor system integration)
	// - Shell Retreat ability (conditional)
	// - Magic items or other class features
	// - Equipment-based PDR calculation

	return pdr;
};
````

## File: src/routes/character-sheet/CharacterSheetClean.tsx
````typescript
import React, { useState, useEffect } from 'react';

// Import types
import type {
	CharacterSheetProps,
	CharacterSheetData,
	SkillData,
	TradeData,
	LanguageData,
	FeatureData,
	CurrentValues,
	AttackData,
	SpellData,
	InventoryItemData,
	CharacterState
} from '../../types';
import type { Spell } from '../../lib/rulesdata/spells-data/types/spell.types';
import type { Weapon } from '../../lib/rulesdata/inventoryItems';
import type { InventoryItem } from '../../lib/rulesdata/inventoryItems';
import {
	getVersatileDamage,
	getWeaponRange,
	getWeaponFeatures,
	parseDamage
} from '../../lib/utils/weaponUtils';

// Import new component modules
import LeftColumn from './components/LeftColumn';
import Currency from './components/Currency';
import Resources from './components/Resources';
import Defenses from './components/Defenses';
import Combat from './components/Combat';
import Attacks from './components/Attacks';
import Spells from './components/Spells';
import Inventory from './components/Inventory';
import Features from './components/Features';
import Movement from './components/Movement';
import RightColumnResources from './components/RightColumnResources';
import DeathExhaustion from './components/DeathExhaustion';
import PlayerNotes from './components/PlayerNotes';
import DiceRoller from './components/DiceRoller';

// Import character state management utilities
import {
	getCharacterState,
	initializeCharacterState,
	saveCharacterState,
	updateCharacterState,
	revertToOriginal,
	characterStateToCurrentValues
} from '../../lib/utils/characterState';

// Import defense notes utilities
import { clearDefenseNotesForField } from '../../lib/utils/defenseNotes';

// Import rules data
import { skillsData } from '../../lib/rulesdata/skills';
import { tradesData } from '../../lib/rulesdata/trades';
import { knowledgeData } from '../../lib/rulesdata/knowledge';
import { traitsData } from '../../lib/rulesdata/traits';
import {
	findClassByName,
	getClassSpecificInfo,
	getLegacyChoiceId,
	getDisplayLabel
} from '../../lib/rulesdata/loaders/class-features.loader';
import { ancestriesData } from '../../lib/rulesdata/ancestries';
import { getDetailedClassFeatureDescription } from '../../lib/utils/classFeatureDescriptions';

// Import styled components
import {
	StyledContainer,
	StyledBackButton,
	StyledCharacterSheet,
	StyledMainGrid,
	StyledLeftColumn,
	StyledMiddleColumn,
	StyledRightColumn,
	StyledMobileNav,
	StyledMobileNavButton,
	StyledActionButtons,
	StyledActionButton
} from './styles/Layout';

import { StyledHeader, StyledHeaderSection, StyledLabel, StyledValue } from './styles/Header';

import {
	StyledFeaturePopupOverlay,
	StyledFeaturePopupContent,
	StyledFeaturePopupHeader,
	StyledFeaturePopupTitle,
	StyledFeaturePopupClose,
	StyledFeaturePopupDescription,
	StyledFeaturePopupSourceInfo
} from './styles/FeaturePopup';

import { calculateDeathThreshold } from '../../lib/rulesdata/death';

// Character data service - fetches from localStorage and fixes missing/invalid calculations
const getCharacterData = async (characterId: string): Promise<CharacterSheetData> => {
	console.log('Loading character data for ID:', characterId);

	// Get characters from localStorage
	const savedCharacters = JSON.parse(localStorage.getItem('savedCharacters') || '[]');

	// Find the character by ID
	const character = savedCharacters.find((char: any) => char.id === characterId);

	if (!character) {
		throw new Error(`Character with ID "${characterId}" not found in localStorage`);
	}

	// Fix missing or invalid prime modifier values
	const fixedCharacter = { ...character };
	
	// Recalculate prime modifier if missing or invalid
	if (!fixedCharacter.finalPrimeModifierValue || isNaN(fixedCharacter.finalPrimeModifierValue)) {
		const attributes = {
			might: fixedCharacter.finalMight || 0,
			agility: fixedCharacter.finalAgility || 0,
			charisma: fixedCharacter.finalCharisma || 0,
			intelligence: fixedCharacter.finalIntelligence || 0
		};
		
		const maxValue = Math.max(...Object.values(attributes));
		const primeAttribute = Object.keys(attributes).find(
			key => attributes[key as keyof typeof attributes] === maxValue
		) || 'might';
		
		fixedCharacter.finalPrimeModifierValue = maxValue;
		fixedCharacter.finalPrimeModifierAttribute = primeAttribute;
	}
	
	// Fix missing combat mastery
	if (!fixedCharacter.finalCombatMastery || isNaN(fixedCharacter.finalCombatMastery)) {
		fixedCharacter.finalCombatMastery = Math.ceil((fixedCharacter.finalLevel || 1) / 2);
	}

	// Return the fixed character data
	return {
		...fixedCharacter,
		selectedTraitIds: fixedCharacter.selectedTraitIds || fixedCharacter.selectedTraitsJson || '[]',
		selectedFeatureChoices: fixedCharacter.selectedFeatureChoices || '{}'
	};
};

// Save manual defense overrides to localStorage
const saveManualDefense = (
	characterId: string,
	field: 'manualPD' | 'manualPDR' | 'manualAD',
	value: number | undefined
) => {
	const savedCharacters = JSON.parse(localStorage.getItem('savedCharacters') || '[]');
	const characterIndex = savedCharacters.findIndex((char: any) => char.id === characterId);

	if (characterIndex !== -1) {
		// Update the character's manual defense value
		savedCharacters[characterIndex] = {
			...savedCharacters[characterIndex],
			[field]: value,
			lastModified: new Date().toISOString()
		};

		localStorage.setItem('savedCharacters', JSON.stringify(savedCharacters));
		console.log(`Manual defense ${field} updated for character ${characterId}:`, value);
	}
};

const CharacterSheet: React.FC<CharacterSheetProps> = ({ characterId, onBack }) => {
	const [characterData, setCharacterData] = useState<CharacterSheetData | null>(null);
	const [characterState, setCharacterState] = useState<CharacterState | null>(null);
	// Keep currentValues for backwards compatibility with existing components
	const [currentValues, setCurrentValues] = useState<CurrentValues>({
		currentHP: 0,
		currentSP: 0,
		currentMP: 0,
		currentGritPoints: 0,
		currentRestPoints: 0,
		tempHP: 0,
		actionPointsUsed: 0,
		exhaustionLevel: 0,
		// Currency
		goldPieces: 0,
		silverPieces: 0,
		copperPieces: 0,
		electrumPieces: 0,
		platinumPieces: 0
	});
	const [loading, setLoading] = useState(true);
	const [error, setError] = useState<string | null>(null);
	const [selectedFeature, setSelectedFeature] = useState<FeatureData | null>(null);
	const [selectedSpell, setSelectedSpell] = useState<Spell | null>(null);
	const [selectedAttack, setSelectedAttack] = useState<{
		attack: AttackData;
		weapon: Weapon | null;
	} | null>(null);
	const [selectedInventoryItem, setSelectedInventoryItem] = useState<{
		inventoryData: InventoryItemData;
		item: InventoryItem | null;
	} | null>(null);
	const [attacks, setAttacks] = useState<AttackData[]>([]);
	const [spells, setSpells] = useState<SpellData[]>([]);
	const [inventory, setInventory] = useState<InventoryItemData[]>([]);

	// Mobile navigation state
	type MobileSection = 'character' | 'combat' | 'features' | 'info';
	const [activeMobileSection, setActiveMobileSection] = useState<MobileSection>('character');
	const [isMobile, setIsMobile] = useState(false);

	// Check if mobile resolution
	useEffect(() => {
		const checkMobile = () => {
			setIsMobile(window.innerWidth <= 768);
		};

		checkMobile();
		window.addEventListener('resize', checkMobile);
		return () => window.removeEventListener('resize', checkMobile);
	}, []);

	// Save character current values back to localStorage using comprehensive state management
	const saveCharacterData = (characterId: string, currentValues: CurrentValues) => {
		updateCharacterState(characterId, {
			resources: {
				original: characterState?.resources.original || {
					maxHP: characterData?.finalHPMax || 0,
					maxSP: characterData?.finalSPMax || 0,
					maxMP: characterData?.finalMPMax || 0,
					maxGritPoints: characterData?.finalGritPoints || 0,
					maxRestPoints: characterData?.finalRestPoints || 0
				},
				current: {
					currentHP: currentValues.currentHP,
					currentSP: currentValues.currentSP,
					currentMP: currentValues.currentMP,
					currentGritPoints: currentValues.currentGritPoints,
					currentRestPoints: currentValues.currentRestPoints,
					tempHP: currentValues.tempHP,
					actionPointsUsed: currentValues.actionPointsUsed,
					exhaustionLevel: currentValues.exhaustionLevel
				}
			},
			currency: {
				original: characterState?.currency.original || {
					goldPieces: 0,
					silverPieces: 0,
					copperPieces: 0,
					electrumPieces: 0,
					platinumPieces: 0
				},
				current: {
					goldPieces: currentValues.goldPieces,
					silverPieces: currentValues.silverPieces,
					copperPieces: currentValues.copperPieces,
					electrumPieces: currentValues.electrumPieces,
					platinumPieces: currentValues.platinumPieces
				}
			}
		});
	};

	// Save attacks to comprehensive state
	const saveAttacksData = (newAttacks: AttackData[]) => {
		updateCharacterState(characterId, {
			attacks: {
				original: characterState?.attacks.original || [],
				current: newAttacks
			}
		});
	};

	// Save spells to comprehensive state
	const saveSpellsData = (newSpells: SpellData[]) => {
		updateCharacterState(characterId, {
			spells: {
				original: characterState?.spells.original || [],
				current: newSpells
			}
		});
	};

	// Save inventory to comprehensive state
	const saveInventoryData = (newInventory: InventoryItemData[]) => {
		updateCharacterState(characterId, {
			inventory: {
				original: characterState?.inventory.original || [],
				current: newInventory
			}
		});
	};

	// Wrapper for setAttacks that also saves to comprehensive state
	const updateAttacks = (newAttacks: AttackData[] | ((prev: AttackData[]) => AttackData[])) => {
		setAttacks((prev) => {
			const result = typeof newAttacks === 'function' ? newAttacks(prev) : newAttacks;
			saveAttacksData(result);
			return result;
		});
	};

	// Wrapper for setSpells that also saves to comprehensive state
	const updateSpells = (newSpells: SpellData[] | ((prev: SpellData[]) => SpellData[])) => {
		setSpells((prev) => {
			const result = typeof newSpells === 'function' ? newSpells(prev) : newSpells;
			saveSpellsData(result);
			return result;
		});
	};

	// Wrapper for setInventory that also saves to comprehensive state
	const updateInventory = (
		newInventory: InventoryItemData[] | ((prev: InventoryItemData[]) => InventoryItemData[])
	) => {
		setInventory((prev) => {
			const result = typeof newInventory === 'function' ? newInventory(prev) : newInventory;
			saveInventoryData(result);
			return result;
		});
	};

	// Load character data
	useEffect(() => {
		const loadCharacterData = async () => {
			try {
				setLoading(true);
				setError(null);

				// Load the character data from API
				const data = await getCharacterData(characterId);
				setCharacterData(data);

				// Get existing character state from localStorage
				const existingState = getCharacterState(characterId);

				// Initialize comprehensive character state
				const initialState = initializeCharacterState(data, existingState);
				setCharacterState(initialState);

				// Save the initial state to localStorage if it doesn't exist
				if (!existingState) {
					saveCharacterState(characterId, initialState);
					console.log('Initial character state saved to localStorage');
				}

				// Update component states from the comprehensive state
				const legacyCurrentValues = characterStateToCurrentValues(initialState);
				setCurrentValues(legacyCurrentValues);
				setAttacks(initialState.attacks?.current || []);
				setSpells(initialState.spells?.current || []);
				setInventory(initialState.inventory?.current || []);

				console.log('Character data and state loaded:', {
					characterData: data,
					characterState: initialState,
					legacyCurrentValues
				});
			} catch (err) {
				setError(err instanceof Error ? err.message : 'An error occurred');
			} finally {
				setLoading(false);
			}
		};

		loadCharacterData();
	}, [characterId]);

	// Calculate original defense values using enhanced calculator for supported classes
	const getCalculatedDefenses = () => {
		if (!characterData)
			return {
				calculatedPD: 0,
				calculatedPDR: 0,
				calculatedAD: 0,
				pdBreakdown: '',
				adBreakdown: '',
				pdrBreakdown: ''
			};

		// For supported classes, try to use enhanced calculator for accurate breakdowns
		const supportedClasses = ['barbarian', 'cleric', 'hunter', 'champion', 'wizard', 'monk', 'rogue', 'sorcerer', 'spellblade', 'warlock'];
		
		let calculatedPD, calculatedAD, calculatedPDR;
		let pdBreakdown, adBreakdown, pdrBreakdown;

		if (supportedClasses.includes(characterData.classId || '')) {
			try {
				// Try to recalculate using enhanced system for precise breakdown
				const mockBuildData = {
					id: characterData.id,
					finalName: characterData.finalName || '',
					level: characterData.finalLevel || 1,
					attribute_might: characterData.finalMight || 0,
					attribute_agility: characterData.finalAgility || 0,
					attribute_charisma: characterData.finalCharisma || 0,
					attribute_intelligence: characterData.finalIntelligence || 0,
					combatMastery: characterData.finalCombatMastery || 1,
					classId: characterData.classId || '',
					ancestry1Id: characterData.ancestry1Id,
					ancestry2Id: characterData.ancestry2Id,
					selectedTraitIds: JSON.parse(characterData.selectedTraitIds || '[]'),
					selectedTraitChoices: JSON.parse(characterData.selectedTraitChoices || '{}'),
					featureChoices: JSON.parse(characterData.selectedFeatureChoices || '{}'),
					skillsJson: characterData.skillsJson || '{}',
					tradesJson: characterData.tradesJson || '{}',
					languagesJson: characterData.languagesJson || '{}',
					lastModified: Date.now()
				};

				const { convertToEnhancedBuildData, calculateCharacterWithBreakdowns } = require('../../lib/services/enhancedCharacterCalculator');
				const enhancedData = convertToEnhancedBuildData(mockBuildData);
				const result = calculateCharacterWithBreakdowns(enhancedData);

				calculatedPD = result.stats.finalPD;
				calculatedAD = result.stats.finalAD;
				calculatedPDR = result.stats.finalPDR;

				// Get breakdowns from enhanced calculator
				pdBreakdown = result.breakdowns?.pd ? 
					result.breakdowns.pd.effects.map(e => `${e.value > 0 ? '+' : ''}${e.value} (${e.source})`).join(' ') + ` = ${calculatedPD}` :
					`8 (base) + ${characterData.finalCombatMastery} (Combat Mastery) + ${characterData.finalAgility} (Agility) + ${characterData.finalIntelligence} (Intelligence) = ${calculatedPD}`;

				adBreakdown = result.breakdowns?.ad ?
					result.breakdowns.ad.effects.map(e => `${e.value > 0 ? '+' : ''}${e.value} (${e.source})`).join(' ') + ` = ${calculatedAD}` :
					`8 (base) + ${characterData.finalCombatMastery} (Combat Mastery) + ${characterData.finalMight} (Might) + ${characterData.finalCharisma} (Charisma) = ${calculatedAD}`;

				pdrBreakdown = calculatedPDR > 0
					? `${calculatedPDR} (from equipped armor and class features)`
					: '0 (no PDR from current equipment/class)';

			} catch (error) {
				console.warn('Enhanced calculator failed, falling back to manual calculation:', error);
				// Fallback to manual calculation
				calculatedPD = 8 + characterData.finalCombatMastery + characterData.finalAgility + characterData.finalIntelligence;
				calculatedAD = 8 + characterData.finalCombatMastery + characterData.finalMight + characterData.finalCharisma;
				calculatedPDR = characterData.finalPDR;

				pdBreakdown = `8 (base) + ${characterData.finalCombatMastery} (Combat Mastery) + ${characterData.finalAgility} (Agility) + ${characterData.finalIntelligence} (Intelligence) = ${calculatedPD}`;
				adBreakdown = `8 (base) + ${characterData.finalCombatMastery} (Combat Mastery) + ${characterData.finalMight} (Might) + ${characterData.finalCharisma} (Charisma) = ${calculatedAD}`;
				pdrBreakdown = calculatedPDR > 0 ? `${calculatedPDR} (from equipped armor and class features)` : '0 (no PDR from current equipment/class)';
			}
		} else {
			// Fallback for non-migrated classes (shouldn't happen now)
			calculatedPD = 8 + characterData.finalCombatMastery + characterData.finalAgility + characterData.finalIntelligence;
			calculatedAD = 8 + characterData.finalCombatMastery + characterData.finalMight + characterData.finalCharisma;
			calculatedPDR = characterData.finalPDR;

			pdBreakdown = `8 (base) + ${characterData.finalCombatMastery} (Combat Mastery) + ${characterData.finalAgility} (Agility) + ${characterData.finalIntelligence} (Intelligence) = ${calculatedPD}`;
			adBreakdown = `8 (base) + ${characterData.finalCombatMastery} (Combat Mastery) + ${characterData.finalMight} (Might) + ${characterData.finalCharisma} (Charisma) = ${calculatedAD}`;
			pdrBreakdown = calculatedPDR > 0 ? `${calculatedPDR} (from equipped armor and class features)` : '0 (no PDR from current equipment/class)';
		}

		return {
			calculatedPD,
			calculatedPDR,
			calculatedAD,
			pdBreakdown,
			adBreakdown,
			pdrBreakdown
		};
	};

	// Resource management functions with auto-save
	const adjustResource = (resource: keyof CurrentValues, amount: number) => {
		setCurrentValues((prev) => {
			const newValue = prev[resource] + amount;
			let maxValue = 999;

			switch (resource) {
				case 'currentHP':
					// HP can go up to normal max + temp HP
					maxValue = (characterData?.finalHPMax || 0) + prev.tempHP;
					break;
				case 'currentSP':
					maxValue = characterData?.finalSPMax || 0;
					break;
				case 'currentMP':
					maxValue = characterData?.finalMPMax || 0;
					break;
				case 'currentGritPoints':
					maxValue = characterData?.finalGritPoints || 0;
					break;
				case 'currentRestPoints':
					maxValue = characterData?.finalRestPoints || 0;
					break;
				case 'actionPointsUsed':
					maxValue = 4; // Standard AP limit
					break;
				case 'exhaustionLevel':
					maxValue = 5; // Max exhaustion level
					break;
			}

			const newValues = {
				...prev,
				[resource]: Math.max(0, Math.min(newValue, maxValue))
			};

			// Special case: when reducing temp HP, cap current HP to new effective max
			if (resource === 'tempHP' && amount < 0) {
				const newEffectiveMaxHP = (characterData?.finalHPMax || 0) + newValues.tempHP;
				if (prev.currentHP > newEffectiveMaxHP) {
					newValues.currentHP = newEffectiveMaxHP;
				}
			}

			// Save to localStorage after state update
			if (characterData?.id) {
				setTimeout(() => saveCharacterData(characterData.id, newValues), 0);
			}

			return newValues;
		});
	};

	const handleResourceInputChange = (resource: keyof CurrentValues, value: string) => {
		const numValue = parseInt(value) || 0;
		let maxValue = 999;

		switch (resource) {
			case 'currentHP':
				// HP can go up to normal max + temp HP
				maxValue = (characterData?.finalHPMax || 0) + currentValues.tempHP;
				break;
			case 'currentSP':
				maxValue = characterData?.finalSPMax || 0;
				break;
			case 'currentMP':
				maxValue = characterData?.finalMPMax || 0;
				break;
			case 'currentGritPoints':
				maxValue = characterData?.finalGritPoints || 0;
				break;
			case 'currentRestPoints':
				maxValue = characterData?.finalRestPoints || 0;
				break;
			case 'actionPointsUsed':
				maxValue = 4;
				break;
			case 'exhaustionLevel':
				maxValue = 5;
				break;
		}

		setCurrentValues((prev) => {
			const newValues = {
				...prev,
				[resource]: Math.max(0, Math.min(numValue, maxValue))
			};

			// Special case: when changing temp HP directly, cap current HP to new effective max
			if (resource === 'tempHP') {
				const newEffectiveMaxHP = (characterData?.finalHPMax || 0) + newValues.tempHP;
				if (prev.currentHP > newEffectiveMaxHP) {
					newValues.currentHP = newEffectiveMaxHP;
				}
			}

			// Save to localStorage after state update
			if (characterData?.id) {
				setTimeout(() => saveCharacterData(characterData.id, newValues), 0);
			}

			return newValues;
		});
	};

	const handleManualDefenseChange = (
		field: 'manualPD' | 'manualPDR' | 'manualAD',
		value: number | undefined
	) => {
		if (!characterData?.id) return;

		// Save to localStorage
		saveManualDefense(characterData.id, field, value);

		// Update local character data
		setCharacterData((prev) => {
			if (!prev) return prev;
			return {
				...prev,
				[field]: value
			};
		});
	};

	// Parse skills data from character - show ALL skills with their proficiency levels and calculated bonuses
	const getSkillsData = (): SkillData[] => {
		// Parse character's skill proficiencies (if any)
		let characterSkills: Record<string, number> = {};
		if (characterData?.skillsJson) {
			try {
				characterSkills = JSON.parse(characterData.skillsJson);
			} catch (error) {
				console.error('Error parsing skills JSON:', error);
			}
		}

		// Create skill data for ALL skills from rules data, merging with character's proficiencies
		return skillsData.map((skill) => {
			const proficiency = characterSkills[skill.id] || 0;
			const masteryBonus = proficiency * 2;
			
			// Get attribute modifier based on skill's attribute association
			let attributeModifier = 0;
			switch (skill.attributeAssociation.toLowerCase()) {
				case 'might':
					attributeModifier = characterData?.finalMight || 0;
					break;
				case 'agility':
					attributeModifier = characterData?.finalAgility || 0;
					break;
				case 'charisma':
					attributeModifier = characterData?.finalCharisma || 0;
					break;
				case 'intelligence':
					attributeModifier = characterData?.finalIntelligence || 0;
					break;
				case 'prime':
					// For prime skills, use the prime modifier value
					attributeModifier = characterData?.finalPrimeModifierValue || 0;
					break;
				default:
					attributeModifier = 0;
			}
			
			const totalBonus = attributeModifier + masteryBonus;
			
			return {
				id: skill.id,
				name: skill.name,
				attribute: skill.attributeAssociation,
				proficiency,
				bonus: totalBonus
			};
		});
	};

	// Parse trades data from character - show ONLY selected trades with their proficiency levels and calculated bonuses
	const getTradesData = (): TradeData[] => {
		// Parse character's trade proficiencies (if any)
		let characterTrades: Record<string, number> = {};
		if (characterData?.tradesJson) {
			try {
				characterTrades = JSON.parse(characterData.tradesJson);
			} catch (error) {
				console.error('Error parsing trades JSON:', error);
			}
		}

		// Only show trades that have been selected (proficiency > 0) from tradesData only
		return tradesData
			.filter((trade) => characterTrades[trade.id] && characterTrades[trade.id] > 0)
			.map((trade) => {
				const proficiency = characterTrades[trade.id] || 0;
				const masteryBonus = proficiency * 2;
				
				// Get attribute modifier based on trade's attribute association
				let attributeModifier = 0;
				switch (trade.attributeAssociation.toLowerCase()) {
					case 'might':
						attributeModifier = characterData?.finalMight || 0;
						break;
					case 'agility':
						attributeModifier = characterData?.finalAgility || 0;
						break;
					case 'charisma':
						attributeModifier = characterData?.finalCharisma || 0;
						break;
					case 'intelligence':
						attributeModifier = characterData?.finalIntelligence || 0;
						break;
					default:
						attributeModifier = 0;
				}
				
				const totalBonus = attributeModifier + masteryBonus;
				
				return {
					id: trade.id,
					name: trade.name,
					proficiency,
					bonus: totalBonus
				};
			});
	};

	// Parse knowledge data from character - show ALL knowledge with their proficiency levels and calculated bonuses
	const getKnowledgeData = (): TradeData[] => {
		// Parse character's trade proficiencies (if any) - knowledge is stored in tradesJson
		let characterTrades: Record<string, number> = {};
		if (characterData?.tradesJson) {
			try {
				characterTrades = JSON.parse(characterData.tradesJson);
			} catch (error) {
				console.error('Error parsing trades JSON:', error);
			}
		}

		// Show ALL knowledge skills with their proficiency levels and calculated bonuses
		return knowledgeData.map((knowledge) => {
			const proficiency = characterTrades[knowledge.id] || 0;
			const masteryBonus = proficiency * 2;
			
			// Get attribute modifier based on knowledge's attribute association
			let attributeModifier = 0;
			switch (knowledge.attributeAssociation.toLowerCase()) {
				case 'might':
					attributeModifier = characterData?.finalMight || 0;
					break;
				case 'agility':
					attributeModifier = characterData?.finalAgility || 0;
					break;
				case 'charisma':
					attributeModifier = characterData?.finalCharisma || 0;
					break;
				case 'intelligence':
					attributeModifier = characterData?.finalIntelligence || 0;
					break;
				default:
					attributeModifier = 0;
			}
			
			const totalBonus = attributeModifier + masteryBonus;
			
			return {
				id: knowledge.id,
				name: knowledge.name,
				proficiency,
				bonus: totalBonus
			};
		});
	};

	// Parse languages data from character
	const getLanguagesData = (): LanguageData[] => {
		if (!characterData?.languagesJson) {
			return [];
		}

		try {
			const languagesFromDB = JSON.parse(characterData.languagesJson);

			return Object.entries(languagesFromDB)
				.filter(([_, data]: [string, any]) => data.fluency !== 'none')
				.map(([langId, data]: [string, any]) => ({
					id: langId,
					name: data.name || langId.charAt(0).toUpperCase() + langId.slice(1),
					fluency: data.fluency as 'limited' | 'fluent'
				}));
		} catch (error) {
			console.error('Error parsing languages JSON:', error);
			return [];
		}
	};

	// Get class-specific display information generically
	const getClassDisplayInfo = (): { label: string; value: string }[] => {
		if (!characterData?.className || !characterData?.selectedFeatureChoices) {
			return [];
		}

		const { displayInfo } = getClassSpecificInfo(
			characterData.className,
			characterData.selectedFeatureChoices
		);
		return displayInfo;
	};

	// Get all features (traits and class features) for the character
	const getFeaturesData = (): FeatureData[] => {
		if (!characterData) return [];

		const features: FeatureData[] = [];

		// Get ancestry default traits
		const ancestry1 = ancestriesData.find((a) => a.name === characterData.ancestry1Name);
		if (ancestry1) {
			ancestry1.defaultTraitIds?.forEach((traitId) => {
				const trait = traitsData.find((t) => t.id === traitId);
				if (trait) {
					features.push({
						id: trait.id,
						name: trait.name,
						description: trait.description,
						source: 'ancestry',
						sourceDetail: `${ancestry1.name} (Default)`
					});
				}
			});
		}

		// Get selected ancestry traits
		if (characterData.selectedTraitIds) {
			try {
				const selectedTraitIds: string[] = JSON.parse(characterData.selectedTraitIds);
				selectedTraitIds.forEach((traitId) => {
					const trait = traitsData.find((t) => t.id === traitId);
					if (trait) {
						// Check if this trait is not already added as default
						const alreadyAdded = features.some((f) => f.id === trait.id);
						if (!alreadyAdded) {
							const sourceAncestry = ancestriesData.find(
								(a) => a.expandedTraitIds.includes(traitId) || a.defaultTraitIds?.includes(traitId)
							);
							features.push({
								id: trait.id,
								name: trait.name,
								description: trait.description,
								source: 'ancestry',
								sourceDetail: `${sourceAncestry?.name || 'Unknown'} (Selected)`
							});
						}
					}
				});
			} catch (error) {
				console.error('Error parsing selected traits JSON:', error);
			}
		}

		// Get class features from the new class features structure
		const selectedClassFeatures = findClassByName(characterData.className);

		if (selectedClassFeatures) {
			// Add level 1 core features
			selectedClassFeatures.coreFeatures
				.filter((feature) => feature.levelGained === 1)
				.forEach((feature) => {
					features.push({
						id: feature.featureName,
						name: feature.featureName,
						description: feature.description,
						source: 'class',
						sourceDetail: `${selectedClassFeatures.className} (Lvl 1)`
					});
				});

			// Add selected feature choices
			if (characterData.selectedFeatureChoices) {
				try {
					const selectedChoices: { [key: string]: string } = JSON.parse(
						characterData.selectedFeatureChoices
					);

					// Process each core feature that has choices
					selectedClassFeatures.coreFeatures.forEach((feature) => {
						if (feature.choices) {
							feature.choices.forEach((choice, choiceIndex) => {
								// Use the same mapping logic as the class-features loader
								const choiceId = getLegacyChoiceId(
									selectedClassFeatures.className,
									feature.featureName,
									choiceIndex
								);
								const selectedOptionValues = selectedChoices[choiceId];

								if (selectedOptionValues && choice.options) {
									if (choice.count > 1) {
										// Handle multiple selections (like cleric domains)
										const selectedValueArray: string[] = JSON.parse(selectedOptionValues);

										selectedValueArray.forEach((value) => {
											const selectedOption = choice.options?.find((opt) => opt.name === value);

											if (selectedOption) {
												// Get the detailed description
												let description = selectedOption.description || 'Feature choice selected.';
												const detailedDescription = getDetailedClassFeatureDescription(
													choiceId,
													value
												);
												if (detailedDescription) {
													description = detailedDescription;
												}

												// Use generic display label
												const displayLabel = getDisplayLabel(
													selectedClassFeatures.className,
													feature.featureName,
													choiceIndex
												);
												const sourceDetail = `${selectedClassFeatures.className} (${displayLabel})`;

												const featureToAdd = {
													id: `${choiceId}_${value}`,
													name: selectedOption.name,
													description: description,
													source: 'choice' as const,
													sourceDetail: sourceDetail
												};
												features.push(featureToAdd);
											}
										});
									} else {
										// Handle single selections
										const selectedOption = choice.options?.find(
											(opt) => opt.name === selectedOptionValues
										);
										if (selectedOption) {
											// Get the detailed description
											let description = selectedOption.description || 'Feature choice selected.';
											const detailedDescription = getDetailedClassFeatureDescription(
												choiceId,
												selectedOptionValues
											);
											if (detailedDescription) {
												description = detailedDescription;
											}

											// Use generic display label
											const displayLabel = getDisplayLabel(
												selectedClassFeatures.className,
												feature.featureName,
												choiceIndex
											);
											const sourceDetail = `${selectedClassFeatures.className} (${displayLabel})`;

											features.push({
												id: `${choiceId}_${selectedOptionValues}`,
												name: selectedOption.name,
												description: description,
												source: 'choice',
												sourceDetail: sourceDetail
											});
										}
									}
								}
							});
						}
					});
				} catch (error) {
					console.error('Error parsing selected feature choices JSON:', error);
				}
			}
		}

		return features;
	};

	// Handle feature popup
	const openFeaturePopup = (feature: FeatureData) => {
		setSelectedFeature(feature);
	};

	const closeFeaturePopup = () => {
		setSelectedFeature(null);
	};

	// Handle spell popup
	const openSpellPopup = (spell: Spell) => {
		setSelectedSpell(spell);
	};

	const closeSpellPopup = () => {
		setSelectedSpell(null);
	};

	// Handle attack popup
	const openAttackPopup = (attack: AttackData, weapon: Weapon | null) => {
		setSelectedAttack({ attack, weapon });
	};

	const closeAttackPopup = () => {
		setSelectedAttack(null);
	};

	// Handle inventory popup
	const openInventoryPopup = (inventoryData: InventoryItemData, item: InventoryItem | null) => {
		setSelectedInventoryItem({ inventoryData, item });
	};

	const closeInventoryPopup = () => {
		setSelectedInventoryItem(null);
	};

	// Currency management function
	const handleCurrencyChange = (currency: string, value: number) => {
		setCurrentValues((prev) => {
			const newValues = {
				...prev,
				[currency]: value
			};

			// Save to localStorage after state update
			if (characterData?.id) {
				setTimeout(() => saveCharacterData(characterData.id, newValues), 0);
			}

			return newValues;
		});
	};

	// Handle exhaustion level changes
	const handleExhaustionChange = (level: number) => {
		setCurrentValues((prev) => {
			const newLevel = prev.exhaustionLevel === level ? level - 1 : level;
			const newValues = {
				...prev,
				exhaustionLevel: Math.max(0, Math.min(5, newLevel))
			};

			// Save to localStorage after state update
			if (characterData?.id) {
				setTimeout(() => saveCharacterData(characterData.id, newValues), 0);
			}

			return newValues;
		});
	};

	// Handle death step changes
	const handleDeathStepChange = (step: number) => {
		if (!characterData) return;

		const deathThreshold = calculateDeathThreshold(
			characterData.finalPrimeModifierValue,
			characterData.finalCombatMastery
		);
		const targetHP = -step;

		// Don't allow going below death threshold
		if (targetHP < deathThreshold) {
			setCurrentValues((prev) => {
				const newValues = { ...prev, currentHP: deathThreshold };
				// Save to localStorage after state update
				if (characterData?.id) {
					setTimeout(() => saveCharacterData(characterData.id, newValues), 0);
				}
				return newValues;
			});
		} else {
			setCurrentValues((prev) => {
				const newValues = { ...prev, currentHP: targetHP };
				// Save to localStorage after state update
				if (characterData?.id) {
					setTimeout(() => saveCharacterData(characterData.id, newValues), 0);
				}
				return newValues;
			});
		}
	};

	// Helper function to safely calculate fill percentage
	const getFillPercentage = (current: number, max: number): number => {
		if (max === 0) return 0;
		return Math.max(0, Math.min(100, (current / max) * 100));
	};

	// Copy character data to clipboard
	// Revert character data to original values
	const handleRevertToOriginal = (
		dataType: 'resources' | 'currency' | 'attacks' | 'spells' | 'inventory' | 'all'
	) => {
		if (dataType === 'all') {
			// Revert all data types
			revertToOriginal(characterId, 'resources');
			revertToOriginal(characterId, 'currency');
			revertToOriginal(characterId, 'attacks');
			revertToOriginal(characterId, 'spells');
			revertToOriginal(characterId, 'inventory');

			// Also clear all manual defense overrides (PDR, PD, AD)
			clearDefenseNotesForField(characterId, 'manualPD');
			clearDefenseNotesForField(characterId, 'manualPDR');
			clearDefenseNotesForField(characterId, 'manualAD');

			// Clear the manual defense values in localStorage
			saveManualDefense(characterId, 'manualPD', undefined);
			saveManualDefense(characterId, 'manualPDR', undefined);
			saveManualDefense(characterId, 'manualAD', undefined);

			// Reload the page to reflect changes
			window.location.reload();
		} else {
			revertToOriginal(characterId, dataType);

			// Update local state based on what was reverted
			if (dataType === 'resources') {
				setCurrentValues((prev) => ({
					...prev,
					currentHP: characterData?.finalHPMax || 0,
					currentSP: characterData?.finalSPMax || 0,
					currentMP: characterData?.finalMPMax || 0,
					currentGritPoints: characterData?.finalGritPoints || 0,
					currentRestPoints: characterData?.finalRestPoints || 0,
					tempHP: 0,
					actionPointsUsed: 0,
					exhaustionLevel: 0
				}));
			} else if (dataType === 'currency') {
				setCurrentValues((prev) => ({
					...prev,
					goldPieces: 0,
					silverPieces: 0,
					copperPieces: 0,
					electrumPieces: 0,
					platinumPieces: 0
				}));
			} else if (dataType === 'attacks') {
				// Reset to default attacks
				const defaultAttacks: AttackData[] = [
					{
						id: '1',
						weaponId: '',
						name: '',
						attackBonus: 0,
						damage: '',
						damageType: '',
						critRange: '',
						critDamage: '',
						brutalDamage: '',
						heavyHitEffect: ''
					},
					{
						id: '2',
						weaponId: '',
						name: '',
						attackBonus: 0,
						damage: '',
						damageType: '',
						critRange: '',
						critDamage: '',
						brutalDamage: '',
						heavyHitEffect: ''
					},
					{
						id: '3',
						weaponId: '',
						name: '',
						attackBonus: 0,
						damage: '',
						damageType: '',
						critRange: '',
						critDamage: '',
						brutalDamage: '',
						heavyHitEffect: ''
					}
				];
				setAttacks(defaultAttacks);
			} else if (dataType === 'spells') {
				setSpells([]);
			} else if (dataType === 'inventory') {
				setInventory([]);
			}
		}
	};

	const copyCharacterToClipboard = async () => {
		try {
			if (!characterData) {
				alert('Character data not found');
				return;
			}

			const character = getCharacterFromStorage(characterData.id);
			if (!character) {
				alert('Character data not found in storage');
				return;
			}

			const characterBackup = {
				...character,
				exportedAt: new Date().toISOString(),
				exportVersion: '1.0'
			};

			const jsonString = JSON.stringify(characterBackup, null, 2);
			await navigator.clipboard.writeText(jsonString);

			// Show success message
			alert('Character data copied to clipboard! You can save this as a backup.');
		} catch (error) {
			console.error('Failed to copy character data:', error);
			alert('Failed to copy character data to clipboard');
		}
	};

	// Helper function to get character from localStorage
	const getCharacterFromStorage = (characterId: string) => {
		const savedCharacters = JSON.parse(localStorage.getItem('savedCharacters') || '[]');
		return savedCharacters.find((char: any) => char.id === characterId);
	};

	// Helper function for HP fill percentage (shows current HP vs total effective HP)
	const getHPFillPercentage = (currentHP: number, maxHP: number, tempHP: number): number => {
		const totalEffectiveHP = maxHP + tempHP;
		if (totalEffectiveHP === 0) return 0;
		return Math.max(0, (currentHP / totalEffectiveHP) * 100);
	};

	// Group skills by attribute like in the official sheet
	const getSkillsByAttribute = () => {
		const skills = getSkillsData();
		return {
			might: skills.filter((skill) => skill.attribute === 'might'),
			agility: skills.filter((skill) => skill.attribute === 'agility'),
			charisma: skills.filter((skill) => skill.attribute === 'charisma'),
			intelligence: skills.filter((skill) => skill.attribute === 'intelligence'),
			prime: skills.filter((skill) => skill.attribute === 'prime')
		};
	};

	// Get data from character or empty defaults if no character data
	const trades = characterData ? getTradesData() : [];
	const knowledge = characterData ? getKnowledgeData() : [];
	const languages = characterData ? getLanguagesData() : [];
	const features = characterData ? getFeaturesData() : [];
	const skillsByAttribute = characterData
		? getSkillsByAttribute()
		: { might: [], agility: [], charisma: [], intelligence: [], prime: [] };

	if (loading) {
		return (
			<StyledContainer>
				<div style={{ textAlign: 'center', padding: '4rem' }}>
					<h2>Loading character sheet...</h2>
				</div>
			</StyledContainer>
		);
	}

	if (error || !characterData) {
		return (
			<StyledContainer>
				<div style={{ textAlign: 'center', padding: '4rem' }}>
					<h2>Error loading character sheet</h2>
					<p>{error}</p>
					<StyledBackButton onClick={onBack}>← Back</StyledBackButton>
				</div>
			</StyledContainer>
		);
	}

	return (
		<StyledContainer style={{ position: 'relative' }}>
			{/* Action Buttons - Hidden on mobile */}
			<StyledActionButtons>
				<StyledActionButton
					$variant="danger"
					onClick={() => handleRevertToOriginal('all')}
					title="Revert all modifications back to calculated defaults"
				>
					🔄 Revert All
				</StyledActionButton>
				<StyledActionButton
					onClick={copyCharacterToClipboard}
					title="Copy character data to clipboard for backup"
				>
					📋 Copy to Clipboard
				</StyledActionButton>
			</StyledActionButtons>

			<StyledBackButton onClick={onBack}>← Back to Menu</StyledBackButton>

			<StyledCharacterSheet>
				{/* Header Section */}
				<StyledHeader>
					<StyledHeaderSection>
						<StyledLabel>Player Name</StyledLabel>
						<StyledValue>{characterData.finalPlayerName || 'Unknown'}</StyledValue>
						<StyledLabel style={{ marginTop: '0.5rem' }}>Character Name</StyledLabel>
						<StyledValue>{characterData.finalName}</StyledValue>
					</StyledHeaderSection>

					<StyledHeaderSection>
						<StyledLabel>Class & Subclass</StyledLabel>
						<StyledValue>{characterData.className}</StyledValue>
						{(() => {
							const classDisplayInfo = getClassDisplayInfo();
							return classDisplayInfo.map((info, index) => (
								<div key={index}>
									<StyledLabel style={{ marginTop: '0.25rem', fontSize: '0.8rem' }}>
										{info.label}
									</StyledLabel>
									<StyledValue style={{ fontSize: '0.9rem' }}>{info.value}</StyledValue>
								</div>
							));
						})()}
						<StyledLabel style={{ marginTop: '0.5rem' }}>Ancestry & Background</StyledLabel>
						<StyledValue>{characterData.ancestry1Name || 'Unknown'}</StyledValue>
					</StyledHeaderSection>

					<StyledHeaderSection>
						<StyledLabel>Level</StyledLabel>
						<StyledValue>{characterData.finalLevel}</StyledValue>
						<StyledLabel style={{ marginTop: '0.5rem' }}>Combat Mastery</StyledLabel>
						<StyledValue>+{characterData.finalCombatMastery}</StyledValue>
					</StyledHeaderSection>

					<div style={{ textAlign: 'center', alignSelf: 'center' }}>
						<div style={{ fontSize: '2rem', fontWeight: 'bold', color: '#8b4513' }}>DC20</div>
					</div>
				</StyledHeader>

				{/* Mobile Navigation - Only show on mobile */}
				{isMobile && (
					<StyledMobileNav>
						<StyledMobileNavButton
							$isActive={activeMobileSection === 'character'}
							onClick={() => setActiveMobileSection('character')}
						>
							🎯 Skills
						</StyledMobileNavButton>
						<StyledMobileNavButton
							$isActive={activeMobileSection === 'combat'}
							onClick={() => setActiveMobileSection('combat')}
						>
							⚔️ Combat
						</StyledMobileNavButton>
						<StyledMobileNavButton
							$isActive={activeMobileSection === 'features'}
							onClick={() => setActiveMobileSection('features')}
						>
							🎒 Items
						</StyledMobileNavButton>
						<StyledMobileNavButton
							$isActive={activeMobileSection === 'info'}
							onClick={() => setActiveMobileSection('info')}
						>
							ℹ️ Info
						</StyledMobileNavButton>
					</StyledMobileNav>
				)}

				{/* Desktop Layout - Only show on desktop */}
				{!isMobile && (
					<StyledMainGrid>
						{/* Left Column - Attributes with Skills */}
						<StyledLeftColumn>
							<LeftColumn
								characterData={characterData}
								skillsByAttribute={skillsByAttribute}
								knowledge={knowledge}
								trades={trades}
								languages={languages}
							/>
						</StyledLeftColumn>

						{/* Middle Column - Resources, Combat, and Core Stats */}
						<StyledMiddleColumn>
							{/* Resources Section - Circular design like official sheet */}
							<Resources
								characterData={characterData}
								currentValues={currentValues}
								onAdjustResource={adjustResource}
								onResourceInputChange={handleResourceInputChange}
								getFillPercentage={getFillPercentage}
								getHPFillPercentage={getHPFillPercentage}
								isMobile={false}
							/>

							{/* Defenses - Shield-like design */}
							<Defenses
								characterData={{
									...characterData,
									manualPD: characterData?.manualPD,
									manualPDR: characterData?.manualPDR,
									manualAD: characterData?.manualAD
								}}
								calculatedDefenses={getCalculatedDefenses()}
								onUpdateManualDefense={handleManualDefenseChange}
								isMobile={false}
							/>

							{/* Combat Section */}
							<Combat
								characterData={characterData}
								currentValues={currentValues}
								setCurrentValues={setCurrentValues}
							/>

							{/* Death & Exhaustion */}
							<DeathExhaustion
								characterData={characterData}
								currentValues={currentValues}
								onExhaustionChange={handleExhaustionChange}
								onDeathStepChange={handleDeathStepChange}
							/>

							{/* Spells Section */}
							<Spells
								spells={spells}
								setSpells={updateSpells}
								characterData={characterData}
								onSpellClick={openSpellPopup}
							/>

							{/* Attacks Section */}
							<Attacks
								attacks={attacks}
								setAttacks={updateAttacks}
								characterData={characterData}
								onAttackClick={openAttackPopup}
							/>

							{/* Inventory */}
							<Inventory
								inventory={inventory}
								setInventory={updateInventory}
								onItemClick={openInventoryPopup}
							/>

							{/* Player Notes */}
							<PlayerNotes characterId={characterData.id} />
						</StyledMiddleColumn>

						{/* Right Column - Movement, Resources, Inventory, Features */}
						<StyledRightColumn>
							{/* Movement & Utility */}
							<Movement characterData={characterData} />

							{/* Resources */}
							<RightColumnResources
								characterData={characterData}
								currentValues={currentValues}
								onResourceInputChange={handleResourceInputChange}
							/>

							{/* Features */}
							<Features features={features} onFeatureClick={openFeaturePopup} />

							{/* Currency Section */}
							<Currency currentValues={currentValues} onCurrencyChange={handleCurrencyChange} />
						</StyledRightColumn>
					</StyledMainGrid>
				)}

				{/* Mobile Layout - Only show on mobile */}
				{isMobile && (
					<div>
						{/* Skills Tab - Mobile */}
						{activeMobileSection === 'character' && (
							<div>
								<LeftColumn
									characterData={characterData}
									skillsByAttribute={skillsByAttribute}
									knowledge={knowledge}
									trades={trades}
									languages={languages}
								/>
								<Features features={features} onFeatureClick={openFeaturePopup} />
							</div>
						)}

						{/* Combat Tab - Mobile */}
						{activeMobileSection === 'combat' && (
							<div>
								<Resources
									characterData={characterData}
									currentValues={currentValues}
									onAdjustResource={adjustResource}
									onResourceInputChange={handleResourceInputChange}
									getFillPercentage={getFillPercentage}
									getHPFillPercentage={getHPFillPercentage}
									isMobile={true}
								/>
								<Defenses
									characterData={{
										...characterData,
										manualPD: characterData?.manualPD,
										manualPDR: characterData?.manualPDR,
										manualAD: characterData?.manualAD
									}}
									calculatedDefenses={getCalculatedDefenses()}
									onUpdateManualDefense={handleManualDefenseChange}
									isMobile={true}
								/>
								<Combat
									characterData={characterData}
									currentValues={currentValues}
									setCurrentValues={setCurrentValues}
								/>
								<DeathExhaustion
									characterData={characterData}
									currentValues={currentValues}
									onExhaustionChange={handleExhaustionChange}
									onDeathStepChange={handleDeathStepChange}
								/>
								<Attacks
									attacks={attacks}
									setAttacks={updateAttacks}
									characterData={characterData}
									onAttackClick={openAttackPopup}
								/>
								<Movement characterData={characterData} />
								<RightColumnResources
									characterData={characterData}
									currentValues={currentValues}
									onResourceInputChange={handleResourceInputChange}
								/>
							</div>
						)}

						{/* Items Tab - Mobile */}
						{activeMobileSection === 'features' && (
							<div>
								<Inventory
									inventory={inventory}
									setInventory={updateInventory}
									onItemClick={openInventoryPopup}
								/>
								<Currency currentValues={currentValues} onCurrencyChange={handleCurrencyChange} />
							</div>
						)}

						{/* Info Tab - Mobile */}
						{activeMobileSection === 'info' && (
							<div>
								<div
									style={{
										border: '2px solid #8b4513',
										borderRadius: '8px',
										padding: '1rem',
										background: 'white',
										marginBottom: '1rem'
									}}
								>
									<h3
										style={{
											color: '#8b4513',
											marginTop: '0',
											marginBottom: '1rem',
											textAlign: 'center',
											fontSize: '1.2rem'
										}}
									>
										Character Information
									</h3>

									<div style={{ marginBottom: '1rem' }}>
										<StyledLabel>Player Name</StyledLabel>
										<StyledValue>{characterData.finalPlayerName || 'Unknown'}</StyledValue>
									</div>

									<div style={{ marginBottom: '1rem' }}>
										<StyledLabel>Character Name</StyledLabel>
										<StyledValue>{characterData.finalName}</StyledValue>
									</div>

									<div style={{ marginBottom: '1rem' }}>
										<StyledLabel>Class & Subclass</StyledLabel>
										<StyledValue>{characterData.className}</StyledValue>
										{(() => {
											const classDisplayInfo = getClassDisplayInfo();
											return classDisplayInfo.map((info, index) => (
												<div key={index}>
													<StyledLabel style={{ marginTop: '0.25rem', fontSize: '0.8rem' }}>
														{info.label}
													</StyledLabel>
													<StyledValue style={{ fontSize: '0.9rem' }}>{info.value}</StyledValue>
												</div>
											));
										})()}
									</div>

									<div style={{ marginBottom: '1rem' }}>
										<StyledLabel>Ancestry & Background</StyledLabel>
										<StyledValue>{characterData.ancestry1Name || 'Unknown'}</StyledValue>
									</div>

									<div style={{ marginBottom: '1rem' }}>
										<StyledLabel>Level</StyledLabel>
										<StyledValue>{characterData.finalLevel}</StyledValue>
									</div>

									<div style={{ marginBottom: '1rem' }}>
										<StyledLabel>Combat Mastery</StyledLabel>
										<StyledValue>+{characterData.finalCombatMastery}</StyledValue>
									</div>

									<div style={{ textAlign: 'center', marginTop: '1.5rem' }}>
										<div style={{ fontSize: '2rem', fontWeight: 'bold', color: '#8b4513' }}>
											DC20
										</div>
									</div>
								</div>
								<PlayerNotes characterId={characterData.id} />
							</div>
						)}
					</div>
				)}
			</StyledCharacterSheet>

			{/* Feature Popup */}
			{selectedFeature && (
				<StyledFeaturePopupOverlay onClick={closeFeaturePopup}>
					<StyledFeaturePopupContent onClick={(e) => e.stopPropagation()}>
						<StyledFeaturePopupHeader>
							<StyledFeaturePopupTitle>{selectedFeature.name}</StyledFeaturePopupTitle>
							<StyledFeaturePopupClose onClick={closeFeaturePopup}>×</StyledFeaturePopupClose>
						</StyledFeaturePopupHeader>
						<StyledFeaturePopupDescription>
							{selectedFeature.description}
						</StyledFeaturePopupDescription>
						{selectedFeature.sourceDetail && (
							<StyledFeaturePopupSourceInfo>
								Source: {selectedFeature.sourceDetail}
							</StyledFeaturePopupSourceInfo>
						)}
					</StyledFeaturePopupContent>
				</StyledFeaturePopupOverlay>
			)}

			{/* Spell Popup Modal */}
			{selectedSpell && (
				<StyledFeaturePopupOverlay onClick={closeSpellPopup}>
					<StyledFeaturePopupContent onClick={(e) => e.stopPropagation()}>
						<StyledFeaturePopupHeader>
							<StyledFeaturePopupTitle>{selectedSpell.name}</StyledFeaturePopupTitle>
							<StyledFeaturePopupClose onClick={closeSpellPopup}>×</StyledFeaturePopupClose>
						</StyledFeaturePopupHeader>
						<StyledFeaturePopupDescription>
							<strong>School:</strong> {selectedSpell.school}
							<br />
							<strong>AP Cost:</strong> {selectedSpell.cost.ap}
							<br />
							{selectedSpell.cost.mp && (
								<>
									<strong>MP Cost:</strong> {selectedSpell.cost.mp}
									<br />
								</>
							)}
							<strong>Range:</strong> {selectedSpell.range}
							<br />
							<strong>Duration:</strong> {selectedSpell.duration}
							<br />
							{selectedSpell.isCantrip && (
								<>
									<strong>Type:</strong> Cantrip
									<br />
								</>
							)}
							{selectedSpell.isRitual && (
								<>
									<strong>Ritual:</strong> Yes
									<br />
								</>
							)}
							<br />
							{selectedSpell.effects?.[0]?.description || 'No description available.'}
							{selectedSpell.cantripPassive && (
								<>
									<br />
									<br />
									<strong>Cantrip Passive:</strong> {selectedSpell.cantripPassive}
								</>
							)}
						</StyledFeaturePopupDescription>
						{selectedSpell.enhancements?.length > 0 && (
							<StyledFeaturePopupSourceInfo>
								Enhancements Available: {selectedSpell.enhancements.length}
							</StyledFeaturePopupSourceInfo>
						)}
					</StyledFeaturePopupContent>
				</StyledFeaturePopupOverlay>
			)}

			{/* Attack Popup Modal */}
			{selectedAttack && (
				<StyledFeaturePopupOverlay onClick={closeAttackPopup}>
					<StyledFeaturePopupContent onClick={(e) => e.stopPropagation()}>
						<StyledFeaturePopupHeader>
							<StyledFeaturePopupTitle>
								{selectedAttack.weapon?.name || selectedAttack.attack.name || 'Unknown Weapon'}
							</StyledFeaturePopupTitle>
							<StyledFeaturePopupClose onClick={closeAttackPopup}>×</StyledFeaturePopupClose>
						</StyledFeaturePopupHeader>
						<StyledFeaturePopupDescription>
							{selectedAttack.weapon ? (
								<>
									<strong>Weapon Type:</strong> {selectedAttack.weapon.type}
									<br />
									<strong>Handedness:</strong> {selectedAttack.weapon.handedness}
									<br />
									<strong>Style:</strong>{' '}
									{Array.isArray(selectedAttack.weapon.style)
										? selectedAttack.weapon.style.join('/')
										: selectedAttack.weapon.style}
									<br />
									<strong>Damage:</strong> {selectedAttack.weapon.damage}
									<br />
									{getVersatileDamage(selectedAttack.weapon) && (
										<>
											<strong>Versatile Damage:</strong>{' '}
											{getVersatileDamage(selectedAttack.weapon)?.twoHanded}
											<br />
										</>
									)}
									<strong>Damage Type:</strong>{' '}
									{parseDamage(selectedAttack.weapon.damage).typeDisplay}
									<br />
									{getWeaponRange(selectedAttack.weapon) && (
										<>
											<strong>Range:</strong> {getWeaponRange(selectedAttack.weapon)?.short}/
											{getWeaponRange(selectedAttack.weapon)?.long}
											<br />
										</>
									)}
									{selectedAttack.weapon.properties.includes('Ammo') && (
										<>
											<strong>Ammunition:</strong> Required
											<br />
										</>
									)}
									{selectedAttack.weapon.properties.includes('Reload') && (
										<>
											<strong>Reload:</strong> Required
											<br />
										</>
									)}
									<br />
									<strong>Damage Calculations:</strong>
									<br />• <strong>Hit:</strong> {selectedAttack.weapon.damage} + ability modifier
									<br />• <strong>Heavy Hit (+5):</strong> {selectedAttack.weapon.damage} + 1 +
									ability modifier
									<br />• <strong>Brutal Hit (+10):</strong> {selectedAttack.weapon.damage} + 2 +
									ability modifier
									<br />
									<br />
									{selectedAttack.weapon.properties.length > 0 && (
										<>
											<strong>Properties:</strong> {selectedAttack.weapon.properties.join(', ')}
											<br />
										</>
									)}
									{getWeaponFeatures(selectedAttack.weapon).length > 0 && (
										<>
											<strong>Features:</strong>{' '}
											{getWeaponFeatures(selectedAttack.weapon).join(', ')}
										</>
									)}
								</>
							) : (
								<>
									<strong>Custom Attack</strong>
									<br />
									<strong>Attack Bonus:</strong> +{selectedAttack.attack.attackBonus}
									<br />
									<strong>Damage:</strong> {selectedAttack.attack.damage}
									<br />
									<strong>Damage Type:</strong> {selectedAttack.attack.damageType}
									<br />
									{selectedAttack.attack.critRange && (
										<>
											<strong>Crit Range:</strong> {selectedAttack.attack.critRange}
											<br />
										</>
									)}
									{selectedAttack.attack.critDamage && (
										<>
											<strong>Crit Damage:</strong> {selectedAttack.attack.critDamage}
											<br />
										</>
									)}
									{selectedAttack.attack.brutalDamage && (
										<>
											<strong>Brutal Damage:</strong> {selectedAttack.attack.brutalDamage}
											<br />
										</>
									)}
									{selectedAttack.attack.heavyHitEffect && (
										<>
											<strong>Heavy Hit Effect:</strong> {selectedAttack.attack.heavyHitEffect}
										</>
									)}
								</>
							)}
						</StyledFeaturePopupDescription>
					</StyledFeaturePopupContent>
				</StyledFeaturePopupOverlay>
			)}

			{/* Inventory Popup Modal */}
			{selectedInventoryItem && (
				<StyledFeaturePopupOverlay onClick={closeInventoryPopup}>
					<StyledFeaturePopupContent onClick={(e) => e.stopPropagation()}>
						<StyledFeaturePopupHeader>
							<StyledFeaturePopupTitle>
								{selectedInventoryItem.item?.name ||
									selectedInventoryItem.inventoryData.itemName ||
									'Unknown Item'}
							</StyledFeaturePopupTitle>
							<StyledFeaturePopupClose onClick={closeInventoryPopup}>×</StyledFeaturePopupClose>
						</StyledFeaturePopupHeader>
						<StyledFeaturePopupDescription>
							{selectedInventoryItem.item ? (
								<>
									<strong>Type:</strong> {selectedInventoryItem.item.itemType}
									<br />
									{selectedInventoryItem.item.itemType === 'Weapon' && (
										<>
											<strong>Weapon Type:</strong> {(selectedInventoryItem.item as any).type}
											<br />
											<strong>Style:</strong> {(selectedInventoryItem.item as any).style}
											<br />
											<strong>Handedness:</strong> {(selectedInventoryItem.item as any).handedness}
											<br />
											<strong>Damage:</strong> {(selectedInventoryItem.item as any).damage}
											<br />
											{(selectedInventoryItem.item as any).properties && (
												<>
													<strong>Properties:</strong>{' '}
													{(selectedInventoryItem.item as any).properties.join(', ')}
													<br />
												</>
											)}
											{(selectedInventoryItem.item as any).price && (
												<>
													<strong>Price:</strong> {(selectedInventoryItem.item as any).price}
													<br />
												</>
											)}
										</>
									)}
									{selectedInventoryItem.item.itemType === 'Armor' && (
										<>
											<strong>Type:</strong> {(selectedInventoryItem.item as any).type}
											<br />
											<strong>PDR:</strong> {(selectedInventoryItem.item as any).pdr}
											<br />
											<strong>AD Modifier:</strong> {(selectedInventoryItem.item as any).adModifier}
											<br />
											{(selectedInventoryItem.item as any).agilityCap && (
												<>
													<strong>Agility Cap:</strong>{' '}
													{(selectedInventoryItem.item as any).agilityCap}
													<br />
												</>
											)}
											{(selectedInventoryItem.item as any).price && (
												<>
													<strong>Price:</strong> {(selectedInventoryItem.item as any).price}
													<br />
												</>
											)}
										</>
									)}
									{selectedInventoryItem.item.itemType === 'Shield' && (
										<>
											<strong>PDR:</strong> {(selectedInventoryItem.item as any).pdr}
											<br />
											<strong>AD Modifier:</strong> {(selectedInventoryItem.item as any).adModifier}
											<br />
											{(selectedInventoryItem.item as any).price && (
												<>
													<strong>Price:</strong> {(selectedInventoryItem.item as any).price}
													<br />
												</>
											)}
										</>
									)}
									{selectedInventoryItem.item.itemType === 'Potion' && (
										<>
											<strong>Level:</strong> {(selectedInventoryItem.item as any).level}
											<br />
											<strong>Healing:</strong> {(selectedInventoryItem.item as any).healing}
											<br />
											<strong>Price:</strong> {(selectedInventoryItem.item as any).price}g<br />
										</>
									)}
									{selectedInventoryItem.item.itemType === 'Adventuring Supply' && (
										<>
											{(selectedInventoryItem.item as any).description && (
												<>
													<strong>Description:</strong>{' '}
													{(selectedInventoryItem.item as any).description}
													<br />
												</>
											)}
											{(selectedInventoryItem.item as any).price && (
												<>
													<strong>Price:</strong> {(selectedInventoryItem.item as any).price}
													<br />
												</>
											)}
										</>
									)}
									<br />
									<strong>Count:</strong> {selectedInventoryItem.inventoryData.count}
									<br />
									{selectedInventoryItem.inventoryData.cost && (
										<>
											<strong>Cost:</strong> {selectedInventoryItem.inventoryData.cost}
										</>
									)}
								</>
							) : (
								<>
									<strong>Custom Item</strong>
									<br />
									<strong>Type:</strong> {selectedInventoryItem.inventoryData.itemType}
									<br />
									<strong>Count:</strong> {selectedInventoryItem.inventoryData.count}
									<br />
									{selectedInventoryItem.inventoryData.cost && (
										<>
											<strong>Cost:</strong> {selectedInventoryItem.inventoryData.cost}
										</>
									)}
								</>
							)}
						</StyledFeaturePopupDescription>
					</StyledFeaturePopupContent>
				</StyledFeaturePopupOverlay>
			)}

			{/* Draconic Dice Roller */}
			<DiceRoller 
				onRoll={(results, total, rollMode) => {
					console.log('Dice rolled:', { results, total, rollMode });
				}}
			/>
		</StyledContainer>
	);
};

export default CharacterSheet;
````
