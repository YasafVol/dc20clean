/**
 * Convex Character CRUD Mutations and Queries
 *
 * DRAFT FILE - Rename to characters.ts after running `npx convex dev`
 *
 * These functions handle all character persistence operations.
 */

import { v } from 'convex/values';
import { mutation, query } from './_generated/server';
import { getAuthUserId } from '@convex-dev/auth/server';

// ============================================================================
// QUERIES
// ============================================================================

/**
 * List all characters for the authenticated user
 */
export const list = query({
	args: {},
	handler: async (ctx) => {
		const userId = await getAuthUserId(ctx);
		if (!userId) {
			return [];
		}

		const characters = await ctx.db
			.query('characters')
			.withIndex('by_user', (q) => q.eq('userId', userId))
			.collect();

		return characters;
	},
});

/**
 * Get a single character by ID (must belong to authenticated user)
 */
export const getById = query({
	args: { characterId: v.id('characters') },
	handler: async (ctx, args) => {
		const userId = await getAuthUserId(ctx);
		if (!userId) {
			return null;
		}

		const character = await ctx.db.get(args.characterId);

		// Verify ownership
		if (!character || character.userId !== userId) {
			return null;
		}

		return character;
	},
});

/**
 * Get a character by name (for the authenticated user)
 */
export const getByName = query({
	args: { name: v.string() },
	handler: async (ctx, args) => {
		const userId = await getAuthUserId(ctx);
		if (!userId) {
			return null;
		}

		const character = await ctx.db
			.query('characters')
			.withIndex('by_user_and_name', (q) => q.eq('userId', userId).eq('finalName', args.name))
			.first();

		return character;
	},
});

// ============================================================================
// MUTATIONS
// ============================================================================

/**
 * Create a new character
 */
export const create = mutation({
	args: {
		character: v.any(), // Full SavedCharacter object (minus ID and userId)
	},
	handler: async (ctx, args) => {
		const userId = await getAuthUserId(ctx);
		if (!userId) {
			throw new Error('Not authenticated');
		}

		const now = new Date().toISOString();

		const characterId = await ctx.db.insert('characters', {
			...args.character,
			userId,
			createdAt: now,
			lastModified: now,
		});

		return characterId;
	},
});

/**
 * Update an existing character
 */
export const update = mutation({
	args: {
		characterId: v.id('characters'),
		updates: v.any(), // Partial<SavedCharacter>
	},
	handler: async (ctx, args) => {
		const userId = await getAuthUserId(ctx);
		if (!userId) {
			throw new Error('Not authenticated');
		}

		// Verify ownership
		const existing = await ctx.db.get(args.characterId);
		if (!existing || existing.userId !== userId) {
			throw new Error('Character not found or access denied');
		}

		await ctx.db.patch(args.characterId, {
			...args.updates,
			lastModified: new Date().toISOString(),
		});

		return args.characterId;
	},
});

/**
 * Update only the characterState (for frequent saves during gameplay)
 */
export const updateState = mutation({
	args: {
		characterId: v.id('characters'),
		characterState: v.any(), // CharacterState object
	},
	handler: async (ctx, args) => {
		const userId = await getAuthUserId(ctx);
		if (!userId) {
			throw new Error('Not authenticated');
		}

		// Verify ownership
		const existing = await ctx.db.get(args.characterId);
		if (!existing || existing.userId !== userId) {
			throw new Error('Character not found or access denied');
		}

		await ctx.db.patch(args.characterId, {
			characterState: args.characterState,
			lastModified: new Date().toISOString(),
		});

		return args.characterId;
	},
});

/**
 * Delete a character
 */
export const remove = mutation({
	args: { characterId: v.id('characters') },
	handler: async (ctx, args) => {
		const userId = await getAuthUserId(ctx);
		if (!userId) {
			throw new Error('Not authenticated');
		}

		// Verify ownership
		const existing = await ctx.db.get(args.characterId);
		if (!existing || existing.userId !== userId) {
			throw new Error('Character not found or access denied');
		}

		await ctx.db.delete(args.characterId);

		return { success: true };
	},
});

/**
 * Duplicate a character (creates a copy with new ID)
 */
export const duplicate = mutation({
	args: { characterId: v.id('characters') },
	handler: async (ctx, args) => {
		const userId = await getAuthUserId(ctx);
		if (!userId) {
			throw new Error('Not authenticated');
		}

		// Get existing character
		const existing = await ctx.db.get(args.characterId);
		if (!existing || existing.userId !== userId) {
			throw new Error('Character not found or access denied');
		}

		const now = new Date().toISOString();

		// Create copy with new name
		const { _id, _creationTime, ...characterData } = existing;
		const newCharacterId = await ctx.db.insert('characters', {
			...characterData,
			finalName: `${existing.finalName} (Copy)`,
			createdAt: now,
			lastModified: now,
		});

		return newCharacterId;
	},
});
