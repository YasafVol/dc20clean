This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
src/
  components/
    Menu.tsx
    Snackbar.tsx
    styled.ts
  lib/
    config/
      features.ts
    hooks/
      useAttributeCalculation.ts
      useEnhancedCharacterCalculation.ts
    rulesdata/
      _new_schema/
        ancestries.ts
        barbarian_features.ts
        barbarian_table.json
        bard_features.ts
        bard_table.json
        champion_features.ts
        champion_table.json
        cleric_features.ts
        cleric_table.json
        commander_features.ts
        commander_table.json
        druid_features.ts
        druid_table.json
        hunter_features.ts
        hunter_table.json
        monk_features.ts
        monk_table.json
        rogue_features.ts
        rogue_table.json
        sorcerer_features.ts
        sorcerer_table.json
        spellblade_features.ts
        spellblade_table.json
        traits.ts
        warlock_features.ts
        warlock_table.json
        wizard_features.ts
        wizard_table.json
      loaders/
        class-features.loader.ts
        class.loader.ts
      schemas/
        character.schema.ts
        class.schema.ts
      spells-data/
        spells/
          additional-spells/
            close-wounds.ts
            death-bolt.ts
            druidcraft.ts
            find-familiar.ts
            index.ts
            shield.ts
            tethering-vines.ts
          fiendborn-ancestry-spells/
            acid-bolt.ts
            index.ts
            poison-bolt.ts
          fire-and-flames/
            burning-flames.ts
            dancing-flames.ts
            fire-bolt.ts
            fire-shield.ts
            fog-cloud.ts
            grease.ts
            index.ts
            minor-flame-blade.ts
          holy-and-restoration/
            bless.ts
            guidance.ts
            guiding-bolt.ts
            heal.ts
            index.ts
            light.ts
            sacred-bolt.ts
            shield-of-faith.ts
          ice-and-illusions/
            catapult.ts
            frost-bolt.ts
            ice-knife.ts
            index.ts
            mage-hand.ts
            magic-missile.ts
            minor-illusion.ts
            silent-image.ts
          lightning-and-teleportation/
            crackling-lightning.ts
            gust.ts
            index.ts
            lightning-blade.ts
            lightning-bolt.ts
            misty-step.ts
            returning-shock.ts
            shocking-grasp.ts
          psychic-and-enchantment/
            bane.ts
            befriend.ts
            command.ts
            index.ts
            message.ts
            psi-bolt.ts
            psychic-fear.ts
            sleep.ts
          special-class-spells/
            index.ts
            sorcery.ts
          index.ts
        types/
          spell.types.ts
      ancestries.ts
      attributes.ts
      death.ts
      inventoryItems.ts
      knowledge.ts
      languages.ts
      maneuvers.ts
      rulesdata.spec.ts
      skills.ts
      techniques.ts
      trades.ts
      traits.ts
      types.ts
    server/
      auth.ts
    services/
      characterCompletion.ts
      dataMapping.ts
      enhancedCharacterCalculator.ts
      spellAssignment.ts
    stores/
      characterContext.reducer.spec.ts
      characterContext.tsx
    types/
      dataContracts.ts
      effectSystem.ts
    utils/
      characterEdit.ts
      characterState.ts
      classFeatureDescriptions.ts
      defenseNotes.ts
      storageUtils.spec.ts
      storageUtils.ts
      traitCosts.ts
      weaponUtils.ts
    index.ts
  routes/
    api/
      _backup/
        character/
          [characterId]/
            +server.ts
          progress/
            _backup_merge_stages_20250621/
              stageA+server.ts
              stageB+server.ts
            complete/
              +server.ts
    character-creation/
      components/
        BackgroundPointsManager.tsx
        LanguagesTab.tsx
        SkillsTab.tsx
        TradesTab.tsx
        TraitChoiceSelector.tsx
      styles/
        AncestryPointsCounter.styles.ts
        AncestrySelector.styles.ts
        Attributes.styles.ts
        Background.styles.ts
        CharacterCreation.styles.ts
        CharacterName.styles.ts
        ClassFeatures.styles.ts
        ClassSelector.styles.ts
        LoadCharacter.styles.ts
        SelectedAncestries.styles.ts
        SpellsAndManeuvers.styles.ts
      AncestryPointsCounter.tsx
      AncestrySelector.tsx
      AttributePointsCounter.tsx
      Attributes.tsx
      Background.tsx
      CharacterCreation.spec.ts
      CharacterCreation.tsx
      CharacterName.tsx
      ClassFeatures.tsx
      ClassSelector.tsx
      LevelUp.tsx
      LoadCharacter.tsx
      SelectedAncestries.tsx
      SpellsAndManeuvers.tsx
    character-sheet/
      components/
        AttackPopup.tsx
        Attacks.tsx
        Attributes.tsx
        AttributesSections.tsx
        Combat.tsx
        Currency.tsx
        DeathExhaustion.tsx
        DefenseChangeModal.tsx
        Defenses.tsx
        DiceRoller.tsx
        EnhancedFeatures.tsx
        EnhancedStatTooltips.tsx
        FeaturePopup.tsx
        Features.tsx
        Inventory.tsx
        InventoryPopup.tsx
        KnowledgeTrades.tsx
        Languages.tsx
        LeftColumn.tsx
        Maneuvers.tsx
        Movement.tsx
        PlayerNotes.tsx
        Resources.tsx
        Resources.tsx.backup
        RightColumnResources.tsx
        SpellPopup.tsx
        Spells.tsx
        StatTooltips.tsx
        Tooltip.tsx
      hooks/
        CharacterSheetProvider.tsx
        useCharacterSheetReducer.test.ts
        useCharacterSheetReducer.ts
      styles/
        Attacks.ts
        Attributes.ts
        AttributesSections.styles.ts
        Combat.ts
        Currency.ts
        Death.ts
        DeathExhaustion.styles.ts
        Defenses.ts
        DesktopLayout.ts
        DiceRoller.ts
        Exhaustion.ts
        FeaturePopup.ts
        Features.styles.ts
        Features.ts
        Header.ts
        Info.ts
        Inventory.ts
        KnowledgeTrades.ts
        Languages.ts
        Layout.ts
        Movement.styles.ts
        Movement.ts
        PlayerNotes.styles.ts
        Potions.ts
        Resources.ts
        RightColumnResources.styles.ts
        Skills.ts
        Spells.ts
      CharacterSheetClean.tsx
      CharacterSheetDesktop.tsx
      CharacterSheetMobile.tsx
      CharacterSheetRouter.tsx
  styles/
    App.styles.ts
  types/
    character.ts
    defenseNotes.ts
    index.ts
  app.d.ts
  App.tsx
  demo.spec.ts
  main.tsx
```

# Files

## File: src/components/Snackbar.tsx
```typescript
import React, { useEffect, useState } from 'react';
import styled, { keyframes } from 'styled-components';

const slideIn = keyframes`
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
`;

const slideOut = keyframes`
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(100%);
    opacity: 0;
  }
`;

const StyledSnackbar = styled.div<{ $isVisible: boolean; $isExiting: boolean }>`
	position: fixed;
	top: 2rem;
	right: 2rem;
	padding: 1rem 1.5rem;
	background: linear-gradient(145deg, #10b981 0%, #059669 100%);
	color: white;
	border-radius: 8px;
	box-shadow: 0 8px 32px rgba(16, 185, 129, 0.3);
	font-weight: bold;
	font-size: 0.9rem;
	z-index: 1000;
	min-width: 300px;
	animation: ${(props) => (props.$isExiting ? slideOut : slideIn)} 0.3s ease-out;
	display: ${(props) => (props.$isVisible ? 'block' : 'none')};

	&::before {
		content: '✓';
		margin-right: 0.5rem;
		font-size: 1.2rem;
	}
`;

interface SnackbarProps {
	message: string;
	isVisible: boolean;
	onClose: () => void;
	duration?: number;
}

const Snackbar: React.FC<SnackbarProps> = ({ message, isVisible, onClose, duration = 3000 }) => {
	const [isExiting, setIsExiting] = useState(false);

	useEffect(() => {
		if (isVisible) {
			const timer = setTimeout(() => {
				setIsExiting(true);
				setTimeout(() => {
					onClose();
					setIsExiting(false);
				}, 300); // Animation duration
			}, duration);

			return () => clearTimeout(timer);
		}
	}, [isVisible, onClose, duration]);

	return (
		<StyledSnackbar $isVisible={isVisible} $isExiting={isExiting}>
			{message}
		</StyledSnackbar>
	);
};

export default Snackbar;
```

## File: src/lib/rulesdata/schemas/class.schema.ts
```typescript
import { z } from 'zod';

// Schema for IEffect
const effectSchema = z.object({
	type: z.string(),
	target: z.string().optional(),
	value: z.any().optional(),
	condition: z.string().optional(),
	userChoiceRequired: z
		.object({
			prompt: z.string(),
			options: z.array(z.string()).optional()
		})
		.optional(),
	descriptionOverride: z.string().optional(),
	subFeature: z.string().optional(),
	schools: z.array(z.string()).optional()
});

// Schema for IClassFeatureChoiceOption
const classFeatureChoiceOptionSchema = z.object({
	value: z.string(),
	label: z.string(),
	description: z.string().optional(),
	effectsOnChoice: z.array(effectSchema).optional()
});

// Schema for IClassFeatureChoice
const classFeatureChoiceSchema = z.object({
	id: z.string(),
	prompt: z.string(),
	type: z.enum(['select_one', 'select_multiple']),
	maxSelections: z.number().optional(),
	options: z.array(classFeatureChoiceOptionSchema)
});

// Schema for IBenefit
const benefitSchema = z.object({
	name: z.string(),
	description: z.string(),
	effects: z.array(effectSchema).optional()
});

// Schema for IClassFeature
const classFeatureSchema = z.object({
	id: z.string(),
	name: z.string(),
	description: z.string(),
	level: z.number(),
	effects: z.array(effectSchema).optional(),
	benefits: z.array(benefitSchema).optional()
});

// Schema for IClassDefinition
export const classSchema = z.object({
	id: z.string(),
	name: z.string(),
	description: z.string(),
	baseHpContribution: z.number(),
	startingSP: z.number(),
	startingMP: z.number(),
	skillPointGrantLvl1: z.number().optional(),
	tradePointGrantLvl1: z.number().optional(),
	combatTraining: z.array(z.string()).optional(),
	maneuversKnownLvl1: z.union([z.string(), z.number()]).optional(),
	techniquesKnownLvl1: z.number().optional(),
	saveDCBase: z.number(),
	deathThresholdBase: z.number(),
	moveSpeedBase: z.number(),
	restPointsBase: z.number(),
	gritPointsBase: z.number(),
	initiativeBonusBase: z.number(),
	cantripsKnownLvl1: z.number().optional(),
	spellsKnownLvl1: z.number().optional(),
	// Level progression data for future level gaining
	levelProgression: z.array(z.object({
		level: z.number(),
		healthPoints: z.number(),
		attributePoints: z.number(),
		skillPoints: z.number(),
		tradePoints: z.number(),
		staminaPoints: z.number(),
		maneuversKnown: z.number(),
		techniquesKnown: z.number(),
		manaPoints: z.number(),
		cantripsKnown: z.number(),
		spellsKnown: z.number(),
		features: z.string() // Description of features gained at this level
	})),
	// Features should be handled by class-features.loader.ts, but keeping for schema compatibility
	level1Features: z.array(classFeatureSchema).optional(),
	featureChoicesLvl1: z.array(classFeatureChoiceSchema).optional()
});

// Schema for an array of class definitions
export const classesDataSchema = z.array(classSchema);

// Infer the TypeScript type from the schema
export type IClassDefinition = z.infer<typeof classSchema>;
```

## File: src/lib/rulesdata/spells-data/spells/additional-spells/close-wounds.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const closeWounds: Spell = {
	name: 'Close Wounds',
	premadeList: PremadeSpellList.Additional,
	school: SpellSchool.Restoration,
	isCantrip: true,
	cost: { ap: 1 },
	range: '1 Space',
	duration: 'Instant',
	spellLists: [SpellList.Divine],
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Heal Allied Creature',
			description:
				'You touch an allied creature that has at least 1 HP, tapping into its inner life force to cause a surge of natural healing. Make a DC 10 Spell Check. Success: The target can spend 1 Rest Point to regain 2 HP. Failure: The target spends 1 Rest Point to regain 1 HP.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Range',
			description: 'You increase the range to 10 Spaces (and don’t have to touch the target).'
		},
		{
			type: 'MP',
			cost: 1,
			name: 'Bolster',
			description:
				'You increase the HP regained by 3. You can take this enhancement multiple times.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/additional-spells/death-bolt.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const deathBolt: Spell = {
	name: 'Death Bolt',
	premadeList: PremadeSpellList.Additional,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [SpellList.Arcane, SpellList.Divine],
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Spell Attack',
			description:
				'You can make a Spell Check against the PD of a target within range. Hit: The target takes 2 Umbral damage.'
		},
		{
			title: 'Black Orb',
			description:
				'Black wispy magic swirls around your hands. Your touch send chills down the spine of creatures and make small plants wither. You can hold this dark energy in your hands for 1 minute.'
		}
	],
	cantripPassive: 'You deal +1 damage against creatures that are Bloodied.',
	enhancements: [
		{ type: 'AP', cost: 1, name: 'Damage', description: 'You deal +1 Umbral damage.' },
		{ type: 'AP', cost: 1, name: 'Range', description: 'You increase the range by 5 Spaces.' },
		{
			type: 'AP',
			cost: 1,
			name: 'Dampen Heal',
			description:
				'Creatures that take damage from this Spell can’t regain HP until the start of their next turn.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/additional-spells/druidcraft.ts
```typescript
import { Spell, SpellSchool, PremadeSpellList } from '../../types/spell.types';

export const druidcraft: Spell = {
	name: 'Druidcraft',
	premadeList: PremadeSpellList.Additional,
	school: SpellSchool.Transmutation,
	isCantrip: true,
	cost: { ap: 1 },
	range: '5 Spaces',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Natural Sensory Effect',
			description:
				'You target an area within range and produce a harmless natural smell (such as flowers, faint odor of skunk, etc.) or sound (rustling leaves, a small animal, etc.).'
		},
		{
			title: 'Accelerate Plant Growth',
			description:
				'You target a living mundane plant and instantly accelerate the growth of the plant (flowers bloom, seeds open, etc.).'
		},
		{
			title: 'Revive Plant',
			description:
				'You target a wounded or dead mundane plant (smaller than a 1 Space cube) and bring it back to life.'
		}
	],
	enhancements: [] // No enhancements specified in PDF
};
```

## File: src/lib/rulesdata/spells-data/spells/additional-spells/find-familiar.ts
```typescript
import { Spell, SpellSchool, PremadeSpellList } from '../../types/spell.types';

export const findFamiliar: Spell = {
	name: 'Find Familiar',
	premadeList: PremadeSpellList.Additional,
	school: SpellSchool.Conjuration,
	isCantrip: false,
	isRitual: true,
	cost: { ap: 1, mp: 1 },
	range: '2 Spaces',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Summon Familiar',
			description:
				'You summon a friendly spirit that enters your service. It takes the form of a Tiny creature of your choice, but with a Creature Type of your choice (except Giant and Humanoid). Your Familiar uses the statblock below: Familiar Level 1/8, Tiny (Chosen Type) HP Shared Prime & CM Shared PD 8+CM PDR 0 AD 8+CM MDR 0 MIG 0 CHA 0 AGI 0 INT 0 Check Shared Save DC Shared AP Shared Speed 5 Recasting the Spell: You can’t have more than 1 Familiar at a time. If you cast this Spell while you already have a Familiar, your Familiar can retain its form, adopt a new form of your choice, or it disappears and a new one takes its place. The new Familiar can be a previous one you summoned in the past or a new one altogether. In either case, you can reassign its Familiar Traits. Base Familiar Traits: Your Familiar has the following Familiar Traits: Familiar Bond: Your Familiar shares your HP and Death’s Door Threshold. If you both take damage from the same source, you only take 1 instance of that damage. While your Familiar occupies the same Space as you, it can’t be targeted by Attacks. Shared Telepathy: While within 20 Spaces, you and your Familiar can speak Telepathically with each other. Spell Delivery: While within 10 Spaces of your Familiar, you can cast a Spell with a range of Touch as if you were standing in your Familiar’s Space. Additional Traits: When you cast this Spell, you can spend additional MP (up to your Mana Spend Limit) to grant your Familiar 2 additional Traits per MP spent. You can choose Traits from the Familiar Traits or Beast Traits (you can’t choose Negative Traits). Spell Actions: Pocket Dimension: You can spend a Minor Action to dismiss the Familiar into a pocket dimension, summon it from that pocket dimension, or summon it from anywhere on the same plane of existence. When dismissed, any items it was carrying are left behind. When summoned, it appears in the nearest unoccupied Space of your choice. Shared Senses: While your Familiar is within 20 Spaces, you can spend 1 AP to connect your senses to the Familiar’s senses until the end of your next turn. For the duration, you’re Deafened and Blinded to your own senses but you can see what your Familiar sees and hear what it hears. The connection ends early if either of you moves farther than 20 Spaces from each other. Managing the Familiar: Combat: The Familiar shares your Initiative, acting on your turn. You can spend 1 AP to command the Familiar to use an Action. It can’t take the Attack Action or Spell Action unless it has a Familiar Feature that allows it to. When you take an Action, your Familiar can move up to its Speed immediately before or after the Action. If you don’t command it, it takes the Dodge Action. Shared MCP: When the Familiar makes a Check, it shares your Multiple Check Penalty. Death & Resurrection: Your Familiar dies when you die. When it does, its body disappears and its spirit returns from which it came. If you’re resurrected, the Familiar doesn’t return to life until the next time you cast this Spell. When it does, you follow the normal rules for recasting the Spell.'
		}
	],
	enhancements: [] // No enhancements specified in PDF
};
```

## File: src/lib/rulesdata/spells-data/spells/additional-spells/index.ts
```typescript
import { druidcraft } from './druidcraft';
import { findFamiliar } from './find-familiar';
import { shield } from './shield';
import { tetheringVines } from './tethering-vines';
import { closeWounds } from './close-wounds';
import { deathBolt } from './death-bolt';

export const additionalSpells = [
	druidcraft,
	findFamiliar,
	shield,
	tetheringVines,
	closeWounds,
	deathBolt
];
```

## File: src/lib/rulesdata/spells-data/spells/additional-spells/shield.ts
```typescript
import { Spell, SpellSchool, PremadeSpellList } from '../../types/spell.types';

export const shield: Spell = {
	name: 'Shield',
	premadeList: PremadeSpellList.Additional,
	school: SpellSchool.Protection,
	isCantrip: true,
	cost: { ap: 1 },
	range: '1 Space',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Create Barrier',
			description:
				'You create a barrier of magic to protect yourself or another creature nearby. Trigger: When a creature you can see within range (including yourself) is targeted by an Attack. Reaction: You grant the target a +5 bonus to its PD and AD against the Attack.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Increase Range',
			description: 'The range increases to 5 Spaces.'
		},
		{
			type: 'MP',
			cost: 1,
			name: 'Multiple Targets',
			description:
				'You can target 1 additional creature in range from the same triggering Attack (such as an Area of Effect).'
		},
		{
			type: 'MP',
			cost: 2,
			name: 'Increase Duration',
			description: 'The PD and AD bonus lasts until the start of your next turn.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/additional-spells/tethering-vines.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const tetheringVines: Spell = {
	name: 'Tethering Vines',
	premadeList: PremadeSpellList.Additional,
	school: SpellSchool.Conjuration,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '10 Spaces',
	duration: '1 min (Sustained)',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Sprout Vines',
			description:
				'Choose a Space within range. Vines and weeds sprout up from the ground in a 3 Space Radius from the chosen Space, making the area Difficult Terrain. Make a Spell Check Contested by a Physical Save from all creatures (other than you) within range. Success: The creature is Tethered. Tethered: While Tethered, the creature can’t leave the area. The creature can spend 1 AP to make a Physical Check of your choice against your Save DC. Success: The target is no longer Tethered. When the Spell ends, the conjured plants wilt away.'
		}
	],
	enhancements: [
		{ type: 'MP', cost: 1, name: 'Widen Vines', description: 'The radius increases by 1 Space.' }
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/fiendborn-ancestry-spells/acid-bolt.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const acidBolt: Spell = {
	name: 'Acid Bolt',
	premadeList: PremadeSpellList.FiendbornAncestry,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [SpellList.Arcane, SpellList.Primal],
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Spell Attack',
			description:
				'You can make a Spell Check against the PD of a target within range. Hit: The target takes 2 Corrosion damage.'
		}
	],
	cantripPassive: 'You deal +1 damage against creatures that are Hindered.',
	enhancements: [
		{ type: 'AP', cost: 1, name: 'Damage', description: 'You deal +1 Corrosion damage.' },
		{ type: 'AP', cost: 1, name: 'Range', description: 'You increase the range by 5 Spaces.' },
		{
			type: 'AP',
			cost: 1,
			name: 'Corrode',
			description:
				'The target makes a Physical Save. Failure: Target becomes Hindered for 1 minute or until a creature (including itself) within 1 Space spends 1 AP to clear off the acid.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/fiendborn-ancestry-spells/index.ts
```typescript
import { poisonBolt } from './poison-bolt';
import { acidBolt } from './acid-bolt';

export const fiendbornAncestrySpells = [poisonBolt, acidBolt];
```

## File: src/lib/rulesdata/spells-data/spells/fiendborn-ancestry-spells/poison-bolt.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const poisonBolt: Spell = {
	name: 'Poison Bolt',
	premadeList: PremadeSpellList.FiendbornAncestry,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [SpellList.Arcane, SpellList.Primal],
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Spell Attack',
			description:
				'You can make a Spell Check against the PD of a target within range. Hit: The target takes 2 Poison damage.'
		}
	],
	cantripPassive: 'You deal +1 damage against creatures that are Impaired.',
	enhancements: [
		{ type: 'AP', cost: 1, name: 'Damage', description: 'You deal +1 Poison damage.' },
		{ type: 'AP', cost: 1, name: 'Range', description: 'You increase the range by 5 Spaces.' },
		{
			type: 'AP',
			cost: 1,
			name: 'Sicken',
			description:
				'The target makes a Physical Save. Failure: Target becomes Impaired for 1 minute. A creature within 1 Space, including itself, can spend 1 AP to make a DC 10 Medicine Check to end the Condition early.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/fire-and-flames/burning-flames.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const burningFlames: Spell = {
	name: 'Burning Flames',
	premadeList: PremadeSpellList.FireAndFlames,
	school: SpellSchool.Destruction,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: 'Self (10 Spaces)',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Area of Effect',
			description:
				'A brilliant flame manifests around you. Choose a type of area: Line, Cone, or Sphere. You are the Spell’s Point of Origin. Line: The Spell affects every target in a 1 Space wide and 10 Space long line. Cone: The Spell creates a 3 Space long Cone. Sphere: The Spell affects every target in a 2 Space radius. Make a Spell Check against every target’s AD within the Spell’s area. Hit: The target takes 2 Fire damage.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Burning',
			description:
				'Each target makes a Physical Save. Failure: The target begins Burning until a creature (including itself) within 1 Space spends 1 AP to put it out.'
		},
		{
			type: 'MP',
			cost: 1,
			name: 'Range',
			description:
				'The Point of Origin of the Spell becomes a point of your choice within 15 Spaces (instead of Self).'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/fire-and-flames/dancing-flames.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const dancingFlames: Spell = {
	name: 'Dancing Flames',
	premadeList: PremadeSpellList.FireAndFlames,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '20 Spaces',
	duration: '1 min (Sustained)',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Create Flames',
			description:
				'Make a DC 10 Spell Check. Success: You create up to 3 torch-sized Flames within range, making them appear as torches, lanterns, or glowing orbs that hover in the air for the duration. Success (each 5): +1 Flame. Failure: 2 Flames. You can also combine 4 Flames into 1 glowing vaguely humanoid form of Medium Size. Whichever form you choose, each Flame sheds Bright Light in a 2 Space radius. You can spend 1 AP to move the Flames up to 10 Spaces to a new Space within range. A Flame must be within 5 Spaces of another Flame created by this Spell and be within 20 Spaces from you, or it winks out of existence.'
		}
	],
	enhancements: [
		{
			type: 'AP',
			cost: 2,
			name: 'Detonate',
			description:
				'Spend 2 AP and 1 MP to detonate the Flames. Make a single Spell Check and compare it against the AD of each target sharing a Space with a Flame. Hit: Each Flame in that Space deals 1 Fire damage to the target, but doesn’t benefit from Heavy, Brutal, or Critical Hits.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/fire-and-flames/fire-bolt.ts
```typescript
import { Spell, SpellSchool, SpellList, ClassName, PremadeSpellList } from '../../types/spell.types';

export const fireBolt: Spell = {
	name: 'Fire Bolt',
	premadeList: PremadeSpellList.FireAndFlames,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [SpellList.Arcane, SpellList.Primal],
	availableClasses: [ClassName.Wizard, ClassName.Sorcerer],
	effects: [
		{
			title: 'Spell Attack',
			description:
				'You can make a Spell Check against the PD of a target within range. Hit: The target takes 2 Fire damage.'
		},
		{
			title: 'Fire Orb',
			description:
				'A flickering flame appears in your hand. The flame can remain there for 10 minutes and harms neither you nor your equipment. The flame sheds Bright Light in a 5 Space radius. The Spell ends early if you dismiss it for free, if you cast it again, or spend 1 AP to make a Spell Attack with it.'
		}
	],
	cantripPassive: 'You deal +1 damage against creatures that are Burning.',
	enhancements: [
		{ type: 'AP', cost: 1, name: 'Damage', description: 'You deal +1 Fire damage.' },
		{ type: 'AP', cost: 1, name: 'Range', description: 'You increase the range by +5 Spaces.' },
		{
			type: 'AP',
			cost: 1,
			name: 'Burning',
			description: 'The target makes a Physical Save. Failure: Target begins Burning.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/fire-and-flames/fire-shield.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const fireShield: Spell = {
	name: 'Fire Shield',
	premadeList: PremadeSpellList.FireAndFlames,
	school: SpellSchool.Abjuration,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: 'Self',
	duration: '1 hour',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Protective Force',
			description:
				'A protective magical force surrounds you, manifesting as spectral flames that cover you and your gear. You emit Bright Light in a 2 Space Radius. Make a DC 15 Spell Check. Success: You gain 3 Temp HP. Success (each 5): +1 Temp HP. Failure: 2 Temp HP. If a creature hits you with a Melee Attack while you have this Temp HP, the creature takes 1 Fire damage for each Temp HP it consumed with its Attack. The Spell ends once the Temp HP is consumed.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 3,
			name: 'Fire Protection',
			description: 'You gain Fire Resistance (Half) and 10 more Temp HP.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/fire-and-flames/fog-cloud.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const fogCloud: Spell = {
	name: 'Fog Cloud',
	premadeList: PremadeSpellList.FireAndFlames,
	school: SpellSchool.Conjuration,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '20 Spaces',
	duration: '1 hour (Sustained)',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Create Fog',
			description:
				'Make a DC 10 Spell Check. Success: You create a sphere of fog with up to a 4 Space radius, centered on a point within range. Succeed (each 5): Radius increases by 1 Space. Failure: 3 Space radius. The Sphere spreads around corners and its area is Fully Concealed. Creatures within 1 Space of each other can see each other normally. The fog lasts for the duration or until a wind of moderate or greater speed disperses it.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Area of Effect',
			description: 'The radius of the Spell’s effect increases by 3 Spaces.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/fire-and-flames/grease.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const grease: Spell = {
	name: 'Grease',
	premadeList: PremadeSpellList.FireAndFlames,
	school: SpellSchool.Conjuration,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '10 Spaces',
	duration: '1 min',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Slick Ground',
			description:
				'Make a DC 10 Spell Check. Success: Slick grease covers the ground in 4 Spaces of your choosing within range. Failure: Only 3 Spaces. The Spaces must connect to each other and all be within range of the Spell. These Spaces are considered to be Difficult Terrain for the duration and are flammable. If fire touches one of these Spaces, the grease ignites and deals 1 Fire damage to any creature within the Space instantly and again to any creature who ends their turn in this Space before the Spell ends. If a creature is standing in one of the Spaces when the grease initially appears, when they end their turn, or when they enter it for the first time on a turn they must make an Agility Save. Failure: They fall Prone.'
		}
	],
	enhancements: [
		{ type: 'MP', cost: 1, name: 'More Grease', description: 'You add 4 more Spaces of grease.' },
		{
			type: 'MP',
			cost: 1,
			name: 'More Fire',
			description: 'Fire damage dealt by the Spell is increased by 1.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/fire-and-flames/index.ts
```typescript
import { fireBolt } from './fire-bolt';
import { minorFlameBlade } from './minor-flame-blade';
import { dancingFlames } from './dancing-flames';
import { burningFlames } from './burning-flames';
import { fogCloud } from './fog-cloud';
import { fireShield } from './fire-shield';
import { grease } from './grease';

export const fireAndFlamesSpells = [
	fireBolt,
	minorFlameBlade,
	dancingFlames,
	burningFlames,
	fogCloud,
	fireShield,
	grease
];
```

## File: src/lib/rulesdata/spells-data/spells/fire-and-flames/minor-flame-blade.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const minorFlameBlade: Spell = {
	name: 'Minor Flame Blade',
	premadeList: PremadeSpellList.FireAndFlames,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: 'Self',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Imbue Weapon',
			description:
				'You imbue a Melee Weapon you’re wielding with flames. Until the end of your next turn, the next Attack Check that hits with this weapon deals an additional 1 Fire damage to your target or a creature within 1 Space of the target.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Flame Strike',
			description:
				'You deal an extra 2 Fire damage to the target (must be done before the Attack is made). Miss: Deal 1 Fire damage to the target.'
		},
		{
			type: 'MP',
			cost: 1,
			name: 'Flame Bound',
			description:
				'You deal an extra 1 Fire damage to the target and another target within 1 Space.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/holy-and-restoration/bless.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const bless: Spell = {
	name: 'Bless',
	premadeList: PremadeSpellList.HolyAndRestoration,
	school: SpellSchool.Divination,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '5 Spaces',
	duration: '1 min (Sustained)',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Bless Creatures',
			description:
				'Make a DC 10 Spell Check. Success: You bless up to 3 creatures of your choice within range. Success (each 10): +1 additional creature. Failure: Only 2 creatures. Whenever a target makes a Check or Save before the Spell ends, the target can roll a d4 and add the number rolled to the total.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Targets',
			description: 'You increase the number of targets by 1.'
		},
		{
			type: 'MP',
			cost: 2,
			name: 'Grace',
			description: 'You change the d4 granted by the Spell to a d6.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/holy-and-restoration/guidance.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const guidance: Spell = {
	name: 'Guidance',
	premadeList: PremadeSpellList.HolyAndRestoration,
	school: SpellSchool.Divination,
	isCantrip: true,
	cost: { ap: 1 },
	range: '5 Spaces',
	duration: '1 Round',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Grant Help Die',
			description:
				'You grant a Help Die (d8) to an ally within range. The target can use this Help Die to add to any Check they make before the start of your next turn. Casting Guidance counts as taking the Help Action and still triggers the “Multiple Action Penalty (Help)”. If you cast Guidance again or take the Help Action, the Help Die would be a d6, then a d4, then you wouldn’t be able to grant any more during the same round of Combat.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Sustained',
			description: 'The duration increases to 1 minute, but it requires the Sustain Action.'
		},
		{
			type: 'MP',
			cost: 1,
			name: 'Expand',
			description:
				'You grant an additional Help Die (of the same size you granted with the casting of the Spell).'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/holy-and-restoration/guiding-bolt.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const guidingBolt: Spell = {
	name: 'Guiding Bolt',
	premadeList: PremadeSpellList.HolyAndRestoration,
	school: SpellSchool.Destruction,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '15 Spaces',
	duration: '1 Round',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Flash of Light',
			description:
				'A flash of light streaks toward a creature of your choice within range, surrounding them in a holy glow. Make a Spell Check against the target’s PD. Hit: The target takes 3 Radiant damage and the next Attack Check made against the target before the end of your next turn has ADV.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Guiding Damage',
			description:
				'The next Attack Check made against the target also deals an extra 3 Radiant damage on a Hit.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/holy-and-restoration/heal.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const heal: Spell = {
	name: 'Heal',
	premadeList: PremadeSpellList.HolyAndRestoration,
	school: SpellSchool.Restoration,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Heal Target',
			description:
				'Make a DC 10 Spell Check. Success: You heal the target creature within range for 3 HP. Success (each 5): + 1 HP. Critical Success: +2 HP. Failure: Only heal for 2 HP. If you’re touching the target of this Spell when you cast it, they regain an extra 1 HP.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Quick Heal',
			description: 'You reduce the AP cost of this Spell by 1.'
		},
		{
			type: 'MP',
			cost: 1,
			name: 'Bolster',
			description:
				'You increase the HP regained by 3. You can take this enhancement multiple times.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/holy-and-restoration/index.ts
```typescript
import { sacredBolt } from './sacred-bolt';
import { guidance } from './guidance';
import { light } from './light';
import { guidingBolt } from './guiding-bolt';
import { bless } from './bless';
import { heal } from './heal';
import { shieldOfFaith } from './shield-of-faith';

export const holyAndRestorationSpells = [
	sacredBolt,
	guidance,
	light,
	guidingBolt,
	bless,
	heal,
	shieldOfFaith
];
```

## File: src/lib/rulesdata/spells-data/spells/holy-and-restoration/light.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const light: Spell = {
	name: 'Light',
	premadeList: PremadeSpellList.HolyAndRestoration,
	school: SpellSchool.Conjuration,
	isCantrip: true,
	cost: { ap: 1 },
	range: 'Touch',
	duration: '1 hour',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Shed Light',
			description:
				'You touch an object that’s no larger than Medium. Until the spell ends, the object sheds Bright Light in a 5 Space radius. You choose the color of the light. Completely covering the object with something opaque blocks the light. The Spell ends if you cast it again or dismiss it as a Free Action. If you target an object held or worn by a hostile creature, make an Attack Check contested by the target’s Agility Save. Success: You cast Light on the object.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Blinding Light',
			description:
				'You make a Spell Check contested by a Physical Save from all targets within 2 Spaces of the Light source. Failure: The target is Blinded for 1 Round.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/holy-and-restoration/sacred-bolt.ts
```typescript
import { Spell, SpellSchool, SpellList, ClassName, PremadeSpellList } from '../../types/spell.types';

export const sacredBolt: Spell = {
	name: 'Sacred Bolt',
	premadeList: PremadeSpellList.HolyAndRestoration,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [SpellList.Divine],
	availableClasses: [ClassName.Cleric],
	effects: [
		{
			title: 'Spell Attack',
			description:
				'You can make a Spell Check against the PD of a target within range. Hit: The target takes 2 Radiant damage.'
		},
		{
			title: 'Sacred Glow',
			description:
				'A beam of Bright Light illuminates a creature that you can see within range, or you can make a creature within range glow with a subtle Dim Light for 10 minutes.'
		}
	],
	cantripPassive: 'You deal +1 Radiant damage against Undead and Exposed creatures.',
	enhancements: [
		{ type: 'AP', cost: 1, name: 'Damage', description: 'You deal +1 Radiant damage.' },
		{ type: 'AP', cost: 1, name: 'Range', description: 'You increase the range by 5 Spaces.' },
		{
			type: 'AP',
			cost: 1,
			name: 'Holy Bolt',
			description:
				'The target makes a Mental Save. Failure: Target becomes Exposed (Attack Checks against it have ADV) against the next Attack Check made against it before the end of your next turn.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/holy-and-restoration/shield-of-faith.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const shieldOfFaith: Spell = {
	name: 'Shield of Faith',
	premadeList: PremadeSpellList.HolyAndRestoration,
	school: SpellSchool.Protection,
	isCantrip: false,
	cost: { ap: 1, mp: 1 },
	range: '10 Spaces',
	duration: '10 min (Sustained)',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Protective Field',
			description:
				'A shimmering field appears and surrounds a creature of your choice within range. Make a DC 10 Spell Check. Success: The target gains +2 PD for the duration. Success (each 10): +1 PD. Failure: The target gains 1 PD instead.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Targets',
			description: 'You increase the number of creatures you can affect by 1.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/ice-and-illusions/catapult.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const catapult: Spell = {
	name: 'Catapult',
	premadeList: PremadeSpellList.IceAndIllusions,
	school: SpellSchool.Destruction,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Launch Object',
			description:
				'Choose one object weighing 1 to 5 pounds within range that isn’t being worn or carried. The object flies in a straight line up to 15 Spaces in a direction you choose before falling to the ground, stopping early if it impacts against a solid surface. If you attempt to strike a creature, make a Spell Check against the target’s PD. Hit: 3 Bludgeoning damage.'
		}
	],
	enhancements: [
		{ type: 'MP', cost: 1, name: 'Damage', description: 'You deal +2 Bludgeoning damage.' }
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/ice-and-illusions/frost-bolt.ts
```typescript
import { Spell, SpellSchool, SpellList, ClassName, PremadeSpellList } from '../../types/spell.types';

export const frostBolt: Spell = {
	name: 'Frost Bolt',
	premadeList: PremadeSpellList.IceAndIllusions,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [SpellList.Arcane, SpellList.Primal],
	availableClasses: [ClassName.Wizard, ClassName.Sorcerer],
	effects: [
		{
			title: 'Spell Attack',
			description:
				'You can make a Spell Check against the PD of a target within range. Hit: The target takes 2 Cold damage.'
		},
		{
			title: 'Ice Orb',
			description:
				'A flurry of ice appears in your hand. The ice can remain there for 10 minutes and harms neither you nor your equipment, cooling the area within 5 Spaces. The Spell ends early if you dismiss it for free, if you cast it again, or spend 1 AP to make a Spell Attack with it.'
		}
	],
	cantripPassive: 'You deal +1 damage against creatures that are Slowed.',
	enhancements: [
		{ type: 'AP', cost: 1, name: 'Damage', description: 'You deal +1 Cold damage.' },
		{ type: 'AP', cost: 1, name: 'Range', description: 'You increase the range by 5 Spaces.' },
		{
			type: 'AP',
			cost: 1,
			name: 'Slow',
			description:
				'The target makes a Physical Save. Failure: Target becomes Slowed until the end of your next turn.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/ice-and-illusions/ice-knife.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const iceKnife: Spell = {
	name: 'Ice Knife',
	premadeList: PremadeSpellList.IceAndIllusions,
	school: SpellSchool.Destruction,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Ice Shard',
			description:
				'You create a shard of ice and fling it at one creature within range. Make a Spell Check against the target’s PD. Hit: The target takes 2 Cold damage and then the ice explodes. Compare the Spell Check to the AD of each creature within 1 space of the original target (including the target). Hit: Deal 1 Cold damage. Miss: The spell doesn’t explode and only deals half damage to the original target.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Damage',
			description: 'You increase the damage of the initial hit and the explosion by 1 each.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/ice-and-illusions/index.ts
```typescript
import { frostBolt } from './frost-bolt';
import { minorIllusion } from './minor-illusion';
import { mageHand } from './mage-hand';
import { catapult } from './catapult';
import { magicMissile } from './magic-missile';
import { iceKnife } from './ice-knife';
import { silentImage } from './silent-image';

export const iceAndIllusionsSpells = [
	frostBolt,
	minorIllusion,
	mageHand,
	catapult,
	magicMissile,
	iceKnife,
	silentImage
];
```

## File: src/lib/rulesdata/spells-data/spells/ice-and-illusions/mage-hand.ts
```typescript
import { Spell, SpellSchool, PremadeSpellList } from '../../types/spell.types';

export const mageHand: Spell = {
	name: 'Mage Hand',
	premadeList: PremadeSpellList.IceAndIllusions,
	school: SpellSchool.Conjuration,
	isCantrip: true,
	cost: { ap: 1 },
	range: '5 Spaces',
	duration: '1 min',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Spectral Hand',
			description:
				'A spectral, floating hand appears at a point you choose within range. The hand lasts for the duration or until you dismiss it as a Free Action. The hand vanishes if it ever moves outside of the Spell’s range or if you cast this Spell again. When you cast the Spell, and by spending 1 AP while the Spell is active, you can control the hand. You can use the hand to manipulate an object, open an unlocked door or container, stow or retrieve an item from an open container, or pour the contents out of a container. You can move the hand up to 5 Spaces each time you use it, but it must stay within range. The hand can’t Attack, activate magic items, or carry more than 10 pounds.'
		}
	],
	enhancements: [
		{ type: 'MP', cost: 1, name: 'Range Hand', description: 'The range increases to 20 Spaces.' },
		{ type: 'MP', cost: 1, name: 'Lasting Hand', description: 'The duration increases to 1 hour.' }
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/ice-and-illusions/magic-missile.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const magicMissile: Spell = {
	name: 'Magic Missile',
	premadeList: PremadeSpellList.IceAndIllusions,
	school: SpellSchool.Destruction,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Glowing Darts',
			description:
				'You attempt to fire out glowing darts of magical force. Make a DC 10 Spell Check. Success: You create 2 Missiles. Success (each 5): +1 Missile. Failure: Only 1 Missile. Each Missile automatically deals 1 True damage to its target. Each missile may have the same or different targets.'
		}
	],
	enhancements: [
		{ type: 'MP', cost: 1, name: 'Damage', description: '+1 Missile.' },
		{ type: 'MP', cost: 1, name: 'Range', description: 'You increase the range to 15 Spaces.' }
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/ice-and-illusions/minor-illusion.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const minorIllusion: Spell = {
	name: 'Minor Illusion',
	premadeList: PremadeSpellList.IceAndIllusions,
	school: SpellSchool.Illusion,
	isCantrip: true,
	cost: { ap: 1 },
	range: '5 Spaces',
	duration: '1 min',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Create Sound or Image',
			description:
				'You create a sound or an image of an object within range that lasts for the duration. The illusion ends if you dismiss it for 1 AP or cast this Spell again. If you create a sound, its volume can range from a whisper to a scream. It can be your voice, someone else’s voice, a lion’s roar, a beating of drums, or any other sound you choose. The sound can continue unabated throughout the duration or you can make discrete sounds at different times before the Spell ends. If you create an image of an object—such as a chair, muddy footprints, or a small chest—it must be no larger than 1 Space. The image can’t create sound, light, smell, or any other sensory effect. Discerning the Illusion: If the illusion is an image, any physical interaction with the image reveals it to be an illusion as things pass through it. A creature can spend 1 AP to examine the sound or image to attempt to determine if the illusion is real, by making an Investigation Check against your Save DC. Success: The creature discerns that the objects or sounds made by the Spell are illusions. If the illusion is an image, the illusion becomes transparent to the creature.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Sight and Sound',
			description: 'The illusion can include both a sound and an image.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/ice-and-illusions/silent-image.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const silentImage: Spell = {
	name: 'Silent Image',
	premadeList: PremadeSpellList.IceAndIllusions,
	school: SpellSchool.Illusion,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '10 Spaces',
	duration: '10 min (Sustained)',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Create Image',
			description:
				'You create the image of an object, a creature, or some other visible phenomenon in a 3 Space cube. The image appears at a spot within range and lasts for the duration. The image is purely visual and isn’t accompanied by sound, smell, or other sensory effects. You can spend 1 AP to cause the image to move to any spot within range. As the image changes location, you can alter its appearance so that its movements appear natural. Discerning the Illusion: Physical interaction with the image reveals it to be an illusion. Alternatively, a creature can spend 1 AP to examine the image to attempt to determine if the illusion is real. The creature makes an Investigation Check against your Save DC. Success: The creature discerns the illusion for what it is, revealing it to be false and making the illusion transparent to the creature.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Sound and Smell',
			description: 'You can add sounds and a smell to the illusion.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/lightning-and-teleportation/crackling-lightning.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const cracklingLightning: Spell = {
	name: 'Crackling Lightning',
	premadeList: PremadeSpellList.LightningAndTeleportation,
	school: SpellSchool.Destruction,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: 'Self (10 Spaces)',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Area of Effect',
			description:
				'Crackling lightning forms around you. Choose a type of area: Line, Cone, or Sphere. You are the Spell’s Point of Origin. Line: The Spell affects every target in a 1 Space wide and 10 Space long line. Cone: The Spell creates a 3 Space long Cone. Sphere: The Spell affects every target in a 2 Space radius. Make a Spell Check against every target’s AD within the Spell’s area. Hit: The target takes 2 Lightning damage.'
		}
	],
	enhancements: [
		{
			type: 'AP',
			cost: 1,
			name: 'Frazzled',
			description:
				'Each target makes a Mental Save. Failure: The target becomes Dazed for 1 minute.'
		},
		{
			type: 'MP',
			cost: 1,
			name: 'Range',
			description:
				'The Point of Origin of the Spell becomes a point of your choice within 15 Spaces (instead of Self).'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/lightning-and-teleportation/gust.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const gust: Spell = {
	name: 'Gust',
	premadeList: PremadeSpellList.LightningAndTeleportation,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '5 Spaces',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Push Creature',
			description:
				'Choose a Medium or smaller creature and make a Spell Check contested by their Might Save. Success: Target is pushed 1 Space in a direction of your choice. Success (each 5): +1 Space.'
		},
		{
			title: 'Push Object',
			description:
				'Choose an object that’s neither held nor carried and that weighs no more than 5 pounds. Make a DC 10 Spell Check. Success: The object is pushed up to 3 Spaces away from you. Success (each 5): +1 Space. Failure: Only 2 Spaces.'
		},
		{
			title: 'Sensory Effect',
			description:
				'You create a harmless sensory effect using air, such as causing leaves to rustle, wind to slam shutters closed, or your clothing to ripple as in a breeze.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Wind Tunnel',
			description:
				'You create a 10 Space long and 2 Space wide Line that lasts 1 minute and requires the Sustain Action. The start of the Wind Tunnel must be within 5 Spaces of you. You choose the direction the Line goes in and what direction the wind is blowing. Creatures in the Wind Tunnel are Slowed 1 moving against the wind, but can move 2 Spaces for every 1 Space spent moving the same direction as the wind. Any creature that starts their turn in the Wind Tunnel must make a Might Save or be pushed 4 Spaces in the direction of the wind. You can spend 1 AP to reverse the direction of the wind in the tunnel.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/lightning-and-teleportation/index.ts
```typescript
import { lightningBolt } from './lightning-bolt';
import { lightningBlade } from './lightning-blade';
import { shockingGrasp } from './shocking-grasp';
import { gust } from './gust';
import { returningShock } from './returning-shock';
import { mistyStep } from './misty-step';
import { cracklingLightning } from './crackling-lightning';

export const lightningAndTeleportationSpells = [
	lightningBolt,
	lightningBlade,
	shockingGrasp,
	gust,
	returningShock,
	mistyStep,
	cracklingLightning
];
```

## File: src/lib/rulesdata/spells-data/spells/lightning-and-teleportation/lightning-blade.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const lightningBlade: Spell = {
	name: 'Lightning Blade',
	premadeList: PremadeSpellList.LightningAndTeleportation,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: 'Self (1 Space radius)',
	duration: '1 round',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Imbue Weapon',
			description:
				'You imbue a Melee Weapon you’re wielding with crackling energy. The next Attack Check that hits with this weapon sheathes the target in booming energy. If the target leaves, or is moved from, the current Space they’re in, they automatically take 2 Lightning damage and the Spell ends. This effect can be stacked multiple times from the same or different sources.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Damage',
			description: 'You increase the Lightning damage dealt by 2.'
		},
		{ type: 'MP', cost: 1, name: 'Duration', description: 'You increase the duration to 1 minute.' }
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/lightning-and-teleportation/lightning-bolt.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList, ClassName } from '../../types/spell.types';

export const lightningBolt: Spell = {
	name: 'Lightning Bolt',
	premadeList: PremadeSpellList.LightningAndTeleportation,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [SpellList.Arcane, SpellList.Primal],
	availableClasses: [ClassName.Wizard, ClassName.Sorcerer],
	effects: [
		{
			title: 'Spell Attack',
			description:
				'You can make a Spell Check against the PD of a target within range. Hit: The target takes 2 Lightning damage.'
		},
		{
			title: 'Lightning Orb',
			description:
				'Crackling lightning appears between both of your hands. The electric energy can remain there for 10 minutes and harms neither you nor your equipment. The energy sheds Bright Light in a 10 Space radius. The Spell ends early if you dismiss it for free, if you cast it again, stop using both hands, or spend 1 AP to make a Spell Attack with it.'
		}
	],
	cantripPassive: 'You deal +1 damage against creatures that are wearing metal armor.',
	enhancements: [
		{ type: 'AP', cost: 1, name: 'Damage', description: 'You deal +1 Lightning damage.' },
		{ type: 'AP', cost: 1, name: 'Range', description: 'You increase the range by 5 Spaces.' },
		{
			type: 'AP',
			cost: 1,
			name: 'Chain',
			description:
				'Choose 1 additional target within 2 Spaces of the original target. Compare your Spell Check against the new target’s PD. Hit: The additional target takes 2 Lightning damage and is unaffected by features that allow you to deal more damage, including Heavy Hits and higher (except the Cantrip Passive). You can use this Enhancement multiple times, choosing an additional target within 2 Spaces of the previously chosen target.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/lightning-and-teleportation/misty-step.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const mistyStep: Spell = {
	name: 'Misty Step',
	premadeList: PremadeSpellList.LightningAndTeleportation,
	school: SpellSchool.Astromancy,
	isCantrip: false,
	cost: { ap: 1, mp: 1 },
	range: 'Self',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Teleport',
			description:
				'You are briefly surrounded by a silvery mist and attempt to teleport to a new location. Make a DC 20 Spell Check. Success: You teleport up to 5 Spaces to an unoccupied Space that you can see. Success (each 5): +2 Spaces. Failure: Only 3 Spaces.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Far Step',
			description: 'You increase the distance you can teleport by 4 Spaces.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/lightning-and-teleportation/returning-shock.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const returningShock: Spell = {
	name: 'Returning Shock',
	premadeList: PremadeSpellList.LightningAndTeleportation,
	school: SpellSchool.Destruction,
	isCantrip: false,
	cost: { ap: 1, mp: 1 },
	range: '15 Spaces',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Shock on Damage',
			description:
				'Trigger: You are damaged by a creature within range. Reaction: Make a Spell Check against the target’s PD. Hit: 3 Lightning damage.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Chain',
			description:
				'You can choose 1 additional target within 2 Spaces of the original target. Compare you Spell Check against the new target’s PD. Hit: The additional target takes 3 Lightning damage, and is unaffected by features that allow you to deal more damage, including Heavy Hits and higher. You can use this Enhancement multiple times, choosing an additional target within 2 Spaces of the previously chosen target.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/lightning-and-teleportation/shocking-grasp.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const shockingGrasp: Spell = {
	name: 'Shocking Grasp',
	premadeList: PremadeSpellList.LightningAndTeleportation,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '1 Space',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Shock',
			description:
				'Lightning springs from your hand to shock a creature within range. Make a Spell Check against the target’s PD, and you have ADV if they’re wearing armor made of metal. The target must make a Physical Save. Hit: 1 Lightning damage. Failed Save: Target can’t spend AP until the start of its next turn.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Lightning Lure',
			description:
				'The damage increases by 1 and the range becomes 5 Spaces. Additionally, if the target fails their Save you can pull them up to 3 spaces toward you.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/psychic-and-enchantment/bane.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const bane: Spell = {
	name: 'Bane',
	premadeList: PremadeSpellList.PsychicAndEnchantment,
	school: SpellSchool.Enchantment,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '5 Spaces',
	duration: '1 min (Sustained)',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Curse',
			description:
				'Choose 3 creatures that you can see within range. Make a Spell Check contested by their Mental Save. Failure: The target must roll a d4 and subtract the number from each Attack Check or Save they make until the Spell ends.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Targets',
			description: 'You increase the number of targets by 1.'
		},
		{
			type: 'MP',
			cost: 2,
			name: 'Dread',
			description: 'Targets subtract a d6 instead of a d4 from their Attack Checks and Saves.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/psychic-and-enchantment/befriend.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const befriend: Spell = {
	name: 'Befriend',
	premadeList: PremadeSpellList.PsychicAndEnchantment,
	school: SpellSchool.Enchantment,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: '1 min (Sustained)',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Charm Creature',
			description:
				'You attempt to Charm a creature within range. Choose a non-hostile creature that can see and hear you and make a Spell Check contested by the target’s Charisma Save. Success: The creature is Charmed by you for the duration or until it takes damage. When the Spell effect ends or you fail the Check, the creature realizes that you used magic to influence its mood and may become hostile toward you.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Hostile Charm',
			description: 'You can target even hostile creatures with the Spell.'
		},
		{
			type: 'MP',
			cost: 2,
			name: 'Clear Suspicion',
			description: 'The target doesn’t realize that magic was used on them when the Spell ends.'
		},
		{
			type: 'MP',
			cost: 2,
			name: 'More Friends',
			description: 'You can target an additional creature and increase the range by 10 Spaces.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/psychic-and-enchantment/command.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const command: Spell = {
	name: 'Command',
	premadeList: PremadeSpellList.PsychicAndEnchantment,
	school: SpellSchool.Enchantment,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '10 Spaces',
	duration: '1 Round',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Issue Command',
			description:
				'You speak a command to a creature that you can see within range that can hear you. You don’t have to see the creature if you’ve seen them within the last minute. Make a Spell Check contested by the target’s Charisma Save. Success: The creature immediately spends 2 AP to follow the command given, regardless of its usual AP cost. The creature can’t spend any resources (AP, SP, or MP) to modify the Action it takes. Ignoring a Command: The Spell has no effect if the target doesn’t understand your language, if it’s unable to follow your command, or if your command is directly harmful to itself. Choosing a Command: You can choose from the list of example commands below or improvise your own at the GM’s discretion. Move: The target moves up to its Speed to a location (or in a direction) of your choice. Prone: The target falls Prone. Drop: The target drops anything it’s holding. Attack: The target makes 1 Attack Check or Spell Check (your choice) that normally costs 1 AP. You choose the target of the Attack, which must be within the commanded creature’s range.'
		}
	],
	enhancements: [
		{ type: 'MP', cost: 1, name: 'Duration', description: 'You increase the duration by 1 Round.' },
		{ type: 'MP', cost: 2, name: 'Targets', description: 'You can add 1 additional target.' }
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/psychic-and-enchantment/index.ts
```typescript
import { psiBolt } from './psi-bolt';
import { message } from './message';
import { befriend } from './befriend';
import { psychicFear } from './psychic-fear';
import { bane } from './bane';
import { command } from './command';
import { sleep } from './sleep';

export const psychicAndEnchantmentSpells = [
	psiBolt,
	message,
	befriend,
	psychicFear,
	bane,
	command,
	sleep
];
```

## File: src/lib/rulesdata/spells-data/spells/psychic-and-enchantment/message.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const message: Spell = {
	name: 'Message',
	premadeList: PremadeSpellList.PsychicAndEnchantment,
	school: SpellSchool.Divination,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: '1 Round (each way)',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Whisper Message',
			description:
				'You point your finger toward a creature you can see within range and verbally whisper a message. The target hears the message in their head and they can reply back with a whisper that you can hear in your head. If you’re familiar with a creature, but you can’t see them or you know they’re beyond a wall or barrier, you can still target them with this Spell but the range is reduced by half.'
		}
	],
	enhancements: [
		{ type: 'MP', cost: 1, name: 'Range', description: 'You increase the range to 30 Spaces.' }
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/psychic-and-enchantment/psi-bolt.ts
```typescript
import { Spell, SpellSchool, SpellList, ClassName, PremadeSpellList } from '../../types/spell.types';

export const psiBolt: Spell = {
	name: 'Psi Bolt',
	premadeList: PremadeSpellList.PsychicAndEnchantment,
	school: SpellSchool.Destruction,
	isCantrip: true,
	cost: { ap: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [SpellList.Arcane],
	availableClasses: [ClassName.Wizard, ClassName.Sorcerer],
	effects: [
		{
			title: 'Spell Attack',
			description:
				'You can make a Spell Check against the PD of a target within range. Hit: The target takes 2 Psychic damage.'
		},
		{
			title: 'Headache',
			description:
				'You tear into the mind of a creature you can see within range and give them a mild headache for 1 minute.'
		}
	],
	cantripPassive: 'You deal +1 damage against creatures that are Dazed.',
	enhancements: [
		{ type: 'AP', cost: 1, name: 'Damage', description: 'You deal +1 Psychic damage.' },
		{ type: 'AP', cost: 1, name: 'Range', description: 'You increase the range by 5 Spaces.' },
		{
			type: 'AP',
			cost: 1,
			name: 'Dazed',
			description:
				'The target makes a Mental Save. Failure: Target becomes Dazed (DisADV on Mental Checks) on the next Mental Check it makes before the end of your next turn.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/psychic-and-enchantment/psychic-fear.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const psychicFear: Spell = {
	name: 'Psychic Fear',
	premadeList: PremadeSpellList.PsychicAndEnchantment,
	school: SpellSchool.Enchantment,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '10 Spaces',
	duration: 'Instant',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Discordant Melody',
			description:
				'You whisper a discordant melody, only audible to your target, to a creature of your choice within range that you can see and that can hear you, wracking it with terrible pain. Make a Spell Check against the target’s AD while it makes an Intelligence Save. Hit: The target takes 2 Psychic damage. Save Failure: If it has any AP, the target spends 1 AP to move as far as its Speed allows away from you. The creature doesn’t move into obviously dangerous ground, such as a fire or a pit.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Loud Whispers',
			description:
				'On a failed Save, the target to uses an additional 1 AP (if available) to move an additional number of Spaces away from you equal to its Speed.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/psychic-and-enchantment/sleep.ts
```typescript
import { Spell, SpellSchool, SpellList, PremadeSpellList } from '../../types/spell.types';

export const sleep: Spell = {
	name: 'Sleep',
	premadeList: PremadeSpellList.PsychicAndEnchantment,
	school: SpellSchool.Enchantment,
	isCantrip: false,
	cost: { ap: 2, mp: 1 },
	range: '15 Spaces',
	duration: '1 min',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [], // Not specified in PDF, assuming empty
	effects: [
		{
			title: 'Magical Slumber',
			description:
				'You attempt to force creatures within 4 Spaces of a point you choose within range to fall into a magical slumber. Make a DC 10 Spell Check. Success: This Spell can effect 10 HP worth of creatures. Success (each 5): +2 HP. Failure: 5 HP. Starting with the creature with the lowest current HP, each creature affected by this Spell falls Unconscious. Subtract each creature’s HP from the total before moving on to the creature with the next lowest current HP. A creature’s HP must be equal to or less than the remaining total for that creature to be affected. The sleep lasts until the Spell ends or another creature within 1 Space spends 1 AP to shake or slap the sleeping creature awake. Undead and creatures that don’t sleep aren’t affected by this spell.'
		}
	],
	enhancements: [
		{ type: 'MP', cost: 1, name: 'Slumber', description: 'You increase the HP affected by 10.' }
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/special-class-spells/index.ts
```typescript
import { sorcery } from './sorcery';

export const specialClassSpells = [sorcery];
```

## File: src/lib/rulesdata/spells-data/spells/special-class-spells/sorcery.ts
```typescript
import { Spell, SpellSchool, ClassName, PremadeSpellList } from '../../types/spell.types';

export const sorcery: Spell = {
	name: 'Sorcery',
	premadeList: PremadeSpellList.SpecialClass,
	school: SpellSchool.Transmutation,
	isCantrip: true,
	cost: { ap: 1 },
	range: '1 Space',
	duration: '1 min',
	spellLists: [], // Not specified in PDF, assuming empty
	availableClasses: [ClassName.Sorcerer],
	effects: [
		{
			title: 'Minor Wonder',
			description:
				'You manifest a minor wonder (Divine), a sign of supernatural power (Primal), or arcane prowess (Arcane) depending on which Spell List you have access to. When you gain this Spell, choose from the following types of energy: Fire, Water, Lightning, Earth, Holy, Unholy, or Arcane (which manifests as energy of a specific color). This chosen type will be the form this Spell’s energy takes. You create one of the following magical effects of your chosen energy type within range and can dismiss it by spending 1 AP: Your voice booms up to 3 times louder than normal. You summon harmless magic of your chosen energy type to swirl around you in a visual display. Your eyes glow with your chosen energy type.'
		}
	],
	enhancements: [
		{
			type: 'MP',
			cost: 1,
			name: 'Multiple Effects',
			description: 'You can have up to all 3 of the effects going at once.'
		}
	]
};
```

## File: src/lib/rulesdata/spells-data/spells/index.ts
```typescript
import { fireAndFlamesSpells } from './fire-and-flames';
import { iceAndIllusionsSpells } from './ice-and-illusions';
import { lightningAndTeleportationSpells } from './lightning-and-teleportation';
import { psychicAndEnchantmentSpells } from './psychic-and-enchantment';
import { holyAndRestorationSpells } from './holy-and-restoration';
import { specialClassSpells } from './special-class-spells';
import { fiendbornAncestrySpells } from './fiendborn-ancestry-spells';
import { additionalSpells } from './additional-spells';

export * from './fire-and-flames';
export * from './ice-and-illusions';
export * from './lightning-and-teleportation';
export * from './psychic-and-enchantment';
export * from './holy-and-restoration';
export * from './special-class-spells';
export * from './fiendborn-ancestry-spells';
export * from './additional-spells';

export const allSpells = [
	...fireAndFlamesSpells,
	...iceAndIllusionsSpells,
	...lightningAndTeleportationSpells,
	...psychicAndEnchantmentSpells,
	...holyAndRestorationSpells,
	...specialClassSpells,
	...fiendbornAncestrySpells,
	...additionalSpells
];
```

## File: src/lib/rulesdata/spells-data/types/spell.types.ts
```typescript
// ./spells-data/types/spell.types.ts

/**
 * @file spell.types.ts
 * @description This file contains the definitive TypeScript schemas and enumerations
 * for modeling all spells in the DC20 system.
 */

export enum SpellSchool {
	Astromancy = 'Astromancy',
	Conjuration = 'Conjuration',
	Destruction = 'Destruction',
	Divination = 'Divination',
	Enchantment = 'Enchantment',
	Illusion = 'Illusion',
	Protection = 'Protection',
	Restoration = 'Restoration',
	Transmutation = 'Transmutation',
	Abjuration = 'Abjuration'
}

export enum SpellList {
	Arcane = 'Arcane',
	Primal = 'Primal',
	Divine = 'Divine'
}

export enum ClassName {
	Wizard = 'Wizard',
	Sorcerer = 'Sorcerer',
	Cleric = 'Cleric',
	Druid = 'Druid'
}

export enum PremadeSpellList {
	FireAndFlames = 'Fire & Flames List',
	IceAndIllusions = 'Ice & Illusions List',
	LightningAndTeleportation = 'Lightning & Teleportation List',
	PsychicAndEnchantment = 'Psychic & Enchantment List',
	HolyAndRestoration = 'Holy & Restoration List',
	SpecialClass = 'Special Class Feature Spells',
	FiendbornAncestry = 'Fiendborn Ancestry Trait Spells',
	Additional = 'Additional Spells'
}

export interface SpellCost {
	ap: number;
	mp?: number;
}

export interface SpellEffect {
	title: string;
	description: string;
}

export interface SpellEnhancement {
	type: 'AP' | 'MP';
	cost: number;
	name: string;
	description: string;
}

export interface Spell {
	name: string;
	premadeList: PremadeSpellList;
	school: SpellSchool;
	isCantrip: boolean;
	isRitual?: boolean;
	cost: SpellCost;
	range: string;
	duration: string;
	spellLists: SpellList[];
	availableClasses: ClassName[];
	effects: SpellEffect[];
	cantripPassive?: string;
	enhancements: SpellEnhancement[];
}
```

## File: src/lib/rulesdata/ancestries.ts
```typescript
// src/lib/rulesdata/ancestries.ts

import type { IAncestry } from './types';

export const ancestriesData: IAncestry[] = [
	{
		id: 'human',
		name: 'Human',
		description:
			'Humans are the most common ancestry in the world, known for their adaptability and resilience.',
		defaultTraitIds: [
			'human_attribute_increase',
			'human_skill_expertise',
			'human_resolve',
			'human_undying'
		],
		expandedTraitIds: [
			'human_trade_expertise',
			'human_determination',
			'human_unbreakable',
			'human_attribute_decrease'
		]
	},
	{
		id: 'elf',
		name: 'Elf',
		description: 'Elves are graceful and long-lived beings with a deep connection to nature.',
		defaultTraitIds: ['elf_elven_will', 'elf_nimble', 'elf_agile_explorer', 'elf_discerning_sight'],
		expandedTraitIds: [
			'elf_quick_reactions',
			'elf_peerless_sight',
			'elf_climb_speed',
			'elf_speed_increase',
			'elf_trade_expertise_elf',
			'elf_plant_knowledge',
			'elf_brittle',
			'elf_frail',
			'elf_might_decrease'
		]
	},
	{
		id: 'dwarf',
		name: 'Dwarf',
		description:
			'Dwarves are a stout and resilient folk, known for their craftsmanship and deep connection to the earth.',
		defaultTraitIds: [
			'dwarf_tough',
			'dwarf_toxic_fortitude',
			'dwarf_physically_sturdy',
			'dwarf_iron_stomach'
		],
		expandedTraitIds: [
			'dwarf_thick_skinned',
			'dwarf_natural_combatant',
			'dwarf_stone_blood',
			'dwarf_minor_tremorsense',
			'dwarf_stubborn',
			'dwarf_trade_expertise',
			'dwarf_earthen_knowledge',
			'dwarf_charisma_attribute_decrease',
			'dwarf_short_legged'
		]
	},
	{
		id: 'halfling',
		name: 'Halfling',
		description:
			'Halflings are a small and nimble folk, known for their bravery and love of comfort.',
		defaultTraitIds: [
			'halfling_small_sized',
			'halfling_elusive',
			'halfling_bravery',
			'halfling_endurance',
			'halfling_deft_footwork',
			'halfling_beast_whisperer'
		],
		expandedTraitIds: [
			'halfling_beast_insight',
			'halfling_burst_of_bravery',
			'halfling_trade_expertise',
			'halfling_critter_knowledge',
			'halfling_brittle',
			'halfling_intelligence_attribute_decrease',
			'halfling_short_legged'
		]
	},
	{
		id: 'gnome',
		name: 'Gnome',
		description:
			'Gnomes are small and energetic folk, known for their inventiveness and connection to the feywild.',
		defaultTraitIds: [
			'gnome_small_sized',
			'gnome_escape_artist',
			'gnome_magnified_vision',
			'gnome_mental_clarity',
			'gnome_strong_minded',
			'gnome_predict_weather'
		],
		expandedTraitIds: [
			'gnome_mana_increase',
			'gnome_trapper',
			'gnome_lightning_insulation',
			'gnome_trade_expertise',
			'gnome_storm_knowledge',
			'gnome_agility_attribute_decrease',
			'gnome_short_legged'
		]
	},
	{
		id: 'orc',
		name: 'Orc',
		description:
			'Orcs are a strong and fierce folk, known for their martial prowess and intimidating presence.',
		defaultTraitIds: [
			'orc_cursed_mind',
			'orc_rush',
			'orc_brutal_strikes',
			'orc_tough',
			'orc_orcish_resolve',
			'orc_already_cursed'
		],
		expandedTraitIds: [
			'orc_intimidating_shout',
			'orc_dash',
			'orc_finishing_blow',
			'orc_imposing_presence',
			'orc_provocation',
			'orc_reckless'
		]
	},
	{
		id: 'dragonborn',
		name: 'Dragonborn',
		description:
			'Dragonborn are a proud and powerful folk, who trace their lineage back to dragons.',
		defaultTraitIds: [
			'dragonborn_darkvision',
			'dragonborn_draconic_resistance',
			'dragonborn_draconic_breath_weapon',
			'dragonborn_reptilian_superiority'
		],
		expandedTraitIds: [
			'dragonborn_mana_increase',
			'dragonborn_thick_skinned',
			'dragonborn_second_breath',
			'dragonborn_concussive_breath',
			'dragonborn_draconic_affinity',
			'dragonborn_dying_breath',
			'dragonborn_draconic_ward',
			'dragonborn_draconic_protection',
			'dragonborn_glide_speed',
			'dragonborn_guardians_bond'
		],
		origin: {
			// Draconic Origin
			prompt: 'Choose a Draconic Origin:',
			options: [
				'cold',
				'corrosion',
				'fire',
				'lightning',
				'poison',
				'sonic',
				'psychic',
				'radiant',
				'umbral'
			]
		}
	},
	{
		id: 'giantborn',
		name: 'Giantborn',
		description: 'Giantborn are a large and powerful folk, who trace their lineage back to giants.',
		defaultTraitIds: [
			'giantborn_tough',
			'giantborn_powerful_build',
			'giantborn_unstoppable',
			'giantborn_giants_resolve',
			'giantborn_unyielding_movement'
		],
		expandedTraitIds: [
			'giantborn_giants_fortitude',
			'giantborn_strong_body',
			'giantborn_mighty_hurl',
			'giantborn_titanic_toss',
			'giantborn_mighty_leap',
			'giantborn_brute',
			'giantborn_heavy_riser',
			'giantborn_clumsiness',
			'giantborn_intelligence_attribute_decrease'
		]
	},
	{
		id: 'angelborn',
		name: 'Angelborn',
		description: 'Angelborn are a celestial folk, known for their grace and divine connection.',
		defaultTraitIds: [
			'angelborn_radiant_resistance',
			'angelborn_celestial_magic',
			'angelborn_healing_touch',
			'angelborn_divine_glow'
		],
		expandedTraitIds: [
			'angelborn_mana_increase',
			'angelborn_celestial_clarity',
			'angelborn_angelic_insight',
			'angelborn_gift_of_the_angels',
			'angelborn_blinding_light',
			'angelborn_glide_speed',
			'angelborn_pacifist',
			'angelborn_umbral_weakness'
		],
		variantTraits: [
			// Fallen Angelborn
			{
				id: 'angelborn_fallen',
				name: 'Fallen',
				cost: 0,
				description: 'You can now spend your Ancestry Points on Fiendborn Traits.'
			}
		]
	},
	{
		id: 'fiendborn',
		name: 'Fiendborn',
		description: 'Fiendborn are a fiendish folk, known for their cunning and infernal connection.',
		defaultTraitIds: [
			'fiendborn_fiendish_resistance',
			'fiendborn_fiendish_magic',
			'fiendborn_darkvision',
			'fiendborn_lights_bane'
		],
		expandedTraitIds: [
			'fiendborn_mana_increase',
			'fiendborn_silver_tongued',
			'fiendborn_fiendish_aura',
			'fiendborn_superior_darkvision',
			'fiendborn_infernal_bravery',
			'fiendborn_intimidator',
			'fiendborn_charming_gaze',
			'fiendborn_glide_speed',
			'fiendborn_radiant_weakness',
			'fiendborn_divine_dampening'
		],
		origin: {
			// Fiendish Origin
			prompt: 'Choose a Fiendish Origin:',
			options: ['cold', 'corrosion', 'fire', 'poison', 'umbral']
		},
		variantTraits: [
			// Fiendborn Redemption
			{
				id: 'fiendborn_redeemed',
				name: 'Redeemed',
				cost: 0,
				description: 'You can now spend your Ancestry Points on Angelborn Traits.'
			}
		]
	},
	{
		id: 'beastborn',
		name: 'Beastborn',
		description: 'Beastborn are a diverse folk, who take on the characteristics of various beasts.',
		defaultTraitIds: [], // Beastborn has no Default Traits
		expandedTraitIds: [
			// Listed under Beast Traits sections in PDF
			// Senses
			'beastborn_darkvision',
			'beastborn_echolocation',
			'beastborn_keen_sense',
			'beastborn_sunlight_sensitivity',
			// Mobility
			'beastborn_quick_reactions',
			'beastborn_climb_speed',
			'beastborn_spider_climb',
			'beastborn_web_walk',
			'beastborn_water_breathing',
			'beastborn_swim_speed',
			'beastborn_speed_increase',
			'beastborn_sprint',
			'beastborn_charge',
			'beastborn_burrow_speed',
			// Jumping
			'beastborn_jumper',
			'beastborn_strong_jumper',
			// Flying
			'beastborn_glide_speed',
			'beastborn_limited_flight',
			'beastborn_full_flight',
			'beastborn_flyby',
			'beastborn_stealth_feathers',
			'beastborn_winged_arms',
			// Body
			'beastborn_tough',
			'beastborn_thick_skinned',
			'beastborn_powerful_build',
			'beastborn_long_limbed',
			'beastborn_secondary_arms',
			'beastborn_prehensile_appendage',
			'beastborn_hazardous_hide',
			'beastborn_natural_armor',
			'beastborn_hard_shell',
			'beastborn_shell_retreat',
			'beastborn_camouflage',
			'beastborn_prowler',
			'beastborn_cold_resistance',
			'beastborn_fire_resistance',
			'beastborn_short_legged',
			'beastborn_small_sized',
			'beastborn_reckless',
			// Natural Weapons
			'beastborn_natural_weapon',
			'beastborn_extended_natural_weapon',
			'beastborn_natural_projectile',
			'beastborn_natural_weapon_passive',
			'beastborn_rend',
			'beastborn_retractable_natural_weapon',
			'beastborn_venomous_natural_weapon',
			// Miscellaneous
			'beastborn_fast_reflexes',
			'beastborn_mimicry',
			'beastborn_intimidating_shout',
			'beastborn_toxic_fortitude',
			'beastborn_shoot_webs'
		],
		origin: {
			// Beastborn Origin
			prompt: 'Choose a type of Beast you are modeled after:',
			options: [] // Options are open-ended, based on GM/player choice
		}
	}
];
```

## File: src/lib/rulesdata/attributes.ts
```typescript
// src/lib/rulesdata/attributes.ts

import type { IAttributeData } from './types';
// To be placed in: src/lib/rulesdata/attributes.ts
export const attributesData: IAttributeData[] = [
	// TODO: Replace bracketed placeholders with accurate information from the DC20 Beta 0.9.5 rulebook.
	{
		id: 'might',
		name: 'Might',
		description: 'Your Strength of Body.',
		derivedStats: [
			// Examples, verify/adjust based on actual rules for each attribute
			{ statName: 'AD (area defense)', formula: '8 + CM + Might + Charisma + Bonuses' },
			{ statName: 'Max HP', formula: 'Class HP + Might + Ancestry HP' }
		]
	},
	{
		id: 'agility',
		name: 'Agility',
		description: 'Your Balance, Nimbleness, and Dexterity.',
		derivedStats: [
			{ statName: 'PD (precision defense)', formula: '8 + CM + Agility + Intelligence + Bonuses' },
			{ statName: 'Jump Distance', formula: 'Agility (min 1)' },
			{ statName: 'Initiative', formula: 'CM + Agility' },
			{ statName: 'Movement Speed', formula: '5 spaces (base) + trait modifiers' }
		]
	},
	{
		id: 'charisma',
		name: 'Charisma',
		description: 'Your Charm, Presence, Persuasiveness, and Force of Will.',
		derivedStats: [{ statName: 'Grit Points', formula: '2 + Charisma' }]
	},
	{
		id: 'intelligence',
		name: 'Intelligence',
		description: 'Your Reasoning, Understanding, and Wisdom.',
		derivedStats: [{ statName: 'Base Skill Points', formula: '5 + Intelligence' }]
	}
];
```

## File: src/lib/rulesdata/death.ts
```typescript
/**
 * DC20 Death & Health Threshold Rules
 * Based on official DC20 rulebook pages for Health Points & Death's Door
 */

export interface HealthStatus {
	status: 'healthy' | 'bloodied' | 'well-bloodied' | 'deaths-door' | 'dead';
	description: string;
	effects: string[];
}

export interface DeathSaveResult {
	success: boolean;
	effect: string;
}

/**
 * Calculate current health status based on HP
 */
export function getHealthStatus(
	currentHP: number,
	maxHP: number,
	deathThreshold: number
): HealthStatus {
	const halfHP = Math.floor(maxHP / 2);
	const quarterHP = Math.floor(maxHP / 4);

	if (currentHP <= deathThreshold) {
		return {
			status: 'dead',
			description: 'Dead',
			effects: ['Character is dead']
		};
	}

	if (currentHP <= 0) {
		return {
			status: 'deaths-door',
			description: "Death's Door",
			effects: [
				'Immediately gain Exhaustion 1',
				'Action Point Limit: 1 AP until end of next turn or restored to 1 HP',
				"Can't Concentrate",
				'Death Saves at end of turns (d20, 10+ succeeds)',
				'Failure: 1 True damage, Critical Failure: Unconscious until 1 HP',
				'Critical Success: Restored to 1 HP'
			]
		};
	}

	if (currentHP <= quarterHP) {
		return {
			status: 'well-bloodied',
			description: 'Well-Bloodied',
			effects: ['HP is 1/4 or lower of maximum', 'Subject to Well-Bloodied effects from abilities']
		};
	}

	if (currentHP <= halfHP) {
		return {
			status: 'bloodied',
			description: 'Bloodied',
			effects: ['HP is 1/2 or lower of maximum', 'Subject to Bloodied effects from abilities']
		};
	}

	return {
		status: 'healthy',
		description: 'Healthy',
		effects: ['No health penalties']
	};
}

/**
 * Calculate Death Threshold
 * Death Threshold = 0 HP minus Prime Modifier + Combat Mastery
 */
export function calculateDeathThreshold(primeModifier: number, combatMastery: number): number {
	return -(primeModifier + combatMastery);
}

/**
 * Death Save mechanics
 */
export function processDeathSave(roll: number): DeathSaveResult {
	if (roll === 1) {
		return {
			success: false,
			effect:
				'Critical Failure: Take 1 True damage and become Unconscious until restored to 1 HP or higher'
		};
	}

	if (roll === 20) {
		return {
			success: true,
			effect: 'Critical Success: Restored to 1 HP'
		};
	}

	if (roll >= 10) {
		return {
			success: true,
			effect: 'Success: Become Stabilized'
		};
	}

	return {
		success: false,
		effect: 'Failure: Take 1 True damage'
	};
}

/**
 * Death's Door After Combat rules
 */
export function getDeathsDoorAfterCombat(): string[] {
	return [
		"When Combat ends, any creature on Death's Door must immediately make a Death Save",
		'They repeat this Death Save every 12 seconds until they become Stabilized, are restored to 1 HP or higher, or die',
		'Failure: Take 1 True damage and fall Unconscious until Stabilized',
		'Success: Become Stabilized'
	];
}

/**
 * Stabilization rules
 */
export function getStabilizationRules(): string[] {
	return [
		"A creature that takes the Medicine Action and succeeds on a DC 10 Medicine Check can Stabilize a creature on Death's Door",
		"A Stabilized creature doesn't make Death Saves while on Death's Door",
		"A creature remains Stabilized until it's restored to 1 HP or takes damage"
	];
}

/**
 * Continuous damage rules (Bleeding, Burning)
 */
export function getContinuousDamageRules(): string[] {
	return [
		"Continuous damage (such as Bleeding and Burning) does not affect you while on Death's Door",
		"You still have these conditions on you, but they don't deal damage unless you're above 0 HP"
	];
}

/**
 * Death's Door threshold tracking for UI
 * Returns how many "steps" until death based on current HP and death threshold
 */
export function getDeathSteps(
	currentHP: number,
	deathThreshold: number
): {
	currentStep: number;
	maxSteps: number;
	isDead: boolean;
} {
	if (currentHP > 0) {
		return { currentStep: 0, maxSteps: 0, isDead: false };
	}

	const maxSteps = Math.abs(deathThreshold);
	const currentStep = Math.abs(currentHP);
	const isDead = currentHP <= deathThreshold;

	return { currentStep, maxSteps, isDead };
}
```

## File: src/lib/rulesdata/inventoryItems.ts
```typescript
// inventoryItems.ts

//==============================================================================
// SCHEMAS / TYPES
//==============================================================================

export enum ItemType {
	Weapon = 'Weapon',
	Armor = 'Armor',
	Shield = 'Shield',
	AdventuringSupply = 'Adventuring Supply',
	Potion = 'Potion'
}

export enum WeaponType {
	Melee = 'Melee',
	Ranged = 'Ranged',
	Special = 'Special'
}

export enum WeaponHandedness {
	OneHanded = 'One-Handed',
	Versatile = 'Versatile',
	TwoHanded = 'Two-Handed'
}

export enum WeaponStyle {
	Axe = 'Axe',
	Fist = 'Fist',
	Hammer = 'Hammer',
	Pick = 'Pick',
	Spear = 'Spear',
	Sword = 'Sword',
	Whip = 'Whip',
	Chained = 'Chained',
	Bow = 'Bow',
	Crossbow = 'Crossbow',
	AxePick = 'Axe/Pick',
	HammerPick = 'Hammer/Pick',
	SwordSpear = 'Sword/Spear',
	ChainedHammer = 'Chained/Hammer',
	Staff = 'Staff'
}

export enum DamageType {
	Slashing = 'S',
	Piercing = 'P',
	Bludgeoning = 'B',
	SlashingOrPiercing = 'S/P',
	BludgeoningOrPiercing = 'B/P'
}

// Based on properties from pages 76 & 77
export type WeaponProperty =
	| 'Ammo'
	| 'Concealable'
	| 'Guard'
	| 'Heavy'
	| 'Impact'
	| 'Long-Ranged'
	| 'Multi-Faceted'
	| 'Reach'
	| 'Reload'
	| 'Silent'
	| 'Toss (5/10)'
	| 'Thrown (10/20)'
	| 'Two-Handed'
	| 'Unwieldy'
	| 'Versatile'
	| 'Returning'
	| 'Capture (5/10)'
	| 'Capture (10/20)'
	| 'Range (15/45)'
	| 'Range (30/90)';

export interface Weapon {
	itemType: ItemType.Weapon;
	name: string;
	type: WeaponType;
	style: WeaponStyle | WeaponStyle[];
	handedness: WeaponHandedness;
	damage: string; // Using string to accommodate '0 B' etc.
	properties: WeaponProperty[];
}

export enum ArmorType {
	Light = 'Light Armor',
	Heavy = 'Heavy Armor'
}

export interface Armor {
	itemType: ItemType.Armor;
	name: string;
	type: ArmorType;
	pdBonus: number;
	adBonus: number;
	pdr?: 'Half';
	speedPenalty: number;
	agilityCheckDisadvantage: boolean;
}

export enum ShieldType {
	Light = 'Light Shield',
	Heavy = 'Heavy Shield'
}

export type ShieldProperty = 'Grasp' | 'Toss (5/10)' | 'Mounted';

export interface Shield {
	itemType: ItemType.Shield;
	name: string;
	type: ShieldType;
	pdBonus: number;
	adBonus: number;
	speedPenalty: number;
	agilityCheckDisadvantage: boolean;
	properties?: ShieldProperty[];
}

export interface AdventuringSupply {
	itemType: ItemType.AdventuringSupply;
	name: string;
	description: string;
	price?: string; // e.g., "5g"
}

export interface HealingPotion {
	itemType: ItemType.Potion;
	name: string;
	level: number;
	healing: string; // e.g., "2 HP"
	price: number; // in gold pieces (g)
}

// Union type for all inventory items
export type InventoryItem = Weapon | Armor | Shield | AdventuringSupply | HealingPotion;

//==============================================================================
// INVENTORY DATA
//==============================================================================

export const weapons: Weapon[] = [
	// Melee Weapons - One-Handed
	{
		itemType: ItemType.Weapon,
		name: 'Sickle',
		type: WeaponType.Melee,
		style: WeaponStyle.Axe,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 S',
		properties: ['Concealable', 'Toss (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Hand Axe',
		type: WeaponType.Melee,
		style: WeaponStyle.Axe,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 S',
		properties: ['Concealable', 'Toss (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Throwing Star',
		type: WeaponType.Melee,
		style: WeaponStyle.Axe,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 S',
		properties: ['Concealable', 'Toss (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Brass Knuckles',
		type: WeaponType.Melee,
		style: WeaponStyle.Fist,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 B',
		properties: ['Concealable', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Club',
		type: WeaponType.Melee,
		style: WeaponStyle.Hammer,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 B',
		properties: ['Concealable', 'Toss (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Light Hammer',
		type: WeaponType.Melee,
		style: WeaponStyle.Hammer,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 B',
		properties: ['Impact', 'Toss (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Dart',
		type: WeaponType.Melee,
		style: WeaponStyle.Pick,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 P',
		properties: ['Concealable', 'Toss (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Mining Pick',
		type: WeaponType.Melee,
		style: WeaponStyle.Pick,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 P',
		properties: ['Concealable', 'Toss (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Javelin',
		type: WeaponType.Melee,
		style: WeaponStyle.Spear,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 P',
		properties: ['Thrown (10/20)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Throwing Dagger',
		type: WeaponType.Melee,
		style: WeaponStyle.Sword,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 S',
		properties: ['Concealable', 'Toss (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Short Sword',
		type: WeaponType.Melee,
		style: WeaponStyle.Sword,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 S',
		properties: ['Guard', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Rapier',
		type: WeaponType.Melee,
		style: [WeaponStyle.Sword, WeaponStyle.Spear],
		handedness: WeaponHandedness.OneHanded,
		damage: '1 S/P',
		properties: ['Guard', 'Multi-Faceted']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Chain Whip',
		type: WeaponType.Melee,
		style: WeaponStyle.Whip,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 S',
		properties: ['Reach', 'Impact']
	},

	// Melee Weapons - Versatile
	{
		itemType: ItemType.Weapon,
		name: 'Battleaxe',
		type: WeaponType.Melee,
		style: WeaponStyle.Axe,
		handedness: WeaponHandedness.Versatile,
		damage: '1 S',
		properties: ['Versatile', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Flail',
		type: WeaponType.Melee,
		style: WeaponStyle.Chained,
		handedness: WeaponHandedness.Versatile,
		damage: '1 B',
		properties: ['Versatile', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Morningstar',
		type: WeaponType.Melee,
		style: [WeaponStyle.Hammer, WeaponStyle.Pick],
		handedness: WeaponHandedness.Versatile,
		damage: '1 B/P',
		properties: ['Versatile', 'Multi-Faceted']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Warhammer',
		type: WeaponType.Melee,
		style: [WeaponStyle.Hammer, WeaponStyle.Pick],
		handedness: WeaponHandedness.Versatile,
		damage: '1 B/P',
		properties: ['Versatile', 'Multi-Faceted']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Pickaxe',
		type: WeaponType.Melee,
		style: WeaponStyle.Pick,
		handedness: WeaponHandedness.Versatile,
		damage: '1 P',
		properties: ['Versatile', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Spear',
		type: WeaponType.Melee,
		style: WeaponStyle.Spear,
		handedness: WeaponHandedness.Versatile,
		damage: '1 P',
		properties: ['Versatile', 'Toss (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Long Spear',
		type: WeaponType.Melee,
		style: WeaponStyle.Spear,
		handedness: WeaponHandedness.Versatile,
		damage: '1 P',
		properties: ['Versatile', 'Reach']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Quarterstaff',
		type: WeaponType.Melee,
		style: WeaponStyle.Staff,
		handedness: WeaponHandedness.Versatile,
		damage: '1 B',
		properties: ['Versatile', 'Guard']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Longsword',
		type: WeaponType.Melee,
		style: WeaponStyle.Sword,
		handedness: WeaponHandedness.Versatile,
		damage: '1 S',
		properties: ['Versatile', 'Guard']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Bastard Sword',
		type: WeaponType.Melee,
		style: WeaponStyle.Sword,
		handedness: WeaponHandedness.Versatile,
		damage: '1 S',
		properties: ['Versatile', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Bull Whip',
		type: WeaponType.Melee,
		style: WeaponStyle.Whip,
		handedness: WeaponHandedness.Versatile,
		damage: '1 S',
		properties: ['Versatile', 'Reach', 'Unwieldy', 'Impact']
	},

	// Melee Weapons - Two-Handed
	{
		itemType: ItemType.Weapon,
		name: 'Scythe',
		type: WeaponType.Melee,
		style: WeaponStyle.Axe,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 S',
		properties: ['Two-Handed', 'Heavy', 'Reach']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Greataxe',
		type: WeaponType.Melee,
		style: WeaponStyle.Axe,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 S',
		properties: ['Two-Handed', 'Heavy', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Halberd',
		type: WeaponType.Melee,
		style: [WeaponStyle.Axe, WeaponStyle.Pick],
		handedness: WeaponHandedness.TwoHanded,
		damage: '1 S/P',
		properties: ['Two-Handed', 'Multi-Faceted', 'Reach', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'War Flail',
		type: WeaponType.Melee,
		style: WeaponStyle.Chained,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 B',
		properties: ['Two-Handed', 'Heavy', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Meteor Hammer',
		type: WeaponType.Melee,
		style: [WeaponStyle.Chained, WeaponStyle.Hammer],
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 B',
		properties: ['Two-Handed', 'Heavy', 'Multi-Faceted', 'Reach', 'Unwieldy']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Greatmaul',
		type: WeaponType.Melee,
		style: WeaponStyle.Hammer,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 B',
		properties: ['Two-Handed', 'Heavy', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Pike',
		type: WeaponType.Melee,
		style: WeaponStyle.Spear,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 P',
		properties: ['Two-Handed', 'Heavy', 'Reach', 'Impact', 'Unwieldy']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Longpole',
		type: WeaponType.Melee,
		style: WeaponStyle.Staff,
		handedness: WeaponHandedness.TwoHanded,
		damage: '1 B',
		properties: ['Two-Handed', 'Guard', 'Reach', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Glaive',
		type: WeaponType.Melee,
		style: WeaponStyle.Sword,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 S',
		properties: ['Two-Handed', 'Heavy', 'Reach']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Greatsword',
		type: WeaponType.Melee,
		style: WeaponStyle.Sword,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 S',
		properties: ['Two-Handed', 'Heavy', 'Impact']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Great Whip',
		type: WeaponType.Melee,
		style: WeaponStyle.Whip,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 S',
		properties: ['Two-Handed', 'Heavy', 'Reach', 'Impact', 'Unwieldy']
	},

	// Ranged Weapons
	{
		itemType: ItemType.Weapon,
		name: 'Sling',
		type: WeaponType.Ranged,
		style: WeaponStyle.Bow,
		handedness: WeaponHandedness.TwoHanded,
		damage: '1 B',
		properties: ['Ammo', 'Unwieldy', 'Impact', 'Range (15/45)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Shortbow',
		type: WeaponType.Ranged,
		style: WeaponStyle.Bow,
		handedness: WeaponHandedness.TwoHanded,
		damage: '1 P',
		properties: ['Two-Handed', 'Ammo', 'Silent', 'Range (15/45)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Longbow',
		type: WeaponType.Ranged,
		style: WeaponStyle.Bow,
		handedness: WeaponHandedness.TwoHanded,
		damage: '1 P',
		properties: ['Two-Handed', 'Ammo', 'Unwieldy', 'Impact', 'Long-Ranged']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Greatbow',
		type: WeaponType.Ranged,
		style: WeaponStyle.Bow,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 P',
		properties: ['Two-Handed', 'Ammo', 'Unwieldy', 'Heavy', 'Range (15/45)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Blowgun (Needle)',
		type: WeaponType.Ranged,
		style: WeaponStyle.Crossbow,
		handedness: WeaponHandedness.TwoHanded,
		damage: '1 P',
		properties: ['Two-Handed', 'Ammo', 'Silent', 'Range (15/45)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Hand Crossbow',
		type: WeaponType.Ranged,
		style: WeaponStyle.Crossbow,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 P',
		properties: ['Ammo', 'Reload', 'Range (15/45)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Light Crossbow',
		type: WeaponType.Ranged,
		style: WeaponStyle.Crossbow,
		handedness: WeaponHandedness.TwoHanded,
		damage: '2 P',
		properties: ['Two-Handed', 'Ammo', 'Reload', 'Impact', 'Range (15/45)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Heavy Crossbow',
		type: WeaponType.Ranged,
		style: WeaponStyle.Crossbow,
		handedness: WeaponHandedness.TwoHanded,
		damage: '3 P',
		properties: ['Two-Handed', 'Ammo', 'Unwieldy', 'Reload', 'Heavy', 'Range (15/45)']
	},

	// Special Weapons
	{
		itemType: ItemType.Weapon,
		name: 'Bolas',
		type: WeaponType.Special,
		style: WeaponStyle.Chained,
		handedness: WeaponHandedness.OneHanded,
		damage: '0 B',
		properties: ['Thrown (10/20)', 'Capture (10/20)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Net',
		type: WeaponType.Special,
		style: WeaponStyle.Chained,
		handedness: WeaponHandedness.Versatile,
		damage: '0 B',
		properties: ['Toss (5/10)', 'Versatile', 'Capture (5/10)']
	},
	{
		itemType: ItemType.Weapon,
		name: 'Boomerang',
		type: WeaponType.Special,
		style: WeaponStyle.Hammer,
		handedness: WeaponHandedness.OneHanded,
		damage: '1 B',
		properties: ['Toss (5/10)', 'Returning']
	}
];

export const armors: Armor[] = [
	// Light Armor
	{
		itemType: ItemType.Armor,
		name: 'Light Defensive Armor',
		type: ArmorType.Light,
		pdBonus: 1,
		adBonus: 1,
		speedPenalty: 0,
		agilityCheckDisadvantage: false
	},
	{
		itemType: ItemType.Armor,
		name: 'Light Deflecting Armor',
		type: ArmorType.Light,
		pdBonus: 2,
		adBonus: 0,
		speedPenalty: 0,
		agilityCheckDisadvantage: false
	},
	{
		itemType: ItemType.Armor,
		name: 'Light Fortified Armor',
		type: ArmorType.Light,
		pdBonus: 0,
		adBonus: 2,
		speedPenalty: 0,
		agilityCheckDisadvantage: false
	},

	// Heavy Armor
	{
		itemType: ItemType.Armor,
		name: 'Heavy Defensive Armor',
		type: ArmorType.Heavy,
		pdBonus: 1,
		adBonus: 1,
		pdr: 'Half',
		speedPenalty: -1,
		agilityCheckDisadvantage: true
	},
	{
		itemType: ItemType.Armor,
		name: 'Heavy Deflecting Armor',
		type: ArmorType.Heavy,
		pdBonus: 2,
		adBonus: 0,
		pdr: 'Half',
		speedPenalty: -1,
		agilityCheckDisadvantage: true
	},
	{
		itemType: ItemType.Armor,
		name: 'Heavy Fortified Armor',
		type: ArmorType.Heavy,
		pdBonus: 0,
		adBonus: 2,
		pdr: 'Half',
		speedPenalty: -1,
		agilityCheckDisadvantage: true
	},
	{
		itemType: ItemType.Armor,
		name: 'Highly Defensive Armor',
		type: ArmorType.Heavy,
		pdBonus: 2,
		adBonus: 2,
		pdr: 'Half',
		speedPenalty: -1,
		agilityCheckDisadvantage: true
	}
];

export const shields: Shield[] = [
	// Light Shields
	{
		itemType: ItemType.Shield,
		name: 'Buckler',
		type: ShieldType.Light,
		pdBonus: 1,
		adBonus: 0,
		speedPenalty: 0,
		agilityCheckDisadvantage: false,
		properties: ['Grasp']
	},
	{
		itemType: ItemType.Shield,
		name: 'Round Shield',
		type: ShieldType.Light,
		pdBonus: 0,
		adBonus: 1,
		speedPenalty: 0,
		agilityCheckDisadvantage: false,
		properties: ['Toss (5/10)']
	},
	{
		itemType: ItemType.Shield,
		name: 'Heater Shield',
		type: ShieldType.Light,
		pdBonus: 1,
		adBonus: 1,
		speedPenalty: 0,
		agilityCheckDisadvantage: false,
		properties: []
	},

	// Heavy Shields
	{
		itemType: ItemType.Shield,
		name: 'Kite Shield',
		type: ShieldType.Heavy,
		pdBonus: 1,
		adBonus: 2,
		speedPenalty: -1,
		agilityCheckDisadvantage: true,
		properties: ['Mounted']
	},
	{
		itemType: ItemType.Shield,
		name: 'Tower Shield',
		type: ShieldType.Heavy,
		pdBonus: 2,
		adBonus: 2,
		speedPenalty: -1,
		agilityCheckDisadvantage: true,
		properties: []
	}
];

export const adventuringSupplies: AdventuringSupply[] = [
	{
		itemType: ItemType.AdventuringSupply,
		name: 'Gauntlet',
		description:
			'Wearing a Gauntlet gives your Unarmed Strikes with that hand the Impact Weapon Property (+1 damage on Heavy Hits).',
		price: '5g'
	},
	{
		itemType: ItemType.AdventuringSupply,
		name: 'First Aid Kit',
		description:
			"A fully stocked kit contains 5 charges, which can be spent to treat a creature's wounds or cure an ailment by taking the Object Action."
	}
];

export const healingPotions: HealingPotion[] = [
	{
		itemType: ItemType.Potion,
		name: '1st Level Healing Potion',
		level: 1,
		healing: '2 HP',
		price: 10
	},
	{
		itemType: ItemType.Potion,
		name: '2nd Level Healing Potion',
		level: 2,
		healing: '4 HP',
		price: 25
	},
	{
		itemType: ItemType.Potion,
		name: '3rd Level Healing Potion',
		level: 3,
		healing: '6 HP',
		price: 40
	},
	{
		itemType: ItemType.Potion,
		name: '4th Level Healing Potion',
		level: 4,
		healing: '8 HP',
		price: 60
	},
	{
		itemType: ItemType.Potion,
		name: '5th Level Healing Potion',
		level: 5,
		healing: '10 HP',
		price: 100
	}
];

export const allItems = [
	...weapons,
	...armors,
	...shields,
	...adventuringSupplies,
	...healingPotions
];
```

## File: src/lib/rulesdata/knowledge.ts
```typescript
import { ITradeData } from './types';

export const knowledgeData: ITradeData[] = [
	{
		id: 'arcana',
		name: 'Arcana',
		attributeAssociation: 'intelligence',
		description:
			'Arcana is the study of magic, its history, theories, and the planes of existence. This includes recalling information about spells, magical creatures, and magical phenomena.',
		tools: undefined // Knowledge trade
	},
	{
		id: 'history',
		name: 'History',
		attributeAssociation: 'intelligence',
		description:
			'History is the study of past events, ancient lore, and how civilizations have shaped the present. This includes recalling information about historical figures, events, and cultures.',
		tools: undefined // Knowledge trade
	},
	{
		id: 'nature',
		name: 'Nature',
		attributeAssociation: 'intelligence',
		description:
			'Nature is the study of the natural world, including plants, animals, weather patterns, and natural phenomena.',
		tools: undefined // Knowledge trade
	},
	{
		id: 'religion',
		name: 'Religion',
		attributeAssociation: 'intelligence',
		description:
			'Religion is the knowledge of deities, religious practices, and holy texts. This includes understanding religious beliefs, rituals, and scriptures.',
		tools: undefined // Knowledge trade
	},
	{
		id: 'occultism',
		name: 'Occultism',
		attributeAssociation: 'intelligence',
		description:
			'Occultism is the study of hidden mysteries, forbidden lore, and supernatural phenomena beyond normal magical understanding.',
		tools: undefined // Knowledge trade
	}
];
```

## File: src/lib/rulesdata/languages.ts
```typescript
import type { ILanguageData } from './types';

export const languagesData: ILanguageData[] = [
	{
		id: 'common',
		name: 'Common',
		type: 'standard', // From DC20 p.18
		description:
			'Common is the most simple and universal language in the world. All Player Characters start Fluent in Common.'
	},
	{
		id: 'elvish',
		name: 'Elvish',
		type: 'standard', // From DC20 p.18
		description: 'Elvish is a fluid and melodic language spoken by Elves. Typical Speakers: Elves.'
	},
	{
		id: 'draconic',
		name: 'Draconic',
		type: 'exotic', // From DC20 p.18
		description:
			'Draconic is a harsh, guttural language spoken by Dragons and Dragonkin. Typical Speakers: Dragons, Dragonkin.'
	},
	{
		id: 'dwarvish',
		name: 'Dwarvish',
		type: 'standard', // From DC20 p.18
		description:
			'Dwarvish is a language of hard consonants and guttural sounds, spoken by Dwarves. Typical Speakers: Dwarves.'
	},
	{
		id: 'gnomish',
		name: 'Gnomish',
		type: 'standard', // From DC20 p.18
		description:
			'Gnomish is a language filled with trills and clicks, spoken by Gnomes. Typical Speakers: Gnomes.'
	},
	{
		id: 'goblin',
		name: 'Goblin',
		type: 'standard', // From DC20 p.18
		description:
			'Goblin is a rough and simple language spoken by Goblins, Hobgoblins, and Bugbears. Typical Speakers: Goblins, Hobgoblins, Bugbears.'
	},
	{
		id: 'halfling',
		name: 'Halfling',
		type: 'standard', // From DC20 p.18
		description:
			'Halfling is a soft and gentle language spoken by Halflings. Typical Speakers: Halflings.'
	},
	{
		id: 'orcish',
		name: 'Orcish',
		type: 'standard', // From DC20 p.18
		description: 'Orcish is a brutal and harsh language spoken by Orcs. Typical Speakers: Orcs.'
	},
	{
		id: 'primordial',
		name: 'Primordial',
		type: 'exotic', // From DC20 p.18
		description: 'Primordial is the language of Elementals. Typical Speakers: Elementals.'
	},
	{
		id: 'celestial',
		name: 'Celestial',
		type: 'exotic', // From DC20 p.18
		description: 'Celestial is the language of Celestials. Typical Speakers: Celestials.'
	},
	{
		id: 'abyssal',
		name: 'Abyssal',
		type: 'exotic', // From DC20 p.18
		description: 'Abyssal is the language of Demons. Typical Speakers: Demons.'
	},
	{
		id: 'infernal',
		name: 'Infernal',
		type: 'exotic', // From DC20 p.18
		description: 'Infernal is the language of Devils. Typical Speakers: Devils.'
	},
	{
		id: 'undercommon',
		name: 'Undercommon',
		type: 'exotic', // From DC20 p.18
		description:
			'Undercommon is a language spoken by inhabitants of the Underdark, such as Drow. Typical Speakers: Drow, Underdark inhabitants.'
	}
];
```

## File: src/lib/rulesdata/maneuvers.ts
```typescript
/**
 * @file maneuvers.ts
 * @description Contains the schemas and a complete list of all Martial Maneuvers
 * from the DC20 Beta 0.9.5 rulebook (pages 48-50).
 */

//==============================================================================
// SCHEMAS / TYPES
//==============================================================================

/**
 * Categorizes maneuvers based on their function as described in the rulebook.
 */
export enum ManeuverType {
	Attack = 'Attack',
	Save = 'Save',
	Grapple = 'Grapple',
	Defense = 'Defense'
}

/**
 * Represents the resource cost of a maneuver, typically in Action Points (AP).
 */
export interface ManeuverCost {
	ap: number;
}

/**
 * The definitive blueprint for a single Maneuver object.
 */
export interface Maneuver {
	name: string;
	type: ManeuverType;
	cost: ManeuverCost;
	description: string;
	isReaction: boolean;
	trigger?: string; // Optional: The condition for using a Reaction maneuver.
	requirement?: string; // Optional: Any prerequisites for using the maneuver.
}

//==============================================================================
// MANEUVER DATA
//==============================================================================

/**
 * A comprehensive list of all martial maneuvers available in the game.
 */
export const maneuvers: Maneuver[] = [
	// --- Attack Maneuvers (Page 48) ---
	{
		name: 'Extend Attack',
		type: ManeuverType.Attack,
		cost: { ap: 1 },
		description:
			'Your Melee Attack Range is increased by 1 Space (or your Ranged Attack Range is increased by 5 Spaces) for the Attack.',
		isReaction: false
	},
	{
		name: 'Power Attack',
		type: ManeuverType.Attack,
		cost: { ap: 1 },
		description: 'You deal +1 damage with the Attack. You can use this Maneuver multiple times.',
		isReaction: false
	},
	{
		name: 'Sweep Attack',
		type: ManeuverType.Attack,
		cost: { ap: 1 },
		description:
			'Choose 1 additional target within 1 Space of the original target that’s within your Attack Range. Make 1 Attack Check against all targets. Attack Hit: The original target takes your Attack’s damage, and each additional target Hit takes 1 damage of the same type. You can use this Maneuver multiple times.',
		isReaction: false
	},

	// --- Save Maneuvers (Page 49) ---
	{
		name: 'Bleed',
		type: ManeuverType.Save,
		cost: { ap: 1 },
		description: 'The target begins Bleeding (1 True damage at the start of their turn).',
		isReaction: false
	},
	{
		name: 'Daze',
		type: ManeuverType.Save,
		cost: { ap: 1 },
		description:
			'The target becomes Dazed (DisADV on Mental Checks) on the next Mental Check it makes before the end of your next turn.',
		isReaction: false
	},
	{
		name: 'Expose',
		type: ManeuverType.Save,
		cost: { ap: 1 },
		description:
			'The target becomes Exposed (Attacks against it have ADV) against the next Attack made against it before the end of your next turn.',
		isReaction: false
	},
	{
		name: 'Hamstring',
		type: ManeuverType.Save,
		cost: { ap: 1 },
		description:
			'The target becomes Slowed (every 1 Space you move costs an extra 1 Space of movement) until the end of your next turn.',
		isReaction: false
	},
	{
		name: 'Hinder',
		type: ManeuverType.Save,
		cost: { ap: 1 },
		description:
			'The target becomes Hindered (DisADV on Attacks) on the next Attack it makes before the end of your next turn.',
		isReaction: false
	},
	{
		name: 'Impair',
		type: ManeuverType.Save,
		cost: { ap: 1 },
		description:
			'The target becomes Impaired (DisADV on Physical Checks) on the next Physical Check it makes before the end of your next turn.',
		isReaction: false
	},
	{
		name: 'Knockback',
		type: ManeuverType.Save,
		cost: { ap: 1 },
		description:
			'The target is pushed 1 Space away + up to 1 additional Space for every 5 it fails its Save by.',
		isReaction: false
	},
	{
		name: 'Trip',
		type: ManeuverType.Save,
		cost: { ap: 1 },
		description: 'The target falls Prone.',
		isReaction: false
	},

	// --- Grapple Maneuvers (Page 49) ---
	{
		name: 'Body Block',
		type: ManeuverType.Grapple,
		cost: { ap: 1 },
		isReaction: true,
		trigger: 'You are targeted by an Attack.',
		description:
			'You reposition a creature Grappled by you to shield yourself from damage. You and the Grappled creature take half the damage dealt by the attack and you can move the Grappled creature to any space adjacent to you immediately afterwards.'
	},
	{
		name: 'Restrain',
		type: ManeuverType.Grapple,
		cost: { ap: 1 },
		description:
			'The target is Restrained until the Grapple ends. On its turn it can spend 1 AP to end being Restrained, but it remains Grappled until the Condition ends.',
		isReaction: false
	},
	{
		name: 'Slam',
		type: ManeuverType.Grapple,
		cost: { ap: 1 },
		description: 'The target takes 1 Bludgeoning damage. Success (each 5): +1 damage.',
		isReaction: false
	},
	{
		name: 'Takedown',
		type: ManeuverType.Grapple,
		cost: { ap: 1 },
		description: 'The target falls Prone. You don’t fall Prone unless you choose to do so.',
		isReaction: false
	},
	{
		name: 'Throw',
		type: ManeuverType.Grapple,
		cost: { ap: 1 },
		requirement: 'The Grappled creature is your Size or smaller.',
		description:
			'The target is thrown up to a number of Spaces away from you equal to 1/2 of your Might (ending the Grappled Condition) + up to 1 additional Space for every 5 they fail the Contest by.',
		isReaction: false
	},

	// --- Defense Maneuvers (Page 50) ---
	{
		name: 'Parry',
		type: ManeuverType.Defense,
		cost: { ap: 1 },
		isReaction: true,
		trigger:
			'When a creature you can see within 1 Space (including yourself) is targeted by an Attack against its PD.',
		description: 'You grant the target a +5 bonus to PD against this Attack.'
	},
	{
		name: 'Protect',
		type: ManeuverType.Defense,
		cost: { ap: 1 },
		isReaction: true,
		trigger: 'A creature you can see within 1 Space is Hit by an Attack.',
		description:
			'The target takes half of the damage and you take the other half. The damage you take bypasses any Damage Reduction.'
	},
	{
		name: 'Raise Shield',
		type: ManeuverType.Defense,
		cost: { ap: 1 },
		isReaction: true,
		trigger:
			'When a creature you can see within 1 Space (including yourself) is targeted by an Attack against its AD.',
		requirement: 'You’re wielding a Shield.',
		description: 'You grant the target a +5 bonus to AD against this Attack.'
	},
	{
		name: 'Side Step',
		type: ManeuverType.Defense,
		cost: { ap: 1 },
		isReaction: true,
		trigger: 'You’re targeted by an Attack against your PD.',
		description:
			'You move 1 Space to a Space that’s still within the Attack’s range. When you do, the Attack has DisADV against you. If you move behind Cover, you don’t gain the benefit of that Cover against the Attack.'
	},
	{
		name: 'Swap',
		type: ManeuverType.Defense,
		cost: { ap: 1 },
		description:
			'You switch Spaces with a willing creature within 1 Space. If this movement would provoke an Opportunity Attack against you or the target creature, any Opportunity Attacks are made against you.',
		isReaction: false // This is a standard action, not a reaction.
	},
	{
		name: 'Taunt',
		type: ManeuverType.Defense,
		cost: { ap: 1 },
		description:
			'Choose an enemy creature that can see or hear you within 5 Spaces. Make an Attack Check, Influence Check, or Intimidation Check (your choice) contested by the target’s Mental Save. Contest Success: The target is Taunted (DisADV on Attacks against creatures other than you) by you on their next Attack.',
		isReaction: false
	}
];

/** A simple alias for the main maneuvers array. */
export const allManeuvers = maneuvers;
```

## File: src/lib/rulesdata/skills.ts
```typescript
import type { ISkillData } from './types';

export const skillsData: ISkillData[] = [
	{
		id: 'athletics',
		name: 'Athletics',
		attributeAssociation: 'might',
		description:
			'Athletics covers activities that involve physical prowess, such as climbing, swimming, and jumping in difficult circumstances, or participating in a Grapple.'
	},
	{
		id: 'intimidation',
		name: 'Intimidation',
		attributeAssociation: 'might',
		description:
			'Intimidation covers attempts to influence a creature’s behavior using threats, hostile actions, and physical violence.'
	},
	{
		id: 'acrobatics',
		name: 'Acrobatics',
		attributeAssociation: 'agility',
		description: 'Acrobatics covers activities that require flexibility, nimbleness, and balance.'
	},
	{
		id: 'trickery',
		name: 'Trickery',
		attributeAssociation: 'agility',
		description:
			'Trickery covers non-verbal means of deceiving others, such as pickpocketing things, concealing an object on your person, or other forms of physical deception.'
	},
	{
		id: 'stealth',
		name: 'Stealth',
		attributeAssociation: 'agility',
		description:
			'Stealth covers attempts to avoid being seen or heard by other creatures, such as sneaking about or hiding behind cover.'
	},
	{
		id: 'animal',
		name: 'Animal',
		attributeAssociation: 'charisma',
		description:
			'Animal covers interactions such as corralling, training, calming, and gauging the intention of Beasts.'
	},
	{
		id: 'insight',
		name: 'Insight',
		attributeAssociation: 'charisma',
		description:
			'Insight governs your ability to discern intentions. This could be from observing a creature’s body language, facial cues, and mannerisms. Alternatively, Insight can represent a gut feeling or intuition about a situation.'
	},
	{
		id: 'influence',
		name: 'Influence',
		attributeAssociation: 'charisma',
		description:
			'Influence covers your attempts to manipulate a creature’s behavior using compelling arguments based on truth, half-truths, lies, or some combination in between.'
	},
	{
		id: 'investigation',
		name: 'Investigation',
		attributeAssociation: 'intelligence',
		description:
			'Investigation covers using your senses to search for and discover things that are not readily observable. You look for clues and then make deductions on those clues to try and discern the locations of things or how they work (finding hidden objects, secret doors, or weak points in structures). It also covers the process of researching information through various texts.'
	},
	{
		id: 'medicine',
		name: 'Medicine',
		attributeAssociation: 'intelligence',
		description:
			'Medicine covers activities that involve medical knowledge and application, such as treating a wounded creature, diagnosing an illness, or identifying a cure to an ailment.'
	},
	{
		id: 'survival',
		name: 'Survival',
		attributeAssociation: 'intelligence',
		description:
			'Survival covers the activities required to survive in the wilderness, such as tracking quarry, foraging for food and water, and navigating through uncharted territory.'
	},
	{
		id: 'awareness',
		name: 'Awareness',
		attributeAssociation: 'prime', // Uses Prime Modifier
		description:
			'Awareness governs your ability to detect the presence of other creatures or objects using your sight, hearing, smell, or other senses.'
	}
];
```

## File: src/lib/rulesdata/techniques.ts
```typescript
/**
 * @file techniques.ts
 * @description Contains the schemas and a complete list of all Martial Techniques
 * from the DC20 Beta 0.9.5 rulebook (pages 51-53).
 */

//==============================================================================
// SCHEMAS / TYPES
//==============================================================================

/**
 * Represents the resource cost of a technique or its enhancement.
 */
export interface MartialAbilityCost {
	ap?: number;
	sp?: number;
}

/**
 * The blueprint for a Technique's optional enhancement.
 */
export interface TechniqueEnhancement {
	name: string;
	cost: {
		ap?: number;
		sp: number;
	};
	description: string;
}

/**
 * The definitive blueprint for a single Technique object.
 */
export interface Technique {
	name: string;
	cost: MartialAbilityCost;
	description: string;
	isReaction: boolean;
	trigger?: string;
	requirement?: string;
	enhancements: TechniqueEnhancement[];
}

//==============================================================================
// TECHNIQUE DATA
//==============================================================================

/**
 * A comprehensive list of all martial techniques available in the game.
 */
export const techniques: Technique[] = [
	{
		name: 'Forbearance',
		cost: { ap: 1, sp: 1 },
		isReaction: true,
		trigger: 'When a creature you can see within 1 Space is targeted by an Attack.',
		description:
			'You become the new target of the Check, and choose to switch places with the original target (if it’s willing). If the Check is accompanied by a Save, you make the Save instead of the original target.',
		enhancements: [
			{
				name: 'Steadfast Forbearance',
				cost: { sp: 1 },
				description:
					'If multiple creatures within 1 Space of you are targeted by the same Check, you can attempt to protect them as well. You can spend 1 SP per additional target to become the new target of its Check as well. You take the collective damage of all protected creatures against the Check.'
			},
			{
				name: 'Immense Defense',
				cost: { sp: 2 },
				description: 'You gain Resistance (Half) against all damage taken using this Technique.'
			}
		]
	},
	{
		name: 'Heroic Bash',
		cost: { ap: 1, sp: 1 },
		isReaction: false,
		requirement: 'Melee Weapon or Unarmed Strike',
		description:
			"Using a Melee Weapon (or Unarmed Strike) you can attempt to send an enemy hurling through the air. Make an Attack Check against the PD of a target within 1 Space of you, and it makes a Physical Save against your Save DC. Attack Hit: It takes your Weapon's (or Unarmed Strike) damage. Save Failure: It gets knockback horizontally up to 3 Spaces + 1 additional Space for every 5 it fails the Save by.",
		enhancements: [
			{
				name: 'Extended Knockback',
				cost: { sp: 1 },
				description:
					'You can spend 1 SP to increase the Knockback distance by 2 Spaces and increase the damage by 1.'
			},
			{
				name: 'Painful Knockback',
				cost: { sp: 1 },
				description: 'You can spend 1 SP to increase the damage by 2.'
			},
			{
				name: 'Bash & Smash',
				cost: { ap: 1, sp: 1 },
				description:
					'You can spend an additional 1 AP and 1 SP to change the Target from one creature to every creature’s PD within 1 Space.'
			}
		]
	},
	{
		name: 'Heroic Leap',
		cost: { ap: 1, sp: 1 },
		isReaction: false,
		requirement: 'Melee Weapon or Unarmed Strike',
		description:
			'You perform an exceptional leap and assault a creature. You gain up to your Speed in Spaces and increase your Jump Distance by 1 on the next Long or Vertical Jump you make. You leap into the air and make an Attack Check against the PD of a target within 1 Space of where you land, and it makes a Physical Save against your Save DC. Attack Hit: It takes your Weapon (or Unarmed Strike) damage. Save Failure: The target falls Prone.',
		enhancements: [
			{
				name: 'Brutal Leap',
				cost: { sp: 1 },
				description:
					'You can spend 1 SP to transfer all of the Falling damage you would usually take into the target instead.'
			},
			{
				name: 'Far Leap',
				cost: { sp: 1 },
				description: 'You can spend 1 SP to increase your damage by 1 and your Jump Distance by 2.'
			},
			{
				name: 'Heroic Slam',
				cost: { ap: 1, sp: 1 },
				description:
					'You can spend 1 AP and 1 SP to compare your Attack Check against the AD of all creatures within 1 Space of where you land (instead of a single target).'
			}
		]
	},
	{
		name: 'Heroic Parry',
		cost: { ap: 1, sp: 1 },
		isReaction: true,
		trigger:
			'You or a creature you can see within 1 Space are targeted by an Attack against its PD.',
		description: 'You grant the target a +5 bonus to its PD until the start of its next turn.',
		enhancements: [
			{
				name: 'Heroic Disengage',
				cost: { sp: 1 },
				description:
					'You can spend 1 SP to allow the target to Disengage and move up to half its Speed after the Attack.'
			}
		]
	},
	{
		name: 'Heroic Taunt',
		cost: { ap: 1, sp: 1 },
		isReaction: false,
		description:
			'You attempt to Taunt all enemies within 5 Spaces. Make an Attack Check or Intimidation Check (your choice) contested by each target’s Mental Save. Contest Success: Each creature you beat is Taunted (DisADV on Attack and Spell Checks against creatures other than you) by you until the end of your next turn.',
		enhancements: [
			{
				name: 'Legendary Taunt',
				cost: { sp: 2 },
				description:
					'You can spend 2 SP to have any damage dealt by Taunted enemies to be halved against any creatures other than you.'
			}
		]
	},
	{
		name: 'Slip Away',
		cost: { ap: 1, sp: 1 },
		isReaction: true,
		trigger: 'A Creature misses you with an Attack.',
		description: 'You take the Full Dodge Action and move up to your Speed.',
		enhancements: [
			{
				name: 'Diving Attack',
				cost: { sp: 1 },
				description:
					'You can spend 1 SP to make an Attack Check against a creature within 1 Space of you as part of Slip Away (you make this attack before the creature makes theirs).'
			}
		]
	},
	{
		name: 'Sunder Armor',
		cost: { ap: 1, sp: 1 },
		isReaction: false,
		description:
			'You make a Martial Attack against a creature’s PD. Hit: Until the start of your next turn, the target gains Vulnerability (1) to a damage type dealt by the Attack.',
		enhancements: []
	},
	{
		name: 'Tumble and Dive',
		cost: { ap: 2, sp: 1 },
		isReaction: true,
		trigger: 'You are the target of an Attack.',
		description:
			'You move up to your Speed and avoid the attack entirely as long as you end your movement outside the range or behind Full Cover of the Attack. Additional Opportunity Attacks are still able to be made against you.',
		enhancements: [
			{
				name: 'Heroic Dive',
				cost: { sp: 2 },
				description:
					'You can spend 2 SP to bring a willing creature within 1 Space along with you as part of Tumble and Dive. They move the same amount of Spaces as you and must also end their movement within 1 Space of you.'
			}
		]
	},
	{
		name: 'Volley',
		cost: { ap: 2, sp: 1 },
		isReaction: false,
		requirement: 'Ranged Weapon',
		description:
			'You launch a volley of projectiles. Choose a point within your Weapon’s range. Make a single Attack Check and compare it against the AD of all creatures of your choice within 1 Space of the chosen point. Attack Hit: You deal 2 damage of the Weapon’s type to each creature.',
		enhancements: [
			{
				name: 'Impairing Volley',
				cost: { sp: 1 },
				description:
					'You can spend 1 SP to cause each creature within the area to make a Physical Save against your Save DC. Failure: They’re Impaired (DisADV on Physical Checks) until the end of your next turn.'
			},
			{
				name: 'Blanket of Arrows',
				cost: { sp: 1 },
				description: 'You can spend 1 SP to increase the area to 3 Spaces from the chosen point.'
			},
			{
				name: 'Line of Arrows',
				cost: { sp: 1 },
				description:
					'You can spend 1 SP to also target each creature occupying a Space in a Line between you and the chosen point.'
			}
		]
	},
	{
		name: 'Whirlwind',
		cost: { ap: 2, sp: 1 },
		isReaction: false,
		requirement: 'Melee Weapon or Unarmed Strike',
		description:
			'You make a single Attack Check against the AD of all creatures of your choice within 1 Space of you. Attack Hit: You deal your Weapon (or Unarmed Strike) damage to each creature.',
		enhancements: [
			{
				name: 'Blood Whirl',
				cost: { sp: 1 },
				description:
					'You can spend 1 SP to force each creature targeted to make a Physical Save against your Save DC. Failure: They begin Bleeding.'
			},
			{
				name: 'Wide Swing',
				cost: { sp: 1 },
				description:
					'You can spend 1 SP to increase the range of Whirlwind by 1 Space, targeting each creature of your choice within 2 Spaces of you.'
			},
			{
				name: 'Throwing Finisher',
				cost: { sp: 1 },
				description:
					'If you’re wielding a Melee Weapon, you can choose to spend an extra 1 SP at the end of the Whirlwind to throw the Weapon at a target within 5 Spaces. Use the same single Attack Check against this target as well. The weapon lands within 1 Space of the target (GM discretion).'
			}
		]
	}
];

/** A simple alias for the main techniques array. */
export const allTechniques = techniques;
```

## File: src/lib/rulesdata/trades.ts
```typescript
import { ITradeData } from './types';

export const tradesData: ITradeData[] = [
	{
		id: 'alchemy',
		name: 'Alchemy',
		attributeAssociation: 'intelligence',
		description:
			'Alchemy is the practice of creating something by combining or changing other things. This includes creating potions, poisons, and other alchemical substances.',
		tools: "Alchemist's Supplies"
	},
	{
		id: 'architecture',
		name: 'Architecture',
		attributeAssociation: 'intelligence',
		description:
			'Architecture is the knowledge of building design, construction, and structural integrity. This includes understanding how buildings are constructed, identifying weak points, and designing structures.',
		tools: undefined // Knowledge trade
	},
	{
		id: 'blacksmithing',
		name: 'Blacksmithing',
		attributeAssociation: 'might',
		description:
			'Blacksmithing is the crafting and repairing of metal objects, including weapons and armor. This includes working with forges, hammers, and other tools to shape metal.',
		tools: "Smith's Tools"
	},
	{
		id: 'brewing',
		name: 'Brewing',
		attributeAssociation: 'intelligence',
		description:
			'Brewing is the art of creating beverages through fermentation, such as beer, wine, and spirits. This includes understanding the process of fermentation and using brewing equipment.',
		tools: "Brewer's Supplies"
	},
	{
		id: 'calligraphy',
		name: 'Calligraphy',
		attributeAssociation: 'agility',
		description:
			'Calligraphy is the art of decorative handwriting and lettering. This includes using various pens, inks, and techniques to create visually appealing text.',
		tools: "Calligrapher's Supplies"
	},
	{
		id: 'carpentry',
		name: 'Carpentry',
		attributeAssociation: 'might',
		description:
			'Carpentry is the crafting and repairing of wooden objects and structures. This includes working with wood, saws, hammers, and other tools to build and repair.',
		tools: "Carpenter's Tools"
	},
	{
		id: 'cartography',
		name: 'Cartography',
		attributeAssociation: 'intelligence',
		description:
			'Cartography is the art and science of mapmaking. This includes creating maps, reading maps, and navigating using maps.',
		tools: "Cartographer's Tools"
	},
	{
		id: 'cobbling',
		name: 'Cobbling',
		attributeAssociation: 'agility',
		description:
			'Cobbling is the crafting and repairing of footwear. This includes working with leather, thread, and tools to create and repair shoes and boots.',
		tools: "Cobbler's Tools"
	},
	{
		id: 'cooking',
		name: 'Cooking',
		attributeAssociation: 'intelligence',
		description:
			'Cooking is the preparation of food for consumption. This includes understanding ingredients, recipes, and cooking techniques.',
		tools: "Cook's Utensils"
	},
	{
		id: 'deciphering',
		name: 'Deciphering',
		attributeAssociation: 'intelligence',
		description:
			'Deciphering is the understanding of coded messages, ancient scripts, or hidden meanings. This includes analyzing patterns, symbols, and languages to uncover hidden information.',
		tools: undefined // Knowledge trade
	},
	{
		id: 'disguise',
		name: 'Disguise',
		attributeAssociation: 'charisma',
		description:
			"Disguise is the altering of one's appearance to resemble someone else or a different type of person. This includes using makeup, costumes, and props to change appearance.",
		tools: 'Disguise Kit'
	},
	{
		id: 'forgery',
		name: 'Forgery',
		attributeAssociation: 'agility',
		description:
			'Forgery is the creating of convincing copies of documents, signatures, or objects. This includes replicating details and materials to create fakes.',
		tools: 'Forgery Kit'
	},
	{
		id: 'gaming',
		name: 'Gaming',
		attributeAssociation: 'charisma',
		description:
			'Gaming is the proficiency in various games of chance or skill. This includes understanding rules, strategies, and playing games.',
		tools: 'Gaming Set'
	},
	{
		id: 'herbalism',
		name: 'Herbalism',
		attributeAssociation: 'intelligence',
		description:
			'Herbalism is the knowledge of plants, their properties, and uses. This includes identifying plants, preparing herbal remedies, and understanding plant effects.',
		tools: 'Herbalism Kit'
	},
	{
		id: 'jeweler',
		name: 'Jeweler',
		attributeAssociation: 'agility',
		description:
			'Jeweler is the crafting and repairing of jewelry. This includes working with precious metals, gems, and tools to create and repair jewelry.',
		tools: "Jeweler's Tools"
	},
	{
		id: 'leatherworking',
		name: 'Leatherworking',
		attributeAssociation: 'agility',
		description:
			'Leatherworking is the crafting and repairing of leather goods. This includes working with leather, tools, and techniques to create and repair items.',
		tools: "Leatherworker's Tools"
	},
	{
		id: 'linguistics',
		name: 'Linguistics',
		attributeAssociation: 'intelligence',
		description:
			'Linguistics is the study of languages, their structure, and origins. This includes understanding grammar, syntax, and the history of languages.',
		tools: undefined // Knowledge trade
	},
	{
		id: 'masonry',
		name: 'Masonry',
		attributeAssociation: 'might',
		description:
			'Masonry is the working with stone to build structures or objects. This includes cutting, shaping, and laying stone to create buildings and other structures.',
		tools: "Mason's Tools"
	},
	{
		id: 'medicine',
		name: 'Medicine',
		attributeAssociation: 'intelligence',
		description:
			'Medicine is the knowledge and practice of healing injuries and treating diseases. This includes diagnosing ailments, administering treatments, and understanding medical procedures.',
		tools: "Healer's Kit"
	},
	{
		id: 'music',
		name: 'Music',
		attributeAssociation: 'charisma',
		description:
			'Music is the performance of music using instruments or voice. This includes playing instruments, singing, and understanding musical theory.',
		tools: 'Musical Instrument'
	},
	{
		id: 'navigation',
		name: 'Navigation',
		attributeAssociation: 'intelligence',
		description:
			"Navigation is the determining of one's position and plotting a course. This includes using maps, compasses, and celestial bodies to navigate.",
		tools: "Navigator's Tools"
	},
	{
		id: 'painting',
		name: 'Painting',
		attributeAssociation: 'agility',
		description:
			'Painting is the creating of art using paints. This includes using various paints, brushes, and techniques to create visual art.',
		tools: "Painter's Supplies"
	},
	{
		id: 'poisoner',
		name: 'Poisoner',
		attributeAssociation: 'intelligence',
		description:
			'Poisoner is the knowledge and creation of poisons. This includes identifying poisonous substances, preparing poisons, and understanding their effects.',
		tools: "Poisoner's Kit"
	},
	{
		id: 'pottery',
		name: 'Pottery',
		attributeAssociation: 'agility',
		description:
			'Pottery is the crafting of objects from clay. This includes shaping, firing, and glazing clay to create various objects.',
		tools: "Potter's Tools"
	},
	{
		id: 'sculpting',
		name: 'Sculpting',
		attributeAssociation: 'might',
		description:
			'Sculpting is the creating of three-dimensional art from various materials. This includes shaping materials like stone, wood, or clay to create sculptures.',
		tools: "Sculptor's Tools"
	},
	{
		id: 'smithing',
		name: 'Smithing',
		attributeAssociation: 'might',
		description:
			'Smithing is the general knowledge of working with metals. This includes understanding different metals, their properties, and basic metalworking techniques.',
		tools: "Smith's Tools"
	},
	{
		id: 'survival',
		name: 'Survival',
		attributeAssociation: 'intelligence',
		description:
			'Survival is the knowledge and skills needed to survive in the wilderness. This includes tracking, foraging, shelter building, and navigating in natural environments.',
		tools: undefined // Knowledge trade
	},
	{
		id: 'tailoring',
		name: 'Tailoring',
		attributeAssociation: 'agility',
		description:
			'Tailoring is the crafting and repairing of clothing and textiles. This includes working with fabric, needles, and thread to create and repair garments.',
		tools: "Weaver's Tools"
	},
	{
		id: 'thieves',
		name: "Thieves'",
		attributeAssociation: 'agility',
		description:
			"Thieves' is the knowledge and skills related to thievery, including lockpicking and disarming traps. This includes understanding security measures and using specialized tools.",
		tools: "Thieves' Tools"
	},
	{
		id: 'vehicles_land',
		name: 'Vehicles (Land)',
		attributeAssociation: 'agility',
		description:
			'Vehicles (Land) is the proficiency in operating land-based vehicles. This includes riding horses, driving carts, and operating other land vehicles.',
		tools: undefined
	},
	{
		id: 'vehicles_water',
		name: 'Vehicles (Water)',
		attributeAssociation: 'agility',
		description:
			'Vehicles (Water) is the proficiency in operating water-based vehicles. This includes sailing boats, piloting ships, and operating other water vehicles.',
		tools: undefined
	},
	{
		id: 'woodcarving',
		name: 'Woodcarving',
		attributeAssociation: 'agility',
		description:
			'Woodcarving is the creating of art or objects from wood. This includes shaping wood using knives, chisels, and other tools.',
		tools: "Woodcarver's Tools"
	}
];
```

## File: src/lib/rulesdata/traits.ts
```typescript
import type { ITrait } from './types';

export const traitsData: ITrait[] = [
	// Human Traits (p. 108)
	{
		id: 'human_attribute_increase',
		name: 'Attribute Increase',
		description:
			'Choose an Attribute. The chosen Attribute increases by 1 (up to the Attribute Limit).',
		cost: 2,
		effects: [
			{
				type: 'MODIFY_ATTRIBUTE',
				target: 'any_attribute_choice',
				value: 1,
				userChoiceRequired: { prompt: 'Choose an Attribute to increase by 1' }
			}
		]
	},
	{
		id: 'human_skill_expertise',
		name: 'Skill Expertise',
		description:
			'Choose a Skill. Your Mastery Cap and Mastery Level in the chosen Skill both increase by 1. You can only benefit from 1 Feature that increases your Skill Mastery Limit at a time.',
		cost: 2,
		effects: [
			{
				type: 'GRANT_SKILL_EXPERTISE',
				value: { skillId: 'any_skill_choice', capIncrease: 1, levelIncrease: 1 },
				userChoiceRequired: { prompt: 'Choose a skill for Expertise' }
			}
		]
	},
	{
		id: 'human_resolve',
		name: 'Human Resolve',
		description: 'Your Death’s Door Threshold value is expanded by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_DEATH_THRESHOLD_MODIFIER', value: 1 }]
	},
	{
		id: 'human_undying',
		name: 'Undying',
		description: 'You have ADV on Saves against the Doomed Condition.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Doomed' }]
	},
	{
		id: 'human_trade_expertise',
		name: 'Trade Expertise',
		description:
			'Choose a Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1. You can only benefit from 1 Feature that increases your Trade Mastery Limit at a time.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				value: { tradeId: 'any_trade_choice', capIncrease: 1, levelIncrease: 1 },
				userChoiceRequired: { prompt: 'Choose a Trade for Expertise' }
			}
		]
	},
	{
		id: 'human_determination',
		name: 'Human Determination',
		description:
			'Once per Combat, you can give yourself ADV on an Attack Check or Spell Check while Bloodied.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_ADV_ON_CHECK_WHILE_BLOODIED',
				target: 'Attack_or_Spell_Check',
				condition: 'bloodied'
			}
		]
	},
	{
		id: 'human_unbreakable',
		name: 'Unbreakable',
		description: 'You have ADV on Death Saves.',
		cost: 1,
		effects: [{ type: 'GRANT_ADV_ON_SAVE', target: 'Death_Save' }]
	},
	{
		id: 'human_attribute_decrease',
		name: 'Attribute Decrease',
		description:
			'Choose an Attribute. You decrease the chosen Attribute by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [
			{
				type: 'MODIFY_ATTRIBUTE',
				target: 'any_attribute_choice',
				value: -1,
				userChoiceRequired: { prompt: 'Choose an Attribute to decrease by 1' }
			}
		]
	},

	// Elf Traits (p. 108)
	{
		id: 'elf_elven_will',
		name: 'Elven Will',
		description: 'You have ADV on Checks and Saves against being Charmed and put to Sleep.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Charmed' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Sleep_Magic' }
		]
	},
	{
		id: 'elf_nimble',
		name: 'Nimble',
		description:
			'When you take the Dodge Action, you instead gain the benefits of the Full Dodge Action.',
		cost: 2,
		effects: [
			{ type: 'MODIFY_ACTION_BENEFIT', target: 'Dodge_Action', value: 'Full_Dodge_Benefit' }
		]
	},
	{
		id: 'elf_agile_explorer',
		name: 'Agile Explorer',
		description: 'You’re not affected by Difficult Terrain.',
		cost: 2,
		effects: [{ type: 'IGNORE_DIFFICULT_TERRAIN' }]
	},
	{
		id: 'elf_discerning_sight',
		name: 'Discerning Sight',
		description: 'You have ADV on Checks and Saves made to discern through visual illusions.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_CHECKS_SAVES_VS_ILLUSION_VISUAL' }]
	},
	{
		id: 'elf_quick_reactions',
		name: 'Quick Reactions',
		description: 'While you aren’t wearing Armor, you gain +1 PD.',
		cost: 1,
		effects: [{ type: 'MODIFY_PD', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'elf_peerless_sight',
		name: 'Peerless Sight',
		description:
			'You don’t have DisADV as a result of making an Attack with a Weapon at Long Range',
		cost: 1,
		effects: [{ type: 'IGNORE_DISADV_ON_RANGED_ATTACK_AT_LONG_RANGE' }]
	},
	{
		id: 'elf_climb_speed',
		name: 'Climb Speed',
		description: 'You gain a Climb Speed equal to your Movement Speed.',
		cost: 1,
		effects: [{ type: 'GRANT_CLIMB_SPEED_EQUAL_TO_SPEED' }]
	},
	{
		id: 'elf_speed_increase',
		name: 'Speed Increase',
		description: 'Your Speed increases by 1 Space.',
		cost: 2,
		effects: [{ type: 'MODIFY_SPEED', value: 5 }] // 1 Space = 5 feet
	},
	{
		id: 'elf_trade_expertise_elf',
		name: 'Trade Expertise (Elf)',
		description:
			'Choose a Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1. You can only benefit from 1 Feature that increases your Trade Mastery Limit at a time.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				value: { tradeId: 'any_trade_choice', capIncrease: 1, levelIncrease: 1 },
				userChoiceRequired: { prompt: 'Choose a Trade for Expertise' }
			}
		]
	},
	{
		id: 'elf_plant_knowledge',
		name: 'Plant Knowledge',
		description:
			'While within forests, jungles, and swamps, you have ADV on Survival Checks. Additionally, you have ADV on Nature Checks made to recall information about plants.',
		cost: 0,
		isMinor: true,
		effects: [
			{ type: 'GRANT_ADV_ON_SURVIVAL_CHECKS_IN_ENVIRONMENTS', target: 'forests_jungles_swamps' },
			{ type: 'GRANT_ADV_ON_NATURE_CHECKS_ABOUT_PLANTS' }
		]
	},
	{
		id: 'elf_brittle',
		name: 'Brittle',
		description: 'Your AD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_AD', value: -1 }]
	},
	{
		id: 'elf_frail',
		name: 'Frail',
		description: 'Your HP maximum decreases by 2.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_HP_MAX_STATIC', value: -2 }]
	},
	{
		id: 'elf_might_decrease',
		name: 'Might Decrease',
		description: 'Your Might decreases by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'might', value: -1 }]
	},

	// Dwarf Traits (p. 109)
	{
		id: 'dwarf_tough',
		name: 'Tough',
		description: 'Your HP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_HP_MAX_STATIC', value: 1 }]
	},
	{
		id: 'dwarf_toxic_fortitude',
		name: 'Toxic Fortitude',
		description: 'You have Poison Resistance (Half) and ADV on Saves against being Poisoned.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE_HALF', target: 'Poison' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Poisoned' }
		]
	},
	{
		id: 'dwarf_physically_sturdy',
		name: 'Physically Sturdy',
		description: 'You have ADV on Saves against being Impaired, Deafened, or Petrified.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Impaired' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Deafened' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Petrified' }
		]
	},
	{
		id: 'dwarf_iron_stomach',
		name: 'Iron Stomach',
		description: 'You have ADV on Saves against effects that come from consuming food or liquids.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_SAVE_VS_EFFECT_FROM_CONSUMING' }]
	},
	{
		id: 'dwarf_thick_skinned',
		name: 'Thick-Skinned',
		description: 'While you aren’t wearing Armor, you gain +1 AD.',
		cost: 1,
		effects: [{ type: 'MODIFY_AD', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'dwarf_natural_combatant',
		name: 'Natural Combatant',
		description: 'You gain Combat Training with Heavy Armor and All Shields.',
		cost: 1,
		effects: [
			{ type: 'GRANT_COMBAT_TRAINING', target: 'Heavy_Armor' },
			{ type: 'GRANT_COMBAT_TRAINING', target: 'All_Shields' }
		]
	},
	{
		id: 'dwarf_stone_blood',
		name: 'Stone Blood',
		description:
			'You have ADV on Saves against Bleeding. Additionally, you can spend 1 AP to end the Bleeding Condition on yourself.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Bleeding' },
			{ type: 'GRANT_ABILITY', value: 'End_Bleeding_Self_1AP' }
		]
	},
	{
		id: 'dwarf_minor_tremorsense',
		name: 'Minor Tremorsense',
		description: 'You have Tremorsense 3 Spaces.',
		cost: 1,
		effects: [{ type: 'GRANT_TREMORSENSE', value: 3 }]
	},
	{
		id: 'dwarf_stubborn',
		name: 'Stubborn',
		description: 'You have ADV on Saves against being Taunted and against being forcibly moved.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Taunted' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_FORCED_MOVEMENT' }
		]
	},
	{
		id: 'dwarf_trade_expertise',
		name: 'Trade Expertise',
		description:
			'Choose a Crafting or Services Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				value: {
					tradeId: 'any_crafting_or_services_trade_choice',
					capIncrease: 1,
					levelIncrease: 1
				},
				userChoiceRequired: { prompt: 'Choose a Crafting or Services Trade for Expertise' }
			}
		]
	},
	{
		id: 'dwarf_earthen_knowledge',
		name: 'Earthen Knowledge',
		description:
			'While within mountainous and subterranean environments, you have ADV on Survival Checks. Additionally, you have ADV on Nature Checks made to recall information about rocks, soil, crystals, and gems.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_ADV_ON_SURVIVAL_CHECKS_IN_ENVIRONMENTS',
				target: 'mountainous_and_subterranean'
			},
			{ type: 'GRANT_ADV_ON_NATURE_CHECKS_ABOUT_ROCKS_SOIL_CRYSTALS_GEMS' }
		]
	},
	{
		id: 'dwarf_charisma_attribute_decrease',
		name: 'Charisma Attribute Decrease',
		description: 'You decrease your Charisma by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'charisma', value: -1 }]
	},
	{
		id: 'dwarf_short_legged',
		name: 'Short-Legged',
		description: 'Your Speed decreases by 1 Space.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SPEED', value: -5 }]
	},

	// Halfling Traits (p. 109)
	{
		id: 'halfling_small_sized',
		name: 'Small-Sized',
		description: 'Your Size is considered Small.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SIZE', target: 'Small' }]
	},
	{
		id: 'halfling_elusive',
		name: 'Elusive',
		description:
			'When you take the Disengage Action, you instead gain the benefits of the Full Disengage Action.',
		cost: 2,
		effects: [
			{ type: 'MODIFY_ACTION_BENEFIT', target: 'Disengage_Action', value: 'Full_Disengage_Action' }
		]
	},
	{
		id: 'halfling_bravery',
		name: 'Halfling Bravery',
		description: 'You have ADV on Saves against being Intimidated, Rattled, or Frightened',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Intimidated' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Rattled' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Frightened' }
		]
	},
	{
		id: 'halfling_endurance',
		name: 'Halfling Endurance',
		description: 'You have Exhaustion Resistance.',
		cost: 1,
		effects: [{ type: 'GRANT_CONDITION_RESISTANCE', target: 'Exhaustion' }]
	},
	{
		id: 'halfling_deft_footwork',
		name: 'Deft Footwork',
		description:
			'You can move through the space of a hostile creature 1 size larger than you as if it were Difficult Terrain.',
		cost: 1,
		effects: [{ type: 'IGNORE_DIFFICULT_TERRAIN_WHEN_MOVING_THROUGH_SPACE_OF_LARGER_HOSTILE' }]
	},
	{
		id: 'halfling_beast_whisperer',
		name: 'Beast Whisperer',
		description:
			'You can speak to Beasts in a limited manner. They can understand the meanings of simple words, concepts, or states of emotion. You don’t have a special ability to understand them in return.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_LIMITED_COMMUNICATION_WITH_BEASTS' }]
	},
	{
		id: 'halfling_beast_insight',
		name: 'Beast Insight',
		description:
			'You can understand Beasts in a limited manner. You can understand the meaning of their noises and behaviors, though they have no special ability to understand you in return.',
		cost: 1,
		effects: [{ type: 'GRANT_LIMITED_UNDERSTANDING_OF_BEASTS' }]
	},
	{
		id: 'halfling_burst_of_bravery',
		name: 'Burst of Bravery',
		description:
			'Once per Combat, you can end the Intimidated, Rattled, or Frightened Condition on yourself for free at any time.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ABILITY', value: 'End_Intimidated_Rattled_Frightened_Self_OncePerCombat' }
		]
	},
	{
		id: 'halfling_trade_expertise',
		name: 'Trade Expertise',
		description:
			'Choose a Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				value: { tradeId: 'any_trade_choice', capIncrease: 1, levelIncrease: 1 },
				userChoiceRequired: { prompt: 'Choose a Trade for Expertise' }
			}
		]
	},
	{
		id: 'halfling_critter_knowledge',
		name: 'Critter Knowledge',
		description:
			'You have ADV on Nature, Survival, and Animal Checks involving Small size creatures and smaller.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_ADV_ON_CHECKS_INVOLVING_SMALL_CREATURES',
				target: 'Nature_Survival_Animal_Checks'
			}
		]
	},
	{
		id: 'halfling_brittle',
		name: 'Brittle',
		description: 'Your AD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_AD', value: -1 }]
	},
	{
		id: 'halfling_intelligence_attribute_decrease',
		name: 'Intelligence Attribute Decrease',
		description: 'You decrease your Intelligence by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'intelligence', value: -1 }]
	},
	{
		id: 'halfling_short_legged',
		name: 'Short-Legged',
		description: 'Your Speed decreases by 1 Space.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SPEED', value: -5 }]
	},

	// Gnome Traits (p. 110)
	{
		id: 'gnome_small_sized',
		name: 'Small-Sized',
		description: 'Your Size is considered Small.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SIZE', target: 'Small' }]
	},
	{
		id: 'gnome_escape_artist',
		name: 'Escape Artist',
		description:
			'You have ADV on Checks and Saves to avoid or escape being Grappled or Restrained.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_CHECKS_SAVES_TO_AVOID_ESCAPE', target: 'Grappled_or_Restrained' }
		]
	},
	{
		id: 'gnome_magnified_vision',
		name: 'Magnified Vision',
		description:
			'You have ADV on Investigation Checks made on something you’re holding or touching.',
		cost: 1,
		effects: [{ type: 'GRANT_ADV_ON_INVESTIGATION_CHECKS_ON_HELD_TOUCHED' }]
	},
	{
		id: 'gnome_mental_clarity',
		name: 'Mental Clarity',
		description: 'You have ADV on Saves against being Dazed or Stunned.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Dazed' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Stunned' }
		]
	},
	{
		id: 'gnome_strong_minded',
		name: 'Strong-Minded',
		description: 'You gain Psychic Resistance (1).',
		cost: 1,
		effects: [{ type: 'GRANT_RESISTANCE_STATIC', target: 'Psychic', value: 1 }]
	},
	{
		id: 'gnome_predict_weather',
		name: 'Predict Weather',
		description:
			'You can naturally tell what the weather is going to be in the next hour in the area within 1 mile of you. You don’t have DisADV on Checks or Saves as a result of naturally occurring weather.',
		cost: 0,
		isMinor: true,
		effects: [
			{ type: 'GRANT_ABILITY', value: 'Predict_Weather_1Mile_1Hour' },
			{ type: 'IGNORE_DISADV_FROM_NATURAL_WEATHER' }
		]
	},
	{
		id: 'gnome_mana_increase',
		name: 'Mana Increase',
		description: 'Your MP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_MP_MAX', value: 1 }]
	},
	{
		id: 'gnome_trapper',
		name: 'Trapper',
		description:
			'You have ADV on Investigation Checks to spot Traps and on Trickery Checks to Hide Traps.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_INVESTIGATION_CHECKS_TO_SPOT_TRAPS' },
			{ type: 'GRANT_ADV_ON_TRICKERY_CHECKS_TO_HIDE_TRAPS' }
		]
	},
	{
		id: 'gnome_lightning_insulation',
		name: 'Lightning Insulation',
		description: 'You have Lightning Resistance (Half) and can’t be struck by natural lightning.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE_HALF', target: 'Lightning' },
			{ type: 'IMMUNE_TO_NATURAL_LIGHTNING' }
		]
	},
	{
		id: 'gnome_trade_expertise',
		name: 'Trade Expertise',
		description:
			'Choose a Crafting or Subterfuge Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				value: {
					tradeId: 'any_crafting_or_subterfuge_trade_choice',
					capIncrease: 1,
					levelIncrease: 1
				},
				userChoiceRequired: { prompt: 'Choose a Crafting or Subterfuge Trade for Expertise' }
			}
		]
	},
	{
		id: 'gnome_storm_knowledge',
		name: 'Storm Knowledge',
		description:
			'While within rainy, snowy, or stormy environments, you have ADV on Survival Checks. Additionally, you have ADV on Knowledge Checks made to recall information about rain, snow, and storms.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SURVIVAL_CHECKS_IN_ENVIRONMENTS', target: 'rainy_snowy_stormy' },
			{ type: 'GRANT_ADV_ON_KNOWLEDGE_CHECKS_ABOUT_RAIN_SNOW_STORMS' }
		]
	},
	{
		id: 'gnome_agility_attribute_decrease',
		name: 'Agility Decrease',
		description: 'You decrease your Agility by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'agility', value: -1 }]
	},
	{
		id: 'gnome_short_legged',
		name: 'Short-Legged',
		description: 'Your Speed decreases by 1 Space.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SPEED', value: -5 }]
	},

	// Orc Traits (p. 110)
	{
		id: 'orc_cursed_mind',
		name: 'Cursed Mind',
		description: 'You gain Psychic Vulnerability (1).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_VULNERABILITY_STATIC', target: 'Psychic', value: 1 }]
	},
	{
		id: 'orc_rush',
		name: 'Orc Rush',
		description:
			'Once per Combat when you willingly move toward an enemy, you can spend 1 AP to gain Temp HP equal to your Prime Modifier.',
		cost: 2,
		effects: [
			{ type: 'GRANT_TEMP_HP_ONCE_PER_COMBAT_WHEN_MOVE_TOWARD_ENEMY', value: 'Prime_Modifier' }
		]
	},
	{
		id: 'orc_brutal_strikes',
		name: 'Brutal Strikes',
		description:
			'You deal +1 damage when you score a Brutal or Critical Hit with a Melee Weapon or Unarmed Strike.',
		cost: 2,
		effects: [
			{
				type: 'MODIFY_DAMAGE_ON_HIT',
				target: 'Melee_Martial_Attack',
				value: 1,
				condition: 'Brutal_or_Critical_Hit'
			}
		]
	},
	{
		id: 'orc_tough',
		name: 'Tough',
		description: 'Your HP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_HP_MAX_STATIC', value: 1 }]
	},
	{
		id: 'orc_orcish_resolve',
		name: 'Orcish Resolve',
		description: 'You gain 1 additional AP while on Death’s Door.',
		cost: 1,
		effects: [{ type: 'MODIFY_AP_WHILE_DEATHS_DOOR', value: 1 }]
	},
	{
		id: 'orc_already_cursed',
		name: 'Already Cursed',
		description: 'You have ADV on Saves against Curses.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Curses' }]
	},
	{
		id: 'orc_intimidating_shout',
		name: 'Intimidating Shout',
		description:
			'Once per Combat, you can spend 1 AP to let out an Intimidating Shout. All creatures within 5 Spaces that can hear you must make a Charisma Save contested by your Attack Check. Failure: A target is Hindered on the next Attack Check or Spell Attack it makes before the start of your next turn.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', value: 'Intimidating_Shout_OncePerCombat_1AP' }]
	},
	{
		id: 'orc_dash',
		name: 'Orc Dash',
		description:
			'Once per Combat you can use your Minor Action to move, as long as that movement is towards an enemy.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Move_As_Minor_Action_OncePerCombat_Toward_Enemy' }]
	},
	{
		id: 'orc_finishing_blow',
		name: 'Finishing Blow',
		description: 'You deal +1 damage to creatures who are Well-Bloodied.',
		cost: 1,
		effects: [
			{
				type: 'MODIFY_DAMAGE_ON_HIT',
				target: 'Martial_Attacks',
				value: 1,
				condition: 'Well_Bloodied'
			}
		]
	},
	{
		id: 'orc_imposing_presence',
		name: 'Imposing Presence',
		description:
			'Once per Combat when a creature makes an Attack against you, you can force them to make a Charisma Save. Save Failure: They must choose a new target for the Attack. If there are no other targets, then the Attack is wasted.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Force_New_Target_OncePerCombat_Reaction' }]
	},
	{
		id: 'orc_provocation',
		name: 'Provocation',
		description: 'You have DisADV on Checks and Saves against being Taunted.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_DISADV_ON_CHECKS_SAVES_VS_CONDITION', target: 'Taunted' }]
	},
	{
		id: 'orc_reckless',
		name: 'Reckless',
		description: 'Your PD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_PD', value: -1 }]
	},

	// Dragonborn Traits (p. 111)
	{
		id: 'dragonborn_darkvision',
		name: 'Darkvision',
		description: 'You have Darkvision 10 Spaces.',
		cost: 1,
		effects: [{ type: 'GRANT_DARKVISION', value: 10 }]
	},
	{
		id: 'dragonborn_draconic_resistance',
		name: 'Draconic Resistance',
		description: 'You gain Resistance (Half) to your Draconic damage type.',
		cost: 2,
		effects: [{ type: 'GRANT_RESISTANCE_HALF', target: 'Draconic_damage_type' }]
	},
	{
		id: 'dragonborn_draconic_breath_weapon',
		name: 'Draconic Breath Weapon',
		description:
			'You gain a Breath Weapon that you can use by spending 2 AP to exhale destructive power in an Area or Focused against a specific target. You can use this ability once per Long Rest, and regain the ability to use it again when you roll for Initiative.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ABILITY', value: 'Draconic_Breath_Weapon_OncePerLongRest_RegainOnInitiative' }
		]
	},
	{
		id: 'dragonborn_reptilian_superiority',
		name: 'Reptilian Superiority',
		description:
			'You have ADV on Intimidation Checks against reptilian creatures of Medium Size and smaller (not including other Dragonborn).',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_INTIMIDATION_CHECKS_VS_REPTILIAN_MEDIUM_SMALL' }]
	},
	{
		id: 'dragonborn_mana_increase',
		name: 'Mana Increase',
		description: 'Your MP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_MP_MAX', value: 1 }]
	},
	{
		id: 'dragonborn_thick_skinned',
		name: 'Thick-Skinned',
		description: 'While you aren’t wearing Armor, you gain +1 AD.',
		cost: 1,
		effects: [{ type: 'MODIFY_AD', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'dragonborn_second_breath',
		name: 'Second Breath',
		description:
			'You can now use your Draconic Breath Weapon twice per Combat. Additionally, whenever you use your Draconic Breath Weapon, you can spend 2 uses to increase the damage by 2 if its an Area, or by 4 if its Focused.',
		cost: 1,
		prerequisites: ['dragonborn_draconic_breath_weapon'],
		effects: [
			{ type: 'GRANT_ABILITY', value: 'Draconic_Breath_Weapon_TwicePerCombat' },
			{ type: 'GRANT_ABILITY', value: 'Draconic_Breath_Weapon_Enhanced_Damage_Spend_Uses' }
		]
	},
	{
		id: 'dragonborn_concussive_breath',
		name: 'Concussive Breath',
		description:
			'When you use your Draconic Breath Weapon, you can force all targets to make a Physical Save. Save Failure: The target is pushed 1 Space away +1 additional Space for every 5 it fails its Save by.',
		cost: 1,
		prerequisites: ['dragonborn_draconic_breath_weapon'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Draconic_Breath_Weapon_Concussive_Push' }]
	},
	{
		id: 'dragonborn_draconic_affinity',
		name: 'Draconic Affinity',
		description:
			'When you take damage of the same type as your Draconic damage, your next Draconic Breath Weapon deals +1 bonus damage.',
		cost: 1,
		effects: [
			{
				type: 'MODIFY_DAMAGE_ON_NEXT_DRACONIC_BREATH_WEAPON',
				value: 1,
				condition: 'take_same_type_damage'
			}
		]
	},
	{
		id: 'dragonborn_dying_breath',
		name: 'Dying Breath',
		description:
			'Once per Combat when you enter Death’s Door, you regain a use of your Draconic Breath Weapon and can immediately use it as a Reaction for free (0 AP).',
		cost: 1,
		prerequisites: ['dragonborn_draconic_breath_weapon'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Draconic_Breath_Weapon_Reaction_On_Deaths_Door' }]
	},
	{
		id: 'dragonborn_draconic_ward',
		name: 'Draconic Ward',
		description:
			'Once per Combat when you enter Death’s Door, you gain 2 Temp HP. Whenever you’re Hit by a Melee Attack while you have this Temp HP, your Attacker takes 1 Draconic damage.',
		cost: 1,
		effects: [
			{ type: 'GRANT_TEMP_HP_ONCE_PER_COMBAT_ON_DEATHS_DOOR', value: 2 },
			{ type: 'GRANT_DAMAGE_ON_MELEE_HIT_WHILE_TEMP_HP', target: 'Draconic_damage_type', value: 1 }
		]
	},
	{
		id: 'dragonborn_draconic_protection',
		name: 'Draconic Protection',
		description:
			'Once per Combat, when an ally within 20 Spaces is on Death’s Door, you begin to surge with an ancient power. While they remain on Death’s Door their PD and AD increases by 5 until Combat ends.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Increase_PD_AD_Ally_On_Deaths_Door' }]
	},
	{
		id: 'dragonborn_glide_speed',
		name: 'Glide Speed',
		description:
			'You have a set of wings that you can use to horizontally glide and slow your descent. Provided you aren’t Incapacitated, you gain the following benefits while in the air: Controlled Falling: You suffer no damage from Controlled Falling. Altitude Drop: If you end your turn midair, you Controlled Fall 4 Spaces. Glide Speed: You can use your movement to glide horizontally.',
		cost: 2,
		effects: [{ type: 'GRANT_GLIDE_SPEED' }]
	},
	{
		id: 'dragonborn_guardians_bond',
		name: 'Guardian’s Bond',
		description:
			'Once per Combat when an ally enters Death’s Door within 20 Spaces of you, you take an amount of True damage equal to your Prime Modifier.',
		cost: -1,
		isNegative: true,
		effects: [
			{ type: 'TAKE_TRUE_DAMAGE_ONCE_PER_COMBAT_WHEN_ALLY_DEATHS_DOOR', value: 'Prime_Modifier' }
		]
	},

	// Giantborn Traits (p. 112)
	{
		id: 'giantborn_tough',
		name: 'Tough',
		description: 'Your HP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_HP_MAX_STATIC', value: 1 }]
	},
	{
		id: 'giantborn_powerful_build',
		name: 'Powerful Build',
		description: 'You increase by 1 Size, but you occupy the Space of a creature 1 Size smaller.',
		cost: 2,
		effects: [
			{ type: 'MODIFY_SIZE', target: 'Large' },
			{ type: 'MODIFY_SPACE_OCCUPIED', target: '1_Size_Smaller' }
		]
	},
	{
		id: 'giantborn_unstoppable',
		name: 'Unstoppable',
		description: 'You have ADV on Saves against being Slowed or Stunned.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Slowed' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Stunned' }
		]
	},
	{
		id: 'giantborn_giants_resolve',
		name: 'Giant’s Resolve',
		description: 'While on Death’s Door, you reduce all damage taken by 1.',
		cost: 1,
		effects: [{ type: 'REDUCE_DAMAGE_TAKEN', value: 1, condition: 'deaths_door' }]
	},
	{
		id: 'giantborn_unyielding_movement',
		name: 'Unyielding Movement',
		description: 'You’re immune to being Slowed 2 (or higher).',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'IMMUNE_TO_SLOWED_2_OR_HIGHER' }]
	},
	{
		id: 'giantborn_giants_fortitude',
		name: 'Giant’s Fortitude',
		description: 'You also gain the benefits of your Giant’s Resolve Trait while Well-Bloodied.',
		cost: 2,
		prerequisites: ['giantborn_giants_resolve'],
		effects: [{ type: 'GRANT_BENEFIT_WHILE_WELL_BLOODIED', target: 'giantborn_giants_resolve' }]
	},
	{
		id: 'giantborn_strong_body',
		name: 'Strong Body',
		description:
			'Once per Combat when you take damage from an Attack, you can reduce the damage taken by an amount equal to your Might or Agility (your choice).',
		cost: 2,
		effects: [{ type: 'REDUCE_DAMAGE_TAKEN_ONCE_PER_COMBAT', value: 'Might_or_Agility' }]
	},
	{
		id: 'giantborn_mighty_hurl',
		name: 'Mighty Hurl',
		description:
			'You throw creatures 1 Space farther than normal, and objects (including Weapons) 5 Spaces farther than normal.',
		cost: 1,
		effects: [
			{ type: 'MODIFY_THROW_DISTANCE_CREATURES', value: 1 },
			{ type: 'MODIFY_THROW_DISTANCE_OBJECTS', value: 5 }
		]
	},
	{
		id: 'giantborn_titanic_toss',
		name: 'Titanic Toss',
		description:
			'You have ADV on Checks made to throw creatures. Additionally, you don’t have DisADV as a result of making an Attack with a Weapon with the Toss or Thrown Property at Long Range.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_CHECKS', target: 'Throw_Creatures' },
			{ type: 'IGNORE_DISADV_ON_RANGED_ATTACK_WITH_TOSS_THROWN_AT_LONG_RANGE' }
		]
	},
	{
		id: 'giantborn_mighty_leap',
		name: 'Mighty Leap',
		description:
			'You can use your Might instead of Agility to determine your Jump Distance and the damage you take from Falling.',
		cost: 1,
		effects: [{ type: 'USE_ATTRIBUTE_FOR_JUMP_DISTANCE_FALLING_DAMAGE', target: 'Might' }]
	},
	{
		id: 'giantborn_brute',
		name: 'Brute',
		description: 'Once per Combat, you can take the Shove or Grapple Action as a Minor Action.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Shove_or_Grapple_As_Minor_Action_OncePerCombat' }]
	},
	{
		id: 'giantborn_heavy_riser',
		name: 'Heavy Riser',
		description: 'You have to spend 4 Spaces of movement to stand up from Prone.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_MOVEMENT_TO_STAND_UP', value: 4 }]
	},
	{
		id: 'giantborn_clumsiness',
		name: 'Clumsiness',
		description: 'You have DisADV on Agility Checks.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_DISADV_ON_CHECKS', target: 'Agility_Checks' }]
	},
	{
		id: 'giantborn_intelligence_attribute_decrease',
		name: 'Intelligence Decrease',
		description: 'You decrease your Intelligence by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'intelligence', value: -1 }]
	},

	// Angelborn Traits (p. 113)
	{
		id: 'angelborn_radiant_resistance',
		name: 'Radiant Resistance',
		description: 'You have Resistance (Half) to Radiant damage.',
		cost: 1,
		effects: [{ type: 'GRANT_RESISTANCE_HALF', target: 'Radiant' }]
	},
	{
		id: 'angelborn_celestial_magic',
		name: 'Celestial Magic',
		description:
			'You learn 1 Spell of your choice from the Divine Spell List (Holy & Restoration during the Beta). Once per Long Rest, you can cast the chosen Spell spending 1 less MP than normal (minimum of 0 MP). The Spells total MP cost (before all reductions) still can’t exceed your Mana Spend Limit.',
		cost: 2,
		effects: [
			{ type: 'GRANT_SPELL_FROM_LIST', target: 'Divine_Spell_List' },
			{ type: 'REDUCE_MP_COST_ONCE_PER_LONG_REST', value: 1 }
		]
	},
	{
		id: 'angelborn_healing_touch',
		name: 'Healing Touch',
		description:
			'Once per Combat, you can spend 1 AP to touch a creature and Heal it. Make a DC 10 Spell Check. Success: You can restore up to 2 HP to the target. Success (each 5): +1 HP. Failure: You only restore 2 HP.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', value: 'Healing_Touch_OncePerCombat_1AP' }]
	},
	{
		id: 'angelborn_divine_glow',
		name: 'Divine Glow',
		description: 'Your body can emit a Bright Light in a 5 Space radius around you at will.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ABILITY', value: 'Emit_Bright_Light_5Space_Radius_AtWill' }]
	},
	{
		id: 'angelborn_mana_increase',
		name: 'Mana Increase',
		description: 'Your MP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_MP_MAX', value: 1 }]
	},
	{
		id: 'angelborn_celestial_clarity',
		name: 'Celestial Clarity',
		description: 'You have ADV on Saves against being Blinded or Deafened.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Blinded' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Deafened' }
		]
	},
	{
		id: 'angelborn_angelic_insight',
		name: 'Angelic Insight',
		description:
			'Once per Long Rest you can grant yourself ADV on an Insight Check to see if someone is lying.',
		cost: 1,
		effects: [{ type: 'GRANT_ADV_ON_INSIGHT_CHECK_ONCE_PER_LONG_REST', condition: 'see_if_lying' }]
	},
	{
		id: 'angelborn_gift_of_the_angels',
		name: 'Gift of the Angels',
		description:
			'Once per Combat you can spend 1 AP and 1 MP and touch a creature to heal them over time. The creature recovers 1 HP at the start of each of their turns for 1 minute (5 Rounds).',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', value: 'Heal_Over_Time_OncePerCombat_1AP_1MP' }]
	},
	{
		id: 'angelborn_blinding_light',
		name: 'Blinding Light',
		description:
			'Once per Combat, you can spend 1 AP to choose a creature within 5 Spaces and make a Spell Check contested by its Physical Save. Success: The target is Blinded until the end of your next turn.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Blind_Target_OncePerCombat_1AP' }]
	},
	{
		id: 'angelborn_glide_speed',
		name: 'Glide Speed',
		description:
			'You have a set of wings that you can use to horizontally glide and slow your descent. Provided you aren’t Incapacitated, you gain the following benefits while in the air: Controlled Falling: You suffer no damage from Controlled Falling. Altitude Drop: If you end your turn midair, you Controlled Fall 4 Spaces. Glide Speed: You can use your movement to glide horizontally.',
		cost: 2,
		effects: [{ type: 'GRANT_GLIDE_SPEED' }]
	},
	{
		id: 'angelborn_pacifist',
		name: 'Pacifist',
		description:
			'Your divine call is to put others before yourself and resist doing harm. You suffer a -1 penalty to all Checks and Saves made during the first round of Combat.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'PENALTY_ON_CHECKS_SAVES_FIRST_ROUND_OF_COMBAT', value: -1 }]
	},
	{
		id: 'angelborn_umbral_weakness',
		name: 'Umbral Weakness',
		description: 'You have Umbral Vulnerability (1).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_VULNERABILITY_STATIC', target: 'Umbral', value: 1 }]
	},

	// Fiendborn Traits (p. 114)
	{
		id: 'fiendborn_fiendish_resistance',
		name: 'Fiendish Resistance',
		description: 'You gain Resistance (Half) to your Fiendish damage type.',
		cost: 2,
		effects: [{ type: 'GRANT_RESISTANCE_HALF', target: 'Fiendish_damage_type' }]
	},
	{
		id: 'fiendborn_fiendish_magic',
		name: 'Fiendish Magic',
		description:
			'You learn 1 Spell of your choice from the Arcane Spell List from the Destruction or Enchantment Spell Schools. If the Spell deals damage, it must be the same damage type as your Fiendish damage. Once per Long Rest, you can cast the chosen Spell spending 1 less MP than normal (minimum of 0 MP). The Spells total MP cost (before all reductions) still can’t exceed your Mana Spend Limit.',
		cost: 2,
		effects: [
			{
				type: 'GRANT_SPELL_FROM_LIST_SCHOOLS',
				target: 'Arcane_Spell_List',
				schools: ['Destruction', 'Enchantment']
			},
			{
				type: 'REDUCE_MP_COST_ONCE_PER_LONG_REST',
				value: 1,
				condition: 'spell_damage_type_matches_fiendish'
			}
		]
	},
	{
		id: 'fiendborn_darkvision',
		name: 'Darkvision',
		description: 'You have a Darkvision of 10 Spaces.',
		cost: 1,
		effects: [{ type: 'GRANT_DARKVISION', value: 10 }]
	},
	{
		id: 'fiendborn_lights_bane',
		name: 'Light’s Bane',
		description: 'You can spend 1 AP to snuff out a mundane light source within 5 Spaces of you.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ABILITY', value: 'Snuff_Out_Mundane_Light_Source_1AP' }]
	},
	{
		id: 'fiendborn_mana_increase',
		name: 'Mana Increase',
		description: 'Your MP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_MP_MAX', value: 1 }]
	},
	{
		id: 'fiendborn_silver_tongued',
		name: 'Silver-Tongued',
		description:
			'Once per Long Rest you can grant yourself ADV on an Influence Check when trying to deceive someone.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_INFLUENCE_CHECK_ONCE_PER_LONG_REST', condition: 'trying_to_deceive' }
		]
	},
	{
		id: 'fiendborn_fiendish_aura',
		name: 'Fiendish Aura',
		description:
			'You learn the Sorcery Cantrip, but you must choose the type of energy that’s the same as your Fiendish Origin.',
		cost: 1,
		effects: [
			{ type: 'GRANT_SPELL_KNOWN', value: 'Sorcery_Cantrip' },
			{ type: 'SET_SORCERY_ENERGY_TYPE', target: 'Fiendish_Origin' }
		]
	},
	{
		id: 'fiendborn_superior_darkvision',
		name: 'Superior Darkvision',
		description: 'Your Darkvision increases to 20 Spaces.',
		cost: 1,
		prerequisites: ['fiendborn_darkvision'],
		effects: [{ type: 'MODIFY_DARKVISION', value: 20 }]
	},
	{
		id: 'fiendborn_infernal_bravery',
		name: 'Infernal Bravery',
		description: 'You have ADV on Saves against being Intimidated.',
		cost: 1,
		effects: [{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Intimidated' }]
	},
	{
		id: 'fiendborn_intimidator',
		name: 'Intimidator',
		description: 'Once per Combat you can take the Intimidate Action as a Minor Action.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Intimidate_As_Minor_Action_OncePerCombat' }]
	},
	{
		id: 'fiendborn_charming_gaze',
		name: 'Charming Gaze',
		description:
			'You can spend 1 AP to gaze upon a creature you can see within 10 Spaces that can also see you. Make a Spell Check contested by the target’s Repeated Charisma Save. Success: The creature becomes Charmed by you for 1 minute. You can use this ability once per Long Rest, and when you roll for Initiative, or meet some other unique criteria at the GM’s discretion, this ability recharges.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Charm_Target_OncePerLongRest_1AP' }]
	},
	{
		id: 'fiendborn_glide_speed',
		name: 'Glide Speed',
		description:
			'You have a set of wings that you can use to horizontally glide and slow your descent. Provided you aren’t Incapacitated, you gain the following benefits while in the air: Controlled Falling: You suffer no damage from Controlled Falling. Altitude Drop: If you end your turn midair, you Controlled Fall 4 Spaces. Glide Speed: You can use your movement to glide horizontally.',
		cost: 2,
		effects: [{ type: 'GRANT_GLIDE_SPEED' }]
	},
	{
		id: 'fiendborn_radiant_weakness',
		name: 'Radiant Weakness',
		description: 'You have Radiant Vulnerability (1).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_VULNERABILITY_STATIC', target: 'Radiant', value: 1 }]
	},
	{
		id: 'fiendborn_divine_dampening',
		name: 'Divine Dampening',
		description: 'You recover 1 less HP when healed from divine sources.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'REDUCE_HP_REGAINED_FROM_DIVINE_SOURCES', value: 1 }]
	},

	// Beastborn Traits (p. 115-116)
	{
		id: 'beastborn_darkvision',
		name: 'Darkvision',
		description: 'You have Darkvision 10 Spaces.',
		cost: 1,
		effects: [{ type: 'GRANT_DARKVISION', value: 10 }]
	},
	{
		id: 'beastborn_echolocation',
		name: 'Echolocation',
		description:
			'You can spend 1 AP to roar, scream, or screech to gain Blindsight in a 10 Spaces radius that lasts until the start of your next turn. The sound can be heard from up to 100 Spaces away. You gain no benefit from this Trait in an area of Silence.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Echolocation_1AP_10Space_1Round' }]
	},
	{
		id: 'beastborn_keen_sense',
		name: 'Keen Sense',
		description:
			'Choose 1 of the following senses: hearing, sight, or smell. You make Awareness Checks with ADV using the chosen sense.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_ADV_ON_AWARENESS_CHECKS_USING_SENSE',
				target: 'chosen_sense',
				userChoiceRequired: { prompt: 'Choose a sense: hearing, sight, or smell' }
			}
		]
		// This trait can be chosen multiple times, but the interface doesn't directly support that.
		// The logic for handling multiple selections will need to be in the application.
	},
	{
		id: 'beastborn_sunlight_sensitivity',
		name: 'Sunlight Sensitivity',
		description:
			'While you or your target is in sunlight, you have DisADV on Attacks and Awareness Checks that rely on sight.',
		cost: -2,
		isNegative: true,
		effects: [{ type: 'GRANT_DISADV_ON_ATTACKS_AWARENESS_CHECKS_IN_SUNLIGHT' }]
	},
	{
		id: 'beastborn_quick_reactions',
		name: 'Quick Reactions',
		description: 'While you aren’t wearing Armor, you gain +1 PD.',
		cost: 1,
		effects: [{ type: 'MODIFY_PD', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'beastborn_climb_speed',
		name: 'Climb Speed',
		description: 'You gain a Climb Speed equal to your Ground Speed.',
		cost: 1,
		effects: [{ type: 'GRANT_CLIMB_SPEED_EQUAL_TO_SPEED' }]
	},
	{
		id: 'beastborn_spider_climb',
		name: 'Spider Climb',
		description:
			'You can walk without falling on the ceiling and vertical surfaces normally without needing to Climb.',
		cost: 1,
		prerequisites: ['beastborn_climb_speed'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Walk_On_Vertical_Surfaces_Ceilings' }]
	},
	{
		id: 'beastborn_web_walk',
		name: 'Web Walk',
		description:
			'You can walk along and through webs unimpeded. Additionally, you know the location of any creature that’s in contact with the same web.',
		cost: 1,
		effects: [
			{ type: 'IGNORE_DIFFICULT_TERRAIN_FROM_WEBS' },
			{ type: 'KNOW_LOCATION_OF_CREATURES_IN_CONTACT_WITH_WEB' }
		]
	},
	{
		id: 'beastborn_water_breathing',
		name: 'Water Breathing',
		description: 'You can breathe underwater.',
		cost: 1,
		effects: [{ type: 'GRANT_WATER_BREATHING' }]
	},
	{
		id: 'beastborn_swim_speed',
		name: 'Swim Speed',
		description:
			'You gain a Swim Speed equal to your Ground Speed. Additionally, your Breath Duration increases by 3.',
		cost: 1,
		effects: [
			{ type: 'GRANT_SWIM_SPEED_EQUAL_TO_SPEED' },
			{ type: 'MODIFY_BREATH_DURATION', value: 3 }
		]
	},
	{
		id: 'beastborn_speed_increase',
		name: 'Speed Increase',
		description: 'Your Speed increases by 1 Space.',
		cost: 2,
		effects: [{ type: 'MODIFY_SPEED', value: 5 }]
		// This trait can be chosen up to 5 times, but the interface doesn't directly support that.
		// The logic for handling multiple selections will need to be in the application.
	},
	{
		id: 'beastborn_sprint',
		name: 'Sprint',
		description:
			'You can use your Minor Action to take the Move Action. Once you use this Trait, you can’t use it again until you take a turn without taking the Move Action.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', value: 'Move_As_Minor_Action_OncePerTurn_NoMoveAction' }]
	},
	{
		id: 'beastborn_charge',
		name: 'Charge',
		description:
			'If you move at least 2 Spaces in a straight line before making a Melee Attack, the damage of the Attack increases by 1.',
		cost: 2,
		effects: [
			{
				type: 'MODIFY_DAMAGE_ON_MELEE_ATTACK',
				value: 1,
				condition: 'move_2_spaces_straight_before'
			}
		]
	},
	{
		id: 'beastborn_burrow_speed',
		name: 'Burrow Speed',
		description: 'You gain a Burrow Speed equal to half your Movement Speed.',
		cost: 2,
		effects: [{ type: 'GRANT_BURROW_SPEED_HALF_SPEED' }]
	},
	{
		id: 'beastborn_jumper',
		name: 'Jumper',
		description:
			'Your Jump Distance increases by 2, and you can take the Jump Action as a Minor Action.',
		cost: 1,
		effects: [
			{ type: 'MODIFY_JUMP_DISTANCE', value: 2 },
			{ type: 'GRANT_ABILITY', value: 'Jump_As_Minor_Action' }
		]
	},
	{
		id: 'beastborn_strong_jumper',
		name: 'Strong Jumper',
		description:
			'You no longer need to move 2 Spaces before performing a Running Jump, and you take 0 damage from Controlled Falling 5 Spaces or less.',
		cost: 1,
		effects: [
			{ type: 'IGNORE_2_SPACES_MOVEMENT_FOR_RUNNING_JUMP' },
			{ type: 'IGNORE_FALLING_DAMAGE_5_SPACES_OR_LESS' }
		]
	},
	{
		id: 'beastborn_glide_speed',
		name: 'Glide Speed',
		description:
			'You have a set of wings that you can use to horizontally glide and slow your descent. Provided you aren’t Incapacitated, you gain the following benefits while in the air: Controlled Falling: You suffer no damage from Controlled Falling. Altitude Drop: If you end your turn midair, you Controlled Fall 4 Spaces. Glide Speed: You can use your movement to glide horizontally.',
		cost: 2,
		effects: [{ type: 'GRANT_GLIDE_SPEED' }]
	},
	{
		id: 'beastborn_limited_flight',
		name: 'Limited Flight',
		description:
			'You have a set of wings that grant you limited flight. Provided you aren’t Incapacitated, you gain the following benefits: Vertical Ascent: You can spend 2 Spaces of movement to ascend 1 Space vertically. Hover: When you end your turn in the air, you maintain your altitude.',
		cost: 2,
		prerequisites: ['beastborn_glide_speed'],
		effects: [{ type: 'GRANT_LIMITED_FLIGHT' }]
	},
	{
		id: 'beastborn_full_flight',
		name: 'Full Flight',
		description: 'You have a Fly Speed equal to your Ground Speed.',
		cost: 2,
		prerequisites: ['beastborn_limited_flight'],
		effects: [{ type: 'GRANT_FLY_SPEED_EQUAL_TO_SPEED' }]
	},
	{
		id: 'beastborn_flyby',
		name: 'Flyby',
		description: 'You don’t provoke Opportunity Attacks when you Fly out of an enemy’s reach.',
		cost: 1,
		prerequisites: ['beastborn_limited_flight'],
		effects: [{ type: 'IGNORE_OPPORTUNITY_ATTACKS_WHEN_FLY_OUT_OF_REACH' }]
	},
	{
		id: 'beastborn_stealth_feathers',
		name: 'Stealth Feathers',
		description: 'You have ADV on Stealth Checks while Flying.',
		cost: 2,
		prerequisites: ['beastborn_limited_flight'],
		effects: [{ type: 'GRANT_ADV_ON_STEALTH_CHECKS_WHILE_FLYING' }]
	},
	{
		id: 'beastborn_winged_arms',
		name: 'Winged Arms',
		description:
			'Your arms are also your wings. Anytime you use a Glide Speed or Flying Speed, you can’t hold anything in your hands.',
		cost: -1,
		isNegative: true,
		prerequisites: ['beastborn_limited_flight'], // Assuming Limited Flight or Full Flight
		effects: [{ type: 'PENALTY_CANT_HOLD_WHILE_FLYING' }]
	},
	{
		id: 'beastborn_tough',
		name: 'Tough',
		description: 'Your HP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_HP_MAX_STATIC', value: 1 }]
	},
	{
		id: 'beastborn_thick_skinned',
		name: 'Thick-Skinned',
		description: 'While you aren’t wearing Armor, you gain +1 AD.',
		cost: 1,
		effects: [{ type: 'MODIFY_AD', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'beastborn_powerful_build',
		name: 'Powerful Build',
		description: 'You increase by 1 Size, but you occupy the Space of a creature 1 Size smaller.',
		cost: 2,
		effects: [
			{ type: 'MODIFY_SIZE', target: 'Large' },
			{ type: 'MODIFY_SPACE_OCCUPIED', target: '1_Size_Smaller' }
		]
	},
	{
		id: 'beastborn_long_limbed',
		name: 'Long-Limbed',
		description: 'When you make a Melee Martial Attack, your reach is 1 Space greater than normal.',
		cost: 3,
		effects: [{ type: 'MODIFY_MELEE_REACH', value: 1 }]
	},
	{
		id: 'beastborn_secondary_arms',
		name: 'Secondary Arms',
		description:
			'You have 2 slightly smaller secondary arms below your primary pair of arms. They function just like your primary arms, but they can’t wield Weapons with the Heavy Property or Shields.',
		cost: 1,
		effects: [{ type: 'GRANT_SECONDARY_ARMS' }]
	},
	{
		id: 'beastborn_prehensile_appendage',
		name: 'Prehensile Appendage',
		description:
			'You have a prehensile tail or trunk that has a reach of 1 Space and can lift up an amount of pounds equal to your Might times 5 (or half as many kilograms). You can use it to lift, hold, or drop objects, and to push, pull, or grapple creatures. It can’t wield Weapons or Shields, you can’t use tools with it that require manual precision, and you can’t use it in place of Somatic Components for Spells.',
		cost: 1,
		effects: [{ type: 'GRANT_PREHENSILE_APPENDAGE' }]
	},
	{
		id: 'beastborn_hazardous_hide',
		name: 'Hazardous Hide',
		description:
			'You have spikes, retractable barbs, poisonous skin, or some other form of defense mechanism to keep creatures from touching you. Choose 1 of the following damage types: Corrosion, Piercing, or Poison. While you are physically Grappled, your Grappler takes 1 damage of the chosen type at the start of each of its turns. Creatures that start their turn Grappled by you also take this damage.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_DAMAGE_TO_GRAPPLER',
				target: 'chosen_damage_type',
				value: 1,
				userChoiceRequired: { prompt: 'Choose a damage type: Corrosion, Piercing, or Poison' }
			}
		]
	},
	{
		id: 'beastborn_natural_armor',
		name: 'Natural Armor',
		description: 'While not wearing Armor, you gain PDR.',
		cost: 2,
		prerequisites: ['beastborn_thick_skinned'],
		effects: [{ type: 'GRANT_PDR', condition: 'not_wearing_armor' }]
	},
	{
		id: 'beastborn_hard_shell',
		name: 'Hard Shell',
		description:
			'You have a large shell around your body for protection. Your AD increases by 1 (while you’re not wearing Armor), your Movement Speed decreases by 1, and you’re immune to being Flanked.',
		cost: 1,
		prerequisites: ['beastborn_thick_skinned'],
		effects: [
			{ type: 'MODIFY_AD', value: 1, condition: 'not_wearing_armor' },
			{ type: 'MODIFY_SPEED', value: -5 },
			{ type: 'IMMUNE_TO_FLANKING' }
		]
	},
	{
		id: 'beastborn_shell_retreat',
		name: 'Shell Retreat',
		description:
			'Your body has a shell that you can retreat into. You can spend 1 AP to retreat into or come back out of your shell. You gain +5 PD and AD, PDR, EDR and ADV on Might Saves. While in your shell, you’re Prone, you can’t move, you have DisADV on Agility Saves, and you can’t take Reactions.',
		cost: 1,
		prerequisites: ['beastborn_hard_shell'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Retreat_Into_Shell_1AP' }]
	},
	{
		id: 'beastborn_camouflage',
		name: 'Camouflage',
		description:
			'You can change the color and pattern of your body. You have ADV on Stealth Checks while motionless.',
		cost: 2,
		effects: [{ type: 'GRANT_ADV_ON_STEALTH_CHECKS_WHILE_MOTIONLESS' }]
	},
	{
		id: 'beastborn_prowler',
		name: 'Prowler',
		description: 'You have ADV on Stealth Checks while in Darkness.',
		cost: 1,
		effects: [{ type: 'GRANT_ADV_ON_STEALTH_CHECKS_WHILE_IN_DARKNESS' }]
	},
	{
		id: 'beastborn_cold_resistance',
		name: 'Cold Resistance',
		description:
			'You have Cold Resistance (Half) and Resistance to Exhaustion from cold temperatures.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE_HALF', target: 'Cold' },
			{ type: 'GRANT_RESISTANCE_TO_EXHAUSTION', condition: 'cold_temperatures' }
		]
	},
	{
		id: 'beastborn_fire_resistance',
		name: 'Fire Resistance',
		description:
			'You have Fire Resistance (Half) and Resistance to Exhaustion from hot temperatures.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE_HALF', target: 'Fire' },
			{ type: 'GRANT_RESISTANCE_TO_EXHAUSTION', condition: 'hot_temperatures' }
		]
	},
	{
		id: 'beastborn_short_legged',
		name: 'Short-Legged',
		description: 'Your Speed decreases by 1 Space.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SPEED', value: -5 }]
	},
	{
		id: 'beastborn_small_sized',
		name: 'Small-Sized',
		description: 'Your Size is considered Small.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_SIZE', target: 'Small' }]
	},
	{
		id: 'beastborn_reckless',
		name: 'Reckless',
		description: 'Your PD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_PD', value: -1 }]
	},
	{
		id: 'beastborn_natural_weapon',
		name: 'Natural Weapon',
		description:
			'You have up to 2 Natural Weapons (claws, horns, fangs, tail, etc.) which you can use to make Unarmed Strikes that deal 1 Bludgeoning, Piercing, or Slashing damage (your choice upon gaining this Trait). You can perform Attack Maneuvers with your Natural Weapons.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_NATURAL_WEAPON',
				value: 1,
				userChoiceRequired: { prompt: 'Choose a damage type: Bludgeoning, Piercing, or Slashing' }
			}
		]
		// This trait can be chosen multiple times, but the interface doesn't directly support that.
		// The logic for handling multiple selections will need to be in the application.
	},
	{
		id: 'beastborn_extended_natural_weapon',
		name: 'Extended Natural Weapon',
		description: 'Your Natural Weapon now has the Reach Property.',
		cost: 2,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_PROPERTY_TO_NATURAL_WEAPON', target: 'Reach' }]
	},
	{
		id: 'beastborn_natural_projectile',
		name: 'Natural Projectile',
		description:
			'You can use your Natural Weapon to make a Ranged Martial Attack with a Range of 10 Spaces. The Natural Weapon might produce a spine, barb, fluid, or other harmful projectile (your choice).',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Natural_Projectile_Ranged_Attack' }]
	},
	{
		id: 'beastborn_natural_weapon_passive',
		name: 'Natural Weapon Passive',
		description:
			'You can choose 1 Weapon Style that fits your desired Natural Weapon. You can benefit from the chosen Weapon Style’s passive with your Natural Weapon.',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [
			{
				type: 'GRANT_WEAPON_STYLE_PASSIVE_TO_NATURAL_WEAPON',
				target: 'chosen_weapon_style',
				userChoiceRequired: { prompt: 'Choose a Weapon Style' }
			}
		]
	},
	{
		id: 'beastborn_rend',
		name: 'Rend',
		description:
			'You can spend 1 AP when making an Attack Check with your Natural Weapon to force the target to make a Physical Save. Failure: Target begins Bleeding.',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Rend_Bleeding_1AP' }]
	},
	{
		id: 'beastborn_retractable_natural_weapon',
		name: 'Retractable Natural Weapon',
		description:
			'Your Natural Weapon is able to be concealed or retracted and gains the Concealable Property (gain ADV on the first Attack Check you make in Combat).',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_PROPERTY_TO_NATURAL_WEAPON', target: 'Concealable' }]
	},
	{
		id: 'beastborn_venomous_natural_weapon',
		name: 'Venomous Natural Weapon',
		description:
			'When you Hit a creature with your Natural Weapon, they make a Physical Save against your Save DC. Failure: The target becomes Impaired until the start of your next turn.',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_ABILITY', value: 'Venomous_Natural_Weapon_Impaired' }]
	},
	{
		id: 'beastborn_fast_reflexes',
		name: 'Fast Reflexes',
		description:
			'You gain ADV on Initiative Checks and on the first Attack Check you make in Combat.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_INITIATIVE_CHECKS' },
			{ type: 'GRANT_ADV_ON_FIRST_ATTACK_CHECK_IN_COMBAT' }
		]
	},
	{
		id: 'beastborn_mimicry',
		name: 'Mimicry',
		description:
			'You can mimic simple sounds that you’ve heard (such as a baby’s crying, the creak of a door, or single words) and repeat short 3 word phrases that sound identical to what you heard. A creature can make an Insight Check contested by your Trickery Check to determine if this sound is real.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', value: 'Mimic_Simple_Sounds_Short_Phrases' }]
	},
	{
		id: 'beastborn_intimidating_shout',
		name: 'Intimidating Shout',
		description:
			'Once per Combat, you can spend 1 AP to let out an Intimidating Shout. All creatures within 5 Spaces that can hear you must make a Charisma Save contested by your Attack Check. Failure: A target is Hindered on the next Attack Check or Spell Attack it makes before the start of your next turn.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', value: 'Intimidating_Shout_OncePerCombat_1AP' }]
	},
	{
		id: 'beastborn_toxic_fortitude',
		name: 'Toxic Fortitude',
		description: 'You have Poison Resistance (Half) and ADV on Saves against being Poisoned.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE_HALF', target: 'Poison' },
			{ type: 'GRANT_ADV_ON_SAVE_VS_CONDITION', target: 'Poisoned' }
		]
	},
	{
		id: 'beastborn_shoot_webs',
		name: 'Shoot Webs',
		description:
			'You can spend 1 AP to shoot web at a target within 5 Spaces. Make an Attack Check contested by the target’s Physical Save. Success: The target is Restrained by webbing and can spend 1 AP on their turn to attempt to escape (Martial Check vs your Save DC). The webbing can also be attacked and destroyed (PD 5, AD 10, 2 HP; Immunity to Bludgeoning, Poison, and Psychic damage).',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', value: 'Shoot_Webs_1AP' }]
	}
];
```

## File: src/lib/rulesdata/types.ts
```typescript
// src/lib/rulesdata/types.ts

// Interface for Attribute Data
export interface IAttributeData {
	id: 'might' | 'agility' | 'charisma' | 'intelligence';
	name: string;
	description: string;
	derivedStats?: Array<{ statName: string; formula: string }>;
}

// Interface for Trait Effects
export interface ITraitEffect {
	type: string; // e.g., 'MODIFY_ATTRIBUTE', 'GRANT_SKILL_EXPERTISE', 'GRANT_FEATURE'
	target?: string; // e.g., attribute ID ('might'), skill ID ('athletics'), feature ID ('rage')
	value?: any; // e.g., number for attribute modification, object for skill expertise details
	condition?: string; // Optional condition for the effect to apply
	userChoiceRequired?: {
		// Details if the user needs to make a choice for this effect
		prompt: string; // Prompt shown to the user
		options?: string[]; // Optional list of specific options (e.g., skill IDs, attribute IDs)
	};
	descriptionOverride?: string; // Optional override for how this effect is described
	subFeature?: string; // Optional sub-feature identifier for complex effects
	schools?: string[]; // Optional list of spell schools associated with the effect
}

// Interface for Traits
export interface ITrait {
	id: string;
	name: string;
	description: string;
	cost: number; // Ancestry points cost
	isMinor?: boolean; // True if this is a Minor Trait
	isNegative?: boolean; // True if this is a Negative Trait (grants points)
	effects?: ITraitEffect[]; // Array of effects the trait grants
	prerequisites?: any[]; // Optional prerequisites for taking this trait
	sourceAncestryId?: string; // ID of the ancestry this trait belongs to (for combined lists)
}

// Interface for Ancestries
export interface IAncestry {
	id: string;
	name: string;
	description: string;
	defaultTraitIds?: string[]; // Traits automatically granted
	expandedTraitIds: string[]; // Traits available for selection
	origin?: {
		// Optional origin property for ancestries with specific origins (e.g., Dragonborn, Fiendborn, Beastborn)
		prompt: string; // Prompt shown to the user for choosing an origin
		options?: string[]; // Optional list of specific options for the origin
	};
	variantTraits?: ITrait[]; // Optional list of variant traits (e.g., Fallen Angelborn, Redeemed Fiendborn)
}

// Interface for Class Feature Choice Options
export interface IClassFeatureChoiceOption {
	value: string; // Internal value for the choice
	label: string; // Display label for the choice
	description?: string; // Optional description for the choice
	effectsOnChoice?: ITraitEffect[]; // Effects granted if this option is chosen
}

// Interface for Class Feature Choices
export interface IClassFeatureChoice {
	id: string; // Internal ID for the choice (e.g., 'sorcerousOrigin')
	prompt: string; // Prompt shown to the user
	type: 'select_one' | 'select_multiple'; // Type of selection
	maxSelections?: number; // Max number of options if type is 'select_multiple'
	options: IClassFeatureChoiceOption[]; // Available options for the choice
}

// Interface for Class Features
export interface IClassFeature {
	id: string;
	name: string;
	description: string;
	level: number; // Level at which the feature is gained
	effects?: ITraitEffect[]; // Effects granted by the feature
}

// Interface for Class Definitions
export interface IClassDefinition {
	id: string;
	name: string;
	description: string;
	// Base stats granted by the class at Level 1
	baseHpContribution: number;
	startingSP: number;
	startingMP: number;
	skillPointGrantLvl1?: number; // Additional skill points granted at Lvl 1 (beyond Int mod)
	tradePointGrantLvl1?: number; // Additional trade points granted at Lvl 1 (beyond Int mod)
	combatTraining?: string[]; // Array of combat training proficiencies (e.g., 'Weapons', 'All Armor')
	maneuversKnownLvl1?: string | number; // Maneuvers known at Level 1 (can be 'All Attack' or a number)
	techniquesKnownLvl1?: number; // Techniques known at Level 1
	saveDCBase: number;
	deathThresholdBase: number;
	moveSpeedBase: number;
	restPointsBase: number;
	gritPointsBase: number; // Base grit points (before Charisma mod)
	initiativeBonusBase: number; // Base initiative bonus (before Agility mod)
	// Add cantripsKnownLvl1, spellsKnownLvl1 if applicable (not for Barbarian L1)
	cantripsKnownLvl1?: number;
	spellsKnownLvl1?: number;

	level1Features: IClassFeature[]; // Features gained at Level 1
	featureChoicesLvl1?: IClassFeatureChoice[]; // Choices available for features at Level 1
	// ... other level-specific data to be added later
}

// Interface for Skill Data
export interface ISkillData {
	id: string;
	name: string;
	attributeAssociation: 'might' | 'agility' | 'charisma' | 'intelligence' | 'prime'; // Associated attribute
	description: string;
}

// Interface for Trade Data
export interface ITradeData {
	id: string;
	name: string;
	attributeAssociation: 'might' | 'agility' | 'charisma' | 'intelligence'; // Associated attribute
	description: string;
	tools?: string; // Required tools for the trade
}

// Interface for Language Data
export interface ILanguageData {
	id: string;
	name: string;
	type: 'standard' | 'exotic'; // Type of language
	description: string;
}
```

## File: src/lib/server/auth.ts
```typescript
import type { RequestEvent } from '@sveltejs/kit';
import { eq } from 'drizzle-orm';
import { sha256 } from '@oslojs/crypto/sha2';
import { encodeBase64url, encodeHexLowerCase } from '@oslojs/encoding';
import { db } from '$lib/server/db';
import * as table from '$lib/server/db/schema';

const DAY_IN_MS = 1000 * 60 * 60 * 24;

export const sessionCookieName = 'auth-session';

export function generateSessionToken() {
	const bytes = crypto.getRandomValues(new Uint8Array(18));
	const token = encodeBase64url(bytes);
	return token;
}

export async function createSession(token: string, userId: string) {
	const sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));
	const session: table.Session = {
		id: sessionId,
		userId,
		expiresAt: new Date(Date.now() + DAY_IN_MS * 30)
	};
	await db.insert(table.session).values(session);
	return session;
}

export async function validateSessionToken(token: string) {
	const sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));
	const [result] = await db
		.select({
			// Adjust user table here to tweak returned data
			user: { id: table.user.id, username: table.user.username },
			session: table.session
		})
		.from(table.session)
		.innerJoin(table.user, eq(table.session.userId, table.user.id))
		.where(eq(table.session.id, sessionId));

	if (!result) {
		return { session: null, user: null };
	}
	const { session, user } = result;

	const sessionExpired = Date.now() >= session.expiresAt.getTime();
	if (sessionExpired) {
		await db.delete(table.session).where(eq(table.session.id, session.id));
		return { session: null, user: null };
	}

	const renewSession = Date.now() >= session.expiresAt.getTime() - DAY_IN_MS * 15;
	if (renewSession) {
		session.expiresAt = new Date(Date.now() + DAY_IN_MS * 30);
		await db
			.update(table.session)
			.set({ expiresAt: session.expiresAt })
			.where(eq(table.session.id, session.id));
	}

	return { session, user };
}

export type SessionValidationResult = Awaited<ReturnType<typeof validateSessionToken>>;

export async function invalidateSession(sessionId: string) {
	await db.delete(table.session).where(eq(table.session.id, sessionId));
}

export function setSessionTokenCookie(event: RequestEvent, token: string, expiresAt: Date) {
	event.cookies.set(sessionCookieName, token, {
		expires: expiresAt,
		path: '/'
	});
}

export function deleteSessionTokenCookie(event: RequestEvent) {
	event.cookies.delete(sessionCookieName, {
		path: '/'
	});
}
```

## File: src/lib/services/dataMapping.ts
```typescript
// Data mapping utilities for converting between IDs and names
import { ancestriesData } from '../rulesdata/ancestries';
import { classesData } from '../rulesdata/loaders/class.loader';
import type { IAncestry, IClassDefinition } from '../rulesdata/types';

export interface IdNameMapping {
	id: string;
	name: string;
}

/**
 * Get ancestry name from ancestry ID
 */
export const getAncestryName = (ancestryId: string | null): string | null => {
	if (!ancestryId) return null;
	const ancestry = ancestriesData.find((a: IAncestry) => a.id === ancestryId);
	return ancestry?.name || null;
};

/**
 * Get ancestry ID from ancestry name
 */
export const getAncestryId = (ancestryName: string | null): string | null => {
	if (!ancestryName) return null;
	const ancestry = ancestriesData.find(
		(a: IAncestry) => a.name.toLowerCase() === ancestryName.toLowerCase()
	);
	return ancestry?.id || null;
};

/**
 * Get class name from class ID
 */
export const getClassName = (classId: string | null): string | null => {
	if (!classId) return null;
	const classData = classesData.find((c: IClassDefinition) => c.id === classId);
	return classData?.name || null;
};

/**
 * Get class ID from class name
 */
export const getClassId = (className: string | null): string | null => {
	if (!className) return null;
	const classData = classesData.find(
		(c: IClassDefinition) => c.name.toLowerCase() === className.toLowerCase()
	);
	return classData?.id || null;
};

/**
 * Get all available ancestries as ID-name mappings
 */
export const getAncestryMappings = (): IdNameMapping[] => {
	return ancestriesData.map((ancestry: IAncestry) => ({
		id: ancestry.id,
		name: ancestry.name
	}));
};

/**
 * Get all available classes as ID-name mappings
 */
export const getClassMappings = (): IdNameMapping[] => {
	return classesData.map((classData: IClassDefinition) => ({
		id: classData.id,
		name: classData.name
	}));
};

/**
 * Ensure character data has both IDs and names for classes and ancestries
 * This is useful for backwards compatibility and data consistency
 */
export const normalizeCharacterData = (characterData: any): any => {
	const normalized = { ...characterData };

	// Ensure class has both ID and name
	if (normalized.classId && !normalized.className) {
		normalized.className = getClassName(normalized.classId);
	} else if (normalized.className && !normalized.classId) {
		normalized.classId = getClassId(normalized.className);
	}

	// Ensure ancestry1 has both ID and name
	if (normalized.ancestry1Id && !normalized.ancestry1Name) {
		normalized.ancestry1Name = getAncestryName(normalized.ancestry1Id);
	} else if (normalized.ancestry1Name && !normalized.ancestry1Id) {
		normalized.ancestry1Id = getAncestryId(normalized.ancestry1Name);
	}

	// Ensure ancestry2 has both ID and name
	if (normalized.ancestry2Id && !normalized.ancestry2Name) {
		normalized.ancestry2Name = getAncestryName(normalized.ancestry2Id);
	} else if (normalized.ancestry2Name && !normalized.ancestry2Id) {
		normalized.ancestry2Id = getAncestryId(normalized.ancestry2Name);
	}

	return normalized;
};
```

## File: src/lib/utils/classFeatureDescriptions.ts
```typescript
/**
 * @file classFeatureDescriptions.ts
 * @description Utility function to get detailed descriptions for class feature choices
 * from the new class features structure.
 */

import { findChoiceOption } from '../rulesdata/loaders/class-features.loader';

/**
 * Gets detailed description for a class feature choice from the new class features structure.
 *
 * @param choiceId - The ID of the feature choice (e.g., 'cleric_divine_domain')
 * @param optionValue - The value of the selected option (e.g., 'knowledge')
 * @returns Detailed description string or null if not found
 */
export function getDetailedClassFeatureDescription(
	choiceId: string,
	optionValue: string
): string | null {
	switch (choiceId) {
		case 'cleric_divine_domain':
			// Map lowercase option value to proper name for lookup
			const domainNameMap: Record<string, string> = {
				knowledge: 'Knowledge',
				magic: 'Magic',
				divine_damage_expansion: 'Divine Damage Expansion',
				life: 'Life',
				death: 'Death',
				grave: 'Grave',
				light: 'Light',
				dark: 'Dark',
				war: 'War',
				peace: 'Peace',
				order: 'Order',
				chaos: 'Chaos',
				divination: 'Divination',
				trickery: 'Trickery',
				nature: 'Nature',
				tempest: 'Tempest',
				travel: 'Travel',
				ancestral: 'Ancestral'
			};

			const domainName = domainNameMap[optionValue];
			if (!domainName) return null;

			const domainOption = findChoiceOption('Cleric', 'Cleric Order', 0, domainName);
			return domainOption?.description || null;

		case 'monk_stance_choice':
			const stanceNameMap: Record<string, string> = {
				bear_stance: 'Bear Stance',
				bull_stance: 'Bull Stance',
				cobra_stance: 'Cobra Stance',
				gazelle_stance: 'Gazelle Stance',
				mantis_stance: 'Mantis Stance',
				mongoose_stance: 'Mongoose Stance',
				scorpion_stance: 'Scorpion Stance',
				turtle_stance: 'Turtle Stance',
				wolf_stance: 'Wolf Stance'
			};

			const stanceName = stanceNameMap[optionValue];
			if (!stanceName) return null;

			const stanceOption = findChoiceOption('Monk', 'Monk Stance', 0, stanceName);
			return stanceOption?.description || null;

		// Add other class feature choices here when needed
		default:
			return null;
	}
}

/**
 * Type definition for the mapping of choice IDs to their detailed descriptions.
 * This helps with type safety and documentation of what choices have detailed descriptions.
 */
export type SupportedClassFeatureChoices = 'cleric_divine_domain' | 'monk_stance_choice';

/**
 * Checks if a choice ID has detailed descriptions available.
 *
 * @param choiceId - The choice ID to check
 * @returns True if detailed descriptions are available
 */
export function hasDetailedDescription(choiceId: string): choiceId is SupportedClassFeatureChoices {
	const supportedChoices: SupportedClassFeatureChoices[] = [
		'cleric_divine_domain',
		'monk_stance_choice'
	];
	return supportedChoices.includes(choiceId as SupportedClassFeatureChoices);
}
```

## File: src/lib/index.ts
```typescript
// Reexport your entry components here

// Rules data exports
// TODO: weapons.ts deleted - refactor attack system to use inventoryItems.ts
```

## File: src/routes/character-creation/components/LanguagesTab.tsx
```typescript
import React from 'react';
import { languagesData } from '../../../lib/rulesdata/languages';
import type {
	BackgroundPointsData,
	PointConversions,
	ConversionActions
} from './BackgroundPointsManager';
import {
	StyledTabContent,
	StyledSelectionGrid,
	StyledSelectionItem,
	StyledSelectionHeader,
	StyledSelectionName,
	StyledProficiencyButton,
	StyledLanguageFluency,
	StyledPointsRemaining
} from '../styles/Background.styles';

interface LanguagesTabProps {
	currentLanguages: Record<string, { fluency: 'limited' | 'fluent' }>;
	pointsData: BackgroundPointsData;
	conversions: PointConversions;
	actions: ConversionActions;
	onLanguageChange: (languageId: string, fluency: 'limited' | 'fluent' | null) => void;
}

const LanguagesTab: React.FC<LanguagesTabProps> = ({
	currentLanguages,
	pointsData,
	conversions,
	actions,
	onLanguageChange
}) => {
	const getLanguageCost = (fluency: 'limited' | 'fluent') => {
		return fluency === 'limited' ? 1 : 2;
	};

	// Helper function for consistent button styling
	const getButtonStyle = (enabled: boolean, variant: 'primary' | 'danger' = 'primary') => ({
		padding: '0.5rem 1rem',
		backgroundColor: enabled ? (variant === 'primary' ? '#3b82f6' : '#ef4444') : '#6b7280',
		color: 'white',
		border: 'none',
		borderRadius: '6px',
		fontSize: '0.875rem',
		fontWeight: '500',
		cursor: enabled ? 'pointer' : 'not-allowed',
		transition: 'all 0.2s ease',
		opacity: enabled ? 1 : 0.6,
		':hover': enabled
			? {
					backgroundColor: variant === 'primary' ? '#2563eb' : '#dc2626',
					transform: 'translateY(-1px)',
					boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)'
				}
			: {}
	});

	const hasConversions =
		conversions.skillToTradeConversions > 0 ||
		conversions.tradeToSkillConversions > 0 ||
		conversions.tradeToLanguageConversions > 0;

	return (
		<StyledTabContent>
			<StyledPointsRemaining>
				Language Points: {pointsData.availableLanguagePoints - pointsData.languagePointsUsed} /{' '}
				{pointsData.availableLanguagePoints} remaining
				{conversions.tradeToLanguageConversions > 0 && (
					<div
						style={{
							fontSize: '0.9rem',
							color: '#6366f1',
							marginTop: '0.5rem',
							padding: '0.25rem 0.5rem',
							backgroundColor: '#6366f11a',
							borderRadius: '4px',
							border: '1px solid #6366f133'
						}}
					>
						Active conversions: {conversions.tradeToLanguageConversions} trade →{' '}
						{conversions.tradeToLanguageConversions * 2} language
					</div>
				)}
				<div
					style={{
						marginTop: '0.75rem',
						display: 'flex',
						gap: '0.5rem',
						flexWrap: 'wrap'
					}}
				>
					<button
						onClick={actions.convertTradeToLanguage}
						disabled={pointsData.availableTradePoints - pointsData.tradePointsUsed < 1}
						style={getButtonStyle(
							pointsData.availableTradePoints - pointsData.tradePointsUsed >= 1
						)}
						onMouseEnter={(e) => {
							if (pointsData.availableTradePoints - pointsData.tradePointsUsed >= 1) {
								e.currentTarget.style.backgroundColor = '#2563eb';
								e.currentTarget.style.transform = 'translateY(-1px)';
								e.currentTarget.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
							}
						}}
						onMouseLeave={(e) => {
							if (pointsData.availableTradePoints - pointsData.tradePointsUsed >= 1) {
								e.currentTarget.style.backgroundColor = '#3b82f6';
								e.currentTarget.style.transform = 'translateY(0)';
								e.currentTarget.style.boxShadow = 'none';
							}
						}}
					>
						Convert 1 Trade → 2 Language Points
					</button>
					<button
						onClick={actions.resetConversions}
						disabled={!hasConversions}
						style={getButtonStyle(hasConversions, 'danger')}
						onMouseEnter={(e) => {
							if (hasConversions) {
								e.currentTarget.style.backgroundColor = '#dc2626';
								e.currentTarget.style.transform = 'translateY(-1px)';
								e.currentTarget.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
							}
						}}
						onMouseLeave={(e) => {
							if (hasConversions) {
								e.currentTarget.style.backgroundColor = '#ef4444';
								e.currentTarget.style.transform = 'translateY(0)';
								e.currentTarget.style.boxShadow = 'none';
							}
						}}
					>
						Reset Conversions
					</button>
				</div>
			</StyledPointsRemaining>
			<StyledSelectionGrid>
				{languagesData.map((language) => {
					const currentFluency = currentLanguages[language.id]?.fluency || null;
					const isCommon = language.id === 'common';

					return (
						<StyledSelectionItem key={language.id}>
							<StyledSelectionHeader>
								<StyledSelectionName>
									{language.name}
									{isCommon && (
										<span style={{ color: '#10b981', fontSize: '0.8rem', marginLeft: '0.5rem' }}>
											(Free)
										</span>
									)}
								</StyledSelectionName>
								<div style={{ fontSize: '0.8rem', color: '#e2e8f0', textTransform: 'uppercase' }}>
									{(language as any).type}
								</div>
							</StyledSelectionHeader>
							<div style={{ fontSize: '0.9rem', color: '#cbd5e1', marginBottom: '0.5rem' }}>
								{language.description}
							</div>
							<StyledLanguageFluency>
								{!isCommon && (
									<StyledProficiencyButton
										$active={currentFluency === null}
										onClick={() => onLanguageChange(language.id, null)}
									>
										None
									</StyledProficiencyButton>
								)}
								{(['limited', 'fluent'] as const).map((fluency) => {
									const cost = getLanguageCost(fluency);
									const canAfford =
										isCommon ||
										currentFluency === fluency ||
										pointsData.languagePointsUsed + cost <= pointsData.availableLanguagePoints;

									return (
										<StyledProficiencyButton
											key={fluency}
											$active={currentFluency === fluency}
											$disabled={!canAfford && !isCommon}
											onClick={() => {
												if (isCommon || canAfford) {
													onLanguageChange(language.id, fluency);
												}
											}}
										>
											{fluency.charAt(0).toUpperCase() + fluency.slice(1)}{' '}
											{!isCommon && `(${cost})`}
										</StyledProficiencyButton>
									);
								})}
							</StyledLanguageFluency>
						</StyledSelectionItem>
					);
				})}
			</StyledSelectionGrid>
		</StyledTabContent>
	);
};

export default LanguagesTab;
```

## File: src/routes/character-creation/styles/AncestryPointsCounter.styles.ts
```typescript
import styled from 'styled-components';

export const StyledContainer = styled.div`
	padding: 1.5rem;
	border: 2px solid #8b5cf6;
	border-radius: 12px;
	background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
	margin-bottom: 1rem;
	box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3);
	text-align: center;
`;

export const StyledTitle = styled.h2`
	margin: 0;
	color: #fbbf24;
	font-size: 1.3rem;
	font-weight: bold;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	letter-spacing: 1px;
	border-bottom: 2px solid #ef4444;
	padding-bottom: 0.5rem;
`;

export const StyledDetails = styled.div`
	margin-top: 0.5rem;
	color: #d1d5db;
	font-size: 0.9rem;
	font-weight: normal;
`;
```

## File: src/routes/character-creation/styles/Attributes.styles.ts
```typescript
import styled from 'styled-components';

export const StyledContainer = styled.div`
	border: 2px solid #8b5cf6;
	padding: 1.5rem;
	border-radius: 12px;
	background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
	margin-top: 2rem;
	box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3);
`;

export const StyledTitle = styled.h2`
	margin-top: 0;
	color: #fbbf24;
	font-size: 1.3rem;
	font-weight: bold;
	text-align: center;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	letter-spacing: 1px;
	border-bottom: 2px solid #ef4444;
	padding-bottom: 0.5rem;
	margin-bottom: 1rem;
`;

export const StyledPointsRemaining = styled.p`
	margin: 0.5rem 0;
	font-weight: bold;
	color: #ef4444;
	font-size: 1.2rem;
	text-align: center;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledGrid = styled.div`
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
	gap: 1rem;
	margin-top: 1rem;
`;

export const StyledCard = styled.div`
	border: 2px solid #a855f7;
	padding: 1.5rem;
	border-radius: 10px;
	background: linear-gradient(145deg, #2d1b69 0%, #4c1d95 100%);
	text-align: center;
	transition: all 0.3s ease;
	box-shadow: 0 4px 15px rgba(168, 85, 247, 0.2);

	&:hover {
		transform: translateY(-2px);
		box-shadow: 0 8px 25px rgba(168, 85, 247, 0.4);
		border-color: #fbbf24;
	}
`;

export const StyledCardTitle = styled.h3`
	margin: 0 0 0.5rem 0;
	color: #fbbf24;
	font-size: 1.4rem;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledControls = styled.div`
	display: flex;
	align-items: center;
	justify-content: center;
	gap: 1rem;
	margin-top: 0.5rem;
`;

export const StyledButton = styled.button`
	width: 45px;
	height: 45px;
	border: 2px solid #dc2626;
	border-radius: 8px;
	background: linear-gradient(145deg, #991b1b 0%, #dc2626 100%);
	color: #fbbf24;
	cursor: pointer;
	font-size: 1.4rem;
	font-weight: bold;
	transition: all 0.2s ease;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3);

	&:hover {
		background: linear-gradient(145deg, #dc2626 0%, #ef4444 100%);
		transform: translateY(-1px);
		box-shadow: 0 4px 12px rgba(220, 38, 38, 0.5);
		border-color: #fbbf24;
	}

	&:active {
		transform: translateY(0);
	}

	&:disabled {
		opacity: 0.4;
		cursor: not-allowed;
		background: linear-gradient(145deg, #4b5563 0%, #6b7280 100%);
		border-color: #6b7280;
		transform: none;
		box-shadow: none;
	}
`;

export const StyledValue = styled.p`
	margin: 0;
	font-size: 1.5rem;
	font-weight: bold;
	min-width: 40px;
	color: #fbbf24;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	background: linear-gradient(145deg, #1e1b4b 0%, #312e81 100%);
	padding: 0.5rem;
	border-radius: 6px;
	border: 1px solid #8b5cf6;
`;

export const StyledDescription = styled.p`
	color: #e5e7eb;
	font-size: 0.9rem;
	line-height: 1.4;
	margin: 0.5rem 0 1rem 0;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;
```

## File: src/routes/character-creation/styles/Background.styles.ts
```typescript
import styled from 'styled-components';

export const StyledContainer = styled.div`
	border: 2px solid #8b5cf6;
	padding: 1.5rem;
	border-radius: 12px;
	background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
	margin-top: 2rem;
	box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3);
	color: white;
	font-family: 'Inter', sans-serif;
`;

export const StyledSubheading = styled.h2`
	margin-top: 0;
	color: #fbbf24;
	font-size: 1.3rem;
	font-weight: bold;
	text-align: center;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	letter-spacing: 1px;
	border-bottom: 2px solid #ef4444;
	padding-bottom: 0.5rem;
	margin-bottom: 1rem;
`;

export const StyledDescription = styled.p`
	color: #e2e8f0;
	text-align: center;
	margin-bottom: 1.5rem;
	line-height: 1.6;
	font-size: 1rem;
`;

export const StyledTabContainer = styled.div`
	display: flex;
	justify-content: center;
	margin-bottom: 1.5rem;
	border: 2px solid #a855f7;
	border-radius: 10px;
	background: rgba(45, 27, 105, 0.3);
	padding: 0.5rem;
	gap: 0.5rem;
`;

export const StyledTab = styled.button<{ $active: boolean }>`
	padding: 0.75rem 1.5rem;
	border: none;
	border-radius: 8px;
	font-size: 1rem;
	font-weight: 600;
	cursor: pointer;
	transition: all 0.3s ease;

	background: ${(props) =>
		props.$active ? 'linear-gradient(145deg, #fbbf24 0%, #f59e0b 100%)' : 'transparent'};
	color: ${(props) => (props.$active ? '#1e1b4b' : '#e2e8f0')};

	&:hover {
		background: ${(props) =>
			props.$active
				? 'linear-gradient(145deg, #f59e0b 0%, #d97706 100%)'
				: 'rgba(251, 191, 36, 0.1)'};
	}
`;

export const StyledTabContent = styled.div`
	margin: 0 auto;
`;

export const StyledPointsRemaining = styled.div`
	margin: 0.5rem 0;
	font-weight: bold;
	color: #ef4444;
	font-size: 1.2rem;
	text-align: center;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	margin-bottom: 1.5rem;
`;

export const StyledSelectionGrid = styled.div`
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
	gap: 1rem;
	margin-top: 1rem;
`;

export const StyledSelectionItem = styled.div`
	border: 2px solid #a855f7;
	padding: 1.5rem;
	border-radius: 10px;
	background: linear-gradient(145deg, #2d1b69 0%, #4c1d95 100%);
	transition: all 0.3s ease;
	box-shadow: 0 4px 15px rgba(168, 85, 247, 0.2);

	&:hover {
		border-color: #fbbf24;
		transform: translateY(-2px);
		box-shadow: 0 8px 25px rgba(251, 191, 36, 0.3);
	}
`;

export const StyledSelectionHeader = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 0.5rem;
`;

export const StyledSelectionName = styled.h4`
	font-size: 1.1rem;
	font-weight: 600;
	margin: 0;
	color: #fbbf24;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledProficiencySelector = styled.div`
	display: flex;
	gap: 0.5rem;
	flex-wrap: wrap;
	margin-top: 0.5rem;
`;

export const StyledProficiencyButton = styled.button<{ $active?: boolean; $disabled?: boolean }>`
	padding: 0.5rem 1rem;
	border: 2px solid ${(props) => (props.$active ? '#fbbf24' : '#6b7280')};
	border-radius: 6px;
	background: ${(props) => (props.$active ? '#fbbf24' : 'transparent')};
	color: ${(props) => (props.$active ? '#1e1b4b' : '#e2e8f0')};
	font-weight: 600;
	cursor: ${(props) => (props.$disabled ? 'not-allowed' : 'pointer')};
	transition: all 0.2s ease;
	opacity: ${(props) => (props.$disabled ? 0.5 : 1)};

	&:hover:not(:disabled) {
		background: ${(props) => (props.$active ? '#f59e0b' : 'rgba(251, 191, 36, 0.1)')};
		border-color: #fbbf24;
	}
`;

export const StyledLanguageFluency = styled.div`
	display: flex;
	gap: 0.5rem;
	flex-wrap: wrap;
	margin-top: 0.5rem;
`;

export const StyledError = styled.div`
	background-color: rgba(239, 68, 68, 0.1);
	border: 1px solid #ef4444;
	color: #ef4444;
	padding: 0.75rem;
	border-radius: 6px;
	margin-top: 1rem;
	font-size: 0.9rem;
	text-align: center;
`;
```

## File: src/routes/character-creation/styles/CharacterName.styles.ts
```typescript
import styled from 'styled-components';

export const StyledContainer = styled.div`
	border: 2px solid #8b5cf6;
	padding: 2rem;
	border-radius: 12px;
	background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
	margin-top: 2rem;
	box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3);
	max-width: 600px;
	margin: 2rem auto;
`;

export const StyledTitle = styled.h2`
	margin-top: 0;
	color: #fbbf24;
	font-size: 1.3rem;
	font-weight: bold;
	text-align: center;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	letter-spacing: 1px;
	border-bottom: 2px solid #ef4444;
	padding-bottom: 0.5rem;
	margin-bottom: 2rem;
`;

export const StyledInputGroup = styled.div`
	margin-bottom: 1.5rem;
`;

export const StyledLabel = styled.label`
	display: block;
	margin-bottom: 0.5rem;
	color: #fbbf24;
	font-weight: bold;
	font-size: 1rem;
`;

export const StyledInput = styled.input`
	width: 100%;
	padding: 0.75rem;
	border: 2px solid #a855f7;
	border-radius: 8px;
	background: rgba(45, 27, 105, 0.8);
	color: #e5e7eb;
	font-size: 1rem;
	transition: all 0.3s ease;

	&:focus {
		outline: none;
		border-color: #fbbf24;
		box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.2);
	}

	&::placeholder {
		color: #9ca3af;
	}
`;

export const StyledSuggestionSection = styled.div`
	margin-top: 1.5rem;
	padding: 1.5rem;
	border: 2px solid #a855f7;
	border-radius: 8px;
	background: rgba(45, 27, 105, 0.4);
`;

export const StyledSuggestionTitle = styled.h3`
	margin: 0 0 1rem 0;
	color: #fbbf24;
	font-size: 1.1rem;
	font-weight: bold;
`;

export const StyledSuggestionGrid = styled.div`
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
	gap: 0.5rem;
	margin-bottom: 1rem;
	max-height: 200px;
	overflow-y: auto;
`;

export const StyledSuggestionButton = styled.button`
	padding: 0.5rem 1rem;
	border: 2px solid #a855f7;
	border-radius: 6px;
	background: transparent;
	color: #e5e7eb;
	cursor: pointer;
	transition: all 0.3s ease;
	font-size: 0.9rem;

	&:hover {
		background: #a855f7;
		color: #1e1b4b;
		transform: translateY(-2px);
	}
`;

export const StyledGenerateButton = styled.button`
	padding: 0.75rem 1.5rem;
	border: none;
	border-radius: 8px;
	background: linear-gradient(145deg, #fbbf24 0%, #f59e0b 100%);
	color: #1e1b4b;
	font-weight: bold;
	cursor: pointer;
	transition: all 0.3s ease;
	width: 100%;

	&:hover {
		background: linear-gradient(145deg, #f59e0b 0%, #d97706 100%);
		transform: translateY(-2px);
		box-shadow: 0 4px 12px rgba(251, 191, 36, 0.4);
	}

	&:disabled {
		opacity: 0.5;
		cursor: not-allowed;
		transform: none;
	}
`;

export const StyledCharacterInfo = styled.div`
	margin-bottom: 1.5rem;
	padding: 1rem;
	border: 2px solid #ef4444;
	border-radius: 8px;
	background: rgba(239, 68, 68, 0.1);
	text-align: center;
`;

export const StyledCharacterDetails = styled.p`
	margin: 0;
	color: #e5e7eb;
	font-size: 1rem;
	line-height: 1.6;
`;
```

## File: src/routes/character-creation/styles/SelectedAncestries.styles.ts
```typescript
import styled from 'styled-components';

export const StyledOuterContainer = styled.div`
	border: 2px solid #8b5cf6;
	padding: 1.5rem;
	border-radius: 12px;
	background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
	margin-top: 2rem;
	box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3);
`;

export const StyledMainTitle = styled.h2`
	margin-top: 0;
	color: #fbbf24;
	font-size: 1.3rem;
	font-weight: bold;
	text-align: center;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	letter-spacing: 1px;
	border-bottom: 2px solid #ef4444;
	padding-bottom: 0.5rem;
	margin-bottom: 1rem;
`;

export const StyledContainer = styled.div`
	display: flex;
	flex-direction: column;
	gap: 2rem;
`;

export const StyledAncestryDetails = styled.div`
	border: 2px solid #a855f7;
	padding: 1.5rem;
	border-radius: 10px;
	background: linear-gradient(145deg, #2d1b69 0%, #4c1d95 100%);
	box-shadow: 0 4px 15px rgba(168, 85, 247, 0.2);
`;

export const StyledTitle = styled.h2`
	margin: 0 0 1rem 0;
	color: #fbbf24;
	font-size: 1.3rem;
	font-weight: bold;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	text-align: center;
	border-bottom: 2px solid #ef4444;
	padding-bottom: 0.5rem;
`;

export const StyledSubtitle = styled.h3`
	margin: 1rem 0 0.5rem 0;
	color: #ef4444;
	font-size: 1.3rem;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	border-bottom: 1px solid #ef4444;
	padding-bottom: 0.25rem;
`;

export const StyledList = styled.ul`
	list-style: none;
	padding: 0;
	margin: 0;
`;

export const StyledListItem = styled.li`
	margin-bottom: 0.8rem;
	padding: 0.5rem;
	border-radius: 5px;
	background: rgba(139, 92, 246, 0.1);
	border-left: 3px solid #8b5cf6;
`;

export const StyledLabel = styled.label`
	display: flex;
	align-items: flex-start;
	gap: 0.8rem;
	cursor: pointer;
	color: #e5e7eb;
	font-size: 0.95rem;
	line-height: 1.4;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);

	&:hover {
		color: #fbbf24;
	}
`;

export const StyledCheckbox = styled.input`
	margin-top: 0.25rem;
	flex-shrink: 0;
	width: 18px;
	height: 18px;
	accent-color: #ef4444;
	cursor: pointer;
`;
```

## File: src/routes/character-creation/CharacterCreation.spec.ts
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';

// Mock the complex dependencies
vi.mock('../../lib/rulesdata/loaders/class.loader', () => ({
  classesData: [
    {
      id: 'barbarian',
      name: 'Barbarian',
      hitDie: 'd12'
    }
  ]
}));

vi.mock('../../lib/rulesdata/loaders/class-features.loader', () => ({
  findClassByName: (className: string) => ({
    className: 'Barbarian',
    coreFeatures: [
      {
        levelGained: 1,
        featureName: 'Test Feature',
        effects: [
          {
            type: 'MODIFY_STAT',
            target: 'skillPoints',
            value: 1
          }
        ]
      }
    ]
  })
}));

vi.mock('../../lib/rulesdata/_new_schema/traits', () => ({
  traitsData: [
    // Human traits
    {
      id: 'human_skill_expertise',
      name: 'Skill Expertise',
      description: 'Grants +1 skill point',
      cost: 2,
      effects: [
        {
          type: 'MODIFY_STAT',
          target: 'skillPoints',
          value: 1
        }
      ]
    },
    {
      id: 'human_resolve',
      name: 'Human Resolve',
      description: 'Expanded death threshold',
      cost: 1,
      effects: [
        {
          type: 'MODIFY_STAT',
          target: 'deathThresholdModifier',
          value: 1
        }
      ]
    },
    // Grasslands Urban traits
    {
      id: 'grasslands_urban_versatility',
      name: 'Urban Versatility',
      description: 'Grants +1 skill point from urban environment',
      cost: 1,
      effects: [
        {
          type: 'MODIFY_STAT',
          target: 'skillPoints',
          value: 1
        }
      ]
    },
    {
      id: 'grasslands_survival',
      name: 'Grasslands Survival',
      description: 'Survival skills in grasslands',
      cost: 1,
      effects: [
        {
          type: 'GRANT_PROFICIENCY',
          target: 'survival',
          value: 1
        }
      ]
    }
  ]
}));

// Test data for validation
const mockCharacterState = {
  currentStep: 4,
  classId: 'barbarian',
  ancestry1Id: 'human',
  ancestry2Id: 'grasslands',
  selectedTraitIds: ['human_skill_expertise', 'human_resolve', 'grasslands_urban_versatility'],
  attribute_intelligence: 0,
  selectedFeatureChoices: {},
  skillsData: {},
  tradesData: {},
  languagesData: { common: { fluency: 'fluent' } },
  selectedSpells: [],
  selectedManeuvers: [],
  skillToTradeConversions: 0,
  tradeToSkillConversions: 0,
  schemaVersion: 2
};

// Helper function to extract skill points from validation logic
const calculateSkillPoints = (
  intelligenceModifier: number,
  selectedTraitIds: string[],
  classFeatures?: any,
  selectedFeatureChoices?: any
): number => {
  const { traitsData } = require('../../lib/rulesdata/_new_schema/traits');
  
  let bonusSkillPoints = 0;
  
  // From traits
  selectedTraitIds.forEach((traitId: string) => {
    const trait = traitsData.find((t: any) => t.id === traitId);
    if (trait) {
      trait.effects.forEach((effect: any) => {
        if (effect.type === 'MODIFY_STAT' && effect.target === 'skillPoints') {
          bonusSkillPoints += effect.value as number;
        }
      });
    }
  });
  
  // From class features (simplified for test)
  if (classFeatures && selectedFeatureChoices) {
    bonusSkillPoints += 1; // Mock class feature bonus
  }
  
  return Math.max(1, 5 + intelligenceModifier + bonusSkillPoints);
};

describe('CharacterCreation - Skill Points Calculation', () => {
  beforeEach(() => {
    // Clear any previous console logs
    vi.clearAllMocks();
  });

  describe('Background Step Validation', () => {
    it('should calculate correct skill points for Human Grasslands Urban with 0 Intelligence', () => {
      const skillPoints = calculateSkillPoints(
        0, // Intelligence modifier
        ['human_skill_expertise', 'grasslands_urban_versatility'], // Traits
        null, // No class features for this test
        {}
      );
      
      // Expected: 5 (base) + 0 (int) + 1 (human) + 1 (grasslands urban) = 7
      expect(skillPoints).toBe(7);
    });

    it('should calculate correct skill points for Human Grasslands Urban with +2 Intelligence', () => {
      const skillPoints = calculateSkillPoints(
        2, // Intelligence modifier
        ['human_skill_expertise', 'grasslands_urban_versatility'],
        null,
        {}
      );
      
      // Expected: 5 (base) + 2 (int) + 1 (human) + 1 (grasslands urban) = 9
      expect(skillPoints).toBe(9);
    });

    it('should calculate correct skill points for Human without Grasslands Urban bonus', () => {
      const skillPoints = calculateSkillPoints(
        0, // Intelligence modifier
        ['human_skill_expertise'], // Only human trait
        null,
        {}
      );
      
      // Expected: 5 (base) + 0 (int) + 1 (human) = 6
      expect(skillPoints).toBe(6);
    });

    it('should handle minimum skill points (1) even with negative intelligence', () => {
      const skillPoints = calculateSkillPoints(
        -3, // Very negative intelligence
        [], // No trait bonuses
        null,
        {}
      );
      
      // Expected: Math.max(1, 5 + (-3) + 0) = Math.max(1, 2) = 2
      expect(skillPoints).toBe(2);
    });

    it('should include class feature bonuses in calculation', () => {
      const { findClassByName } = require('../../lib/rulesdata/loaders/class-features.loader');
      const classFeatures = findClassByName('Barbarian');
      
      const skillPoints = calculateSkillPoints(
        0, // Intelligence modifier
        ['human_skill_expertise'], // +1 from human
        classFeatures, // +1 from class feature
        { 'barbarian_test_feature_0': 'selected' }
      );
      
      // Expected: 5 (base) + 0 (int) + 1 (human) + 1 (class) = 7
      expect(skillPoints).toBe(7);
    });

    it('should handle missing traits gracefully', () => {
      const skillPoints = calculateSkillPoints(
        0,
        ['nonexistent_trait'], // This trait doesn't exist
        null,
        {}
      );
      
      // Expected: 5 (base) + 0 (int) + 0 (no valid traits) = 5
      expect(skillPoints).toBe(5);
    });
  });

  describe('Background Stage Validation Logic', () => {
    it('should validate skill points are fully spent', () => {
      const availableSkillPoints = 7; // Human Grasslands Urban
      const skillPointsUsed = 7; // All points spent
      const skillPointsRemaining = availableSkillPoints - skillPointsUsed;
      
      expect(skillPointsRemaining).toBe(0);
    });

    it('should fail validation when skill points remain unspent', () => {
      const availableSkillPoints = 7; // Human Grasslands Urban
      const skillPointsUsed = 5; // Not all points spent
      const skillPointsRemaining = availableSkillPoints - skillPointsUsed;
      
      expect(skillPointsRemaining).toBeGreaterThan(0);
    });

    it('should allow completion with trade/language points spent', () => {
      const tradePointsUsed = 1;
      const languagePointsUsed = 0;
      const hasSpentSomeTradeOrLanguagePoints = tradePointsUsed > 0 || languagePointsUsed > 0;
      
      expect(hasSpentSomeTradeOrLanguagePoints).toBe(true);
    });

    it('should allow completion when no trade/language points available', () => {
      const availableTradePoints = 0;
      const availableLanguagePoints = 0;
      const hasNoTradeOrLanguagePointsToSpend = availableTradePoints <= 0 && availableLanguagePoints <= 0;
      
      expect(hasNoTradeOrLanguagePointsToSpend).toBe(true);
    });
  });

  describe('Point Conversions', () => {
    it('should handle skill-to-trade conversions correctly', () => {
      // This would test the conversion logic:
      // 1 skill point = 2 trade points
      // 2 trade points = 1 skill point
      
      const baseSkillPoints = 7; // Human Grasslands Urban base
      const skillToTrade = 2; // Convert 2 skill points
      const tradeToSkill = 0;
      
      const availableSkillPoints = baseSkillPoints - skillToTrade + Math.floor(tradeToSkill / 2);
      const expectedAvailableSkillPoints = 5; // 7 - 2 + 0
      
      expect(availableSkillPoints).toBe(expectedAvailableSkillPoints);
    });

    it('should handle trade-to-skill conversions correctly', () => {
      const baseSkillPoints = 7; // Human Grasslands Urban base
      const skillToTrade = 0;
      const tradeToSkill = 4; // Convert 4 trade points (2 skills worth)
      
      const availableSkillPoints = baseSkillPoints - skillToTrade + Math.floor(tradeToSkill / 2);
      const expectedAvailableSkillPoints = 9; // 7 - 0 + Math.floor(4 / 2) = 7 + 2
      
      expect(availableSkillPoints).toBe(expectedAvailableSkillPoints);
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty trait arrays', () => {
      const skillPoints = calculateSkillPoints(0, [], null, {});
      expect(skillPoints).toBe(5); // Just base + intelligence
    });

    it('should handle undefined selectedTraitIds', () => {
      const skillPoints = calculateSkillPoints(0, [], null, {});
      expect(skillPoints).toBe(5);
    });

    it('should handle traits with non-skillPoints effects', () => {
      const skillPoints = calculateSkillPoints(
        0,
        ['human_resolve'], // This trait doesn't give skill points
        null,
        {}
      );
      expect(skillPoints).toBe(5); // No bonus from this trait
    });
  });
});
```

## File: src/routes/character-creation/CharacterName.tsx
```typescript
import { useState } from 'react';
import { useCharacter } from '../../lib/stores/characterContext';
import { nameByRace } from 'fantasy-name-generator';
import {
	StyledContainer,
	StyledTitle,
	StyledInputGroup,
	StyledLabel,
	StyledInput,
	StyledSuggestionSection,
	StyledSuggestionTitle,
	StyledSuggestionGrid,
	StyledSuggestionButton,
	StyledGenerateButton,
	StyledCharacterInfo,
	StyledCharacterDetails
} from './styles/CharacterName.styles';

// Name generation using fantasy-name-generator npm package
const generateNamesFromNPM = (race: string): string[] => {
	try {
		const names: string[] = [];

		// Generate 6 different names (3 male, 3 female)
		for (let i = 0; i < 3; i++) {
			const maleName = nameByRace(race, { gender: 'male' });
			const femaleName = nameByRace(race, { gender: 'female' });

			if (maleName && typeof maleName === 'string') {
				names.push(maleName);
			}
			if (femaleName && typeof femaleName === 'string') {
				names.push(femaleName);
			}
		}

		return names.filter((name) => name.length > 0);
	} catch (error) {
		console.error('Error generating names from npm package:', error);
		return [];
	}
};

function CharacterName() {
	const { state, dispatch } = useCharacter();
	const [characterName, setCharacterName] = useState(state.finalName || '');
	const [playerName, setPlayerName] = useState(state.finalPlayerName || '');
	const [suggestions, setSuggestions] = useState<string[]>([]);
	const [isGenerating, setIsGenerating] = useState(false);

	const getFallbackNames = (ancestry: string) => {
		const fallbackNames: { [key: string]: string[] } = {
			human: ['Aiden', 'Brianna', 'Connor', 'Diana', 'Ethan', 'Fiona'],
			elf: ['Aerdrie', 'Berrian', 'Caelynn', 'Dayereth', 'Enna', 'Galinndan'],
			dwarf: ['Adrik', 'Baern', 'Cathra', 'Darrak', 'Eberk', 'Falkrunn'],
			halfling: ['Alton', 'Bree', 'Cora', 'Daisy', 'Eldon', 'Finnan'],
			dragonborn: ['Arjhan', 'Balasar', 'Bharash', 'Donaar', 'Ghesh', 'Heskan'],
			gnome: ['Alston', 'Boddynock', 'Brocc', 'Burgell', 'Dimble', 'Eldon'],
			'half-elf': ['Aramil', 'Berrian', 'Carric', 'Dayereth', 'Enna', 'Galinndan'],
			'half-orc': ['Dench', 'Feng', 'Gell', 'Henk', 'Holg', 'Imsh'],
			tiefling: ['Akmenos', 'Amnon', 'Barakas', 'Damakos', 'Ekemon', 'Iados']
		};

		return fallbackNames[ancestry] || fallbackNames.human;
	};

	const generateNames = () => {
		// No need for rate limiting with npm package, but keep generating state for UX
		if (isGenerating) {
			return;
		}

		setIsGenerating(true);

		try {
			// Get character details
			const ancestry1 = state.ancestry1Id?.toLowerCase() || 'human';
			const ancestry2 = state.ancestry2Id?.toLowerCase();

			// Map ancestry names to npm package race names
			const raceMapping: { [key: string]: string } = {
				human: 'human',
				elf: 'elf',
				dwarf: 'dwarf',
				halfling: 'halfling',
				dragonborn: 'dragon',
				gnome: 'gnome',
				'half-elf': 'elf',
				'half-orc': 'orc',
				tiefling: 'demon',
				default: 'human'
			};

			// Always generate names from first ancestry
			const mappedRace1 = raceMapping[ancestry1] || 'human';
			const npmNames1 = generateNamesFromNPM(mappedRace1);
			const fallbackNames1 = getFallbackNames(ancestry1);
			let allNames = [...npmNames1, ...fallbackNames1].slice(0, 6);

			// If second ancestry exists, append 6 more names from it
			if (ancestry2) {
				const mappedRace2 = raceMapping[ancestry2] || 'human';
				const npmNames2 = generateNamesFromNPM(mappedRace2);
				const fallbackNames2 = getFallbackNames(ancestry2);
				const names2 = [...npmNames2, ...fallbackNames2].slice(0, 6);
				allNames = [...allNames, ...names2];
			}

			// Remove duplicates and limit appropriately
			const uniqueNames = [...new Set(allNames)];

			// Add a small delay for better UX (simulate processing)
			setTimeout(() => {
				setSuggestions(uniqueNames);
				setIsGenerating(false);
			}, 500);
		} catch (error) {
			console.error('Error generating names:', error);
			// Fallback to local names
			const fallbackNames = getFallbackNames(state.ancestry1Id?.toLowerCase() || 'human');
			setSuggestions(fallbackNames);
			setIsGenerating(false);
		}
	};

	const selectSuggestion = (name: string) => {
		setCharacterName(name);
		// Update the context immediately
		dispatch({
			type: 'UPDATE_STORE',
			updates: {
				finalName: name
			}
		});
	};

	const getCharacterDescription = () => {
		const ancestry1 = state.ancestry1Id;
		const ancestry2 = state.ancestry2Id;
		const classId = state.classId;

		let ancestryDescription = 'Your Character';

		if (ancestry1 && ancestry2) {
			// Both ancestries exist
			ancestryDescription = `${ancestry1.charAt(0).toUpperCase() + ancestry1.slice(1)}/${ancestry2.charAt(0).toUpperCase() + ancestry2.slice(1)}`;
		} else if (ancestry1) {
			// Only first ancestry
			ancestryDescription = `${ancestry1.charAt(0).toUpperCase() + ancestry1.slice(1)}`;
		}

		if (classId) {
			return `${ancestryDescription} ${classId.charAt(0).toUpperCase() + classId.slice(1)}`;
		}

		return ancestryDescription;
	};

	return (
		<StyledContainer>
			<StyledTitle>Name Your Character</StyledTitle>

			<StyledCharacterInfo>
				<StyledCharacterDetails>Creating: {getCharacterDescription()}</StyledCharacterDetails>
			</StyledCharacterInfo>

			<StyledInputGroup>
				<StyledLabel htmlFor="characterName">Character Name</StyledLabel>
				<StyledInput
					id="characterName"
					type="text"
					value={characterName}
					onChange={(e) => {
						const value = e.target.value;
						setCharacterName(value);
						// Update the context immediately
						dispatch({
							type: 'UPDATE_STORE',
							updates: {
								finalName: value.trim() || null
							}
						});
					}}
					placeholder="Enter your character's name"
				/>
			</StyledInputGroup>

			<StyledInputGroup>
				<StyledLabel htmlFor="playerName">Player Name</StyledLabel>
				<StyledInput
					id="playerName"
					type="text"
					value={playerName}
					onChange={(e) => {
						const value = e.target.value;
						setPlayerName(value);
						// Update the context immediately
						dispatch({
							type: 'UPDATE_STORE',
							updates: {
								finalPlayerName: value.trim() || null
							}
						});
					}}
					placeholder="Enter your name"
				/>
			</StyledInputGroup>

			<StyledSuggestionSection>
				<StyledSuggestionTitle>Name Suggestions</StyledSuggestionTitle>
				{suggestions.length > 0 && (
					<StyledSuggestionGrid>
						{suggestions.map((name, index) => (
							<StyledSuggestionButton key={index} onClick={() => selectSuggestion(name)}>
								{name}
							</StyledSuggestionButton>
						))}
					</StyledSuggestionGrid>
				)}
				<StyledGenerateButton onClick={generateNames} disabled={isGenerating}>
					{isGenerating ? 'Generating...' : 'Generate Names'}
				</StyledGenerateButton>
			</StyledSuggestionSection>
		</StyledContainer>
	);
}

export default CharacterName;
```

## File: src/routes/character-sheet/components/DefenseChangeModal.tsx
```typescript
import React, { useState } from 'react';
import styled from 'styled-components';

const ModalOverlay = styled.div`
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background: rgba(0, 0, 0, 0.5);
	display: flex;
	align-items: center;
	justify-content: center;
	z-index: 1000;
`;

const ModalContent = styled.div`
	background: white;
	border: 3px solid #8b4513;
	border-radius: 8px;
	padding: 2rem;
	max-width: 500px;
	width: 90%;
	max-height: 90vh;
	overflow-y: auto;
`;

const ModalTitle = styled.h3`
	color: #8b4513;
	font-size: 1.25rem;
	font-weight: bold;
	margin: 0 0 1rem 0;
	text-align: center;
`;

const ChangeInfo = styled.div`
	background: #f9f9f9;
	border: 1px solid #8b4513;
	border-radius: 4px;
	padding: 1rem;
	margin-bottom: 1rem;
	font-size: 0.9rem;
	color: #2d2d2d;
`;

const Label = styled.label`
	display: block;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.5rem;
`;

const TextArea = styled.textarea`
	width: 100%;
	min-height: 100px;
	padding: 0.75rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	font-family: 'Georgia', serif;
	font-size: 0.9rem;
	color: #2d2d2d;
	resize: vertical;

	&:focus {
		outline: none;
		border-color: #8b4513;
		box-shadow: 0 0 0 1px #8b4513;
	}
`;

const ButtonGroup = styled.div`
	display: flex;
	gap: 0.75rem;
	justify-content: flex-end;
	margin-top: 1.5rem;
`;

const Button = styled.button<{ variant?: 'primary' | 'secondary' }>`
	padding: 0.5rem 1rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	font-weight: bold;
	cursor: pointer;
	transition: all 0.2s ease;

	${(props) =>
		props.variant === 'primary'
			? `
		background: #8b4513;
		color: white;
		
		&:hover {
			background-color: #6d3410;
		}
	`
			: `
		background: #f9f9f9;
		color: #8b4513;
		
		&:hover {
			background: #8b4513;
			color: white;
		}
	`}

	&:disabled {
		opacity: 0.5;
		cursor: not-allowed;
	}
`;

interface DefenseChangeModalProps {
	isOpen: boolean;
	defenseType: string;
	oldValue: number;
	newValue: number;
	onConfirm: (reason: string) => void;
	onCancel: () => void;
}

const DefenseChangeModal: React.FC<DefenseChangeModalProps> = ({
	isOpen,
	defenseType,
	oldValue,
	newValue,
	onConfirm,
	onCancel
}) => {
	const [reason, setReason] = useState('');

	if (!isOpen) return null;

	const handleSubmit = () => {
		if (reason.trim()) {
			onConfirm(reason.trim());
			setReason('');
		}
	};

	const handleCancel = () => {
		onCancel();
		setReason('');
	};

	const handleKeyDown = (e: React.KeyboardEvent) => {
		if (e.key === 'Escape') {
			handleCancel();
		} else if (e.key === 'Enter' && e.ctrlKey && reason.trim()) {
			handleSubmit();
		}
	};

	return (
		<ModalOverlay onClick={handleCancel} onKeyDown={handleKeyDown}>
			<ModalContent onClick={(e) => e.stopPropagation()}>
				<ModalTitle>Defense Change Reason</ModalTitle>

				<ChangeInfo>
					<strong>{defenseType}</strong> changed from <strong>{oldValue}</strong> to{' '}
					<strong>{newValue}</strong>
				</ChangeInfo>

				<Label htmlFor="reason">
					Why are you changing this defense value?
					<span style={{ fontSize: '0.8rem', fontWeight: 'normal', color: '#666' }}>
						{' '}
						(e.g., "Equipped +2 Shield", "Cast Shield spell", "Monk stance bonus")
					</span>
				</Label>

				<TextArea
					id="reason"
					value={reason}
					onChange={(e) => setReason(e.target.value)}
					placeholder="Enter the reason for this defense change..."
					autoFocus
				/>

				<ButtonGroup>
					<Button variant="secondary" onClick={handleCancel}>
						Cancel
					</Button>
					<Button variant="primary" onClick={handleSubmit} disabled={!reason.trim()}>
						Save Change
					</Button>
				</ButtonGroup>

				<div
					style={{
						fontSize: '0.8rem',
						color: '#666',
						marginTop: '0.5rem',
						textAlign: 'center'
					}}
				>
					Press Ctrl+Enter to save, Esc to cancel
				</div>
			</ModalContent>
		</ModalOverlay>
	);
};

export default DefenseChangeModal;
```

## File: src/routes/character-sheet/components/Languages.tsx
```typescript
import React from 'react';
import type { LanguageData } from '../../../types';
import { SectionTitle, SectionDescription } from '../styles/KnowledgeTrades';
import {
	LanguagesSection,
	LanguageRow,
	LanguageName,
	FluencyContainer,
	FluencyBox,
	FluencyHeader,
	LanguageNameHeader,
	FluencyHeaderContainer,
	FluencyHeaderLabel
} from '../styles/Languages';

interface LanguagesProps {
	languages: LanguageData[];
}

const Languages: React.FC<LanguagesProps> = ({ languages }) => {
	return (
		<LanguagesSection>
			<SectionTitle>LANGUAGES</SectionTitle>
			<SectionDescription>LANGUAGE CHECK = d20 + Intelligence or Charisma</SectionDescription>

			{/* Header with L and F labels */}
			<FluencyHeader>
				<LanguageNameHeader>LANGUAGE</LanguageNameHeader>
				<FluencyHeaderContainer>
					<FluencyHeaderLabel title="Limited">L</FluencyHeaderLabel>
					<FluencyHeaderLabel title="Fluent">F</FluencyHeaderLabel>
				</FluencyHeaderContainer>
			</FluencyHeader>

			{languages.map((language) => (
				<LanguageRow key={language.id}>
					<LanguageName>{language.name.toUpperCase()}</LanguageName>
					<FluencyContainer>
						<FluencyBox filled={language.fluency === 'limited'} />
						<FluencyBox filled={language.fluency === 'fluent'} />
					</FluencyContainer>
				</LanguageRow>
			))}
		</LanguagesSection>
	);
};

export default Languages;
```

## File: src/routes/character-sheet/components/RightColumnResources.tsx
```typescript
import React from 'react';
import type { CharacterSheetData, CurrentValues } from '../../../types';
import {
	StyledRightResourcesContainer,
	StyledRightResourcesTitle,
	StyledRightResourceRow,
	StyledRightResourceLabel,
	StyledRightResourceControls,
	StyledRightResourceInput,
	StyledRightResourceMax
} from '../styles/RightColumnResources.styles';

interface RightColumnResourcesProps {
	characterData: CharacterSheetData;
	currentValues: CurrentValues;
	onResourceInputChange: (resource: keyof CurrentValues, value: string) => void;
}

const RightColumnResources: React.FC<RightColumnResourcesProps> = ({
	characterData,
	currentValues,
	onResourceInputChange
}) => {
	return (
		<StyledRightResourcesContainer>
			<StyledRightResourcesTitle>RESOURCES</StyledRightResourcesTitle>

			<StyledRightResourceRow>
				<StyledRightResourceLabel>REST POINTS</StyledRightResourceLabel>
				<StyledRightResourceControls>
					<StyledRightResourceInput
						type="number"
						value={currentValues.currentRestPoints}
						onChange={(e) => onResourceInputChange('currentRestPoints', e.target.value)}
					/>
					<StyledRightResourceMax>/ {characterData.finalRestPoints}</StyledRightResourceMax>
				</StyledRightResourceControls>
			</StyledRightResourceRow>

			<StyledRightResourceRow>
				<StyledRightResourceLabel>GRIT POINTS</StyledRightResourceLabel>
				<StyledRightResourceControls>
					<StyledRightResourceInput
						type="number"
						value={currentValues.currentGritPoints}
						onChange={(e) => onResourceInputChange('currentGritPoints', e.target.value)}
					/>
					<StyledRightResourceMax>/ {characterData.finalGritPoints}</StyledRightResourceMax>
				</StyledRightResourceControls>
			</StyledRightResourceRow>
		</StyledRightResourcesContainer>
	);
};

export default RightColumnResources;
```

## File: src/routes/character-sheet/styles/Attacks.ts
```typescript
import styled from 'styled-components';

export const StyledAttacksSection = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
`;

export const StyledAttacksHeader = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 1rem;
`;

export const StyledAttacksTitle = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	text-align: center;
	flex: 1;
`;

export const StyledAddWeaponButton = styled.button`
	padding: 0.3rem 0.8rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	background: #8b4513;
	color: white;
	font-size: 0.8rem;
	font-weight: bold;
	cursor: pointer;
	transition: background-color 0.2s;

	&:hover {
		background-color: #6d3410;
	}
`;

export const StyledAttacksContainer = styled.div`
	font-size: 0.8rem;
	color: #8b4513;
	overflow-x: auto;

	@media (max-width: 768px) {
		overflow-x: visible;
	}
`;

export const StyledAttacksHeaderRow = styled.div`
	display: grid;
	grid-template-columns: 0.5fr 2fr 1fr 1fr 1fr 0.7fr 0.8fr;
	gap: 0.5rem;
	margin-bottom: 0.5rem;
	border-bottom: 1px solid #e5e5e5;
	padding-bottom: 0.3rem;
	align-items: center;

	@media (max-width: 768px) {
		grid-template-columns: 25px 1fr 45px 40px;
		gap: 0.2rem;
		font-size: 0.7rem;
		
		& > *:nth-child(4),
		& > *:nth-child(5),
		& > *:nth-child(7) {
			display: none;
		}
	}
`;

export const StyledHeaderColumn = styled.span<{ align?: string }>`
	font-weight: bold;
	text-align: ${(props) => props.align || 'left'};
	font-size: 0.8rem;
	line-height: 1.1;

	@media (max-width: 768px) {
		font-size: 0.7rem;
		&:nth-child(4),
		&:nth-child(5),
		&:nth-child(7) {
			display: none;
		}
	}
`;

export const StyledEmptyState = styled.div`
	text-align: center;
	font-style: italic;
	padding: 2rem;
	color: #666;
`;

export const StyledAttackRow = styled.div`
	display: grid;
	grid-template-columns: 0.5fr 2fr 1fr 1fr 1fr 0.7fr 0.8fr;
	gap: 0.5rem;
	margin-bottom: 0.5rem;
	align-items: center;

	@media (max-width: 768px) {
		grid-template-columns: 25px 1fr 45px 40px;
		gap: 0.2rem;
		font-size: 0.7rem;
		
		& > *:nth-child(4),
		& > *:nth-child(5),
		& > *:nth-child(7) {
			display: none;
		}
	}
`;

export const StyledRemoveButton = styled.button`
	width: 24px;
	height: 24px;
	border: 1px solid #dc2626;
	border-radius: 4px;
	background-color: #fee2e2;
	color: #dc2626;
	font-size: 0.8rem;
	font-weight: bold;
	cursor: pointer;
	display: flex;
	align-items: center;
	justify-content: center;
	transition: background-color 0.2s;

	&:hover {
		background-color: #fecaca;
	}
`;

export const StyledWeaponSelect = styled.select`
	padding: 0.2rem;
	border: 1px solid #8b4513;
	border-radius: 3px;
	font-size: 0.7rem;
	background: white;
	width: 100%;
	max-width: 100%;
	overflow: hidden;
	text-overflow: ellipsis;

	@media (max-width: 768px) {
		font-size: 0.6rem;
		padding: 0.1rem;
	}
`;

export const StyledDamageCell = styled.div<{ color?: string }>`
	text-align: center;
	font-weight: bold;
	color: ${(props) => props.color || 'inherit'};
	cursor: pointer;
`;

export const StyledInfoIcon = styled.span`
	display: inline-flex;
	align-items: center;
	justify-content: center;
	width: 14px;
	height: 14px;
	border-radius: 50%;
	background-color: #8b4513;
	color: white;
	font-size: 10px;
	font-weight: bold;
	cursor: pointer;
`;

export const StyledDamageTypeCell = styled.div`
	text-align: center;
	font-size: 1rem;
	font-weight: bold;
	cursor: pointer;
`;
```

## File: src/routes/character-sheet/styles/Attributes.ts
```typescript
import styled from 'styled-components';

export const StyledAttributeSection = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: rgba(245, 243, 240, 0.5);
`;

export const StyledAttributeItem = styled.div`
	display: grid;
	grid-template-columns: 60px 1fr;
	gap: 0.5rem;
	margin-bottom: 1rem;
	align-items: center;
`;

export const StyledAttributeBox = styled.div`
	width: 50px;
	height: 50px;
	border: 2px solid #8b4513;
	border-radius: 8px;
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	background: white;
	position: relative;
`;

export const StyledAttributeAbbr = styled.div`
	font-size: 0.7rem;
	font-weight: bold;
	text-transform: uppercase;
	color: #8b4513;
`;

export const StyledAttributeValue = styled.div`
	font-size: 1.2rem;
	font-weight: bold;
	color: #2d2d2d;
`;

export const StyledAttributeDetails = styled.div`
	display: flex;
	flex-direction: column;
`;

export const StyledAttributeName = styled.div`
	font-size: 0.9rem;
	font-weight: bold;
	text-transform: uppercase;
	color: #8b4513;
`;

export const StyledSaveBonus = styled.div`
	font-size: 0.8rem;
	color: #666;
`;

// New components for refactored layout
export const AttributeSection = styled.div`
	margin-bottom: 1rem;
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
`;

export const AttributeHeader = styled.div`
	display: flex;
	align-items: center;
	margin-bottom: 0.5rem;
`;

export const AttributeBox = styled.div`
	width: 60px;
	height: 60px;
	border: 2px solid #8b4513;
	border-radius: 8px;
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	background: #f5f5dc;
	margin-right: 1rem;
`;

export const AttributeAbbreviation = styled.div`
	font-size: 0.8rem;
	font-weight: bold;
	color: #8b4513;
`;

export const AttributeValue = styled.div`
	font-size: 1.4rem;
	font-weight: bold;
	color: #8b4513;
`;

export const AttributeInfo = styled.div`
	flex: 1;
`;

export const AttributeName = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.2rem;
`;

export const AttributeSave = styled.div`
	font-size: 0.9rem;
	color: #8b4513;
`;

export const SkillRow = styled.div`
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 0.3rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	background: #f9f9f9;
	margin-bottom: 0.3rem;

	&:last-child {
		margin-bottom: 0;
	}
`;

export const SkillName = styled.span`
	font-size: 0.9rem;
	color: #8b4513;
`;

export const PrimeSection = styled.div`
	text-align: center;
	padding: 0.5rem;
	border: 2px solid #8b4513;
	border-radius: 8px;
	background: #f5f5dc;
	margin-bottom: 0.5rem;
`;

export const PrimeLabel = styled.div`
	color: #8b4513;
	font-weight: bold;
	font-size: 1rem;
`;

export const PrimeValue = styled.div`
	font-size: 1.4rem;
	font-weight: bold;
	color: #8b4513;
`;
```

## File: src/routes/character-sheet/styles/AttributesSections.styles.ts
```typescript
import styled from 'styled-components';

export const StyledAttributesSectionsContainer = styled.div`
	/* This is the container for all the remaining inline styled sections */
`;

export const StyledPrimeSection = styled.div`
	margin-bottom: 1rem;
`;

export const StyledPrimeBox = styled.div`
	text-align: center;
	padding: 0.5rem;
	border: 2px solid #8b4513;
	border-radius: 8px;
	background: #f5f5dc;
	margin-bottom: 0.5rem;
`;

export const StyledPrimeLabel = styled.div`
	color: #8b4513;
	font-weight: bold;
`;

export const StyledPrimeValue = styled.div`
	font-size: 1.4rem;
	font-weight: bold;
	color: #8b4513;
`;

export const StyledSkillRow = styled.div`
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 0.3rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	background: white;
	margin-bottom: 0.3rem;
`;

export const StyledSkillName = styled.span`
	font-size: 0.9rem;
	color: #8b4513;
`;

export const StyledAttributeSection = styled.div`
	margin-bottom: 1rem;
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
`;

export const StyledAttributeHeader = styled.div`
	display: flex;
	align-items: center;
	margin-bottom: 0.5rem;
`;

export const StyledAttributeBox = styled.div`
	width: 60px;
	height: 60px;
	border: 2px solid #8b4513;
	border-radius: 8px;
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	background: #f5f5dc;
	margin-right: 1rem;
`;

export const StyledAttributeAbbr = styled.div`
	font-size: 0.8rem;
	font-weight: bold;
	color: #8b4513;
`;

export const StyledAttributeValue = styled.div`
	font-size: 1.4rem;
	font-weight: bold;
	color: #8b4513;
`;

export const StyledAttributeInfo = styled.div`
	flex: 1;
`;

export const StyledAttributeName = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.2rem;
`;

export const StyledAttributeSave = styled.div`
	font-size: 0.9rem;
	color: #8b4513;
`;

export const StyledAttributeSkillRow = styled.div`
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 0.3rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	background: #f9f9f9;
	margin-bottom: 0.3rem;
`;

export const StyledKnowledgeTradesSection = styled.div`
	margin-bottom: 1rem;
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
`;

export const StyledSectionTitle = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.5rem;
	text-align: center;
`;

export const StyledSectionSubtitle = styled.div`
	font-size: 0.8rem;
	color: #8b4513;
	margin-bottom: 0.5rem;
	text-align: center;
`;

export const StyledLanguageRow = styled.div`
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 0.3rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	background: #f9f9f9;
	margin-bottom: 0.3rem;
`;

export const StyledLanguageName = styled.span`
	font-size: 0.9rem;
	color: #8b4513;
`;

export const StyledFluencyControls = styled.div`
	display: flex;
	gap: 0.2rem;
`;

export const StyledFluencyBox = styled.div<{ active: boolean }>`
	width: 15px;
	height: 15px;
	border: 1px solid #8b4513;
	background: ${(props) => (props.active ? '#8b4513' : 'white')};
	border-radius: 2px;
`;

export const StyledFluencyLabel = styled.span`
	font-size: 0.8rem;
	color: #8b4513;
	margin-left: ${(props) => (props.children === 'FLUENT' ? '0.5rem' : '0')};
`;

export const StyledNoItemsMessage = styled.div`
	font-size: 0.9rem;
	color: #8b4513;
	text-align: center;
	font-style: italic;
	padding: 1rem;
`;
```

## File: src/routes/character-sheet/styles/Combat.ts
```typescript
import styled from 'styled-components';

export const StyledCombatSection = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: rgba(245, 243, 240, 0.5);
`;

export const StyledDefenseGrid = styled.div`
	display: grid;
	grid-template-columns: 1fr 1fr;
	gap: 1rem;
	margin-bottom: 1rem;

	@media (max-width: 768px) {
		grid-template-columns: 1fr;
		gap: 0.5rem;
	}
`;

export const StyledDefenseBox = styled.div`
	text-align: center;
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 0.8rem;
	background: white;
`;

export const StyledDefenseValue = styled.div`
	font-size: 1.8rem;
	font-weight: bold;
	color: #8b4513;
`;

export const StyledDefenseLabel = styled.div`
	font-size: 0.7rem;
	font-weight: bold;
	text-transform: uppercase;
	color: #666;
	margin-top: 0.2rem;
`;

export const StyledActionPoints = styled.div`
	display: flex;
	justify-content: center;
	gap: 0.5rem;
	margin: 1rem 0;

	@media (max-width: 768px) {
		gap: 0.3rem;
		flex-wrap: wrap;
	}
`;

export const StyledActionPoint = styled.div<{ used: boolean }>`
	width: 40px;
	height: 40px;
	border: 2px solid #8b4513;
	border-radius: 50%;
	display: flex;
	align-items: center;
	justify-content: center;
	background: ${(props) => (props.used ? '#8b4513' : 'white')};
	color: ${(props) => (props.used ? 'white' : '#8b4513')};
	cursor: pointer;
	font-weight: bold;

	&:hover {
		background: ${(props) => (props.used ? '#6b3410' : '#f0f0f0')};
	}
`;

export const StyledCombatStats = styled.div`
	display: flex;
	justify-content: space-between;
	gap: 1rem;
	margin: 1rem 0;

	@media (max-width: 768px) {
		flex-direction: column;
		gap: 0.5rem;
	}
`;

export const StyledCombatStatBox = styled.div`
	border: 1px solid #ccc;
	border-radius: 4px;
	padding: 0.5rem;
	text-align: center;
	background: white;
	flex: 1;
`;

export const StyledCombatStatValue = styled.div`
	font-size: 1.5rem;
	font-weight: bold;
	color: #333;
`;

export const StyledCombatStatLabel = styled.div`
	font-size: 0.7rem;
	font-weight: bold;
	text-transform: uppercase;
	color: #666;
	margin-top: 0.2rem;
`;
```

## File: src/routes/character-sheet/styles/Currency.ts
```typescript
import styled from 'styled-components';

export const CurrencyContainer = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
`;

export const CurrencyTitle = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 1rem;
	text-align: center;
`;

export const CurrencyRow = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 0.5rem;

	&:last-child {
		margin-bottom: 0;
	}
`;

export const CurrencyIconContainer = styled.div`
	display: flex;
	align-items: center;
	gap: 0.3rem;
`;

export const CurrencyIcon = styled.div<{ color: string; borderColor: string }>`
	width: 16px;
	height: 16px;
	border-radius: 50%;
	background: ${(props) => props.color};
	border: 1px solid ${(props) => props.borderColor};
`;

export const CurrencyLabel = styled.span`
	font-size: 0.9rem;
	color: #8b4513;
	font-weight: bold;
`;

export const CurrencyInput = styled.input`
	width: 60px;
	padding: 0.2rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	text-align: center;
	font-size: 0.8rem;
	background-color: white;

	&:focus {
		outline: none;
		border-color: #6d3410;
		box-shadow: 0 0 0 2px rgba(139, 69, 19, 0.2);
	}
`;
```

## File: src/routes/character-sheet/styles/Death.ts
```typescript
import styled from 'styled-components';

export const StyledDeathContainer = styled.div`
	flex: 1;
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
	text-align: center;
`;

export const StyledDeathTitle = styled.div`
	font-size: 0.9rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.5rem;
`;

export const StyledHealthStatus = styled.div<{
	status: 'healthy' | 'bloodied' | 'well-bloodied' | 'deaths-door' | 'dead';
}>`
	font-size: 0.8rem;
	font-weight: bold;
	margin-bottom: 0.3rem;
	padding: 0.2rem 0.4rem;
	border-radius: 4px;
	color: ${(props) => {
		switch (props.status) {
			case 'healthy':
				return '#22c55e';
			case 'bloodied':
				return '#f59e0b';
			case 'well-bloodied':
				return '#f97316';
			case 'deaths-door':
				return '#dc2626';
			case 'dead':
				return '#7f1d1d';
			default:
				return '#8b4513';
		}
	}};
	background: ${(props) => {
		switch (props.status) {
			case 'healthy':
				return '#dcfce7';
			case 'bloodied':
				return '#fef3c7';
			case 'well-bloodied':
				return '#fed7aa';
			case 'deaths-door':
				return '#fecaca';
			case 'dead':
				return '#fca5a5';
			default:
				return 'transparent';
		}
	}};
`;

export const StyledDeathThreshold = styled.div`
	font-size: 1.5rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.5rem;
`;

export const StyledDeathStepsContainer = styled.div`
	margin-top: 0.5rem;
`;

export const StyledDeathStepsTitle = styled.div`
	font-size: 0.8rem;
	font-weight: bold;
	color: #dc2626;
	margin-bottom: 0.3rem;
`;

export const StyledDeathStepsGrid = styled.div`
	display: flex;
	justify-content: center;
	gap: 0.2rem;
	flex-wrap: wrap;
`;

export const StyledDeathStep = styled.div<{ filled: boolean; isDead: boolean }>`
	position: relative;
	width: 20px;
	height: 20px;
	border: 2px solid ${(props) => (props.isDead ? '#7f1d1d' : '#dc2626')};
	background: ${(props) => {
		if (props.isDead) return '#7f1d1d';
		return props.filled ? '#dc2626' : 'white';
	}};
	color: ${(props) => {
		if (props.isDead) return 'white';
		return props.filled ? 'white' : '#dc2626';
	}};
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 0.7rem;
	font-weight: bold;
	cursor: pointer;
	border-radius: 3px;
	transition: all 0.2s ease;

	&:hover {
		background: ${(props) => {
			if (props.isDead) return '#991b1b';
			return props.filled ? '#b91c1c' : '#fecaca';
		}};
		transform: scale(1.1);
	}

	${(props) =>
		props.isDead &&
		`
    &::after {
      content: '☠';
      font-size: 0.8rem;
    }
  `}
`;

export const StyledDeathStepTooltip = styled.div`
	position: absolute;
	bottom: 100%;
	left: 50%;
	transform: translateX(-50%);
	background: #333;
	color: white;
	padding: 0.3rem 0.5rem;
	border-radius: 4px;
	font-size: 0.7rem;
	white-space: nowrap;
	z-index: 1000;
	margin-bottom: 5px;
	box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
	opacity: 0;
	visibility: hidden;
	transition:
		opacity 0.2s ease,
		visibility 0.2s ease;

	&::after {
		content: '';
		position: absolute;
		top: 100%;
		left: 50%;
		transform: translateX(-50%);
		border: 5px solid transparent;
		border-top-color: #333;
	}

	${StyledDeathStep}:hover & {
		opacity: 1;
		visibility: visible;
	}
`;

export const StyledHealthStatusTooltip = styled.div`
	position: relative;
	cursor: help;

	&::after {
		content: attr(data-tooltip);
		position: absolute;
		bottom: 100%;
		left: 50%;
		transform: translateX(-50%);
		background: #333;
		color: white;
		padding: 0.5rem;
		border-radius: 4px;
		font-size: 0.7rem;
		white-space: pre-line;
		z-index: 1000;
		margin-bottom: 5px;
		box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
		opacity: 0;
		visibility: hidden;
		transition:
			opacity 0.2s ease,
			visibility 0.2s ease;
		max-width: 200px;
		text-align: left;
	}

	&:hover::after {
		opacity: 1;
		visibility: visible;
	}
`;
```

## File: src/routes/character-sheet/styles/DeathExhaustion.styles.ts
```typescript
import styled from 'styled-components';

export const StyledDeathExhaustionContainer = styled.div`
	display: flex;
	gap: 1rem;
	margin-bottom: 1.5rem;
`;

export const StyledExhaustionOnlyContainer = styled.div`
	flex: 1;
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
	text-align: center;
`;

export const StyledExhaustionOnlyTitle = styled.div`
	font-size: 0.9rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.5rem;
`;
```

## File: src/routes/character-sheet/styles/Defenses.ts
```typescript
import styled from 'styled-components';

export const DefensesContainer = styled.div<{ $isMobile?: boolean }>`
	display: flex;
	flex-direction: ${(props) => (props.$isMobile ? 'column' : 'row')};
	justify-content: space-around;
	align-items: center;
	gap: ${(props) => (props.$isMobile ? '1rem' : '0')};
	margin-bottom: 1.5rem;
`;

export const DefenseItem = styled.div`
	text-align: center;
	width: 120px;
	margin: 0 auto;
`;

export const DefenseLabelContainer = styled.div`
	height: 32px;
	display: flex;
	flex-direction: column;
	justify-content: center;
	margin-bottom: 0.3rem;
`;

export const DefenseLabel = styled.div`
	font-size: 0.8rem;
	font-weight: bold;
	color: #8b4513;
	line-height: 1;
`;

export const ShieldContainer = styled.div`
	width: 80px;
	height: 90px;
	border: 3px solid #8b4513;
	border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
	display: flex;
	align-items: center;
	justify-content: center;
	background: white;
	margin: 0 auto;
`;

export const ShieldValue = styled.div`
	font-size: 2rem;
	font-weight: bold;
	color: #8b4513;
	cursor: help;
`;

export const ShieldInput = styled.input`
	font-size: 2rem;
	font-weight: bold;
	color: #8b4513;
	background: transparent;
	border: none;
	text-align: center;
	width: 100%;
	max-width: 60px;
	outline: none;
	cursor: help;

	&:focus {
		background: rgba(139, 69, 19, 0.1);
		border-radius: 4px;
		cursor: text;
	}

	&::-webkit-outer-spin-button,
	&::-webkit-inner-spin-button {
		-webkit-appearance: none;
		margin: 0;
	}

	&[type='number'] {
		-moz-appearance: textfield;
	}
`;

export const DefenseFooter = styled.div`
	min-height: 30px;
	margin-top: 0.2rem;
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	gap: 2px;
`;

export const AutoCalculatedNote = styled.div`
	font-size: 0.6rem;
	color: #8b4513;
`;

export const RevertButton = styled.button`
	font-size: 0.6rem;
	color: #8b4513;
	background: transparent;
	border: 1px solid #8b4513;
	border-radius: 3px;
	padding: 2px 6px;
	cursor: pointer;
	margin-top: 2px;

	&:hover {
		background: rgba(139, 69, 19, 0.1);
	}

	&:active {
		background: rgba(139, 69, 19, 0.2);
	}
`;
```

## File: src/routes/character-sheet/styles/Exhaustion.ts
```typescript
import styled from 'styled-components';

export const StyledExhaustionContainer = styled.div`
	display: flex;
	justify-content: center;
	gap: 0.3rem;
	margin-top: 0.5rem;
`;

export const StyledExhaustionLevel = styled.div<{ filled: boolean }>`
	position: relative;
	width: 24px;
	height: 24px;
	border: 2px solid #8b4513;
	background: ${(props) => (props.filled ? '#8b4513' : 'white')};
	color: ${(props) => (props.filled ? 'white' : '#8b4513')};
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 0.8rem;
	font-weight: bold;
	cursor: pointer;
	border-radius: 3px;
	transition: all 0.2s ease;

	&:hover {
		background: ${(props) => (props.filled ? '#654321' : '#f5f5dc')};
		transform: scale(1.1);
	}
`;

export const StyledExhaustionTooltip = styled.div`
	position: absolute;
	bottom: 100%;
	left: 50%;
	transform: translateX(-50%);
	background: #333;
	color: white;
	padding: 0.5rem 0.75rem;
	border-radius: 4px;
	font-size: 0.8rem;
	white-space: nowrap;
	z-index: 1000;
	margin-bottom: 5px;
	box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
	opacity: 0;
	visibility: hidden;
	transition:
		opacity 0.2s ease,
		visibility 0.2s ease;

	&::after {
		content: '';
		position: absolute;
		top: 100%;
		left: 50%;
		transform: translateX(-50%);
		border: 5px solid transparent;
		border-top-color: #333;
	}

	${StyledExhaustionLevel}:hover & {
		opacity: 1;
		visibility: visible;
	}
`;
```

## File: src/routes/character-sheet/styles/Features.styles.ts
```typescript
import styled from 'styled-components';

export const StyledFeaturesContainer = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
	margin-bottom: 1rem;
	height: 762px;
	overflow-y: auto;
`;

export const StyledFeaturesTitle = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	text-align: center;
	margin-bottom: 1rem;
`;

export const StyledFeatureCategory = styled.div`
	margin-bottom: 1rem;
`;

export const StyledFeatureCategoryTitle = styled.div`
	font-size: 0.9rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.5rem;
	padding-bottom: 0.3rem;
	border-bottom: 1px solid #8b4513;
`;

export const StyledFeatureGrid = styled.div`
	display: flex;
	flex-direction: column;
	gap: 0.3rem;
`;

export const StyledFeatureItem = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0.5rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	background: #f9f9f9;
`;

export const StyledFeatureName = styled.span`
	font-size: 0.85rem;
	color: #8b4513;
	font-weight: 500;
	flex: 1;
`;

export const StyledFeatureReadMore = styled.button`
	background: #8b4513;
	color: white;
	border: none;
	border-radius: 3px;
	padding: 0.2rem 0.5rem;
	font-size: 0.7rem;
	cursor: pointer;
	font-weight: bold;

	&:hover {
		background: #654321;
	}
`;

export const StyledNoFeaturesMessage = styled.div`
	text-align: center;
	font-style: italic;
	padding: 1rem;
	color: #666;
`;

export const StyledFeaturesContent = styled.div`
	font-size: 0.9rem;
	color: #8b4513;
`;
```

## File: src/routes/character-sheet/styles/Features.ts
```typescript
import styled from 'styled-components';

export const StyledFeatureGrid = styled.div`
	display: flex;
	flex-direction: column;
	gap: 0.3rem;
	margin-bottom: 1rem;
`;

export const StyledFeatureItem = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0.4rem 0.5rem;
	border: 1px solid #e5e5e5;
	border-radius: 4px;
	background: #f9f9f9;
	min-height: 36px;
`;

export const StyledFeatureName = styled.span`
	font-size: 0.9rem;
	color: #8b4513;
	font-weight: 500;
	flex: 1;
	line-height: 1.2;
	margin-right: 0.5rem;
`;

export const StyledFeatureReadMore = styled.button`
	background: #8b4513;
	color: white;
	border: none;
	border-radius: 3px;
	padding: 0.2rem 0.4rem;
	font-size: 0.75rem;
	cursor: pointer;
	margin-left: 0.5rem;
	white-space: nowrap;
	flex-shrink: 0;

	&:hover {
		background: #654321;
	}
`;

export const StyledFeatureCategory = styled.div`
	margin-bottom: 1rem;
`;

export const StyledFeatureCategoryTitle = styled.h4`
	margin: 0 0 0.5rem 0;
	color: #8b4513;
	font-size: 1rem;
	font-weight: bold;
	border-bottom: 1px solid #8b4513;
	padding-bottom: 0.2rem;
`;
```

## File: src/routes/character-sheet/styles/Header.ts
```typescript
import styled from 'styled-components';

export const StyledHeader = styled.div`
	display: grid;
	grid-template-columns: 2fr 1fr 1fr 1fr;
	gap: 1rem;
	margin-bottom: 1.5rem;
	border-bottom: 2px solid #8b4513;
	padding-bottom: 1rem;

	@media (max-width: 768px) {
		display: none;
	}
`;

export const StyledHeaderSection = styled.div`
	display: flex;
	flex-direction: column;
`;

export const StyledLabel = styled.label`
	font-size: 0.7rem;
	font-weight: bold;
	text-transform: uppercase;
	color: #8b4513;
	margin-bottom: 0.2rem;
`;

export const StyledValue = styled.div`
	font-size: 1rem;
	font-weight: bold;
	border-bottom: 1px solid #ccc;
	padding: 0.2rem 0;
	min-height: 1.5rem;
`;
```

## File: src/routes/character-sheet/styles/Info.ts
```typescript
import styled from 'styled-components';

export const StyledInfoSection = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: rgba(245, 243, 240, 0.5);
`;

export const StyledSectionTitle = styled.h3`
	font-size: 0.9rem;
	font-weight: bold;
	text-transform: uppercase;
	color: #8b4513;
	margin: 0 0 0.8rem 0;
	text-align: center;
	border-bottom: 1px solid #8b4513;
	padding-bottom: 0.3rem;
`;

export const StyledStatRow = styled.div`
	display: flex;
	justify-content: space-between;
	margin-bottom: 0.4rem;
	font-size: 0.8rem;
`;

export const StyledStatLabel = styled.span`
	color: #666;
`;

export const StyledStatValue = styled.span`
	font-weight: bold;
	color: #2d2d2d;
`;
```

## File: src/routes/character-sheet/styles/Inventory.ts
```typescript
import styled from 'styled-components';

export const StyledInventorySection = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
	margin-bottom: 1rem;
`;

export const StyledInventoryTitle = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	text-align: center;
	margin-bottom: 1rem;
`;

export const StyledAddItemButton = styled.button`
	padding: 0.5rem 1rem;
	background-color: #8b4513;
	color: white;
	border: none;
	border-radius: 4px;
	font-size: 0.9rem;
	cursor: pointer;
	transition: background-color 0.2s;
	margin-bottom: 1rem;

	&:hover {
		background-color: #6d3410;
	}
`;

export const StyledInventoryContainer = styled.div`
	font-size: 0.8rem;
	color: #8b4513;
`;

export const StyledInventoryHeaderRow = styled.div`
	display: grid;
	grid-template-columns: 30px 100px 2fr 60px 30px 70px;
	gap: 0.5rem;
	margin-bottom: 0.5rem;
	border-bottom: 1px solid #e5e5e5;
	padding-bottom: 0.3rem;
	align-items: center;
`;

export const StyledInventoryHeaderColumn = styled.span<{ align?: string }>`
	font-weight: bold;
	text-align: ${(props) => props.align || 'left'};
`;

export const StyledInventoryRow = styled.div`
	display: grid;
	grid-template-columns: 30px 100px 2fr 60px 30px 70px;
	gap: 0.5rem;
	margin-bottom: 0.5rem;
	align-items: center;
`;

export const StyledRemoveItemButton = styled.button`
	width: 24px;
	height: 24px;
	border: 1px solid #dc2626;
	background-color: #fee2e2;
	color: #dc2626;
	border-radius: 4px;
	font-size: 14px;
	cursor: pointer;
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 0;

	&:hover {
		background-color: #fecaca;
	}
`;

export const StyledInventorySelect = styled.select`
	padding: 0.3rem;
	border: 1px solid #ccc;
	border-radius: 4px;
	font-size: 0.8rem;
	background-color: white;

	&:disabled {
		background-color: #f5f5f5;
		color: #999;
	}
`;

export const StyledInventoryInput = styled.input`
	padding: 0.3rem;
	border: 1px solid #ccc;
	border-radius: 4px;
	font-size: 0.8rem;
	text-align: center;
	background-color: white;
`;

export const StyledInventoryInfoIcon = styled.span`
	display: inline-flex;
	align-items: center;
	justify-content: center;
	width: 14px;
	height: 14px;
	border-radius: 50%;
	background-color: #8b4513;
	color: white;
	font-size: 10px;
	font-weight: bold;
	cursor: pointer;
	position: relative;
`;

export const StyledInventoryCost = styled.div`
	text-align: center;
	font-size: 0.8rem;
	font-weight: bold;
`;

export const StyledEmptyInventory = styled.div`
	text-align: center;
	font-style: italic;
	padding: 2rem;
	color: #666;
`;
```

## File: src/routes/character-sheet/styles/KnowledgeTrades.ts
```typescript
import styled from 'styled-components';

export const KnowledgeTradesSection = styled.div`
	margin-bottom: 1rem;
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
`;

export const SectionTitle = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.5rem;
	text-align: center;
`;

export const SectionDescription = styled.div`
	font-size: 0.8rem;
	color: #8b4513;
	margin-bottom: 0.5rem;
	text-align: center;
`;

export const EmptyMessage = styled.div`
	font-size: 0.9rem;
	color: #8b4513;
	text-align: center;
	font-style: italic;
	padding: 1rem;
`;
```

## File: src/routes/character-sheet/styles/Languages.ts
```typescript
import styled from 'styled-components';

export const LanguagesSection = styled.div`
	margin-bottom: 1rem;
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
`;

export const LanguageRow = styled.div`
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 0.3rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	background: #f9f9f9;
	margin-bottom: 0.3rem;

	&:last-child {
		margin-bottom: 0;
	}
`;

export const LanguageName = styled.span`
	font-size: 0.9rem;
	color: #8b4513;
	flex: 1;
	margin-right: 1rem;
	overflow: hidden;
	text-overflow: ellipsis;
	white-space: nowrap;
	min-width: 0;
`;

export const FluencyContainer = styled.div`
	display: flex;
	gap: 0.2rem;
	flex-shrink: 0;
`;

export const FluencyBox = styled.div<{ filled: boolean }>`
	width: 15px;
	height: 15px;
	border: 1px solid #8b4513;
	background: ${(props) => (props.filled ? '#8b4513' : 'white')};
	border-radius: 2px;
`;

export const FluencyLabel = styled.span`
	font-size: 0.7rem;
	color: #8b4513;
	font-weight: bold;
	margin-right: 0.3rem;
`;

export const FluencyItem = styled.div`
	display: flex;
	align-items: center;
	gap: 0.2rem;
	flex-shrink: 0;
	min-width: fit-content;
`;

export const FluencyHeader = styled.div`
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 0.3rem;
	background: #f0f0f0;
	border: 1px solid #8b4513;
	border-radius: 4px;
	margin-bottom: 0.3rem;
	font-weight: bold;
	font-size: 0.85rem;
	color: #8b4513;
`;

export const LanguageNameHeader = styled.span`
	font-size: 0.85rem;
	color: #8b4513;
	font-weight: bold;
	flex: 1;
	margin-right: 1rem;
`;

export const FluencyHeaderContainer = styled.div`
	display: flex;
	gap: 0.2rem;
	flex-shrink: 0;
`;

export const FluencyHeaderLabel = styled.span`
	font-size: 0.75rem;
	color: #8b4513;
	font-weight: bold;
	text-align: center;
	min-width: 15px;
	cursor: help;
`;
```

## File: src/routes/character-sheet/styles/Movement.styles.ts
```typescript
import styled from 'styled-components';

export const StyledMovementContainer = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
	margin-bottom: 1rem;
`;

export const StyledMovementGrid = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 1rem;
`;

export const StyledMovementStat = styled.div`
	text-align: center;
`;

export const StyledMovementLabel = styled.div`
	font-size: 0.8rem;
	font-weight: bold;
	color: #8b4513;
`;

export const StyledMovementValue = styled.div`
	font-size: 1.5rem;
	font-weight: bold;
	color: #8b4513;
`;
```

## File: src/routes/character-sheet/styles/Movement.ts
```typescript
import styled from 'styled-components';

export const MovementContainer = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
	margin-bottom: 1rem;
`;

export const MovementStats = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 1rem;
`;

export const MovementStat = styled.div`
	text-align: center;
`;

export const StatLabel = styled.div`
	font-size: 0.8rem;
	font-weight: bold;
	color: #8b4513;
`;

export const StatValue = styled.div`
	font-size: 1.5rem;
	font-weight: bold;
	color: #8b4513;
`;
```

## File: src/routes/character-sheet/styles/PlayerNotes.styles.ts
```typescript
import styled from 'styled-components';

export const StyledPlayerNotesContainer = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
	margin-bottom: 1rem;
`;

export const StyledPlayerNotesTitle = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	text-align: center;
	margin-bottom: 1rem;
`;

export const StyledNotesContent = styled.div`
	display: flex;
	flex-direction: column;
	gap: 0.75rem;
`;

export const StyledNotesList = styled.div`
	display: flex;
	flex-direction: column;
	gap: 0.5rem;
`;

export const StyledNoteItem = styled.div`
	border: 1px solid #8b4513;
	border-radius: 4px;
	padding: 0.75rem;
	background: #f9f9f9;
	transition: all 0.2s ease;

	&:hover {
		background: #f5f5f5;
	}
`;

export const StyledNoteText = styled.p`
	color: #2d2d2d;
	font-size: 0.9rem;
	line-height: 1.4;
	margin: 0 0 0.5rem 0;
	word-wrap: break-word;
`;

export const StyledNoteActions = styled.div`
	display: flex;
	gap: 0.5rem;
	margin-top: 0.5rem;
`;

export const StyledNoteInput = styled.textarea`
	background: white;
	border: 1px solid #8b4513;
	border-radius: 4px;
	color: #2d2d2d;
	font-size: 0.9rem;
	padding: 0.5rem;
	width: 100%;
	min-height: 60px;
	resize: vertical;
	font-family: 'Georgia', serif;

	&:focus {
		outline: none;
		border-color: #8b4513;
		box-shadow: 0 0 0 1px #8b4513;
	}

	&::placeholder {
		color: #999;
	}
`;

export const StyledAddButton = styled.button`
	background: #8b4513;
	border: 1px solid #8b4513;
	border-radius: 4px;
	color: white;
	font-size: 0.85rem;
	font-weight: bold;
	padding: 0.5rem 0.75rem;
	cursor: pointer;
	transition: all 0.2s ease;

	&:hover {
		background-color: #6d3410;
	}

	&:active {
		transform: translateY(1px);
	}
`;

export const StyledDeleteButton = styled.button`
	width: 24px;
	height: 24px;
	border: 1px solid #dc2626;
	background-color: #fee2e2;
	color: #dc2626;
	border-radius: 4px;
	font-size: 14px;
	cursor: pointer;
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 0;
	font-weight: bold;

	&:hover {
		background-color: #fecaca;
	}

	&:active {
		transform: translateY(1px);
	}
`;

export const StyledEditButton = styled.button`
	background: #f9f9f9;
	border: 1px solid #8b4513;
	border-radius: 4px;
	color: #8b4513;
	font-size: 1rem;
	cursor: pointer;
	transition: all 0.2s ease;
	width: 24px;
	height: 24px;
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 0;

	&:hover {
		background: #8b4513;
		color: white;
	}

	&:active {
		transform: translateY(1px);
	}
`;

export const StyledSaveButton = styled.button`
	background: #f9f9f9;
	border: 1px solid #8b4513;
	border-radius: 4px;
	color: #8b4513;
	font-size: 0.85rem;
	font-weight: bold;
	padding: 0.4rem 0.6rem;
	cursor: pointer;
	transition: all 0.2s ease;

	&:hover {
		background: #8b4513;
		color: white;
	}

	&:active {
		transform: translateY(1px);
	}
`;

export const StyledCancelButton = styled.button`
	background: #f9f9f9;
	border: 1px solid #8b4513;
	border-radius: 4px;
	color: #8b4513;
	font-size: 0.85rem;
	font-weight: bold;
	padding: 0.4rem 0.6rem;
	cursor: pointer;
	transition: all 0.2s ease;

	&:hover {
		background: #8b4513;
		color: white;
	}

	&:active {
		transform: translateY(1px);
	}
`;

export const StyledAddNoteSection = styled.div`
	border-top: 1px solid #8b4513;
	padding-top: 0.75rem;
`;

export const StyledEmptyNotesMessage = styled.div`
	color: #8b4513;
	font-style: italic;
	text-align: center;
	padding: 1.5rem 1rem;
	border: 1px dashed #8b4513;
	border-radius: 4px;
	background: #f9f9f9;
	font-size: 0.9rem;
`;
```

## File: src/routes/character-sheet/styles/Resources.ts
```typescript
import styled from 'styled-components';

export const StyledResourcesSection = styled.div`
	display: grid;
	grid-template-columns: 1fr 1fr 1fr;
	gap: 1rem;
`;

export const StyledResourceBox = styled.div`
	border: 2px solid #8b4513;
	border-radius: 12px;
	padding: 1rem;
	text-align: center;
	background: white;
	position: relative;
`;

export const StyledResourceIcon = styled.div<{ bgColor: string }>`
	width: 60px;
	height: 60px;
	border-radius: 50%;
	background: ${(props) => props.bgColor};
	border: 3px solid #8b4513;
	display: flex;
	align-items: center;
	justify-content: center;
	margin: 0 auto 0.5rem;
	font-size: 1.5rem;
	font-weight: bold;
	color: white;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledResourceControls = styled.div`
	display: flex;
	gap: 0.3rem;
	justify-content: center;
	margin-top: 0.5rem;
`;

export const StyledResourceButton = styled.button<{ variant?: 'damage' | 'heal' }>`
	width: 25px;
	height: 25px;
	border: 1px solid
		${(props) =>
			props.variant === 'damage' ? '#d32f2f' : props.variant === 'heal' ? '#388e3c' : '#8b4513'};
	border-radius: 3px;
	background: ${(props) =>
		props.variant === 'damage' ? '#ffebee' : props.variant === 'heal' ? '#e8f5e8' : 'white'};
	color: ${(props) =>
		props.variant === 'damage' ? '#d32f2f' : props.variant === 'heal' ? '#388e3c' : '#8b4513'};
	cursor: pointer;
	font-size: 0.7rem;
	font-weight: bold;
	display: flex;
	align-items: center;
	justify-content: center;

	&:hover {
		background: ${(props) =>
			props.variant === 'damage' ? '#d32f2f' : props.variant === 'heal' ? '#388e3c' : '#8b4513'};
		color: white;
	}

	&:disabled {
		opacity: 0.5;
		cursor: not-allowed;
	}
`;

export const StyledResourceInput = styled.input<{ variant?: 'circle' | 'standard' }>`
	width: ${(props) => (props.variant === 'circle' ? '50px' : '40px')};
	text-align: center;
	border: ${(props) => (props.variant === 'circle' ? 'none' : '1px solid #8b4513')};
	border-radius: ${(props) => (props.variant === 'circle' ? '0' : '3px')};
	background: ${(props) => (props.variant === 'circle' ? 'transparent' : 'white')};
	font-size: ${(props) => (props.variant === 'circle' ? '1.4rem' : '0.9rem')};
	font-weight: bold;
	padding: 0;
	margin: 0;
	outline: none;

	/* Remove number input spinner arrows completely */
	-webkit-appearance: textfield;
	-moz-appearance: textfield;
	appearance: textfield;

	&::-webkit-outer-spin-button,
	&::-webkit-inner-spin-button {
		-webkit-appearance: none;
		margin: 0;
		display: none;
	}

	&[type='number'] {
		-moz-appearance: textfield;
	}

	/* Force center alignment and remove any browser default styling */
	${(props) =>
		props.variant === 'circle' &&
		`
    line-height: 1;
    vertical-align: baseline;
    box-sizing: border-box;
  `}
`;

export const StyledTempHPInput = styled(StyledResourceInput)`
	width: 25px;
	font-size: 0.7rem;
`;

// New components for refactored layout
export const ResourcesContainer = styled.div<{ $isMobile?: boolean }>`
	display: flex;
	flex-direction: ${(props) => (props.$isMobile ? 'column' : 'row')};
	justify-content: space-around;
	align-items: ${(props) => (props.$isMobile ? 'center' : 'stretch')};
	gap: ${(props) => (props.$isMobile ? '1rem' : '0')};
	margin-bottom: 1.5rem;
`;

export const ResourceColumn = styled.div<{ $isMobile?: boolean }>`
	text-align: center;
	width: ${(props) => (props.$isMobile ? '100%' : 'auto')};
	max-width: ${(props) => (props.$isMobile ? '200px' : 'none')};
`;

export const ResourceLabel = styled.div`
	font-size: 0.8rem;
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.3rem;
`;

export const ResourceControls = styled.div`
	display: flex;
	align-items: center;
	gap: 5px;
`;

export const TempHPControls = styled.div`
	font-size: 0.8rem;
	color: #dc2626;
	margin-top: 0.3rem;
	display: flex;
	align-items: center;
	justify-content: center;
	gap: 0.3rem;
`;

export const TempHPLabel = styled.span`
	font-weight: normal;
`;

export const TempHPInputSmall = styled.input`
	color: #dc2626;
	background: white;
	border: 1px solid #dc2626;
	border-radius: 3px;
	width: 35px;
	text-align: center;
	font-size: 0.8rem;
	padding: 2px;

	&:focus {
		outline: none;
		border-color: #b91c1c;
		box-shadow: 0 0 0 2px rgba(220, 38, 38, 0.2);
	}
`;
```

## File: src/routes/character-sheet/styles/RightColumnResources.styles.ts
```typescript
import styled from 'styled-components';

export const StyledRightResourcesContainer = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: white;
	margin-bottom: 1rem;
`;

export const StyledRightResourcesTitle = styled.div`
	font-size: 1.1rem;
	font-weight: bold;
	color: #8b4513;
	text-align: center;
	margin-bottom: 1rem;
`;

export const StyledRightResourceRow = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 0.8rem;

	&:last-child {
		margin-bottom: 0;
	}
`;

export const StyledRightResourceLabel = styled.span`
	font-size: 0.9rem;
	color: #8b4513;
`;

export const StyledRightResourceControls = styled.div`
	display: flex;
	align-items: center;
	gap: 0.3rem;
`;

export const StyledRightResourceInput = styled.input`
	width: 40px;
	text-align: center;
	border: 1px solid #8b4513;
	border-radius: 4px;
	padding: 0.2rem;
	font-size: 0.9rem;
	color: #8b4513;

	&:focus {
		outline: none;
		border-color: #654321;
		box-shadow: 0 0 0 2px rgba(139, 69, 19, 0.2);
	}
`;

export const StyledRightResourceMax = styled.span`
	font-size: 0.9rem;
	color: #8b4513;
`;
```

## File: src/routes/character-sheet/styles/Spells.ts
```typescript
import styled from 'styled-components';

export const StyledSpellsSection = styled.div`
	margin-bottom: 1.5rem;
	background: white;
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
`;

export const StyledSpellsHeader = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 1rem;
	padding-bottom: 0.5rem;
	border-bottom: 1px solid #8b4513;
`;

export const StyledSpellsTitle = styled.h3`
	margin: 0;
	color: #8b4513;
	font-size: 1.1rem;
	font-weight: bold;
`;

export const StyledSpellsControls = styled.div`
	display: flex;
	gap: 0.5rem;
	align-items: center;
`;

export const StyledAddSpellButton = styled.button`
	background: #8b4513;
	color: white;
	border: none;
	padding: 0.4rem 0.8rem;
	border-radius: 4px;
	cursor: pointer;
	font-size: 0.8rem;
	font-weight: bold;

	&:hover {
		background: #a0522d;
	}
`;

export const StyledSpellsContainer = styled.div`
	display: flex;
	flex-direction: column;
	gap: 0.5rem;
`;

export const StyledSpellsHeaderRow = styled.div`
	display: grid;
	grid-template-columns: 40px 2fr 1fr 1fr 0.8fr 0.8fr 1fr 0.8fr;
	gap: 0.5rem;
	padding: 0.5rem;
	background: #f5f5dc;
	border: 1px solid #8b4513;
	border-radius: 4px;
	font-weight: bold;
	font-size: 0.8rem;
	color: #8b4513;
`;

export const StyledHeaderColumn = styled.div`
	display: flex;
	align-items: center;
	justify-content: center;
	text-align: center;
`;

export const StyledEmptyState = styled.div`
	text-align: center;
	padding: 1rem;
	color: #666;
	font-style: italic;
`;

export const StyledSpellRow = styled.div`
	display: grid;
	grid-template-columns: 40px 2fr 1fr 1fr 0.8fr 0.8fr 1fr 0.8fr;
	gap: 0.5rem;
	padding: 0.5rem;
	border: 1px solid #ddd;
	border-radius: 4px;
	background: white;
	align-items: center;

	&:hover {
		background: #f9f9f9;
	}
`;

export const StyledRemoveButton = styled.button`
	background: #dc3545;
	color: white;
	border: none;
	width: 24px;
	height: 24px;
	border-radius: 50%;
	cursor: pointer;
	font-size: 0.8rem;
	display: flex;
	align-items: center;
	justify-content: center;

	&:hover {
		background: #c82333;
	}
`;

export const StyledSpellSelect = styled.select`
	width: 100%;
	padding: 0.3rem;
	border: 1px solid #ddd;
	border-radius: 4px;
	font-size: 0.8rem;

	&:focus {
		outline: none;
		border-color: #8b4513;
	}
`;

export const StyledSchoolFilter = styled.select`
	padding: 0.3rem;
	border: 1px solid #8b4513;
	border-radius: 4px;
	font-size: 0.8rem;
	background: white;

	&:focus {
		outline: none;
		border-color: #a0522d;
	}
`;

export const StyledSpellCell = styled.div`
	font-size: 0.8rem;
	color: #333;
	display: flex;
	align-items: center;
	justify-content: center;
	text-align: center;
`;

export const StyledPreparedCheckbox = styled.input`
	width: 16px;
	height: 16px;
	cursor: pointer;
`;

export const StyledNotesInput = styled.input`
	width: 100%;
	padding: 0.2rem;
	border: 1px solid #ddd;
	border-radius: 4px;
	font-size: 0.7rem;

	&:focus {
		outline: none;
		border-color: #8b4513;
	}
`;

export const StyledInfoIcon = styled.span`
	display: inline-flex;
	align-items: center;
	justify-content: center;
	width: 14px;
	height: 14px;
	border-radius: 50%;
	background-color: #8b4513;
	color: white;
	font-size: 10px;
	font-weight: bold;
	cursor: pointer;
`;
```

## File: src/types/defenseNotes.ts
```typescript
export interface DefenseNote {
	id: string;
	timestamp: Date;
	reason: string;
	oldValue: number;
	newValue: number;
	field: 'manualPD' | 'manualPDR' | 'manualAD';
}

export interface DefenseNotesData {
	characterId: string;
	notes: DefenseNote[];
}
```

## File: src/types/index.ts
```typescript
// Main export file for all types
export * from './character';
```

## File: src/app.d.ts
```typescript
// See https://svelte.dev/docs/kit/types#app.d.ts
// for information about these interfaces
declare global {
	namespace App {
		interface Locals {
			user: import('$lib/server/auth').SessionValidationResult['user'];
			session: import('$lib/server/auth').SessionValidationResult['session'];
		}
	} // interface Error {}
	// interface Locals {}
} // interface PageData {}
// interface PageState {}

// interface Platform {}
export {};
```

## File: src/demo.spec.ts
```typescript
import { describe, it, expect } from 'vitest';

describe('sum test', () => {
	it('adds 1 + 2 to equal 3', () => {
		expect(1 + 2).toBe(3);
	});
});
```

## File: src/main.tsx
```typescript
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

ReactDOM.createRoot(document.getElementById('root')!).render(
	<React.StrictMode>
		<App />
	</React.StrictMode>
);
```

## File: src/lib/config/features.ts
```typescript
// Feature flags for enabling new systems during development
export const FEATURES = {
  NEW_EFFECT_SYSTEM: process.env.NODE_ENV === 'development' && process.env.VITE_NEW_EFFECTS === 'true'
};
```

## File: src/lib/hooks/useAttributeCalculation.ts
```typescript
/**
 * Intelligent Attribute Point Calculation Hook
 * 
 * This hook calculates attribute points accounting for trait effects,
 * providing real-time feedback for character creation.
 */

import { useMemo } from 'react';

interface AttributeCalculationResult {
  totalPointsAvailable: number;
  pointsSpent: number;
  pointsRemaining: number;
  forcedAdjustments: Array<{
    attribute: string;
    originalValue: number;
    effectiveValue: number;
    pointsCost: number;
  }>;
  isValid: boolean;
  effectiveAttributes: {
    might: number;
    agility: number;
    charisma: number;
    intelligence: number;
  };
}

/**
 * Calculate attribute points accounting for trait effects
 * This is the NEW, correct calculation that replaces the old one
 */
export const useAttributeCalculation = (characterState: any): AttributeCalculationResult => {
  const BASE_ATTRIBUTE_POINTS = 11;
  
  return useMemo(() => {
    const { 
      attribute_might = -2, 
      attribute_agility = -2, 
      attribute_charisma = -2, 
      attribute_intelligence = -2, 
      selectedTraitIds = [] 
    } = characterState || {};
    
    // Base points spent (base attribute is -2, so +2 to get actual cost)
    const basePointsSpent = 
      (attribute_might + 2) + 
      (attribute_agility + 2) + 
      (attribute_charisma + 2) + 
      (attribute_intelligence + 2);
    
    // Get trait effects
    const traitEffects = getCombinedTraitEffects(selectedTraitIds);
    
    let totalAdjustmentCost = 0;
    const forcedAdjustments: Array<{
      attribute: string;
      originalValue: number;
      effectiveValue: number;
      pointsCost: number;
    }> = [];
    
    // Calculate effective attributes after trait modifiers
    const effectiveAttributes = {
      might: attribute_might + (traitEffects.might || 0),
      agility: attribute_agility + (traitEffects.agility || 0),
      charisma: attribute_charisma + (traitEffects.charisma || 0),
      intelligence: attribute_intelligence + (traitEffects.intelligence || 0)
    };
    
    // Check each attribute for forced adjustments
    const baseAttributes = {
      might: attribute_might,
      agility: attribute_agility,
      charisma: attribute_charisma,
      intelligence: attribute_intelligence
    };
    
    Object.entries(baseAttributes).forEach(([attr, baseValue]) => {
      const effect = traitEffects[attr] || 0;
      const effectiveValue = baseValue + effect;
      
      if (effectiveValue < -2) {
        // Trait forces attribute below minimum, costs points to fix
        const pointsCost = -2 - effectiveValue;
        totalAdjustmentCost += pointsCost;
        
        forcedAdjustments.push({
          attribute: attr,
          originalValue: baseValue,
          effectiveValue: effectiveValue,
          pointsCost: pointsCost
        });
      }
    });
    
    // Calculate bonus points from traits
    const bonusPoints = getBonusAttributePointsFromTraits(selectedTraitIds);
    
    const totalPointsAvailable = BASE_ATTRIBUTE_POINTS + bonusPoints;
    const pointsSpent = basePointsSpent + totalAdjustmentCost;
    const pointsRemaining = totalPointsAvailable - pointsSpent;
    
    return {
      totalPointsAvailable,
      pointsSpent,
      pointsRemaining,
      forcedAdjustments,
      isValid: pointsRemaining >= 0,
      effectiveAttributes
    };
  }, [characterState]);
};

/**
 * Helper function to calculate combined trait effects on attributes
 * This needs to be implemented based on your trait system
 */
const getCombinedTraitEffects = (traitIds: string[]): Record<string, number> => {
  // TODO: Implement this based on your actual trait system
  // For now, return empty effects as a placeholder
  
  if (!Array.isArray(traitIds) || traitIds.length === 0) {
    return {};
  }
  
  // Placeholder implementation - replace with actual trait loading logic
  const effects: Record<string, number> = {};
  
  // Example implementation pattern:
  // traitIds.forEach(traitId => {
  //   const trait = getTraitById(traitId);
  //   if (trait?.effects) {
  //     trait.effects.forEach(effect => {
  //       if (effect.type === 'MODIFY_ATTRIBUTE') {
  //         effects[effect.target] = (effects[effect.target] || 0) + effect.value;
  //       }
  //     });
  //   }
  // });
  
  console.log('getCombinedTraitEffects placeholder called with:', traitIds);
  return effects;
};

/**
 * Helper function to calculate bonus attribute points from traits
 * This needs to be implemented based on your trait system
 */
const getBonusAttributePointsFromTraits = (traitIds: string[]): number => {
  // TODO: Implement this based on your actual trait system
  // For now, return 0 as a placeholder
  
  if (!Array.isArray(traitIds) || traitIds.length === 0) {
    return 0;
  }
  
  // Placeholder implementation - replace with actual trait loading logic
  let bonusPoints = 0;
  
  // Example implementation pattern:
  // traitIds.forEach(traitId => {
  //   const trait = getTraitById(traitId);
  //   if (trait?.effects) {
  //     trait.effects.forEach(effect => {
  //       if (effect.type === 'MODIFY_ATTRIBUTE_POINTS') {
  //         bonusPoints += effect.value;
  //       }
  //     });
  //   }
  // });
  
  console.log('getBonusAttributePointsFromTraits placeholder called with:', traitIds);
  return bonusPoints;
};

/**
 * Hook to check if a trait can be selected without exceeding attribute points
 */
export const useCanSelectTrait = (characterState: any) => {
  const currentCalculation = useAttributeCalculation(characterState);
  
  return useMemo(() => {
    return (traitId: string): boolean => {
      if (!traitId || !characterState) return false;
      
      // If trait is already selected, it can always be deselected
      const selectedTraitIds = characterState.selectedTraitIds || [];
      if (selectedTraitIds.includes(traitId)) {
        return true;
      }
      
      // Simulate adding this trait
      const simulatedState = {
        ...characterState,
        selectedTraitIds: [...selectedTraitIds, traitId]
      };
      
      const simulatedCalculation = useAttributeCalculation(simulatedState);
      return simulatedCalculation.isValid;
    };
  }, [characterState, currentCalculation]);
};

/**
 * Hook to get the attribute point impact of selecting a trait
 */
export const useTraitPointImpact = (characterState: any, traitId: string) => {
  const currentCalculation = useAttributeCalculation(characterState);
  
  return useMemo(() => {
    if (!traitId || !characterState) {
      return { pointsRemaining: currentCalculation.pointsRemaining, impact: 0 };
    }
    
    const selectedTraitIds = characterState.selectedTraitIds || [];
    const isCurrentlySelected = selectedTraitIds.includes(traitId);
    
    // Simulate the opposite state (add if not selected, remove if selected)
    const simulatedState = {
      ...characterState,
      selectedTraitIds: isCurrentlySelected 
        ? selectedTraitIds.filter(id => id !== traitId)
        : [...selectedTraitIds, traitId]
    };
    
    const simulatedCalculation = useAttributeCalculation(simulatedState);
    const impact = simulatedCalculation.pointsRemaining - currentCalculation.pointsRemaining;
    
    return {
      pointsRemaining: simulatedCalculation.pointsRemaining,
      impact: impact,
      isValid: simulatedCalculation.isValid,
      forcedAdjustments: simulatedCalculation.forcedAdjustments
    };
  }, [characterState, traitId, currentCalculation]);
};
```

## File: src/lib/hooks/useEnhancedCharacterCalculation.ts
```typescript
/**
 * Enhanced Character Calculation Hook
 * 
 * This hook provides real-time character calculations with detailed breakdowns
 * for tooltips, validation, and effect previews.
 */

import { useMemo, useCallback } from 'react';
import { useCharacter } from '../stores/characterContext';
import { 
  calculateCharacterWithBreakdowns, 
  convertToEnhancedBuildData 
} from '../services/enhancedCharacterCalculator';
import type { 
  CharacterCalculationHook, 
  EnhancedCalculationResult,
  EnhancedStatBreakdown,
  AttributeLimit,
  EffectPreview
} from '../types/effectSystem';

/**
 * Main hook for enhanced character calculations
 */
export function useEnhancedCharacterCalculation(): CharacterCalculationHook {
  const { state, dispatch } = useCharacter();
  
  // Convert context state to enhanced build data
  const buildData = useMemo(() => {
    return convertToEnhancedBuildData(state);
  }, [
    state.attribute_might,
    state.attribute_agility, 
    state.attribute_charisma,
    state.attribute_intelligence,
    state.classId,
    state.ancestry1Id,
    state.ancestry2Id,
    state.selectedTraitIds,
    state.selectedTraitChoices,
    state.selectedFeatureChoices,
    state.skillsJson,
    state.tradesJson,
    state.languagesJson,
    state.level,
    state.combatMastery
  ]);
  
  // Perform calculation with caching
  const calculationResult: EnhancedCalculationResult = useMemo(() => {
    // Check if we have valid cached results
    if (state.cachedEffectResults && state.cacheTimestamp) {
      const cacheAge = Date.now() - state.cacheTimestamp;
      if (cacheAge < 5000) { // Cache for 5 seconds
        try {
          const cached = JSON.parse(state.cachedEffectResults);
          return { ...cached, isFromCache: true };
        } catch (e) {
          // Cache is invalid, recalculate
        }
      }
    }
    
    // Calculate fresh results
    const result = calculateCharacterWithBreakdowns(buildData);
    
    // Cache the results (async to avoid blocking)
    setTimeout(() => {
      dispatch({
        type: 'UPDATE_STORE',
        updates: {
          cachedEffectResults: JSON.stringify(result),
          cacheTimestamp: result.cacheTimestamp
        }
      });
    }, 0);
    
    return result;
  }, [buildData, state.cachedEffectResults, state.cacheTimestamp, dispatch]);
  
  // Helper function to get stat breakdown
  const getStatBreakdown = useCallback((statName: string): EnhancedStatBreakdown | undefined => {
    return calculationResult.breakdowns[statName];
  }, [calculationResult.breakdowns]);
  
  // Helper function to get attribute limit
  const getAttributeLimit = useCallback((attributeId: string): AttributeLimit => {
    return calculationResult.validation.attributeLimits[attributeId] || {
      current: 0,
      base: 0,
      traitBonuses: 0,
      max: 3,
      exceeded: false,
      canIncrease: true,
      canDecrease: true
    };
  }, [calculationResult.validation.attributeLimits]);
  
  // Check if attribute can be increased
  const canIncreaseAttribute = useCallback((attributeId: string): boolean => {
    const limit = getAttributeLimit(attributeId);
    return limit.canIncrease;
  }, [getAttributeLimit]);
  
  // Check if attribute can be decreased  
  const canDecreaseAttribute = useCallback((attributeId: string): boolean => {
    const limit = getAttributeLimit(attributeId);
    return limit.canDecrease;
  }, [getAttributeLimit]);
  
  // Get effect preview for trait choices
  const getEffectPreview = useCallback((
    traitId: string, 
    effectIndex: number, 
    choice: string
  ): EffectPreview | undefined => {
    // Find the unresolved choice
    const unresolvedChoice = calculationResult.unresolvedChoices.find(
      uc => uc.traitId === traitId && uc.effectIndex === effectIndex
    );
    
    if (!unresolvedChoice) return undefined;
    
    const effect = unresolvedChoice.effect;
    
    if (effect.type === 'MODIFY_ATTRIBUTE') {
      const currentValue = (buildData as any)[`attribute_${choice}`] || 0;
      const newValue = currentValue + (effect.value as number);
      
      return {
        type: 'attribute',
        target: choice,
        currentValue,
        newValue,
        description: `${choice} will become ${newValue} (${currentValue} base + ${effect.value} trait)`
      };
    }
    
    if (effect.type === 'GRANT_SKILL_EXPERTISE') {
      return {
        type: 'skill',
        target: choice,
        currentValue: 'Normal mastery limit',
        newValue: 'Increased mastery limit',
        description: `${choice} mastery cap will increase by 1 and you gain 1 level`
      };
    }
    
    return undefined;
  }, [calculationResult.unresolvedChoices, buildData]);
  
  // Validate trait choice
  const validateTraitChoice = useCallback((
    traitId: string, 
    effectIndex: number, 
    choice: string
  ): { isValid: boolean; message?: string } => {
    // Find the effect being validated
    const unresolvedChoice = calculationResult.unresolvedChoices.find(
      uc => uc.traitId === traitId && uc.effectIndex === effectIndex
    );
    
    if (!unresolvedChoice) {
      return { isValid: false, message: 'Choice not found' };
    }
    
    const effect = unresolvedChoice.effect;
    
    if (effect.type === 'MODIFY_ATTRIBUTE') {
      const currentValue = (buildData as any)[`attribute_${choice}`] || 0;
      const newValue = currentValue + (effect.value as number);
      
      if (newValue > 3) {
        return { 
          isValid: false, 
          message: `Would exceed maximum attribute value of +3 (current: ${currentValue}, final: ${newValue})` 
        };
      }
      
      if (newValue < -2) {
        return { 
          isValid: false, 
          message: `Would go below minimum attribute value of -2 (current: ${currentValue}, final: ${newValue})` 
        };
      }
    }
    
    return { isValid: true };
  }, [calculationResult.unresolvedChoices, buildData]);
  
  // Validate attribute change
  const validateAttributeChange = useCallback((
    attributeId: string, 
    newValue: number
  ): { isValid: boolean; message?: string } => {
    const limit = getAttributeLimit(attributeId);
    const finalValue = newValue + limit.traitBonuses;
    
    if (finalValue > 3) {
      return { 
        isValid: false, 
        message: `Would exceed maximum total of +3 including trait bonuses (+${limit.traitBonuses})` 
      };
    }
    
    if (newValue < -2) {
      return { 
        isValid: false, 
        message: `Cannot go below minimum base value of -2` 
      };
    }
    
    return { isValid: true };
  }, [getAttributeLimit]);
  
  // Cache control functions
  const invalidateCache = useCallback(() => {
    dispatch({ type: 'INVALIDATE_CACHE' });
  }, [dispatch]);
  
  const refreshCalculation = useCallback(async () => {
    invalidateCache();
    // The calculation will automatically refresh on the next render
  }, [invalidateCache]);
  
  return {
    calculationResult,
    isLoading: false, // Could add loading states if calculations become expensive
    error: undefined,
    
    // Helper functions
    getStatBreakdown,
    getAttributeLimit,
    canIncreaseAttribute,
    canDecreaseAttribute,
    getEffectPreview,
    
    // Validation helpers
    validateTraitChoice,
    validateAttributeChange,
    
    // Cache control
    invalidateCache,
    refreshCalculation
  };
}

/**
 * Simplified hook for components that only need basic calculation results
 */
export function useCharacterStats() {
  const { calculationResult } = useEnhancedCharacterCalculation();
  return calculationResult.stats;
}

/**
 * Hook for components that need validation information
 */
export function useCharacterValidation() {
  const { calculationResult } = useEnhancedCharacterCalculation();
  return calculationResult.validation;
}

/**
 * Hook for components that need breakdown information for tooltips
 */
export function useStatBreakdowns() {
  const { calculationResult } = useEnhancedCharacterCalculation();
  return calculationResult.breakdowns;
}
```

## File: src/lib/rulesdata/_new_schema/barbarian_features.ts
```typescript
import type { ClassDefinition } from '../schemas/character.schema';

export const barbarianClass: ClassDefinition = {
	className: "Barbarian",
	startingStats: {
		hp: 10, // From barbarian_table.json
		sp: 6,
		mp: 0,
		skillPoints: 4,
		tradePoints: 3,
		languagePoints: 2,
		maneuversKnown: 0, // All Attack maneuvers + additional from table
		techniquesKnown: 1,
		cantripsKnown: 0,
		spellsKnown: 0
	},
	coreFeatures: [
		{
			featureName: "Martial Path",
			levelGained: 1,
			description: "You gain combat training and martial prowess.",
			effects: [
				{ type: 'GRANT_COMBAT_TRAINING', target: 'Weapons', value: true },
				{ type: 'GRANT_COMBAT_TRAINING', target: 'All_Armor', value: true },
				{ type: 'GRANT_COMBAT_TRAINING', target: 'All_Shields', value: true },
				{ type: 'GRANT_MANEUVERS', target: 'all_attack', value: true }
			],
			benefits: [
				{
					name: "Combat Training",
					description: "You gain proficiency with Weapons, All Armor, and All Shields.",
					effects: [
						{ type: 'GRANT_COMBAT_TRAINING', target: 'Weapons', value: true },
						{ type: 'GRANT_COMBAT_TRAINING', target: 'All_Armor', value: true },
						{ type: 'GRANT_COMBAT_TRAINING', target: 'All_Shields', value: true }
					]
				},
				{
					name: "Maneuver Knowledge",
					description: "You learn all Attack maneuvers plus additional maneuvers as shown on the Barbarian Class Table.",
					effects: [
						{ type: 'GRANT_MANEUVERS', target: 'all_attack', value: true }
					]
				},
				{
					name: "Stamina Regeneration", 
					description: "Once per round, you can regain up to half your maximum SP when you score a Heavy or Critical Hit against a creature, or when a Heavy or Critical Hit is scored against you.",
					effects: [
						{ type: 'GRANT_ABILITY', target: 'stamina_regen', value: 'Once per round, regain up to half maximum SP when you score or take a Heavy/Critical Hit.' }
					]
				}
			]
		},
		{
			featureName: "Rage",
			levelGained: 1,
			description: "During Combat, you can spend 1 AP and 1 SP to enter a Rage for 1 minute.",
			effects: [
				{ type: 'GRANT_ABILITY', target: 'rage', value: 'Spend 1 AP and 1 SP to Rage for 1 minute: +1 melee damage, ADV on Might Saves, -5 PD, Resistance (Half) to Elemental and Physical damage.' }
			]
		},
		{
			featureName: "Berserker",
			levelGained: 1,
			description: "Your primal savagery grants you the following benefits:",
			benefits: [
				{
					name: "Charge",
					description: "When you make a Melee Martial Attack on your turn, you can move up to 2 Spaces immediately before making the Attack.",
					effects: [
						{ type: 'GRANT_ABILITY', target: 'charge', value: 'Move up to 2 Spaces before making a Melee Martial Attack on your turn.' }
					]
				},
				{
					name: "Berserker Defense",
					description: "While you aren't wearing Armor you gain +2 AD.",
					effects: [
						{ type: 'MODIFY_STAT', target: 'ad', value: 2, condition: 'not_wearing_armor' }
					]
				},
				{
					name: "Fast Movement", 
					description: "You gain +1 Speed while not wearing Armor.",
					effects: [
						{ type: 'MODIFY_STAT', target: 'moveSpeed', value: 1, condition: 'not_wearing_armor' }
					]
				},
				{
					name: "Mighty Leap",
					description: "You can use your Might instead of Agility to determine your Jump Distance and the damage you take from Falling.",
					effects: [
						{ type: 'SET_VALUE', target: 'jumpCalculationAttribute', value: 'might' }
					]
				}
			]
		},
		{
			featureName: "Shattering Force",
			levelGained: 1,
			description: "When you Hit a structure or mundane object with a Melee Attack, it's considered a Critical Hit.",
			isFlavor: true,
			effects: [
				{ type: 'GRANT_ABILITY', target: 'shattering_force', value: 'Melee Attacks against structures and mundane objects are Critical Hits.' }
			]
		},
		{
			featureName: "Battlecry",
			levelGained: 2,
			description: "You can spend 1 AP and 1 SP to release a shout of your choice.",
			effects: [
				{ type: 'GRANT_ABILITY', target: 'battlecry', value: 'Spend 1 AP and 1 SP to release a shout affecting allies within 10 Spaces until start of your next turn.' }
			],
			choices: [
				{
					id: "barbarian_battlecry_choice",
					prompt: "Choose a shout to learn.",
					count: 3, // Learn all three shout options
					options: [
						{
							name: "Fortitude Shout",
							description: "Each creature gains Resistance (1) against the next source of Physical or Elemental damage.",
							effects: [
								{ type: 'GRANT_ABILITY', target: 'fortitude_shout', value: 'Grant allies Resistance (1) against next Physical or Elemental damage.' }
							]
						},
						{
							name: "Fury Shout", 
							description: "Each creature deals +1 damage on their next Attack against 1 target.",
							effects: [
								{ type: 'GRANT_ABILITY', target: 'fury_shout', value: 'Grant allies +1 damage on their next Attack.' }
							]
						},
						{
							name: "Urgent Shout",
							description: "Each creature gains +1 Speed until the start of your next turn.",
							effects: [
								{ type: 'GRANT_ABILITY', target: 'urgent_shout', value: 'Grant allies +1 Speed until start of your next turn.' }
							]
						}
					]
				}
			]
		},
		{
			featureName: "Talent",
			levelGained: 2,
			description: "You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent.",
			effects: [
				{ type: 'GRANT_CHOICE', target: 'talent', value: 1 }
			]
		}
	],
	subclasses: [
		{
			subclassName: "Elemental Fury",
			description: "Harness the power of the elements in your rage.",
			features: [
				{
					featureName: "Raging Elements",
					levelGained: 3,
					description: "You can surround yourself with the elements while raging.",
					choices: [
						{
							id: "barbarian_elemental_rage_damage_type",
							prompt: "Choose your Elemental Rage damage type.",
							count: 1,
							options: [
								{
									name: "Cold",
									description: "Your Elemental Rage damage is Cold.",
									effects: [
										{ type: 'GRANT_ABILITY', target: 'elemental_rage_cold', value: 'Elemental Rage damage is Cold. Gain 2 Space Aura while Raging with elemental effects.' }
									]
								},
								{
									name: "Fire",
									description: "Your Elemental Rage damage is Fire.",
									effects: [
										{ type: 'GRANT_ABILITY', target: 'elemental_rage_fire', value: 'Elemental Rage damage is Fire. Gain 2 Space Aura while Raging with elemental effects.' }
									]
								},
								{
									name: "Lightning", 
									description: "Your Elemental Rage damage is Lightning.",
									effects: [
										{ type: 'GRANT_ABILITY', target: 'elemental_rage_lightning', value: 'Elemental Rage damage is Lightning. Gain 2 Space Aura while Raging with elemental effects.' }
									]
								},
								{
									name: "Physical",
									description: "Your Elemental Rage damage is Physical (choose type each Rage).",
									effects: [
										{ type: 'GRANT_ABILITY', target: 'elemental_rage_physical', value: 'Elemental Rage damage is Physical (choose Bludgeoning/Piercing/Slashing each Rage). Gain 2 Space Aura while Raging with elemental effects.' }
									]
								}
							]
						},
						{
							id: "barbarian_aura_type",
							prompt: "Choose 1 additional benefit for your Aura Type.",
							count: 1,
							options: [
								{
									name: "Slowing Aura",
									description: "Spaces within your Aura count as Difficult Terrain for creatures of your choice.",
									effects: [
										{ type: 'GRANT_ABILITY', target: 'slowing_aura', value: 'Aura creates Difficult Terrain for chosen creatures. Failed saves also cause Slowed until end of their next turn.' }
									]
								},
								{
									name: "Splashing Aura",
									description: "Once per Turn when you deal Elemental Rage damage to a creature, you can automatically deal 1 Elemental Rage damage to a creature within 1 Space of it.",
									effects: [
										{ type: 'GRANT_ABILITY', target: 'splashing_aura', value: 'Once per turn, Elemental Rage damage splashes to a creature within 1 Space for 1 damage.' }
									]
								},
								{
									name: "Stunning Aura",
									description: "Once per Turn when a creature within your Aura fails a Save you force it to make, it also can't spend AP on Reactions until the start of its next turn.",
									effects: [
										{ type: 'GRANT_ABILITY', target: 'stunning_aura', value: 'Once per turn, creatures that fail saves in your Aura cannot spend AP on Reactions until start of their next turn.' }
									]
								},
								{
									name: "Pushing Aura",
									description: "When you use your Elemental Blast, creatures affected must make a Physical Save.",
									effects: [
										{ type: 'GRANT_ABILITY', target: 'pushing_aura', value: 'Elemental Blast forces Physical Save; failure moves targets 2 Spaces toward or away from you.' }
									]
								}
							]
						}
					]
				},
				{
					featureName: "Elemental Affinity",
					levelGained: 3,
					description: "You are infused with the power of your Element.",
					isFlavor: true,
					effects: [
						{ type: 'GRANT_ABILITY', target: 'elemental_affinity', value: 'Voice can boom 3x louder, create elemental visual displays, Resistance to environmental Exhaustion.' }
					]
				}
			]
		},
		{
			subclassName: "Spirit Guardian",
			description: "Call upon ancestral spirits to aid you in battle.",
			features: [
				{
					featureName: "Ancestral Guardian", 
					levelGained: 3,
					description: "Bestowed Protection and Spiritual Aura while Raging.",
					effects: [
						{ type: 'GRANT_CHOICE', target: 'guardian_maneuver', value: 1 },
						{ type: 'GRANT_RESISTANCE', target: 'Mystical', value: 1, condition: 'raging' },
						{ type: 'GRANT_ABILITY', target: 'spiritual_aura', value: 'While Raging: 5 Space Aura allows Shove on any creature, use Parry/Protect/Raise Shield on any creature in Aura.' }
					],
					choices: [
						{
							id: "barbarian_guardian_maneuver",
							prompt: "Learn 1 of the following Maneuvers (or any Maneuver if you know all 3).",
							count: 1,
							options: [
								{
									name: "Parry",
									description: "Learn the Parry maneuver.",
									effects: [
										{ type: 'GRANT_CHOICE', target: 'maneuver', value: 'Parry' }
									]
								},
								{
									name: "Protect",
									description: "Learn the Protect maneuver.", 
									effects: [
										{ type: 'GRANT_CHOICE', target: 'maneuver', value: 'Protect' }
									]
								},
								{
									name: "Raise Shield",
									description: "Learn the Raise Shield maneuver.",
									effects: [
										{ type: 'GRANT_CHOICE', target: 'maneuver', value: 'Raise Shield' }
									]
								}
							]
						}
					]
				},
				{
					featureName: "Ancestral Knowledge",
					levelGained: 3,
					description: "You have ADV on Checks to recall information about the history of your Ancestries.",
					isFlavor: true,
					effects: [
						{ type: 'GRANT_ABILITY', target: 'ancestral_knowledge', value: 'ADV on Checks about your Ancestries\' history. Once per Long Rest: ADV on a Trade or Language Check.' }
					]
				}
			]
		}
	]
};
```

## File: src/lib/rulesdata/_new_schema/barbarian_table.json
```json
{
	"className": "Barbarian",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 4,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
```

## File: src/lib/rulesdata/_new_schema/bard_features.ts
```typescript
/**
 * Bard Class Definition - New Effect Schema
 * Based on DC20 Bard features with spellcasting and performance abilities
 */

import type { ClassDefinition } from '../schemas/character.schema';

export const bardClass: ClassDefinition = {
  className: 'Bard',
  startingStats: {
    hp: 8, // From bard_table.json level 1
    sp: 0,
    mp: 6,
    skillPoints: 4,
    tradePoints: 3,
    languagePoints: 2,
    maneuversKnown: 0,
    techniquesKnown: 0,
    cantripsKnown: 2,
    spellsKnown: 3
  },
  coreFeatures: [
    {
      featureName: 'Spellcasting Path',
      levelGained: 1,
      description: 'You gain the ability to cast spells from multiple schools.',
      effects: [
        { type: 'GRANT_COMBAT_TRAINING', target: 'Light_Armor', value: true },
        { type: 'GRANT_COMBAT_TRAINING', target: 'Light_Shields', value: true }
      ]
    },
    {
      featureName: 'Font of Inspiration',
      levelGained: 1,
      description: 'You are an ever present source of aid for your allies.',
      benefits: [
        {
          name: 'Ranged Help Attack',
          description: 'The range of your Help Action when aiding an Attack increases to 10 Spaces.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'ranged_help_attack', value: 'Help Action range for attacks extends to 10 Spaces.' }
          ]
        },
        {
          name: 'Help Reaction',
          description: 'When a creature you can see makes a Check, you can take the Help Action as a Reaction to aid them with their Check, provided you\'re within range to do so.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'help_reaction', value: 'Take Help Action as Reaction when creatures make Checks.' }
          ]
        }
      ]
    },
    {
      featureName: 'Remarkable Repertoire',
      levelGained: 1,
      description: 'You\'ve picked up a few tricks along your travels.',
      benefits: [
        {
          name: 'Jack of All Trades',
          description: 'You gain 2 Skill Points.',
          effects: [
            { type: 'MODIFY_STAT', target: 'skillPoints', value: 2 }
          ]
        },
        {
          name: 'Magical Secrets',
          description: 'You learn any 2 Spells of your choice from any Spell List.',
          effects: [
            { type: 'GRANT_SPELL', target: 'any_spell_list', value: 2 }
          ]
        },
        {
          name: 'Magical Expression',
          description: 'You learn to express your art in a unique manner, granting you the ability to alter how you cast Spells.',
          effects: [
            { 
              type: 'GRANT_CHOICE', 
              target: 'magical_expression', 
              value: 1,
              userChoice: {
                prompt: 'Choose your magical expression style',
                options: ['Visual', 'Auditory']
              }
            }
          ]
        }
      ]
    },
    {
      featureName: 'Crowd Pleaser',
      levelGained: 1,
      description: 'When you spend at least 5 minutes performing an Artistry Trade for one or more people who are actively watching or listening to your performance, you can make an Artistry Trade Check Contested by the targets\' Charisma Save.',
      isFlavor: true,
      effects: [
        { type: 'GRANT_ABILITY', target: 'crowd_pleaser', value: 'ADV on Charisma Checks against targets who watched your performance for 1 hour.' }
      ]
    },
    {
      featureName: 'Bardic Performance',
      levelGained: 2,
      description: 'You can spend 1 AP and 1 MP to start a performance that grants you a 10 Space Aura for 1 minute.',
      choices: [
        {
          id: 'bardic_performance_choice',
          prompt: 'Choose a performance type',
          count: 1,
          options: [
            {
              name: 'Battle Ballad',
              description: 'The chosen creatures deal +1 damage against 1 target of their choice on an Attack they make once on each of their turns.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'battle_ballad', value: 'Allies in aura deal +1 damage on first attack per turn against chosen target.' }
              ]
            },
            {
              name: 'Fast Tempo',
              description: 'The chosen creatures gain +1 Speed.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'fast_tempo', value: 'Allies in aura gain +1 Speed.' }
              ]
            },
            {
              name: 'Inspiring',
              description: 'The chosen creatures gain 1 Temp HP at the start of each of their turns.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'inspiring_performance', value: 'Allies in aura gain 1 Temp HP at start of their turns.' }
              ]
            },
            {
              name: 'Emotional',
              description: 'Choose 1 of the following Conditions: Charmed, Frightened, Intimidated, or Taunted. The chosen creatures have Resistance against the chosen Condition.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'emotional_performance', value: 'Allies in aura gain Resistance to chosen condition and can repeat saves.' }
              ]
            }
          ]
        }
      ]
    },
    {
      featureName: 'Talent',
      levelGained: 2,
      description: 'You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent.',
      effects: [
        { type: 'GRANT_CHOICE', target: 'talent', value: 1 }
      ]
    }
  ],
  subclasses: [
    {
      subclassName: 'Eloquence',
      description: 'Masters of persuasion and charm magic.',
      features: [
        {
          featureName: 'Beguiling Presence',
          levelGained: 3,
          description: 'You gain enhanced charm abilities and magical persuasion.',
          benefits: [
            {
              name: 'Enthrall',
              description: 'You learn the Befriend Spell, and it doesn\'t end as a result of the target taking damage.',
              effects: [
                { type: 'GRANT_SPELL', target: 'befriend', value: 1 },
                { type: 'GRANT_ABILITY', target: 'enhanced_befriend', value: 'Befriend spell doesn\'t end from target taking damage.' }
              ]
            },
            {
              name: 'Misleading Muse',
              description: 'When a creature within your Bardic Performance targets only you with an Attack, you can redirect it.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'misleading_muse', value: 'Spend 1 AP as Reaction to charm attacker and redirect attack.' }
              ]
            },
            {
              name: 'Mind Games',
              description: 'When the Charmed Condition ends on a creature Charmed by you, you can deal psychic damage.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'mind_games', value: 'Deal 1 Psychic damage when charm ends.' }
              ]
            }
          ]
        },
        {
          featureName: 'Eloquent Orator',
          levelGained: 3,
          description: 'Your speech is magically enchanted. Creatures can always understand the words you speak, provided they speak at least 1 Language.',
          isFlavor: true,
          effects: [
            { type: 'GRANT_ABILITY', target: 'eloquent_orator', value: 'All creatures with language can understand your speech.' }
          ]
        }
      ]
    },
    {
      subclassName: 'Jester',
      description: 'Comedic performers who use humor and chaos in battle.',
      features: [
        {
          featureName: 'Antagonizing Act',
          levelGained: 3,
          description: 'You gain abilities that frustrate and distract enemies.',
          benefits: [
            {
              name: 'Heckle',
              description: 'Once per Round when a creature within your Bardic Performance fails a Save, they\'re Taunted.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'heckle', value: 'Taunt creatures who fail saves in your performance aura.' }
              ]
            },
            {
              name: 'Distraction',
              description: 'When a hostile creature within 10 Spaces makes an Attack, you can impose DisADV.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'distraction', value: 'Spend 1 AP as Reaction to impose DisADV on nearby attacks.' }
              ]
            },
            {
              name: 'Pratfall',
              description: 'When you fail a Save, you can grant an ally ADV on their next Check.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'pratfall', value: 'Grant ally ADV on Check when you fail a save.' }
              ]
            }
          ]
        },
        {
          featureName: 'Comedian',
          levelGained: 3,
          description: 'You have ADV on Checks to make other creatures laugh.',
          isFlavor: true,
          effects: [
            { type: 'GRANT_ADV_ON_CHECK', target: 'comedy', value: 'ADV' }
          ]
        }
      ]
    }
  ]
};
```

## File: src/lib/rulesdata/_new_schema/bard_table.json
```json
{
	"className": "Bard",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 8,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 6,
			"cantripsKnown": 2,
			"spellsKnown": 3,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
```

## File: src/lib/rulesdata/_new_schema/champion_features.ts
```typescript
/**
 * Champion Class Definition - New Effect Schema
 * Based on DC20 Champion features
 */

import type { ClassDefinition } from '../schemas/character.schema';

export const championClass: ClassDefinition = {
  className: 'Champion',
  startingStats: {
    hp: 10,
    sp: 6,
    mp: 0,
    skillPoints: 3,
    tradePoints: 3,
    languagePoints: 2,
    maneuversKnown: 4,
    techniquesKnown: 1,
    cantripsKnown: 0,
    spellsKnown: 0
  },
  coreFeatures: [
    {
      featureName: 'Martial Path',
      levelGained: 1,
      description: 'You gain extensive combat training.',
      effects: [
        { type: 'GRANT_COMBAT_TRAINING', target: 'Weapons', value: true },
        { type: 'GRANT_COMBAT_TRAINING', target: 'All_Armors', value: true },
        { type: 'GRANT_COMBAT_TRAINING', target: 'All_Shields', value: true },
        { type: 'GRANT_ABILITY', target: 'learns_all_attack_maneuvers', value: 'You learn all Attack Maneuvers.' },
        { type: 'GRANT_ABILITY', target: 'stamina_regen', value: 'Once per round, regain up to half maximum SP when you perform a Maneuver.' }
      ]
    },
    {
      featureName: 'Master-at-Arms',
      levelGained: 1,
      description: 'Your training in warfare has granted you extensive weapon mastery.',
      benefits: [
        {
          name: 'Weapon Master',
          description: 'At the start of each of your turns, you can freely swap any Weapon you are currently wielding in each hand for any other Weapon without provoking Opportunity Attacks.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'weapon_master', value: 'Free weapon swapping at start of turn without provoking Opportunity Attacks.' }
          ]
        },
        {
          name: 'Maneuver Master',
          description: 'You learn 2 Maneuvers of your choice.',
          effects: [
            { type: 'GRANT_CHOICE', target: 'maneuver', value: 2 }
          ]
        },
        {
          name: 'Technique Master',
          description: 'You learn 1 Technique of your choice. Once per Combat, when you perform a Technique you can reduce its SP cost by 1.',
          effects: [
            { type: 'GRANT_CHOICE', target: 'technique', value: 1 },
            { type: 'GRANT_ABILITY', target: 'technique_master', value: 'Once per Combat: reduce a Technique\'s SP cost by 1.' }
          ]
        }
      ]
    },
    {
      featureName: 'Fighting Spirit',
      levelGained: 1,
      description: 'You stand ready for Combat at any moment.',
      benefits: [
        {
          name: 'Combat Readiness',
          description: 'At the start of your first turn in Combat, you gain one of the following benefits: Brace (Dodge Action + ADV on next Save) or Advance (Move Action + ADV on next Physical Check).',
          effects: [
            { type: 'GRANT_ABILITY', target: 'combat_readiness', value: 'First turn in Combat: choose Brace (Dodge + ADV on Save) or Advance (Move + ADV on Physical Check).' }
          ]
        },
        {
          name: 'Second Wind',
          description: 'Once per Combat when you start your turn Bloodied, you can regain 2 HP and 1 SP.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'second_wind', value: 'Once per Combat when Bloodied at turn start: regain 2 HP and 1 SP.' }
          ]
        }
      ]
    },
    {
      featureName: 'Know Your Enemy',
      levelGained: 1,
      description: 'You can spend 1 minute observing or interacting with a creature out of Combat (or spend 1 AP in Combat) to learn information about its physical capabilities compared to your own.',
      isFlavor: true,
      effects: [
        { type: 'GRANT_ABILITY', target: 'know_your_enemy', value: 'Spend 1 minute (or 1 AP in Combat) to assess creature\'s Might, Agility, PD, AD, or HP vs. yours (DC 10 Knowledge/Insight).' }
      ]
    },
    {
      featureName: 'Adaptive Tactics',
      levelGained: 2,
      description: 'When you roll for Initiative, and at the end of each of your turns, you gain a d8 Tactical Die if you don\'t already have one.',
      effects: [
        { type: 'GRANT_ABILITY', target: 'adaptive_tactics', value: 'Gain d8 Tactical Die at Initiative and end of turns. Spend for: Assault (+die to Attack), Defense (+die to PD/AD), or Mobility (+die to Move/Jump).' }
      ]
    }
  ],
  subclasses: []
};
```

## File: src/lib/rulesdata/_new_schema/champion_table.json
```json
{
	"className": "Champion",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 4,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
```

## File: src/lib/rulesdata/_new_schema/cleric_table.json
```json
{
	"className": "Cleric",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 8,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 6,
			"cantripsKnown": 2,
			"spellsKnown": 3,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
```

## File: src/lib/rulesdata/_new_schema/commander_features.ts
```typescript
/**
 * Commander Class Definition - New Effect Schema
 * Based on DC20 Commander features with martial abilities and leadership
 */

import type { ClassDefinition } from '../schemas/character.schema';

export const commanderClass: ClassDefinition = {
  className: 'Commander',
  startingStats: {
    hp: 9, // From commander_table.json level 1
    sp: 1,
    mp: 0,
    skillPoints: 4,
    tradePoints: 3,
    languagePoints: 2,
    maneuversKnown: 4, // All Attack maneuvers + 4 additional
    techniquesKnown: 0,
    cantripsKnown: 0,
    spellsKnown: 0
  },
  coreFeatures: [
    {
      featureName: 'Martial Path',
      levelGained: 1,
      description: 'You gain extensive combat training and martial prowess.',
      effects: [
        { type: 'GRANT_COMBAT_TRAINING', target: 'Weapons', value: true },
        { type: 'GRANT_COMBAT_TRAINING', target: 'All_Armor', value: true },
        { type: 'GRANT_COMBAT_TRAINING', target: 'All_Shields', value: true },
        { type: 'GRANT_MANEUVERS', target: 'all_attack', value: true }
      ],
      benefits: [
        {
          name: 'Combat Training',
          description: 'Proficiency with all weapons, armor, and shields.',
          effects: []
        },
        {
          name: 'Maneuver Training',
          description: 'You learn all Attack Maneuvers plus additional maneuvers.',
          effects: []
        },
        {
          name: 'Stamina Regeneration',
          description: 'Once per round, regain up to half maximum SP when you grant a creature a Help Die.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'stamina_regen', value: 'Regain up to half max SP when granting Help Die (once per round).' }
          ]
        }
      ]
    },
    {
      featureName: 'Inspiring Presence',
      levelGained: 1,
      description: 'Whenever you spend SP while in Combat, you can restore HP to nearby allies.',
      effects: [
        { type: 'GRANT_ABILITY', target: 'inspiring_presence', value: 'When spending SP in combat: restore HP equal to SP spent, divide among allies within 5 Spaces.' }
      ]
    },
    {
      featureName: 'Commander\'s Call',
      levelGained: 1,
      description: 'You can spend 1 AP and 1 SP to command a willing creature within 5 Spaces.',
      benefits: [
        {
          name: 'Attack Command',
          description: 'The creature makes an Attack with ADV without spending resources.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'attack_command', value: 'Command ally to Attack with ADV (1 AP + 1 SP, once per turn).' }
          ]
        },
        {
          name: 'Dodge Command',
          description: 'The creature takes the Full Dodge Action.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'dodge_command', value: 'Command ally to Full Dodge (1 AP + 1 SP, once per turn).' }
          ]
        },
        {
          name: 'Move Command',
          description: 'The creature moves up to their Speed without provoking Opportunity Attacks.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'move_command', value: 'Command ally to move up to Speed without opportunity attacks (1 AP + 1 SP, once per turn).' }
          ]
        }
      ]
    },
    {
      featureName: 'Natural Leader',
      levelGained: 1,
      description: 'You have ADV on Checks made to convince creatures that you are an authority figure.',
      isFlavor: true,
      effects: [
        { type: 'GRANT_ADV_ON_CHECK', target: 'authority_figure', value: 'ADV' },
        { type: 'GRANT_ADV_ON_CHECK', target: 'military_groups', value: 'ADV' }
      ]
    },
    {
      featureName: 'Commanding Aura',
      levelGained: 2,
      description: 'You\'re surrounded by a 5 Space Aura that allows you to aid and support allies.',
      benefits: [
        {
          name: 'Bolster',
          description: 'Take the Help Action to aid attacks within your aura (1 AP or Reaction).',
          effects: [
            { type: 'GRANT_ABILITY', target: 'bolster', value: 'Help Action for attacks in aura (1 AP or Reaction).' }
          ]
        },
        {
          name: 'Rally',
          description: 'Grant creatures of your choice 1 Temp HP (1 AP).',
          effects: [
            { type: 'GRANT_ABILITY', target: 'rally', value: 'Grant 1 Temp HP to creatures in aura (1 AP).' }
          ]
        },
        {
          name: 'Reinforce',
          description: 'Impose DisADV on attacks against creatures in your aura (Reaction).',
          effects: [
            { type: 'GRANT_ABILITY', target: 'reinforce', value: 'Impose DisADV on attacks in aura (Reaction).' }
          ]
        }
      ]
    },
    {
      featureName: 'Talent',
      levelGained: 2,
      description: 'You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent.',
      effects: [
        { type: 'GRANT_CHOICE', target: 'talent', value: 1 }
      ]
    }
  ],
  subclasses: [
    {
      subclassName: 'Crusader',
      description: 'Holy warriors who protect and inspire their allies.',
      features: [
        {
          featureName: 'Virtuous Vanguard',
          levelGained: 3,
          description: 'You become a beacon of courage and protection.',
          benefits: [
            {
              name: 'Aura of Courage',
              description: 'Allies in your Commanding Aura have Resistance to Frightened and Intimidated.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'aura_of_courage', value: 'Allies in aura: Resistance to Frightened and Intimidated.' }
              ]
            },
            {
              name: 'Protective Orders',
              description: 'Creatures who benefit from Commander\'s Call gain damage Resistance.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'protective_orders', value: 'Commander\'s Call targets gain Resistance (1) to next damage before your next turn.' }
              ]
            },
            {
              name: 'Restoring Rally',
              description: 'Bloodied creatures regain HP instead of gaining Temp HP from Rally.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'restoring_rally', value: 'Rally: Bloodied creatures regain HP instead of Temp HP.' }
              ]
            }
          ]
        },
        {
          featureName: 'Gallant Hero',
          levelGained: 3,
          description: 'Your presence is a symbol of hope and safety.',
          isFlavor: true,
          effects: [
            { type: 'GRANT_ADV_ON_CHECK', target: 'convince_not_afraid', value: 'ADV' }
          ]
        }
      ]
    },
    {
      subclassName: 'Warlord',
      description: 'Tactical masters who excel at aggressive battlefield control.',
      features: [
        {
          featureName: 'Offensive Tactics',
          levelGained: 3,
          description: 'You gain aggressive battlefield abilities.',
          benefits: [
            {
              name: 'Morale Breaker',
              description: 'Once per Combat when using Commander\'s Call, use Intimidate Action for free.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'morale_breaker', value: 'Commander\'s Call: Free Intimidate Action against creature within 15 Spaces (once per combat).' }
              ]
            },
            {
              name: 'Battlefield Tactics',
              description: 'Allies deal +1 damage on their first Melee Attack against flanked creatures.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'battlefield_tactics', value: 'Allies in aura: +1 damage on first Melee Attack vs flanked creatures each turn.' }
              ]
            },
            {
              name: 'Priority Target',
              description: 'Grant allies ADV on attacks against a chosen target.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'priority_target', value: 'Priority Target (1 AP + 1 SP): Allies in aura get ADV on first attack vs chosen target until your next turn.' }
              ]
            }
          ]
        },
        {
          featureName: 'Battlefield Tactician',
          levelGained: 3,
          description: 'You\'ve mastered military history and strategy.',
          isFlavor: true,
          effects: [
            { type: 'GRANT_ADV_ON_CHECK', target: 'military_knowledge', value: 'ADV' }
          ]
        }
      ]
    }
  ]
};
```

## File: src/lib/rulesdata/_new_schema/commander_table.json
```json
{
	"className": "Commander",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 4,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
```

## File: src/lib/rulesdata/_new_schema/druid_features.ts
```typescript
/**
 * Druid Class Definition - New Effect Schema
 * Based on DC20 Druid features with wild form and domain abilities
 */

import type { ClassDefinition } from '../schemas/character.schema';

export const druidClass: ClassDefinition = {
  className: 'Druid',
  startingStats: {
    hp: 8, // From druid_table.json level 1
    sp: 0,
    mp: 6,
    skillPoints: 4,
    tradePoints: 3,
    languagePoints: 2,
    maneuversKnown: 0,
    techniquesKnown: 0,
    cantripsKnown: 2,
    spellsKnown: 3
  },
  coreFeatures: [
    {
      featureName: 'Spellcasting Path',
      levelGained: 1,
      description: 'You gain the ability to cast primal spells.',
      effects: [
        { type: 'GRANT_COMBAT_TRAINING', target: 'Light_Armor', value: true }
      ]
    },
    {
      featureName: 'Druid Domain',
      levelGained: 1,
      description: 'You can spend 1 AP and 1 MP to create your own Druid Domain that includes small plant life, sand, shallow water, or other naturally occurring features.',
      benefits: [
        {
          name: 'Domain Creation',
          description: 'Create up to 8 Domain Spaces of difficult terrain that you can cast spells from.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'druid_domain', value: 'Create 8 Domain Spaces (1 AP + 1 MP). Cast spells from any Domain Space.' }
          ]
        },
        {
          name: 'Nature\'s Grasp',
          description: 'Bind creatures within your Domain, preventing movement.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'natures_grasp', value: 'Spend 1 AP to bind creature in Domain (Spell Check vs Repeated Physical Save).' }
          ]
        },
        {
          name: 'Move Creature',
          description: 'Move bound creatures within your Domain.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'move_creature', value: 'Spend 1 AP to move bound creature up to 2 Spaces within Domain.' }
          ]
        },
        {
          name: 'Move Object',
          description: 'Interact with objects anywhere in your Domain.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'move_object', value: 'Use Object Action from any Domain Space, move objects up to 5 Spaces.' }
          ]
        },
        {
          name: 'Wild Growth',
          description: 'Heal targets within your Domain with ongoing regeneration.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'wild_growth', value: '1 AP + 1 MP: DC 10 Spell Check to heal 2+ HP, then 1 HP per turn in Domain.' }
          ]
        }
      ]
    },
    {
      featureName: 'Wild Form',
      levelGained: 1,
      description: 'You can spend 1 AP and 1 MP to transform into a Wild Form of your choice.',
      benefits: [
        {
          name: 'Transformation',
          description: 'Gain Wild Form with 3 HP, natural weapons, and Beast traits.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'wild_form', value: 'Transform: 1 AP + 1 MP (free once per Long Rest). Gain 3 Wild Form HP, natural weapons.' }
          ]
        },
        {
          name: 'Beast Traits',
          description: 'Gain 3 Trait Points for Beast or Wild Form traits, +2 per extra MP spent.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'beast_traits', value: '3 Trait Points for Beast/Wild Form traits. Spend extra MP for +2 Trait Points each.' }
          ]
        },
        {
          name: 'Form Switching',
          description: 'Switch between True Form and available Wild Forms for 1 AP.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'form_switching', value: 'Spend 1 AP to switch between True Form and Wild Forms.' }
          ]
        }
      ]
    },
    {
      featureName: 'Wild Speech',
      levelGained: 1,
      description: 'You learn the Druidcraft Cantrip and can communicate with nature.',
      isFlavor: true,
      effects: [
        { type: 'GRANT_CANTRIP', target: 'druidcraft', value: 1 },
        { 
          type: 'GRANT_CHOICE', 
          target: 'wild_speech', 
          value: 1,
          userChoice: {
            prompt: 'Choose your nature communication',
            options: ['Animals', 'Plants', 'Weather']
          }
        }
      ]
    },
    {
      featureName: 'Nature\'s Torrent',
      levelGained: 2,
      description: 'When a creature within 10 spaces takes Elemental damage, you can summon a torrent of nature.',
      effects: [
        { type: 'GRANT_ABILITY', target: 'natures_torrent', value: 'Reaction: Create 1 Space Radius Sphere. Creatures have Vulnerability (1) to triggering damage type and DisADV on movement saves.' }
      ]
    },
    {
      featureName: 'Talent',
      levelGained: 2,
      description: 'You gain 1 Talent of your choice. If the Talent has any prerequisites, you must meet those prerequisites to choose that Talent.',
      effects: [
        { type: 'GRANT_CHOICE', target: 'talent', value: 1 }
      ]
    }
  ],
  subclasses: [
    {
      subclassName: 'Phoenix',
      description: 'Druids who harness the power of fire and rebirth.',
      features: [
        {
          featureName: 'Flames of Rebirth',
          levelGained: 3,
          description: 'You wield the power of fire to lay destruction and foster new life.',
          benefits: [
            {
              name: 'Fiery Form',
              description: 'Your Wild Forms can become Elemental (Fire) with Fire Resistance and fire damage.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'fiery_form', value: 'Wild Forms: Elemental (Fire) type, Fire Resistance (1), Fire damage natural weapons.' }
              ]
            },
            {
              name: 'Cleansing Flames',
              description: 'Remove conditions when healing creatures in your Domain.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'cleansing_flames', value: 'When healing in Domain: remove Impaired, Dazed, Burning, or Poisoned.' }
              ]
            },
            {
              name: 'Rolling Wild Fire',
              description: 'Creatures take fire damage for moving in your Domain.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'rolling_wild_fire', value: 'Creatures take 1 Fire damage per Space moved in Domain or starting turn in Domain.' }
              ]
            }
          ]
        },
        {
          featureName: 'Fire Within',
          levelGained: 3,
          description: 'You are unaffected by cold weather and can boil liquids with touch.',
          isFlavor: true,
          effects: [
            { type: 'GRANT_ABILITY', target: 'fire_within', value: 'Immune to cold weather. Boil 1 gallon liquid with 1 minute contact.' }
          ]
        }
      ]
    },
    {
      subclassName: 'Rampant Growth',
      description: 'Druids who specialize in plant magic and overgrowth.',
      features: [
        {
          featureName: 'Overgrowth',
          levelGained: 3,
          description: 'You enhance your Domain and Wild Forms with plant-based abilities.',
          benefits: [
            {
              name: 'Plant Form',
              description: 'Your Wild Forms can become Plant type with immunity to Bleeding.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'plant_form', value: 'Wild Forms: Plant type, immune to Bleeding, Poison damage natural weapons.' }
              ]
            },
            {
              name: 'Vineguard',
              description: 'Plant-life in your Domain provides cover to allies.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'vineguard', value: 'Creatures of choice in Domain gain benefits of 1/2 Cover.' }
              ]
            },
            {
              name: 'Thorny Grasp',
              description: 'Creatures who fail saves against Nature\'s Grasp begin Bleeding.',
              effects: [
                { type: 'GRANT_ABILITY', target: 'thorny_grasp', value: 'Creatures who fail Nature\'s Grasp save begin Bleeding.' }
              ]
            }
          ]
        },
        {
          featureName: 'Seed Vault',
          levelGained: 3,
          description: 'You can magically produce the seeds of any mundane plant that you\'ve ever touched.',
          isFlavor: true,
          effects: [
            { type: 'GRANT_ABILITY', target: 'seed_vault', value: 'Produce seeds of any mundane plant you\'ve touched.' }
          ]
        }
      ]
    }
  ]
};
```

## File: src/lib/rulesdata/_new_schema/druid_table.json
```json
{
	"className": "Druid",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 8,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 6,
			"cantripsKnown": 2,
			"spellsKnown": 3,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
```

## File: src/lib/rulesdata/_new_schema/hunter_table.json
```json
{
	"className": "Hunter",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 4,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
```

## File: src/lib/rulesdata/_new_schema/monk_table.json
```json
{
	"className": "Monk",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 4,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
```

## File: src/lib/rulesdata/_new_schema/rogue_table.json
```json
{
	"className": "Rogue",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 4,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
```

## File: src/lib/rulesdata/_new_schema/sorcerer_table.json
```json
{
	"className": "Sorcerer",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 8,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 6,
			"cantripsKnown": 2,
			"spellsKnown": 3,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
```

## File: src/lib/rulesdata/_new_schema/spellblade_table.json
```json
{
	"className": "Spellblade",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 1,
			"maneuversKnown": 2,
			"techniquesKnown": 0,
			"manaPoints": 3,
			"cantripsKnown": 1,
			"spellsKnown": 1,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 1,
			"techniquesKnown": 1,
			"manaPoints": 1,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 1,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 1,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 1,
			"maneuversKnown": 0,
			"techniquesKnown": 1,
			"manaPoints": 1,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
```

## File: src/lib/rulesdata/_new_schema/warlock_table.json
```json
{
	"className": "Warlock",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 9,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 6,
			"cantripsKnown": 2,
			"spellsKnown": 3,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 3,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 3,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
```

## File: src/lib/rulesdata/_new_schema/wizard_table.json
```json
{
	"className": "Wizard",
	"levelProgression": [
		{
			"level": 1,
			"healthPoints": 8,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 6,
			"cantripsKnown": 2,
			"spellsKnown": 3,
			"features": "Class Features"
		},
		{
			"level": 2,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Class Feature, Talent + 1 Path Point"
		},
		{
			"level": 3,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 4,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 5,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Feature"
		},
		{
			"level": 6,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 1,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Feature"
		},
		{
			"level": 7,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Talent + 1 Path Point, 2 Ancestry Points"
		},
		{
			"level": 8,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 1,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 1,
			"spellsKnown": 0,
			"features": "Class Capstone Feature"
		},
		{
			"level": 9,
			"healthPoints": 2,
			"attributePoints": 0,
			"skillPoints": 0,
			"tradePoints": 0,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 2,
			"cantripsKnown": 0,
			"spellsKnown": 1,
			"features": "Subclass Capstone Feature"
		},
		{
			"level": 10,
			"healthPoints": 2,
			"attributePoints": 1,
			"skillPoints": 2,
			"tradePoints": 1,
			"staminaPoints": 0,
			"maneuversKnown": 0,
			"techniquesKnown": 0,
			"manaPoints": 0,
			"cantripsKnown": 0,
			"spellsKnown": 0,
			"features": "Epic Boon, Talent + 1 Path Point"
		}
	]
}
```

## File: src/lib/rulesdata/rulesdata.spec.ts
```typescript
import { describe, it, expect } from 'vitest';
import { classesDataSchema } from './schemas/class.schema';
import { classesData } from './loaders/class.loader';
import { traitsData as newTraitsData } from './_new_schema/traits';
import { ancestriesData as newAncestriesData } from './_new_schema/ancestries';
import { allSpells } from './spells-data/spells';
import { maneuvers } from './maneuvers';
import { techniques } from './techniques';
import { allItems } from './inventoryItems';

describe('Rules Data Validation', () => {
    it('should load and validate all class data against the Zod schema', () => {
        expect(classesData.length).toBeGreaterThan(0);
        expect(() => classesDataSchema.parse(classesData)).not.toThrow();
    });

    it('should ensure all new trait data is structured correctly', () => {
        expect(newTraitsData.length).toBeGreaterThan(0);
        // Basic check for core properties
        newTraitsData.forEach(trait => {
            expect(trait).toHaveProperty('id');
            expect(trait).toHaveProperty('name');
            expect(trait).toHaveProperty('cost');
            expect(trait).toHaveProperty('effects');
        });
    });

    it('should ensure all new ancestry data is structured correctly', () => {
        expect(newAncestriesData.length).toBeGreaterThan(0);
        newAncestriesData.forEach(ancestry => {
            expect(ancestry).toHaveProperty('id');
            expect(ancestry).toHaveProperty('name');
            expect(ancestry).toHaveProperty('expandedTraitIds');
        });
    });

    it('should ensure all spells have required properties', () => {
        expect(allSpells.length).toBeGreaterThan(0);
        allSpells.forEach(spell => {
            expect(spell).toHaveProperty('name');
            expect(spell).toHaveProperty('school');
            expect(spell).toHaveProperty('cost');
            expect(spell).toHaveProperty('effects');
        });
    });

    it('should ensure all maneuvers have required properties', () => {
        expect(maneuvers.length).toBeGreaterThan(0);
        maneuvers.forEach(maneuver => {
            expect(maneuver).toHaveProperty('name');
            expect(maneuver).toHaveProperty('type');
            expect(maneuver).toHaveProperty('cost');
            expect(maneuver).toHaveProperty('description');
        });
    });

    it('should ensure all techniques have required properties', () => {
        expect(techniques.length).toBeGreaterThan(0);
        techniques.forEach(technique => {
            expect(technique).toHaveProperty('name');
            expect(technique).toHaveProperty('cost');
            expect(technique).toHaveProperty('description');
        });
    });

    it('should ensure all inventory items have required properties', () => {
        expect(allItems.length).toBeGreaterThan(0);
        allItems.forEach(item => {
            expect(item).toHaveProperty('itemType');
            expect(item).toHaveProperty('name');
        });
    });
});
```

## File: src/lib/stores/characterContext.reducer.spec.ts
```typescript
import { describe, test, expect } from 'vitest';
import type { CharacterInProgressStoreData } from './characterContext';

// Import the reducer function (we'll need to export it)
// For now, create a minimal test structure

describe('characterReducer', () => {
  test('UPDATE_SKILLS action stores native object', () => {
    const initialState: Partial<CharacterInProgressStoreData> = {
      skillsData: {}
    };

    const action = {
      type: 'UPDATE_SKILLS' as const,
      skillsData: { athletics: 2, stealth: 1 }
    };

    // Mock reducer behavior
    const result = { ...initialState, skillsData: action.skillsData };

    expect(result.skillsData).toEqual({ athletics: 2, stealth: 1 });
    expect(typeof result.skillsData).toBe('object');
  });

  test('SET_TRAITS action stores native array', () => {
    const initialState: Partial<CharacterInProgressStoreData> = {
      selectedTraitIds: []
    };

    const action = {
      type: 'SET_TRAITS' as const,
      selectedTraitIds: ['trait1', 'trait2']
    };

    const result = { ...initialState, selectedTraitIds: action.selectedTraitIds };

    expect(result.selectedTraitIds).toEqual(['trait1', 'trait2']);
    expect(Array.isArray(result.selectedTraitIds)).toBe(true);
  });

  test('UPDATE_SPELLS_AND_MANEUVERS action stores native arrays', () => {
    const initialState: Partial<CharacterInProgressStoreData> = {
      selectedSpells: [],
      selectedManeuvers: []
    };

    const action = {
      type: 'UPDATE_SPELLS_AND_MANEUVERS' as const,
      spells: ['spell1', 'spell2'],
      maneuvers: ['maneuver1']
    };

    const result = {
      ...initialState,
      selectedSpells: action.spells,
      selectedManeuvers: action.maneuvers
    };

    expect(result.selectedSpells).toEqual(['spell1', 'spell2']);
    expect(result.selectedManeuvers).toEqual(['maneuver1']);
    expect(Array.isArray(result.selectedSpells)).toBe(true);
    expect(Array.isArray(result.selectedManeuvers)).toBe(true);
  });
});
```

## File: src/lib/types/dataContracts.ts
```typescript
/**
 * Unified Data Contracts for Character System
 * 
 * This file establishes the single source of truth for character data schemas.
 * All components should use these types instead of legacy JSON string patterns.
 */

import type { EnhancedStatBreakdown } from './effectSystem';

// Re-export necessary types from existing files
export type { ManeuverData, SpellData, InventoryItemData } from '../../types/character';

export interface CharacterState {
  resources: {
    current: {
      currentHP: number;
      currentSP: number;
      currentMP: number;
      currentGritPoints: number;
      currentRestPoints: number;
      tempHP: number;
      actionPointsUsed: number;
      exhaustionLevel: number;
    };
  };
  ui: {
    manualDefenseOverrides: {
      PD?: number;
      AD?: number;
      PDR?: number;
    };
  };
  inventory: {
    items: any[]; // Will use proper InventoryItemData once imported
    currency: {
      gold: number;
      silver: number;
      copper: number;
    };
  };
  notes: {
    playerNotes: string;
  };
}

/**
 * The unified character schema - replaces CharacterSheetData
 * Uses 'final*' naming convention throughout for consistency
 */
export interface SavedCharacter {
  // Core Identity
  id: string;
  finalName: string;
  finalPlayerName?: string;
  level: number;
  
  // Classes & Ancestry
  classId: string;
  className: string;
  ancestry1Id?: string;
  ancestry1Name?: string;
  ancestry2Id?: string; 
  ancestry2Name?: string;
  
  // UNIFIED SCHEMA: Only 'final*' names used throughout
  finalMight: number;
  finalAgility: number;
  finalCharisma: number;
  finalIntelligence: number;
  
  // All calculated stats
  finalPrimeModifierValue: number;
  finalPrimeModifierAttribute: string;
  finalCombatMastery: number;
  finalSaveMight: number;
  finalSaveAgility: number;
  finalSaveCharisma: number;
  finalSaveIntelligence: number;
  finalHPMax: number;
  finalSPMax: number;
  finalMPMax: number;
  finalPD: number;
  finalAD: number;
  finalPDR: number;
  finalSaveDC: number;
  finalDeathThreshold: number;
  finalMoveSpeed: number;
  finalJumpDistance: number;
  finalRestPoints: number;
  finalGritPoints: number;
  finalInitiativeBonus: number;
  
  // TYPED DATA: No more JSON strings
  selectedTraitIds: string[];
  selectedFeatureChoices: Record<string, string>;
  skillsData: Record<string, number>;
  tradesData: Record<string, number>;
  languagesData: string[];
  spells: any[]; // Will use proper SpellData once imported
  maneuvers: any[]; // Will use proper ManeuverData once imported
  
  // Dynamic state as nested object
  characterState: CharacterState;
  
  // Calculation transparency
  breakdowns: Record<string, EnhancedStatBreakdown>;
  
  // Metadata
  createdAt: string;
  lastModified: string;
  completedAt: string;
  schemaVersion: string; // For migration tracking
}

/**
 * Legacy character interface for backwards compatibility during migration
 * This will be removed after migration is complete
 */
export interface LegacyCharacter {
  id: string;
  finalName: string;
  finalPlayerName?: string;
  finalLevel: number;
  
  // Legacy JSON string fields that need migration
  selectedTraitIds?: string; // JSON string
  selectedTraitsJson?: string; // Alternative JSON string
  selectedFeatureChoices?: string; // JSON string
  skillsJson?: string; // JSON string
  tradesJson?: string; // JSON string
  languagesJson?: string; // JSON string
  
  // Legacy duplicate fields that need removal
  currentHP?: number;
  currentSP?: number;
  currentMP?: number;
  currentGritPoints?: number;
  currentRestPoints?: number;
  tempHP?: number;
  actionPointsUsed?: number;
  exhaustionLevel?: number;
  manualPD?: number;
  manualAD?: number;
  manualPDR?: number;
  
  // Character state (may or may not exist)
  characterState?: CharacterState;
  
  // All other fields from SavedCharacter
  [key: string]: any;
}
```

## File: src/lib/types/effectSystem.ts
```typescript
/**
 * Enhanced Effect System Types
 * 
 * These types support the comprehensive UI enhancements by providing
 * detailed attribution, validation, and breakdown information.
 */

import type { Effect } from '../rulesdata/schemas/character.schema';

// Source attribution for effects
export interface EffectSource {
  type: 'trait' | 'class_feature' | 'choice' | 'base' | 'ancestry_default';
  id: string;
  name: string;
  description?: string;
  category?: string; // e.g., "Human Trait", "Barbarian Level 1"
}

// Effect with source attribution and resolution status
export interface AttributedEffect extends Effect {
  source: EffectSource;
  resolved: boolean; // Whether user choices are resolved
  resolvedValue?: any; // Final resolved value after choices
  dependsOnChoice?: string; // Which choice this effect depends on
}

// Detailed stat breakdown for tooltips
export interface EnhancedStatBreakdown {
  statName: string;
  base: number;
  effects: Array<{
    source: EffectSource;
    value: number;
    condition?: string;
    description: string;
    isActive: boolean; // Whether this effect is currently active
  }>;
  total: number;
  conditionalTotal?: number; // Total if all conditional effects were active
}

// Validation result for real-time feedback
export interface ValidationResult {
  isValid: boolean;
  errors: ValidationError[];
  warnings: ValidationWarning[];
  attributeLimits: Record<string, AttributeLimit>;
  masteryLimits: MasteryLimitStatus;
}

export interface ValidationError {
  type: 'attribute_limit' | 'points_exceeded' | 'required_choice' | 'mastery_limit';
  field: string;
  message: string;
  currentValue: number;
  maxValue: number;
}

export interface ValidationWarning {
  type: 'approaching_limit' | 'inefficient_choice' | 'missing_optional';
  field: string;
  message: string;
}

export interface AttributeLimit {
  current: number;
  base: number;
  traitBonuses: number;
  max: number;
  exceeded: boolean;
  canIncrease: boolean;
  canDecrease: boolean;
}

export interface MasteryLimitStatus {
  maxSkillMastery: number;
  maxTradeMastery: number;
  currentAdeptCount: number;
  maxAdeptCount: number;
  canSelectAdept: boolean;
}

// Unresolved choice for character creation UI
export interface UnresolvedChoice {
  traitId: string;
  traitName: string;
  effectIndex: number;
  effect: Effect;
  prompt: string;
  options: ChoiceOption[];
  isRequired: boolean;
}

export interface ChoiceOption {
  value: string;
  displayName: string;
  description?: string;
  isValid: boolean;
  validationMessage?: string;
  preview?: EffectPreview;
}

// Effect preview for showing impact of choices
export interface EffectPreview {
  type: 'attribute' | 'skill' | 'stat' | 'ability';
  target: string;
  currentValue: any;
  newValue: any;
  description: string;
}

// Comprehensive calculation result
export interface EnhancedCalculationResult {
  stats: {
    // Final calculated values
    finalMight: number;
    finalAgility: number;
    finalCharisma: number;
    finalIntelligence: number;
    finalHPMax: number;
    finalSPMax: number;
    finalMPMax: number;
    finalPD: number;
    finalAD: number;
    finalPDR: number;
    finalMoveSpeed: number;
    finalJumpDistance: number;
    finalDeathThreshold: number;
    finalSaveDC: number;
    finalInitiativeBonus: number;
    finalRestPoints: number;
    finalGritPoints: number;
  };
  
  // Detailed breakdowns for tooltips
  breakdowns: Record<string, EnhancedStatBreakdown>;
  
  // Abilities and features
  grantedAbilities: Array<{
    name: string;
    description: string;
    source: EffectSource;
    type: 'passive' | 'active' | 'resistance' | 'advantage';
    isConditional: boolean;
    condition?: string;
  }>;
  
  // Conditional modifiers
  conditionalModifiers: Array<{
    effect: AttributedEffect;
    condition: string;
    description: string;
    affectedStats: string[];
  }>;
  
  // Combat training
  combatTraining: Array<{
    type: string;
    source: EffectSource;
  }>;
  
  // Resistances and vulnerabilities
  resistances: Array<{
    type: string;
    value: string;
    source: EffectSource;
  }>;
  
  vulnerabilities: Array<{
    type: string;
    value: string;
    source: EffectSource;
  }>;
  
  // Senses and movement
  senses: Array<{
    type: string;
    range: number;
    source: EffectSource;
  }>;
  
  movements: Array<{
    type: string;
    speed: string;
    source: EffectSource;
  }>;
  
  // Validation results
  validation: ValidationResult;
  
  // Unresolved choices (for character creation)
  unresolvedChoices: UnresolvedChoice[];
  
  // Cache info
  cacheTimestamp: number;
  isFromCache: boolean;
}

// Trait choice storage format
export interface TraitChoiceStorage {
  [key: string]: string; // Format: "trait_id-effect_index" -> "chosen_value"
}

// Character build data for enhanced calculator
export interface EnhancedCharacterBuildData {
  // Core Info
  id: string;
  finalName: string;
  finalPlayerName?: string;
  level: number;

  // Attributes (from point buy)
  attribute_might: number;
  attribute_agility: number;
  attribute_charisma: number;
  attribute_intelligence: number;

  // Progression
  combatMastery: number;

  // Class & Ancestry
  classId: string;
  ancestry1Id?: string;
  ancestry2Id?: string;

  // Selections
  selectedTraitIds: string[]; // Array of trait IDs
  selectedTraitChoices: TraitChoiceStorage; // User choices for traits
  featureChoices: Record<string, any>; // User choices for class features
  
  // Skills/Trades/Languages
  skillsJson: string;
  tradesJson: string;
  languagesJson: string;
  
  // Manual Overrides
  manualPD?: number;
  manualAD?: number;
  manualPDR?: number;
  
  // Timestamps for caching
  lastModified: number;
}

// Hook result for character calculation
export interface CharacterCalculationHook {
  calculationResult: EnhancedCalculationResult;
  isLoading: boolean;
  error?: string;
  
  // Helper functions
  getStatBreakdown: (statName: string) => EnhancedStatBreakdown | undefined;
  getAttributeLimit: (attributeId: string) => AttributeLimit;
  canIncreaseAttribute: (attributeId: string) => boolean;
  canDecreaseAttribute: (attributeId: string) => boolean;
  getEffectPreview: (traitId: string, effectIndex: number, choice: string) => EffectPreview | undefined;
  
  // Validation helpers
  validateTraitChoice: (traitId: string, effectIndex: number, choice: string) => { isValid: boolean; message?: string };
  validateAttributeChange: (attributeId: string, newValue: number) => { isValid: boolean; message?: string };
  
  // Cache control
  invalidateCache: () => void;
  refreshCalculation: () => Promise<void>;
}
```

## File: src/lib/utils/defenseNotes.ts
```typescript
import { DefenseNote } from '../../types/defenseNotes';
import { getCharacterById, getAllSavedCharacters, saveAllCharacters } from './storageUtils';

// Get character from storage using centralized utility
const getCharacterFromStorage = (characterId: string) => {
	return getCharacterById(characterId);
};

// Save character back to storage using centralized utility
const saveCharacterToStorage = (characterId: string, updates: any) => {
	const savedCharacters = getAllSavedCharacters();
	const characterIndex = savedCharacters.findIndex((char: any) => char.id === characterId);

	if (characterIndex !== -1) {
		savedCharacters[characterIndex] = {
			...savedCharacters[characterIndex],
			...updates,
			lastModified: new Date().toISOString()
		};
		saveAllCharacters(savedCharacters);
	}
};

// Get all defense notes for a character
export const getDefenseNotes = (characterId: string): DefenseNote[] => {
	try {
		const character = getCharacterFromStorage(characterId);
		if (!character || !character.defenseNotes) return [];

		return character.defenseNotes.map((note: any) => ({
			...note,
			timestamp: new Date(note.timestamp)
		}));
	} catch (error) {
		console.error('Error loading defense notes:', error);
		return [];
	}
};

// Get notes for a specific defense field
export const getDefenseNotesForField = (
	characterId: string,
	field: 'manualPD' | 'manualPDR' | 'manualAD'
): DefenseNote[] => {
	const allNotes = getDefenseNotes(characterId);
	return allNotes
		.filter((note) => note.field === field)
		.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
};

// Add a new defense note
export const addDefenseNote = (
	characterId: string,
	field: 'manualPD' | 'manualPDR' | 'manualAD',
	oldValue: number,
	newValue: number,
	reason: string
): void => {
	try {
		const character = getCharacterFromStorage(characterId);
		if (!character) return;

		const newNote: DefenseNote = {
			id: `${characterId}_${field}_${Date.now()}`,
			timestamp: new Date(),
			reason,
			oldValue,
			newValue,
			field
		};

		const existingNotes = character.defenseNotes || [];
		const updatedNotes = [...existingNotes, newNote];

		saveCharacterToStorage(characterId, { defenseNotes: updatedNotes });

		console.log(`Defense note added for ${characterId} - ${field}: ${reason}`);
	} catch (error) {
		console.error('Error saving defense note:', error);
	}
};

// Remove all defense notes for a specific field (when reverting to auto)
export const clearDefenseNotesForField = (
	characterId: string,
	field: 'manualPD' | 'manualPDR' | 'manualAD'
): void => {
	try {
		const character = getCharacterFromStorage(characterId);
		if (!character || !character.defenseNotes) return;

		const filteredNotes = character.defenseNotes.filter(
			(note: DefenseNote) => note.field !== field
		);

		saveCharacterToStorage(characterId, { defenseNotes: filteredNotes });

		console.log(`Defense notes cleared for ${characterId} - ${field}`);
	} catch (error) {
		console.error('Error clearing defense notes:', error);
	}
};

// Get formatted tooltip text for a defense field
export const getDefenseTooltipWithNotes = (
	characterId: string,
	field: 'manualPD' | 'manualPDR' | 'manualAD',
	baseTooltip: string
): string => {
	const notes = getDefenseNotesForField(characterId, field);

	if (notes.length === 0) {
		return baseTooltip;
	}

	const recentNotes = notes.slice(0, 3); // Show last 3 changes
	const notesText = recentNotes
		.map((note) => {
			const date = note.timestamp.toLocaleDateString();
			const time = note.timestamp.toLocaleTimeString('en-US', {
				hour: '2-digit',
				minute: '2-digit'
			});
			return `• ${date} ${time}: ${note.oldValue} → ${note.newValue} (${note.reason})`;
		})
		.join('\n');

	const moreText = notes.length > 3 ? `\n... and ${notes.length - 3} more changes` : '';

	return `${baseTooltip}\n\nRecent Changes:\n${notesText}${moreText}`;
};

// Get defense field display name
export const getDefenseDisplayName = (field: 'manualPD' | 'manualPDR' | 'manualAD'): string => {
	switch (field) {
		case 'manualPD':
			return 'Precision Defense';
		case 'manualPDR':
			return 'Precision Damage Reduction';
		case 'manualAD':
			return 'Area Defense';
		default:
			return field;
	}
};
```

## File: src/lib/utils/traitCosts.ts
```typescript
/**
 * Simple trait cost calculation utility
 * Used by character context to calculate ancestry points spent
 */

import { traitsData } from '../rulesdata/_new_schema/traits';

/**
 * Calculate the total cost of selected traits
 * @param traitIds Array of trait IDs
 * @returns Total cost of all traits
 */
export function calculateTraitCosts(traitIds: string[]): number {
	return traitIds.reduce((total, traitId) => {
		const trait = traitsData.find(t => t.id === traitId);
		return total + (trait?.cost || 0);
	}, 0);
}
```

## File: src/lib/utils/weaponUtils.ts
```typescript
// weaponUtils.ts
// Utility functions for working with inventory weapons in the attack system

import { Weapon, WeaponType, WeaponProperty } from '../rulesdata/inventoryItems';

export interface ParsedDamage {
	amount: number;
	type: 'S' | 'P' | 'B' | 'S/P' | 'B/P';
	typeDisplay:
		| 'slashing'
		| 'piercing'
		| 'bludgeoning'
		| 'slashing/piercing'
		| 'bludgeoning/piercing';
}

/**
 * Parse damage string like "1 S", "2 B", "1 S/P" into structured data
 */
export function parseDamage(damageStr: string): ParsedDamage {
	const match = damageStr.trim().match(/^(\d+)\s+([SPBG\/]+)$/);
	if (!match) {
		// Fallback for malformed damage strings
		return { amount: 0, type: 'B', typeDisplay: 'bludgeoning' };
	}

	const amount = parseInt(match[1]);
	const type = match[2] as ParsedDamage['type'];

	let typeDisplay: ParsedDamage['typeDisplay'];
	switch (type) {
		case 'S':
			typeDisplay = 'slashing';
			break;
		case 'P':
			typeDisplay = 'piercing';
			break;
		case 'B':
			typeDisplay = 'bludgeoning';
			break;
		case 'S/P':
			typeDisplay = 'slashing/piercing';
			break;
		case 'B/P':
			typeDisplay = 'bludgeoning/piercing';
			break;
		default:
			typeDisplay = 'bludgeoning';
			break;
	}

	return { amount, type, typeDisplay };
}

/**
 * Get primary damage type for simple string representation
 */
export function getDamageType(damageStr: string): string {
	const parsed = parseDamage(damageStr);
	return parsed.typeDisplay;
}

/**
 * Check if weapon is ranged
 */
export function isRangedWeapon(weapon: Weapon): boolean {
	return weapon.type === WeaponType.Ranged;
}

/**
 * Get range from weapon properties (parse "Range (15/45)")
 */
export function getWeaponRange(weapon: Weapon): { short: number; long: number } | null {
	const rangeProp = weapon.properties.find((prop) => prop.includes('Range'));
	if (rangeProp) {
		const match = rangeProp.match(/Range \((\d+)\/(\d+)\)/);
		if (match) {
			return {
				short: parseInt(match[1]),
				long: parseInt(match[2])
			};
		}
	}
	return null;
}

/**
 * Get reload value from properties
 */
export function getReloadValue(weapon: Weapon): number | null {
	const reloadProp = weapon.properties.find((prop) => prop === 'Reload');
	// For now, return a default reload value if property exists
	// Could be enhanced to parse specific reload numbers if they exist in properties
	return reloadProp ? 1 : null;
}

/**
 * Calculate attack bonus based on weapon type and character stats
 */
export function calculateAttackBonus(
	weapon: Weapon,
	combatMastery: number,
	mightMod: number,
	agilityMod: number
): number {
	const statMod = isRangedWeapon(weapon) ? agilityMod : mightMod;
	return combatMastery + statMod;
}

/**
 * Calculate damage for different hit types
 */
export function calculateDamage(weapon: Weapon, hitType: 'normal' | 'heavy' | 'brutal'): string {
	const baseDamage = parseDamage(weapon.damage);
	const hasImpact = weapon.properties.includes('Impact');

	let totalDamage = baseDamage.amount;

	switch (hitType) {
		case 'heavy':
			totalDamage += 1;
			if (hasImpact) totalDamage += 1;
			break;
		case 'brutal':
			totalDamage += 2;
			if (hasImpact) totalDamage += 1;
			break;
		default:
			// normal hit, no bonus
			break;
	}

	return `${totalDamage} ${baseDamage.type}`;
}

/**
 * Get versatile damage options for versatile weapons
 */
export function getVersatileDamage(
	weapon: Weapon
): { oneHanded: string; twoHanded: string } | null {
	if (weapon.handedness === 'Versatile') {
		const baseDamage = parseDamage(weapon.damage);
		const twoHandedAmount = baseDamage.amount + 1;

		return {
			oneHanded: weapon.damage,
			twoHanded: `${twoHandedAmount} ${baseDamage.type}`
		};
	}
	return null;
}

/**
 * Get weapon features based on properties
 */
export function getWeaponFeatures(weapon: Weapon): string[] {
	const features: string[] = [];

	weapon.properties.forEach((prop) => {
		switch (prop) {
			case 'Impact':
				features.push('+1 damage on Heavy Hit');
				break;
			case 'Guard':
				features.push('Defensive bonus');
				break;
			case 'Reach':
				features.push('Extended reach');
				break;
			case 'Versatile':
				features.push('Can be used one or two-handed');
				break;
			case 'Heavy':
				features.push('Heavy weapon');
				break;
			case 'Two-Handed':
				features.push('Requires two hands');
				break;
			case 'Concealable':
				features.push('Easy to hide');
				break;
			case 'Silent':
				features.push('Silent attacks');
				break;
			case 'Unwieldy':
				features.push('Difficult to use effectively');
				break;
			default:
				if (prop.includes('Toss') || prop.includes('Thrown')) {
					features.push('Can be thrown');
				} else if (prop.includes('Range')) {
					const range = getWeaponRange(weapon);
					if (range) {
						features.push(`Range: ${range.short}/${range.long}`);
					}
				} else if (prop.includes('Capture')) {
					features.push('Can capture/entangle');
				} else if (prop === 'Ammo') {
					features.push('Requires ammunition');
				} else if (prop === 'Reload') {
					features.push('Must be reloaded');
				}
				break;
		}
	});

	return features;
}

/**
 * Create empty attack data for fallback cases
 */
export function createEmptyAttackData(weaponName?: string): any {
	return {
		id: '',
		weaponName: weaponName || 'unknown',
		name: weaponName || 'Unknown Weapon',
		attackBonus: 0,
		damage: '0 B',
		damageType: 'bludgeoning',
		critRange: '20',
		critDamage: '0 B',
		brutalDamage: '0 B',
		heavyHitEffect: ''
	};
}
```

## File: src/routes/api/_backup/character/[characterId]/+server.ts
```typescript
// src/routes/api/character/[characterId]/+server.ts

import { json } from '@sveltejs/kit';
import { PrismaClient } from '@prisma/client';
import type { RequestHandler } from './$types';

const prisma = new PrismaClient();

export const GET: RequestHandler = async ({ params }) => {
	const { characterId } = params;

	if (!characterId) {
		return json({ error: 'Character ID is required' }, { status: 400 });
	}

	try {
		// First try to get the finalized character sheet data
		const finalizedCharacter = await prisma.characterSheetData.findUnique({
			where: { id: characterId }
		});

		if (finalizedCharacter) {
			return json(finalizedCharacter);
		}

		// If not found in finalized data, check if it's in progress
		const progressCharacter = await prisma.characterInProgress.findUnique({
			where: { id: characterId }
		});

		if (!progressCharacter) {
			return json({ error: 'Character not found' }, { status: 404 });
		}

		// For now, return an error indicating the character isn't finalized
		// In the future, we could calculate stats on-the-fly from progress data
		return json(
			{
				error: 'Character creation not yet complete. Please finish character creation first.'
			},
			{ status: 400 }
		);
	} catch (error) {
		console.error('Error fetching character:', error);
		return json({ error: 'Internal server error' }, { status: 500 });
	}
};
```

## File: src/routes/api/_backup/character/progress/_backup_merge_stages_20250621/stageA+server.ts
```typescript
import { json, error } from '@sveltejs/kit';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Constants for validation (should ideally be shared or sourced from rules data)
const ATTRIBUTE_MIN = -2;
const ATTRIBUTE_MAX_L1 = 3;
const POINT_BUY_BUDGET = 12;

export async function POST({ request }) {
	try {
		const {
			characterId,
			finalName,
			attribute_might,
			attribute_agility,
			attribute_charisma,
			attribute_intelligence
		} = await request.json();

		// Backend Validation
		if (!finalName || typeof finalName !== 'string' || finalName.trim().length === 0) {
			return error(400, { message: 'Character name is required.' });
		}
		// Optional: Add length constraints or character restrictions for finalName

		const attributes = {
			might: attribute_might,
			agility: attribute_agility,
			charisma: attribute_charisma,
			intelligence: attribute_intelligence
		};

		// Validate attribute ranges
		for (const [name, value] of Object.entries(attributes)) {
			if (value < ATTRIBUTE_MIN || value > ATTRIBUTE_MAX_L1) {
				return error(400, { message: `Attribute ${name} is out of the allowed range (-2 to +3).` });
			}
		}

		// Validate total points spent
		const pointsSpent =
			attributes.might -
			ATTRIBUTE_MIN +
			(attributes.agility - ATTRIBUTE_MIN) +
			(attributes.charisma - ATTRIBUTE_MIN) +
			(attributes.intelligence - ATTRIBUTE_MIN);

		if (pointsSpent !== POINT_BUY_BUDGET) {
			return error(400, {
				message: `Total points allocated must be exactly ${POINT_BUY_BUDGET}. You allocated ${pointsSpent}.`
			});
		}

		let updatedCharacter;

		if (characterId) {
			// Update existing character progress
			updatedCharacter = await prisma.characterInProgress.update({
				where: { id: characterId },
				data: {
					finalName: finalName.trim(), // Save character name
					attribute_might,
					attribute_agility,
					attribute_charisma,
					attribute_intelligence,
					pointsSpent, // Store points spent for consistency, though backend validates
					level: 1, // Hardcoded to 1 for MVP
					combatMastery: 1, // Calculated as half level rounded up (1 for Level 1)
					selectedTraitIds: JSON.stringify([]), // Initialize selected traits for Stage B
					selectedFeatureChoices: JSON.stringify([]), // Initialize selected feature choices
					currentStep: 1 // Mark Stage A as complete
				}
			});
		} else {
			// Create new character progress (handles TD-002 for the first save)
			updatedCharacter = await prisma.characterInProgress.create({
				data: {
					finalName: finalName.trim(), // Save character name
					attribute_might,
					attribute_agility,
					attribute_charisma,
					attribute_intelligence,
					pointsSpent,
					level: 1, // Hardcoded to 1 for MVP
					combatMastery: 1, // Calculated as half level rounded up (1 for Level 1)
					selectedTraitIds: JSON.stringify([]), // Initialize selected traits for Stage B
					selectedFeatureChoices: JSON.stringify([]), // Initialize selected feature choices
					currentStep: 1 // Mark Stage A as complete
				}
			});
			// Note: The frontend will need to update its store with this new ID
		}

		// Return success response with the character ID
		return json({ success: true, characterId: updatedCharacter.id });
	} catch (e) {
		console.error('Backend error saving Stage A data:', e);
		// Handle Prisma errors or other exceptions
		if (e instanceof Error) {
			return error(500, { message: `Internal server error: ${e.message}` });
		}
		return error(500, { message: 'An unknown error occurred while saving attributes.' });
	} finally {
		await prisma.$disconnect();
	}
}
```

## File: src/routes/api/_backup/character/progress/_backup_merge_stages_20250621/stageB+server.ts
```typescript
import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { PrismaClient } from '@prisma/client';
import type { ITrait } from '$lib/rulesdata/types'; // Import ITrait type
import { ancestriesData as ancestries } from '$lib/rulesdata/ancestries';
import { traitsData as traits } from '$lib/rulesdata/traits';

const prisma = new PrismaClient();

export const POST: RequestHandler = async ({ request }) => {
	const data = await request.json();

	// Assuming data contains:
	// characterId: string;
	// selectedAncestries: string[]; // Array of ancestry IDs (max 2)
	// selectedTraits: string[]; // Array of trait IDs
	// attributes: { [key: string]: number }; // Attributes after potential reallocation

	// 1. Validate characterId exists and corresponds to an in-progress character
	if (!data.characterId) {
		return json({ success: false, message: 'Character ID is required.' }, { status: 400 });
	}

	// 2. Validate selected ancestries (max 2)
	if (
		!Array.isArray(data.selectedAncestries) ||
		data.selectedAncestries.length === 0 ||
		data.selectedAncestries.length > 2
	) {
		return json(
			{ success: false, message: 'You must select between 1 and 2 ancestries.' },
			{ status: 400 }
		);
	}
	// Validate ancestry IDs
	for (const ancestryId of data.selectedAncestries) {
		const validAncestry = ancestries.find((a) => a.id === ancestryId);
		if (!validAncestry) {
			return json(
				{ success: false, message: `Invalid ancestry ID: ${ancestryId}` },
				{ status: 400 }
			);
		}
	}

	// 3. Validate selected traits
	if (!Array.isArray(data.selectedTraits)) {
		return json({ success: false, message: 'Selected traits data is invalid.' }, { status: 400 });
	}
	// Validate trait IDs and rules
	if (data.selectedTraits.length > 0) {
		// Validate trait IDs exist
		for (const traitId of data.selectedTraits) {
			const validTrait = traits.find((t) => t.id === traitId);
			if (!validTrait) {
				return json({ success: false, message: `Invalid trait ID: ${traitId}` }, { status: 400 });
			}
		}

		// Get full trait objects
		const selectedTraitObjects: ITrait[] = data.selectedTraits
			.map((id: string) => traits.find((t) => t.id === id))
			.filter((t: ITrait | undefined): t is ITrait => t !== undefined);

		// Validate ancestry points budget
		const totalCost = selectedTraitObjects.reduce(
			(sum: number, trait: ITrait) => sum + trait.cost,
			0
		);
		if (totalCost !== 5) {
			return json(
				{ success: false, message: `Total ancestry points must equal 5, got: ${totalCost}` },
				{ status: 400 }
			);
		}

		// Validate minor trait limit
		const minorTraits = selectedTraitObjects.filter((t: ITrait) => t.isMinor);
		if (minorTraits.length > 1) {
			return json(
				{ success: false, message: `Maximum of 1 minor trait allowed, got: ${minorTraits.length}` },
				{ status: 400 }
			);
		}

		// Validate negative trait point gain limit
		const pointsFromNegative = selectedTraitObjects
			.filter((t: ITrait) => t.cost < 0)
			.reduce((sum: number, t: ITrait) => sum + Math.abs(t.cost), 0);
		if (pointsFromNegative > 2) {
			return json(
				{
					success: false,
					message: `Maximum of +2 points from negative traits allowed, got: ${pointsFromNegative}`
				},
				{ status: 400 }
			);
		}
	}

	// 4. Validate attribute values after trait bonuses (within -2 and +3)
	// Assuming data.attributes is an object like { attribute_might: 1, ... }
	if (!data.attributes || typeof data.attributes !== 'object') {
		return json(
			{ success: false, message: 'Attribute data is missing or invalid.' },
			{ status: 400 }
		);
	}
	// Corrected attribute name to match schema
	const attributeNames = [
		'attribute_might',
		'attribute_agility',
		'attribute_charisma',
		'attribute_intelligence'
	];
	for (const attrName of attributeNames) {
		const attrValue = data.attributes[attrName];
		if (typeof attrValue !== 'number' || attrValue < -2 || attrValue > 3) {
			return json(
				{
					success: false,
					message: `Invalid value for attribute ${attrName}: ${attrValue}. Must be between -2 and +3.`
				},
				{ status: 400 }
			);
		}
	}

	// 5. Validate total attribute points (should still be 12 from Stage A base -2)
	// This check assumes the attributes passed in `data.attributes` are the final values after reallocation.
	// The base value for each attribute is -2, so 4 attributes have a base total of -8.
	// The total points allocated in Stage A is 20 (from 12 points + 8 base).
	// If attributes were reallocated in the helper panel, the sum should still reflect the original points + base.
	// Sum of (attributeValue - baseValue) should equal total points allocated.
	const baseAttributeValue = -2;
	const expectedTotalPoints = 12; // Total points allocated in Stage A
	const actualTotalPoints = attributeNames.reduce(
		(sum, attrName) => sum + (data.attributes[attrName] - baseAttributeValue),
		0
	);

	if (actualTotalPoints !== expectedTotalPoints) {
		return json(
			{
				success: false,
				message: `Total attribute points mismatch. Expected ${expectedTotalPoints}, got ${actualTotalPoints}.`
			},
			{ status: 400 }
		);
	}

	try {
		// Fetch the existing character to ensure it's in the correct state (Stage A complete)
		const character = await prisma.characterInProgress.findUnique({
			where: { id: data.characterId },
			select: {
				currentStep: true
				// Select other fields if needed for validation against previous stage data
			}
		});

		if (!character) {
			return json({ success: false, message: 'Character not found.' }, { status: 404 });
		}

		// Optional: Validate that the character is currently at the correct step (Stage A complete)
		// if (character.currentStep !== 1) { // Check against integer 1 for Stage A
		//      return json({ success: false, message: `Character is not in the correct stage. Current stage: ${character.currentStep}` }, { status: 400 });
		// }

		// Update the CharacterInProgress table with Stage B data
		const updatedCharacter = await prisma.characterInProgress.update({
			where: { id: data.characterId },
			data: {
				ancestry1Id: data.selectedAncestries[0] || null, // Store first ancestry ID
				ancestry2Id: data.selectedAncestries[1] || null, // Store second ancestry ID (if exists)
				selectedTraitIds: JSON.stringify(data.selectedTraits), // Store trait IDs as JSON string
				// Update attributes if they were potentially modified in the helper panel
				attribute_might: data.attributes.attribute_might,
				attribute_agility: data.attributes.attribute_agility,
				attribute_charisma: data.attributes.attribute_charisma,
				attribute_intelligence: data.attributes.attribute_intelligence, // Corrected attribute name
				currentStep: 2 // Mark Stage B as complete (using integer 2)
			}
		});

		// Return success response
		return json({ success: true, character: updatedCharacter });
	} catch (error) {
		console.error('Error processing Stage B data:', error);
		// Return appropriate error response
		return json({ success: false, message: 'Failed to save Stage B data.' }, { status: 500 });
	}
};

// TODO: Consider implementing a GET handler to fetch existing Stage B data if needed for resuming progress
// export const GET: RequestHandler = async ({ url }) => {
//     const characterId = url.searchParams.get('characterId');
//     if (!characterId) {
//         return json({ success: false, message: 'Character ID is required.' }, { status: 400 });
//     }
//     try {
//         const character = await prisma.characterInProgress.findUnique({
//             where: { id: characterId },
//             select: {
//                 selectedAncestries: true,
//                 selectedTraits: true,
//                 // Select other relevant fields
//             },
//         });
//         if (!character) {
//             return json({ success: false, message: 'Character not found.' }, { status: 404 });
//         }
//         return json({ success: true, character });
//     } catch (error) {
//         console.error('Error fetching Stage B data:', error);
//         return json({ success: false, message: 'Failed to fetch Stage B data.' }, { status: 500 });
//     }
// };
```

## File: src/routes/api/_backup/character/progress/complete/+server.ts
```typescript
// src/routes/api/character/progress/complete/+server.ts

import { json } from '@sveltejs/kit';
import { PrismaClient } from '@prisma/client';
import { classesData } from '$lib/rulesdata/loaders/class.loader';
import { findClassByName, getLegacyChoiceId } from '$lib/rulesdata/loaders/class-features.loader';
import { traitsData } from '$lib/rulesdata/traits';
import { processTraitEffects } from '$lib/services/traitEffectProcessor';
import type { RequestHandler } from './$types';

const prisma = new PrismaClient();

function validateFeatureChoices(classId: string, selectedChoicesJson: string) {
	const classData = classesData.find((c) => c.id === classId);
	if (!classData) throw new Error(`Invalid class ID: ${classId}`);

	const choices = JSON.parse(selectedChoicesJson || '{}');

	// Use the new class features structure for validation
	const classFeatures = findClassByName(classData.name);
	if (!classFeatures) return; // No class features to validate

	// Get level 1 features that have choices
	const level1Features = classFeatures.coreFeatures.filter(feature => feature.levelGained === 1);
	
	level1Features.forEach((feature) => {
		if (feature.choices) {
			feature.choices.forEach((choice, choiceIndex) => {
				// Create the same legacy choice ID mapping used in the UI
				const choiceId = getLegacyChoiceId(classFeatures.className, feature.featureName, choiceIndex);
				
				if (choice.options && choice.options.length > 0) {
					const selectedValue = choices[choiceId];
					if (selectedValue === undefined) {
						throw new Error(`Missing required choice for ${classData.name}: ${choice.prompt}`);
					}
					
					// Validate the selected option(s)
					if (choice.count > 1) {
						// Multiple selections - should be a JSON array
						try {
							const selectedValues: string[] = JSON.parse(selectedValue);
							const validOptions = choice.options.map((o) => o.name);
							for (const value of selectedValues) {
								if (!validOptions.includes(value)) {
									throw new Error(`Invalid selected option for ${choiceId} in class ${classData.name}`);
								}
							}
							if (selectedValues.length !== choice.count) {
								throw new Error(`Must select exactly ${choice.count} options for ${choiceId} in class ${classData.name}`);
							}
						} catch (error) {
							throw new Error(`Invalid selection format for ${choiceId} in class ${classData.name}`);
						}
					} else {
						// Single selection
						const validOptions = choice.options.map((o) => o.name);
						if (!validOptions.includes(selectedValue)) {
							throw new Error(`Invalid selected option for ${choiceId} in class ${classData.name}`);
						}
					}
				}
			});
		}
	});
}

function validateAttributeCapsAfterTraits(
	attributes: any, 
	selectedTraitIdsJson: string, 
	ancestry1Id: string | null, 
	ancestry2Id: string | null
) {
	const selectedTraitIds = JSON.parse(selectedTraitIdsJson || '[]');
	
	// Use the same trait processing logic as the calculator
	const processedEffects = processTraitEffects(selectedTraitIds, ancestry1Id, ancestry2Id);

	// Apply attribute modifiers
	const finalAttributes = {
		attribute_might: attributes.attribute_might + processedEffects.attributeModifiers.might,
		attribute_agility: attributes.attribute_agility + processedEffects.attributeModifiers.agility,
		attribute_charisma: attributes.attribute_charisma + processedEffects.attributeModifiers.charisma,
		attribute_intelligence: attributes.attribute_intelligence + processedEffects.attributeModifiers.intelligence
	};

	const ATTRIBUTE_MAX_L1 = 3;
	for (const [attrName, finalValue] of Object.entries(finalAttributes)) {
		if (finalValue > ATTRIBUTE_MAX_L1) {
			throw new Error(
				`Final attribute ${attrName.replace('attribute_', '')} exceeds Level 1 cap (+3) after applying traits.`
			);
		}
	}
}

export const POST: RequestHandler = async ({ request }) => {
	try {
		const data = await request.json();

		// Basic validation
		if (
			!data.finalName ||
			typeof data.finalName !== 'string' ||
			data.finalName.trim().length === 0
		) {
			return json({ error: 'Character name is required.' }, { status: 400 });
		}

		// Validate attributes and point buy (Stage A)
		const attributes = {
			attribute_might: data.attribute_might,
			attribute_agility: data.attribute_agility,
			attribute_charisma: data.attribute_charisma,
			attribute_intelligence: data.attribute_intelligence
		};
		const totalPoints = Object.values(attributes).reduce(
			(sum, v) => sum + (typeof v === 'number' ? v : 0),
			0
		);
		if (totalPoints !== 0) {
			return json({ error: 'Attribute points must sum to 0 (point buy).' }, { status: 400 });
		}

		// Validate ancestry selections (Stage B)
		if (!data.ancestry1Id) {
			return json({ error: 'At least one ancestry must be selected.' }, { status: 400 });
		}
		if (data.ancestry2Id && data.ancestry1Id === data.ancestry2Id) {
			return json({ error: 'Cannot select the same ancestry twice.' }, { status: 400 });
		}

		// Validate selected trait IDs (Stage B)
		try {
			const selectedTraitIds = JSON.parse(data.selectedTraitIds || '[]');
			if (!Array.isArray(selectedTraitIds)) throw new Error();
			// Additional trait validation can be added here
		} catch {
			return json({ error: 'Invalid selectedTraitIds format.' }, { status: 400 });
		}

		// Validate class selection (Stage C)
		if (!data.classId || !classesData.find((c) => c.id === data.classId)) {
			return json({ error: 'A valid class must be selected.' }, { status: 400 });
		}

		// Validate feature choices (Stage C)
		try {
			validateFeatureChoices(data.classId, data.selectedFeatureChoices);
		} catch (err: any) {
			return json({ error: err.message }, { status: 400 });
		}

		// Cross-stage validation: attribute caps after traits
		try {
			validateAttributeCapsAfterTraits(attributes, data.selectedTraitIds, data.ancestry1Id, data.ancestry2Id);
		} catch (err: any) {
			return json({ error: err.message }, { status: 400 });
		}

		// Save to DB in a transaction
		const result = await prisma.$transaction(async (tx) => {
			// Upsert CharacterInProgress by id if provided, else create new
			let character;
			if (data.id) {
				character = await tx.characterInProgress.update({
					where: { id: data.id },
					data: {
						...data,
						updatedAt: new Date()
					}
				});
			} else {
				character = await tx.characterInProgress.create({
					data: {
						...data,
						createdAt: new Date(),
						updatedAt: new Date()
					}
				});
			}
			return character;
		});

		return json({ success: true, id: result.id });
	} catch (err: any) {
		return json({ error: err.message || 'Unknown error' }, { status: 500 });
	}
};
```

## File: src/routes/character-creation/components/TradesTab.tsx
```typescript
import React from 'react';
import { tradesData } from '../../../lib/rulesdata/trades';
import { knowledgeData } from '../../../lib/rulesdata/knowledge';
import type {
	BackgroundPointsData,
	PointConversions,
	ConversionActions,
	MasteryLimits,
	MasteryInfo
} from './BackgroundPointsManager';
import {
	getMasteryInfo,
	MASTERY_TABLE
} from './BackgroundPointsManager';
import {
	StyledTabContent,
	StyledSelectionGrid,
	StyledSelectionItem,
	StyledSelectionHeader,
	StyledSelectionName,
	StyledProficiencySelector,
	StyledProficiencyButton,
	StyledPointsRemaining
} from '../styles/Background.styles';

// Combine trades and knowledge for selection
const allTradesAndKnowledge = [...tradesData, ...knowledgeData];

interface TradesTabProps {
	currentTrades: Record<string, number>;
	currentSkills: Record<string, number>;
	pointsData: BackgroundPointsData;
	conversions: PointConversions;
	actions: ConversionActions;
	masteryLimits: MasteryLimits;
	onTradeChange: (tradeId: string, newLevel: number) => void;
}

const TradesTab: React.FC<TradesTabProps> = ({
	currentTrades,
	currentSkills,
	pointsData,
	conversions,
	actions,
	masteryLimits,
	onTradeChange
}) => {
	const canIncreaseProficiency = (
		pointCost: number,
		pointsUsed: number,
		availablePoints: number
	) => {
		return pointsUsed + pointCost <= availablePoints;
	};

	// Enhanced validation including mastery limits
	const canSelectMastery = (tradeId: string, targetLevel: number): boolean => {
		// Check mastery limit
		if (targetLevel > masteryLimits.maxTradeMastery) return false;
		
		// Check Level 1 special rule for Adept (level 2)
		if (targetLevel === 2) {
			const currentlyAdept = currentTrades[tradeId] === 2;
			if (!currentlyAdept && masteryLimits.level1Validation.adeptCount >= 1) {
				return false; // Already have one Adept skill/trade
			}
		}
		
		// Check point availability
		const pointCost = targetLevel - (currentTrades[tradeId] || 0);
		return canIncreaseProficiency(pointCost, pointsData.tradePointsUsed, pointsData.availableTradePoints);
	};

	// Helper function for consistent button styling
	const getButtonStyle = (enabled: boolean, variant: 'primary' | 'danger' = 'primary') => ({
		padding: '0.5rem 1rem',
		backgroundColor: enabled ? (variant === 'primary' ? '#3b82f6' : '#ef4444') : '#6b7280',
		color: 'white',
		border: 'none',
		borderRadius: '6px',
		fontSize: '0.875rem',
		fontWeight: '500',
		cursor: enabled ? 'pointer' : 'not-allowed',
		transition: 'all 0.2s ease',
		opacity: enabled ? 1 : 0.6,
		':hover': enabled
			? {
					backgroundColor: variant === 'primary' ? '#2563eb' : '#dc2626',
					transform: 'translateY(-1px)',
					boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)'
				}
			: {}
	});

	const hasConversions =
		conversions.skillToTradeConversions > 0 ||
		conversions.tradeToSkillConversions > 0 ||
		conversions.tradeToLanguageConversions > 0;

	return (
		<StyledTabContent>
			{/* Level 1 Validation Warning */}
			{!masteryLimits.level1Validation.valid && (
				<div style={{
					background: '#fee2e2',
					border: '1px solid #fecaca',
					color: '#991b1b',
					padding: '0.75rem',
					borderRadius: '0.5rem',
					marginBottom: '1rem'
				}}>
					⚠️ Level 1 characters can only have ONE Adept (level 2) skill or trade total.
					Currently: {masteryLimits.level1Validation.adeptCount} Adept selections.
				</div>
			)}
			
			{/* Mastery Limits Info */}
			<div style={{
				background: '#f3f4f6',
				border: '1px solid #d1d5db',
				padding: '0.5rem',
				borderRadius: '0.375rem',
				marginBottom: '1rem',
				fontSize: '0.875rem'
			}}>
				<strong>Mastery Limits:</strong> Max level {masteryLimits.maxTradeMastery} 
				({MASTERY_TABLE[masteryLimits.maxTradeMastery]?.name})
			</div>

			<StyledPointsRemaining>
				Trade Points: {pointsData.availableTradePoints - pointsData.tradePointsUsed} /{' '}
				{pointsData.availableTradePoints} remaining
				{hasConversions && (
					<div
						style={{
							fontSize: '0.9rem',
							color: '#6366f1',
							marginTop: '0.5rem',
							padding: '0.25rem 0.5rem',
							backgroundColor: '#6366f11a',
							borderRadius: '4px',
							border: '1px solid #6366f133'
						}}
					>
						Active conversions:{' '}
						{conversions.skillToTradeConversions > 0
							? `${conversions.skillToTradeConversions} skill → ${conversions.skillToTradeConversions * 2} trade`
							: ''}
						{conversions.skillToTradeConversions > 0 &&
						(conversions.tradeToSkillConversions > 0 || conversions.tradeToLanguageConversions > 0)
							? ', '
							: ''}
						{conversions.tradeToSkillConversions > 0
							? `${conversions.tradeToSkillConversions} trade → ${Math.floor(conversions.tradeToSkillConversions / 2)} skill`
							: ''}
						{conversions.tradeToSkillConversions > 0 && conversions.tradeToLanguageConversions > 0
							? ', '
							: ''}
						{conversions.tradeToLanguageConversions > 0
							? `${conversions.tradeToLanguageConversions} trade → ${conversions.tradeToLanguageConversions * 2} language`
							: ''}
					</div>
				)}
				<div
					style={{
						marginTop: '0.75rem',
						display: 'flex',
						gap: '0.5rem',
						flexWrap: 'wrap'
					}}
				>
					<button
						onClick={actions.convertTradeToSkill}
						disabled={pointsData.availableTradePoints - pointsData.tradePointsUsed < 2}
						style={getButtonStyle(
							pointsData.availableTradePoints - pointsData.tradePointsUsed >= 2
						)}
						onMouseEnter={(e) => {
							if (pointsData.availableTradePoints - pointsData.tradePointsUsed >= 2) {
								e.currentTarget.style.backgroundColor = '#2563eb';
								e.currentTarget.style.transform = 'translateY(-1px)';
								e.currentTarget.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
							}
						}}
						onMouseLeave={(e) => {
							if (pointsData.availableTradePoints - pointsData.tradePointsUsed >= 2) {
								e.currentTarget.style.backgroundColor = '#3b82f6';
								e.currentTarget.style.transform = 'translateY(0)';
								e.currentTarget.style.boxShadow = 'none';
							}
						}}
					>
						Convert 2 Trade → 1 Skill Point
					</button>
					<button
						onClick={actions.convertTradeToLanguage}
						disabled={pointsData.availableTradePoints - pointsData.tradePointsUsed < 1}
						style={getButtonStyle(
							pointsData.availableTradePoints - pointsData.tradePointsUsed >= 1
						)}
						onMouseEnter={(e) => {
							if (pointsData.availableTradePoints - pointsData.tradePointsUsed >= 1) {
								e.currentTarget.style.backgroundColor = '#2563eb';
								e.currentTarget.style.transform = 'translateY(-1px)';
								e.currentTarget.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
							}
						}}
						onMouseLeave={(e) => {
							if (pointsData.availableTradePoints - pointsData.tradePointsUsed >= 1) {
								e.currentTarget.style.backgroundColor = '#3b82f6';
								e.currentTarget.style.transform = 'translateY(0)';
								e.currentTarget.style.boxShadow = 'none';
							}
						}}
					>
						Convert 1 Trade → 2 Language Points
					</button>
					<button
						onClick={actions.resetConversions}
						disabled={!hasConversions}
						style={getButtonStyle(hasConversions, 'danger')}
						onMouseEnter={(e) => {
							if (hasConversions) {
								e.currentTarget.style.backgroundColor = '#dc2626';
								e.currentTarget.style.transform = 'translateY(-1px)';
								e.currentTarget.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
							}
						}}
						onMouseLeave={(e) => {
							if (hasConversions) {
								e.currentTarget.style.backgroundColor = '#ef4444';
								e.currentTarget.style.transform = 'translateY(0)';
								e.currentTarget.style.boxShadow = 'none';
							}
						}}
					>
						Reset Conversions
					</button>
				</div>
			</StyledPointsRemaining>
			<StyledSelectionGrid>
							{allTradesAndKnowledge.map((trade) => {
				const currentLevel = currentTrades[trade.id] || 0;
				const masteryInfo = getMasteryInfo(currentLevel, masteryLimits.maxTradeMastery);
				
				return (
					<StyledSelectionItem key={trade.id}>
						<StyledSelectionHeader>
							<StyledSelectionName>{trade.name}</StyledSelectionName>
							<div style={{ fontSize: '0.75rem', color: '#6b7280' }}>
								{masteryInfo.name} (+{masteryInfo.bonus}) • {trade.attributeAssociation}
							</div>
						</StyledSelectionHeader>
						<div style={{ fontSize: '0.9rem', color: '#cbd5e1', marginBottom: '0.5rem' }}>
							{trade.description}
						</div>
						{(trade as any).tools && (
							<div
								style={{
									fontSize: '0.8rem',
									color: '#fbbf24',
									marginBottom: '0.5rem',
									fontStyle: 'italic'
								}}
							>
								Tools: {(trade as any).tools}
							</div>
						)}
						<StyledProficiencySelector>
							{[0, 1, 2, 3, 4, 5].map((level) => {
								const masteryDisplay = getMasteryInfo(level, masteryLimits.maxTradeMastery);
								const canSelect = canSelectMastery(trade.id, level);
								
								return (
									<StyledProficiencyButton
										key={level}
										$active={currentLevel === level}
										$disabled={!canSelect && level !== currentLevel}
										title={`${masteryDisplay.name} (+${masteryDisplay.bonus})`}
										onClick={() => {
											if (canSelect || level === currentLevel) {
												onTradeChange(trade.id, level);
											}
										}}
									>
										{level}
									</StyledProficiencyButton>
								);
							})}
						</StyledProficiencySelector>
					</StyledSelectionItem>
				);
			})}
		</StyledSelectionGrid>
		</StyledTabContent>
	);
};

export default TradesTab;
```

## File: src/routes/character-creation/styles/AncestrySelector.styles.ts
```typescript
import styled from 'styled-components';

export const StyledContainer = styled.div`
	border: 2px solid #8b5cf6;
	padding: 1.5rem;
	border-radius: 12px;
	background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
	margin-top: 2rem;
	box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3);
`;

export const StyledTitle = styled.h2`
	margin-top: 0;
	color: #fbbf24;
	font-size: 1.3rem;
	font-weight: bold;
	text-align: center;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	letter-spacing: 1px;
	border-bottom: 2px solid #ef4444;
	padding-bottom: 0.5rem;
	margin-bottom: 1rem;
`;

export const StyledGrid = styled.div`
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
	gap: 1rem;
	margin-top: 1rem;
`;

export const StyledCard = styled.div<{ $selected: boolean }>`
	border: 2px solid #a855f7;
	padding: 1.5rem;
	border-radius: 10px;
	background: linear-gradient(145deg, #2d1b69 0%, #4c1d95 100%);
	cursor: pointer;
	transition: all 0.3s ease;
	text-align: left;
	box-shadow: 0 4px 15px rgba(168, 85, 247, 0.2);
	height: 200px;
	display: flex;
	flex-direction: column;
	overflow: hidden;
	position: relative;

	&:hover {
		transform: translateY(-2px);
		box-shadow: 0 8px 25px rgba(168, 85, 247, 0.4);
		border-color: #fbbf24;
	}

	${(props) =>
		props.$selected &&
		`
    border-color: #ef4444;
    background: linear-gradient(145deg, #991b1b 0%, #dc2626 100%);
    box-shadow: 0 8px 25px rgba(239, 68, 68, 0.5);
    transform: translateY(-2px);
  `}
`;

export const StyledCardHeader = styled.div`
	display: flex;
	align-items: center;
	gap: 1rem;
	margin-bottom: 1rem;
`;

export const StyledAncestryIcon = styled.div`
	font-size: 2rem;
	flex-shrink: 0;
	background: linear-gradient(145deg, #8b5cf6 0%, #a855f7 100%);
	border-radius: 50%;
	width: 50px;
	height: 50px;
	display: flex;
	align-items: center;
	justify-content: center;
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
`;

export const StyledCardTitle = styled.h3`
	margin: 0;
	color: #fbbf24;
	font-size: 1.4rem;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledCardDescription = styled.p`
	margin: 0;
	color: #e5e7eb;
	font-size: 0.9rem;
	line-height: 1.4;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	flex: 1;
	overflow: hidden;
	display: -webkit-box;
	-webkit-line-clamp: 3;
	-webkit-box-orient: vertical;
	position: relative;
`;

export const StyledCardFooter = styled.div`
	margin-top: 0.5rem;
	display: flex;
	justify-content: flex-end;
`;

export const StyledReadMore = styled.span`
	color: #fbbf24;
	font-size: 0.85rem;
	font-weight: bold;
	cursor: pointer;
	text-decoration: underline;
	padding: 0.5rem 0.75rem;
	border-radius: 4px;
	transition: all 0.2s ease;
	display: inline-block;

	&:hover {
		color: #f59e0b;
		background: rgba(251, 191, 36, 0.1);
	}

	&:active {
		transform: scale(0.95);
	}
`;

export const StyledTooltip = styled.div<{ $show: boolean }>`
	position: fixed;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	background: linear-gradient(145deg, #1e1b4b 0%, #312e81 100%);
	color: #e5e7eb;
	padding: 2rem;
	border-radius: 12px;
	border: 3px solid #8b5cf6;
	box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
	z-index: 2000;
	width: 90vw;
	max-width: 500px;
	max-height: 80vh;
	overflow-y: auto;
	font-size: 1rem;
	line-height: 1.6;
	opacity: ${(props) => (props.$show ? 1 : 0)};
	pointer-events: ${(props) => (props.$show ? 'auto' : 'none')};
	transition: opacity 0.3s ease;

	/* Custom scrollbar for popup */
	::-webkit-scrollbar {
		width: 8px;
	}

	::-webkit-scrollbar-track {
		background: #1e1b4b;
		border-radius: 4px;
	}

	::-webkit-scrollbar-thumb {
		background: #8b5cf6;
		border-radius: 4px;
	}

	::-webkit-scrollbar-thumb:hover {
		background: #a855f7;
	}
`;

export const StyledTooltipOverlay = styled.div<{ $show: boolean }>`
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background: rgba(0, 0, 0, 0.7);
	z-index: 1999;
	opacity: ${(props) => (props.$show ? 1 : 0)};
	pointer-events: ${(props) => (props.$show ? 'auto' : 'none')};
	transition: opacity 0.3s ease;
`;

export const StyledTooltipHeader = styled.div`
	display: flex;
	align-items: center;
	gap: 1rem;
	margin-bottom: 1.5rem;
	padding-bottom: 1rem;
	border-bottom: 2px solid #8b5cf6;
`;

export const StyledTooltipIcon = styled.div`
	font-size: 3rem;
	background: linear-gradient(145deg, #8b5cf6 0%, #a855f7 100%);
	border-radius: 50%;
	width: 70px;
	height: 70px;
	display: flex;
	align-items: center;
	justify-content: center;
	box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
`;

export const StyledTooltipTitle = styled.h3`
	margin: 0;
	color: #fbbf24;
	font-size: 1.8rem;
	font-weight: bold;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
`;

export const StyledTooltipContent = styled.p`
	margin: 0;
	color: #e5e7eb;
	font-size: 1.1rem;
	line-height: 1.6;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledCloseHint = styled.div`
	margin-top: 1.5rem;
	padding-top: 1rem;
	border-top: 1px solid #8b5cf6;
	text-align: center;
	color: #9ca3af;
	font-size: 0.9rem;
	font-style: italic;
`;
```

## File: src/routes/character-creation/styles/ClassFeatures.styles.ts
```typescript
import styled from 'styled-components';

export const StyledContainer = styled.div`
	border: 1px solid white;
	padding: 1.5rem;
	border-radius: 12px;
	background: transparent;
	margin-top: 2rem;
`;

export const StyledTitle = styled.h2`
	margin-top: 0;
	color: #fbbf24;
	font-size: 1.3rem;
	font-weight: bold;
	text-align: center;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	letter-spacing: 1px;
	border-bottom: 2px solid #ef4444;
	padding-bottom: 0.5rem;
	margin-bottom: 1rem;
`;

export const StyledSection = styled.div`
	margin-top: 1rem;
`;

export const StyledSectionTitle = styled.h3`
	margin: 0 0 1rem 0;
	color: #ef4444;
	font-size: 1.5rem;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	border-bottom: 2px solid #ef4444;
	padding-bottom: 0.5rem;
`;

export const StyledCard = styled.div`
	border: 2px solid #a855f7;
	padding: 1.5rem;
	border-radius: 10px;
	margin-bottom: 1rem;
	background: linear-gradient(145deg, #2d1b69 0%, #4c1d95 100%);
	box-shadow: 0 4px 15px rgba(168, 85, 247, 0.2);
`;

export const StyledCardTitle = styled.h4`
	margin: 0 0 0.5rem 0;
	color: #fbbf24;
	font-size: 1.3rem;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledCardDescription = styled.p`
	margin: 0;
	color: #e5e7eb;
	line-height: 1.4;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledChoiceOptions = styled.div`
	display: flex;
	flex-direction: column;
	gap: 0.5rem;
`;

export const StyledLabel = styled.label`
	display: flex;
	align-items: flex-start;
	gap: 0.8rem;
	cursor: pointer;
	color: #e5e7eb;
	font-size: 0.95rem;
	line-height: 1.4;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	padding: 0.5rem;
	border-radius: 5px;
	transition: all 0.2s ease;

	&:hover {
		color: #fbbf24;
		background: rgba(139, 92, 246, 0.1);
	}
`;

export const StyledRadio = styled.input`
	margin-top: 0.25rem;
	flex-shrink: 0;
	width: 18px;
	height: 18px;
	accent-color: #ef4444;
	cursor: pointer;
`;

export const StyledOptionDescription = styled.span`
	font-size: 0.9em;
	color: #9ca3af;
	margin-left: 0.5rem;
	font-style: italic;
`;

export const StyledNoSelection = styled.p`
	color: #9ca3af;
	font-style: italic;
	text-align: center;
	font-size: 1.1rem;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledBenefitsList = styled.div`
	margin-top: 1rem;
	padding-left: 0.5rem;
`;

export const StyledBenefit = styled.div`
	margin-bottom: 0.75rem;
	padding: 0.5rem;
	border-left: 3px solid #ef4444;
	background: rgba(139, 92, 246, 0.1);
	border-radius: 0 5px 5px 0;
`;

export const StyledBenefitName = styled.h5`
	margin: 0 0 0.25rem 0;
	color: #fbbf24;
	font-size: 1rem;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;

export const StyledBenefitDescription = styled.p`
	margin: 0;
	color: #e5e7eb;
	font-size: 0.9rem;
	line-height: 1.4;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
`;
```

## File: src/routes/character-creation/styles/ClassSelector.styles.ts
```typescript
import styled from 'styled-components';

export const StyledContainer = styled.div`
	border: none;
	padding: 1.5rem;
	border-radius: 12px;
	background: transparent;
	margin-top: 0;
`;

export const StyledTitle = styled.h2`
	margin-top: -1rem;
	color: #fbbf24;
	font-size: 2.4rem;
	font-weight: bold;
	text-align: center;
	letter-spacing: 1px;
	padding-bottom: 0.5rem;
	margin-bottom: 1rem;
`;

export const StyledGrid = styled.div`
	display: flex;
	flex-wrap: wrap;
	gap: 1rem;
	margin-top: 1rem;
`;

export const StyledCard = styled.button<{ $selected: boolean }>`
	border: 1px solid white;
	padding: 1.5rem;
	border-radius: 10px;
	background: transparent;
	cursor: pointer;
	transition: all 0s ease;
	flex: 1;
	min-width: 280px;
	max-width: 280px;
	height: 200px;
	text-align: left;
	position: relative;
	display: flex;
	flex-direction: column;
	overflow: hidden;

	&:hover {
		border-color: #fbbf24;
	}

	${(props) =>
		props.$selected &&
		`
    border: 2px solid #fbbf24;
  `}
`;

export const StyledCardHeader = styled.div`
	display: flex;
	align-items: center;
	gap: 1rem;
	margin-bottom: 1rem;
`;

export const StyledClassIcon = styled.div`
	font-size: 2rem;
	flex-shrink: 0;
	background: transparent;
	border: 1px solid white;
	border-radius: 50%;
	width: 50px;
	height: 50px;
	display: flex;
	align-items: center;
	justify-content: center;
`;

export const StyledCardTitle = styled.h3`
	margin: 0;
	color: #fbbf24;
	font-size: 1.4rem;
	font-weight: bold;
`;

export const StyledCardDescription = styled.p`
	margin: 0;
	color: #e5e7eb;
	font-size: 0.9rem;
	font-weight: 300;
	line-height: 1.3;
	flex: 1;
	overflow: hidden;
	display: -webkit-box;
	-webkit-line-clamp: 4;
	-webkit-box-orient: vertical;
	position: relative;
	word-wrap: break-word;
	hyphens: auto;
`;
```

## File: src/routes/character-creation/styles/SpellsAndManeuvers.styles.ts
```typescript
// Styled components for SpellsAndManeuvers component
import styled from 'styled-components';

export const StyledContainer = styled.div`
	padding: 2rem;
	min-height: 100vh;
	background: linear-gradient(135deg, #0f0f23 0%, #1e1b4b 50%, #312e81 100%);
`;

export const StyledTitle = styled.h1`
	margin-bottom: 2rem;
	color: #fbbf24;
	text-align: center;
	font-size: 2.2rem;
	font-weight: bold;
	text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7);
	letter-spacing: 2px;
`;

export const StyledSection = styled.div`
	margin-bottom: 2rem;
`;

export const StyledSectionTitle = styled.h2`
	color: #fbbf24;
	font-size: 1.5rem;
	margin-bottom: 1rem;
	text-align: center;
`;

export const StyledGrid = styled.div`
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
	gap: 1.5rem;
	margin-top: 1rem;
`;

export const StyledCard = styled.div<{ $selected: boolean }>`
	border: 2px solid ${props => props.$selected ? '#fbbf24' : '#8b5cf6'};
	border-radius: 12px;
	padding: 1.5rem;
	background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
	box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3);
	transition: all 0.3s ease;
	opacity: ${props => props.$selected ? 1 : 0.8};

	&:hover {
		transform: translateY(-4px);
		box-shadow: 0 12px 40px rgba(139, 92, 246, 0.4);
		border-color: ${props => props.$selected ? '#f59e0b' : '#fbbf24'};
		opacity: 1;
	}
`;

export const StyledCardHeader = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: flex-start;
	margin-bottom: 1rem;
	flex-wrap: wrap;
	gap: 0.5rem;
`;

export const StyledCardTitle = styled.h3`
	color: #fbbf24;
	font-size: 1.2rem;
	font-weight: bold;
	margin: 0;
	flex: 1;
`;

export const StyledCardType = styled.span`
	color: #a855f7;
	font-size: 0.8rem;
	font-weight: bold;
	text-transform: uppercase;
	letter-spacing: 1px;
	padding: 0.25rem 0.5rem;
	background: rgba(168, 85, 247, 0.2);
	border-radius: 4px;
`;

export const StyledCardCost = styled.span`
	color: #ef4444;
	font-size: 0.9rem;
	font-weight: bold;
	padding: 0.25rem 0.5rem;
	background: rgba(239, 68, 68, 0.2);
	border-radius: 4px;
`;

export const StyledCardDescription = styled.p`
	color: #e5e7eb;
	font-size: 0.9rem;
	line-height: 1.5;
	margin-bottom: 1rem;
`;

export const StyledCardActions = styled.div`
	display: flex;
	justify-content: flex-end;
`;

export const StyledButton = styled.button<{ $variant: 'primary' | 'danger' }>`
	padding: 0.5rem 1rem;
	border: 2px solid ${props => props.$variant === 'primary' ? '#fbbf24' : '#ef4444'};
	border-radius: 6px;
	background: ${props => props.$variant === 'primary' ? '#fbbf24' : 'transparent'};
	color: ${props => props.$variant === 'primary' ? '#1e1b4b' : '#ef4444'};
	cursor: pointer;
	transition: all 0.3s ease;
	font-size: 0.8rem;
	font-weight: bold;

	&:hover:not(:disabled) {
		background: ${props => props.$variant === 'primary' ? '#f59e0b' : '#ef4444'};
		color: ${props => props.$variant === 'primary' ? '#1e1b4b' : 'white'};
		transform: translateY(-1px);
	}

	&:disabled {
		opacity: 0.5;
		cursor: not-allowed;
	}
`;

export const StyledTabContainer = styled.div`
	display: flex;
	justify-content: center;
	margin-bottom: 2rem;
	gap: 1rem;
`;

export const StyledTabButton = styled.button<{ $active: boolean }>`
	padding: 0.75rem 1.5rem;
	border: 2px solid ${props => props.$active ? '#fbbf24' : '#8b5cf6'};
	border-radius: 8px;
	background: ${props => props.$active ? '#fbbf24' : 'transparent'};
	color: ${props => props.$active ? '#1e1b4b' : '#8b5cf6'};
	cursor: pointer;
	transition: all 0.3s ease;
	font-size: 1rem;
	font-weight: bold;

	&:hover {
		background: ${props => props.$active ? '#f59e0b' : '#8b5cf6'};
		color: ${props => props.$active ? '#1e1b4b' : 'white'};
		transform: translateY(-2px);
	}
`;

export const StyledEmptyState = styled.div`
	text-align: center;
	padding: 4rem 2rem;
	color: #6b7280;
`;

export const StyledEmptyTitle = styled.h3`
	color: #a855f7;
	font-size: 1.5rem;
	margin-bottom: 1rem;
`;

export const StyledEmptyText = styled.p`
	font-size: 1rem;
	line-height: 1.6;
`;

export const StyledSelectedCount = styled.div`
	text-align: center;
	color: #fbbf24;
	font-size: 1rem;
	font-weight: bold;
	margin-bottom: 1rem;
	padding: 0.5rem;
	background: rgba(251, 191, 36, 0.1);
	border-radius: 8px;
	border: 1px solid rgba(251, 191, 36, 0.3);
`;

export const StyledFilterContainer = styled.div`
	display: flex;
	justify-content: center;
	flex-wrap: wrap;
	gap: 0.5rem;
	margin-bottom: 1.5rem;
`;

export const StyledFilterButton = styled.button<{ $active: boolean }>`
	padding: 0.5rem 1rem;
	border: 2px solid ${props => props.$active ? '#fbbf24' : '#6b7280'};
	border-radius: 6px;
	background: ${props => props.$active ? '#fbbf24' : 'transparent'};
	color: ${props => props.$active ? '#1e1b4b' : '#6b7280'};
	cursor: pointer;
	transition: all 0.3s ease;
	font-size: 0.8rem;
	font-weight: bold;

	&:hover {
		background: ${props => props.$active ? '#f59e0b' : '#6b7280'};
		color: ${props => props.$active ? '#1e1b4b' : 'white'};
		transform: translateY(-1px);
	}
`;
```

## File: src/routes/character-creation/AncestryPointsCounter.tsx
```typescript
import { useCharacter } from '../../lib/stores/characterContext';
import { StyledContainer, StyledTitle, StyledDetails } from './styles/AncestryPointsCounter.styles';

function AncestryPointsCounter() {
	const { ancestryPointsRemaining, ancestryPointsSpent } = useCharacter();

	const isOverBudget = ancestryPointsRemaining < 0;

	return (
		<StyledContainer>
			<StyledTitle style={{ color: isOverBudget ? '#ff4444' : undefined }}>
				Ancestry Points: {ancestryPointsRemaining}/{ancestryPointsSpent + ancestryPointsRemaining}
			</StyledTitle>
			<StyledDetails>
				Spent: {ancestryPointsSpent} | Remaining: {ancestryPointsRemaining}
				{isOverBudget && <span style={{ color: '#ff4444' }}> (Over budget!)</span>}
			</StyledDetails>
		</StyledContainer>
	);
}

export default AncestryPointsCounter;
```

## File: src/routes/character-creation/AncestrySelector.tsx
```typescript
import { useState } from 'react';
import { useCharacter } from '../../lib/stores/characterContext';
import { ancestriesData } from '../../lib/rulesdata/ancestries';
import type { IAncestry } from '../../lib/rulesdata/types';
import {
	StyledContainer,
	StyledTitle,
	StyledGrid,
	StyledCard,
	StyledCardHeader,
	StyledAncestryIcon,
	StyledCardTitle,
	StyledCardDescription,
	StyledCardFooter,
	StyledReadMore,
	StyledTooltip,
	StyledTooltipOverlay,
	StyledTooltipHeader,
	StyledTooltipIcon,
	StyledTooltipTitle,
	StyledTooltipContent,
	StyledCloseHint
} from './styles/AncestrySelector.styles';

// Ancestry-specific icons using Unicode symbols and emojis
const ancestryIcons: { [key: string]: string } = {
	human: '👤',
	elf: '🧝‍♂️',
	dwarf: '🧔',
	halfling: '🧙‍♂️',
	dragonborn: '🐉',
	gnome: '🎭',
	'half-elf': '🧝‍♀️',
	'half-orc': '👹',
	tiefling: '😈',
	orc: '🗡️',
	goblin: '👺',
	kobold: '🦎',
	default: '🌟'
};

function AncestrySelector() {
	const { state, dispatch } = useCharacter();
	const [popupAncestry, setPopupAncestry] = useState<string | null>(null);

	const selectedAncestries: string[] = [];
	if (state.ancestry1Id) selectedAncestries.push(state.ancestry1Id);
	if (state.ancestry2Id) selectedAncestries.push(state.ancestry2Id);

	function handleSelectAncestry(ancestryId: string) {
		const isSelected = selectedAncestries.includes(ancestryId);

		if (isSelected) {
			// Deselect
			let newAncestry1Id = state.ancestry1Id;
			let newAncestry2Id = state.ancestry2Id;

			if (state.ancestry1Id === ancestryId) {
				newAncestry1Id = null;
			} else if (state.ancestry2Id === ancestryId) {
				newAncestry2Id = null;
			}

			dispatch({ type: 'SET_ANCESTRY', ancestry1Id: newAncestry1Id, ancestry2Id: newAncestry2Id });
		} else {
			// Select
			if (!state.ancestry1Id) {
				dispatch({ type: 'SET_ANCESTRY', ancestry1Id: ancestryId, ancestry2Id: state.ancestry2Id });
			} else if (!state.ancestry2Id) {
				dispatch({ type: 'SET_ANCESTRY', ancestry1Id: state.ancestry1Id, ancestry2Id: ancestryId });
			}
		}
	}

	function getAncestryIcon(ancestryId: string): string {
		return ancestryIcons[ancestryId.toLowerCase()] || ancestryIcons.default;
	}

	function truncateText(text: string, maxLength: number): string {
		if (text.length <= maxLength) return text;
		return text.substring(0, maxLength) + '...';
	}

	function needsReadMore(text: string, maxLength: number): boolean {
		return text.length > maxLength;
	}

	function openPopup(ancestryId: string) {
		setPopupAncestry(ancestryId);
	}

	function closePopup() {
		setPopupAncestry(null);
	}

	return (
		<StyledContainer>
			<StyledTitle>Choose Your Ancestry</StyledTitle>
			<StyledGrid>
				{ancestriesData.map((ancestry: IAncestry) => (
					<StyledCard
						key={ancestry.id}
						$selected={selectedAncestries.includes(ancestry.id)}
						onClick={() => handleSelectAncestry(ancestry.id)}
					>
						<StyledCardHeader>
							<StyledAncestryIcon>{getAncestryIcon(ancestry.id)}</StyledAncestryIcon>
							<StyledCardTitle>{ancestry.name}</StyledCardTitle>
						</StyledCardHeader>
						<StyledCardDescription>{truncateText(ancestry.description, 80)}</StyledCardDescription>
						{needsReadMore(ancestry.description, 80) && (
							<StyledCardFooter>
								<StyledReadMore
									onClick={(e) => {
										e.stopPropagation();
										openPopup(ancestry.id);
									}}
								>
									read more...
								</StyledReadMore>
							</StyledCardFooter>
						)}
					</StyledCard>
				))}
			</StyledGrid>

			{/* Popup overlay and content */}
			<StyledTooltipOverlay $show={popupAncestry !== null} onClick={closePopup} />
			{popupAncestry && (
				<StyledTooltip $show={popupAncestry !== null}>
					<StyledTooltipHeader>
						<StyledTooltipIcon>{getAncestryIcon(popupAncestry)}</StyledTooltipIcon>
						<StyledTooltipTitle>
							{ancestriesData.find((a) => a.id === popupAncestry)?.name}
						</StyledTooltipTitle>
					</StyledTooltipHeader>
					<StyledTooltipContent>
						{ancestriesData.find((a) => a.id === popupAncestry)?.description}
					</StyledTooltipContent>
					<StyledCloseHint>Click anywhere to close</StyledCloseHint>
				</StyledTooltip>
			)}
		</StyledContainer>
	);
}

export default AncestrySelector;
```

## File: src/routes/character-creation/AttributePointsCounter.tsx
```typescript
import React from 'react';
import { useCharacter } from '../../lib/stores/characterContext';
import { StyledContainer, StyledTitle, StyledDetails } from './styles/AncestryPointsCounter.styles';

function AttributePointsCounter() {
	const { attributePointsRemaining, attributePointsSpent, totalAttributePoints } = useCharacter();

	const isOverBudget = attributePointsRemaining < 0;

	return (
		<StyledContainer>
			<StyledTitle style={{ color: isOverBudget ? '#ff4444' : undefined }}>
				Attribute Points: {attributePointsRemaining}/{totalAttributePoints}
			</StyledTitle>
			<StyledDetails>
				Spent: {attributePointsSpent} | Remaining: {attributePointsRemaining}
				{isOverBudget && <span style={{ color: '#ff4444' }}> (Over budget!)</span>}
			</StyledDetails>
		</StyledContainer>
	);
}

export default AttributePointsCounter;
```

## File: src/routes/character-creation/LevelUp.tsx
```typescript
import React from 'react';
import type { SavedCharacter } from '../../lib/utils/characterEdit';

interface LevelUpProps {
	character: SavedCharacter;
	onComplete: (updatedCharacter: SavedCharacter) => void;
	onBack: () => void;
}

const LevelUp: React.FC<LevelUpProps> = ({ character, onComplete, onBack }) => {
	const handleLevelUp = () => {
		// For now, just increment the level and call onComplete
		const updatedCharacter = {
			...character,
			level: (character.level || 1) + 1
		};
		onComplete(updatedCharacter);
	};

	return (
		<div style={{ padding: '20px', color: '#e5e7eb' }}>
			<h2>Level Up: {character.name}</h2>
			<p>Current Level: {character.level || 1}</p>
			<p>New Level: {(character.level || 1) + 1}</p>
			
			<div style={{ marginTop: '20px' }}>
				<button 
					onClick={handleLevelUp}
					style={{
						backgroundColor: '#fbbf24',
						color: '#1e1b4b',
						padding: '10px 20px',
						border: 'none',
						borderRadius: '4px',
						marginRight: '10px',
						cursor: 'pointer'
					}}
				>
					Complete Level Up
				</button>
				<button 
					onClick={onBack}
					style={{
						backgroundColor: '#6b7280',
						color: '#ffffff',
						padding: '10px 20px',
						border: 'none',
						borderRadius: '4px',
						cursor: 'pointer'
					}}
				>
					Cancel
				</button>
			</div>
		</div>
	);
};

export default LevelUp;
```

## File: src/routes/character-sheet/components/AttackPopup.tsx
```typescript
import React from 'react';
import type { AttackData } from '../../../types';
import type { Weapon } from '../../../lib/rulesdata/inventoryItems';
import {
	getVersatileDamage,
	getWeaponRange,
	getWeaponFeatures,
	parseDamage
} from '../../../lib/utils/weaponUtils';
import {
	StyledFeaturePopupOverlay,
	StyledFeaturePopupContent,
	StyledFeaturePopupHeader,
	StyledFeaturePopupTitle,
	StyledFeaturePopupClose,
	StyledFeaturePopupDescription
} from '../styles/FeaturePopup';

interface AttackPopupProps {
	selectedAttack: {
		attack: AttackData;
		weapon: Weapon | null;
	} | null;
	onClose: () => void;
}

const AttackPopup: React.FC<AttackPopupProps> = ({ selectedAttack, onClose }) => {
	if (!selectedAttack) return null;

	return (
		<StyledFeaturePopupOverlay onClick={onClose}>
			<StyledFeaturePopupContent onClick={(e) => e.stopPropagation()}>
				<StyledFeaturePopupHeader>
					<StyledFeaturePopupTitle>
						{selectedAttack.weapon?.name || selectedAttack.attack.name || 'Unknown Weapon'}
					</StyledFeaturePopupTitle>
					<StyledFeaturePopupClose onClick={onClose}>×</StyledFeaturePopupClose>
				</StyledFeaturePopupHeader>
				<StyledFeaturePopupDescription>
					{selectedAttack.weapon ? (
						<>
							<strong>Weapon Type:</strong> {selectedAttack.weapon.type}
							<br />
							<strong>Handedness:</strong> {selectedAttack.weapon.handedness}
							<br />
							<strong>Style:</strong>{' '}
							{Array.isArray(selectedAttack.weapon.style)
								? selectedAttack.weapon.style.join('/')
								: selectedAttack.weapon.style}
							<br />
							<strong>Damage:</strong> {selectedAttack.weapon.damage}
							<br />
							{getVersatileDamage(selectedAttack.weapon) && (
								<>
									<strong>Versatile Damage:</strong>{' '}
									{getVersatileDamage(selectedAttack.weapon)?.twoHanded}
									<br />
								</>
							)}
							<strong>Damage Type:</strong>{' '}
							{parseDamage(selectedAttack.weapon.damage).typeDisplay}
							<br />
							{getWeaponRange(selectedAttack.weapon) && (
								<>
									<strong>Range:</strong> {getWeaponRange(selectedAttack.weapon)?.short}/
									{getWeaponRange(selectedAttack.weapon)?.long}
									<br />
								</>
							)}
							{selectedAttack.weapon.properties.includes('Ammo') && (
								<>
									<strong>Ammunition:</strong> Required
									<br />
								</>
							)}
							{selectedAttack.weapon.properties.includes('Reload') && (
								<>
									<strong>Reload:</strong> Required
									<br />
								</>
							)}
							<br />
							<strong>Damage Calculations:</strong>
							<br />• <strong>Hit:</strong> {selectedAttack.weapon.damage} + ability modifier
							<br />• <strong>Heavy Hit (+5):</strong> {selectedAttack.weapon.damage} + 1 +
							ability modifier
							<br />• <strong>Brutal Hit (+10):</strong> {selectedAttack.weapon.damage} + 2 +
							ability modifier
							<br />
							<br />
							{selectedAttack.weapon.properties.length > 0 && (
								<>
									<strong>Properties:</strong> {selectedAttack.weapon.properties.join(', ')}
									<br />
								</>
							)}
							{getWeaponFeatures(selectedAttack.weapon).length > 0 && (
								<>
									<strong>Features:</strong>{' '}
									{getWeaponFeatures(selectedAttack.weapon).join(', ')}
								</>
							)}
						</>
					) : (
						<>
							<strong>Custom Attack</strong>
							<br />
							<strong>Attack Bonus:</strong> +{selectedAttack.attack.attackBonus}
							<br />
							<strong>Damage:</strong> {selectedAttack.attack.damage}
							<br />
							<strong>Damage Type:</strong> {selectedAttack.attack.damageType}
							<br />
							{selectedAttack.attack.critRange && (
								<>
									<strong>Crit Range:</strong> {selectedAttack.attack.critRange}
									<br />
								</>
							)}
							{selectedAttack.attack.critDamage && (
								<>
									<strong>Crit Damage:</strong> {selectedAttack.attack.critDamage}
									<br />
								</>
							)}
							{selectedAttack.attack.brutalDamage && (
								<>
									<strong>Brutal Damage:</strong> {selectedAttack.attack.brutalDamage}
									<br />
								</>
							)}
							{selectedAttack.attack.heavyHitEffect && (
								<>
									<strong>Heavy Hit Effect:</strong> {selectedAttack.attack.heavyHitEffect}
								</>
							)}
						</>
					)}
				</StyledFeaturePopupDescription>
			</StyledFeaturePopupContent>
		</StyledFeaturePopupOverlay>
	);
};

export default AttackPopup;
```

## File: src/routes/character-sheet/components/AttributesSections.tsx
```typescript
import React from 'react';
import type { SkillData, TradeData, LanguageData, CharacterSheetData } from '../../../types';
import {
	StyledAttributesSectionsContainer,
	StyledPrimeSection,
	StyledPrimeBox,
	StyledPrimeLabel,
	StyledPrimeValue,
	StyledSkillRow,
	StyledSkillName,
	StyledAttributeSection,
	StyledAttributeHeader,
	StyledAttributeBox,
	StyledAttributeAbbr,
	StyledAttributeValue,
	StyledAttributeInfo,
	StyledAttributeName,
	StyledAttributeSave,
	StyledAttributeSkillRow,
	StyledKnowledgeTradesSection,
	StyledSectionTitle,
	StyledSectionSubtitle,
	StyledLanguageRow,
	StyledLanguageName,
	StyledFluencyControls,
	StyledFluencyBox,
	StyledFluencyLabel,
	StyledNoItemsMessage
} from '../styles/AttributesSections.styles';
import { StyledProficiencyDots, StyledDot } from '../styles/Skills';

interface SkillsByAttribute {
	prime: SkillData[];
	might: SkillData[];
	agility: SkillData[];
	charisma: SkillData[];
	intelligence: SkillData[];
}

interface AttributesSectionsProps {
	characterData: CharacterSheetData;
	skillsByAttribute: SkillsByAttribute;
	knowledge: TradeData[];
	trades: TradeData[];
	languages: LanguageData[];
}

const AttributesSections: React.FC<AttributesSectionsProps> = ({
	characterData,
	skillsByAttribute,
	knowledge,
	trades,
	languages
}) => {
	return (
		<StyledAttributesSectionsContainer>
			{/* Prime Modifier & Awareness */}
			<StyledPrimeSection>
				<StyledPrimeBox>
					<StyledPrimeLabel>Prime</StyledPrimeLabel>
					<StyledPrimeValue>
						{characterData.finalPrimeModifierAttribute} +{characterData.finalPrimeModifierValue}
					</StyledPrimeValue>
				</StyledPrimeBox>

				{/* Awareness (Prime skill) */}
				{skillsByAttribute.prime.map((skill) => (
					<StyledSkillRow key={skill.id}>
						<StyledSkillName>{skill.name.toUpperCase()}</StyledSkillName>
						<StyledProficiencyDots>
							{[1, 2, 3, 4, 5].map((level) => (
								<StyledDot key={level} $filled={level <= skill.proficiency} />
							))}
						</StyledProficiencyDots>
					</StyledSkillRow>
				))}
			</StyledPrimeSection>

			{/* Might Section */}
			<StyledAttributeSection>
				<StyledAttributeHeader>
					<StyledAttributeBox>
						<StyledAttributeAbbr>MIG</StyledAttributeAbbr>
						<StyledAttributeValue>{characterData.finalMight}</StyledAttributeValue>
					</StyledAttributeBox>
					<StyledAttributeInfo>
						<StyledAttributeName>MIGHT</StyledAttributeName>
						<StyledAttributeSave>SAVE +{characterData.finalSaveMight}</StyledAttributeSave>
					</StyledAttributeInfo>
				</StyledAttributeHeader>

				{/* Might Skills */}
				{skillsByAttribute.might.map((skill) => (
					<StyledAttributeSkillRow key={skill.id}>
						<StyledSkillName>{skill.name.toUpperCase()}</StyledSkillName>
						<StyledProficiencyDots>
							{[1, 2, 3, 4, 5].map((level) => (
								<StyledDot key={level} $filled={level <= skill.proficiency} />
							))}
						</StyledProficiencyDots>
					</StyledAttributeSkillRow>
				))}
			</StyledAttributeSection>

			{/* Agility Section */}
			<StyledAttributeSection>
				<StyledAttributeHeader>
					<StyledAttributeBox>
						<StyledAttributeAbbr>AGI</StyledAttributeAbbr>
						<StyledAttributeValue>{characterData.finalAgility}</StyledAttributeValue>
					</StyledAttributeBox>
					<StyledAttributeInfo>
						<StyledAttributeName>AGILITY</StyledAttributeName>
						<StyledAttributeSave>SAVE +{characterData.finalSaveAgility}</StyledAttributeSave>
					</StyledAttributeInfo>
				</StyledAttributeHeader>

				{/* Agility Skills */}
				{skillsByAttribute.agility.map((skill) => (
					<StyledAttributeSkillRow key={skill.id}>
						<StyledSkillName>{skill.name.toUpperCase()}</StyledSkillName>
						<StyledProficiencyDots>
							{[1, 2, 3, 4, 5].map((level) => (
								<StyledDot key={level} $filled={level <= skill.proficiency} />
							))}
						</StyledProficiencyDots>
					</StyledAttributeSkillRow>
				))}
			</StyledAttributeSection>

			{/* Charisma Section */}
			<StyledAttributeSection>
				<StyledAttributeHeader>
					<StyledAttributeBox>
						<StyledAttributeAbbr>CHA</StyledAttributeAbbr>
						<StyledAttributeValue>{characterData.finalCharisma}</StyledAttributeValue>
					</StyledAttributeBox>
					<StyledAttributeInfo>
						<StyledAttributeName>CHARISMA</StyledAttributeName>
						<StyledAttributeSave>SAVE +{characterData.finalSaveCharisma}</StyledAttributeSave>
					</StyledAttributeInfo>
				</StyledAttributeHeader>

				{/* Charisma Skills */}
				{skillsByAttribute.charisma.map((skill) => (
					<StyledAttributeSkillRow key={skill.id}>
						<StyledSkillName>{skill.name.toUpperCase()}</StyledSkillName>
						<StyledProficiencyDots>
							{[1, 2, 3, 4, 5].map((level) => (
								<StyledDot key={level} $filled={level <= skill.proficiency} />
							))}
						</StyledProficiencyDots>
					</StyledAttributeSkillRow>
				))}
			</StyledAttributeSection>

			{/* Intelligence Section */}
			<StyledAttributeSection>
				<StyledAttributeHeader>
					<StyledAttributeBox>
						<StyledAttributeAbbr>INT</StyledAttributeAbbr>
						<StyledAttributeValue>{characterData.finalIntelligence}</StyledAttributeValue>
					</StyledAttributeBox>
					<StyledAttributeInfo>
						<StyledAttributeName>INTELLIGENCE</StyledAttributeName>
						<StyledAttributeSave>SAVE +{characterData.finalSaveIntelligence}</StyledAttributeSave>
					</StyledAttributeInfo>
				</StyledAttributeHeader>

				{/* Intelligence Skills */}
				{skillsByAttribute.intelligence.map((skill) => (
					<StyledAttributeSkillRow key={skill.id}>
						<StyledSkillName>{skill.name.toUpperCase()}</StyledSkillName>
						<StyledProficiencyDots>
							{[1, 2, 3, 4, 5].map((level) => (
								<StyledDot key={level} $filled={level <= skill.proficiency} />
							))}
						</StyledProficiencyDots>
					</StyledAttributeSkillRow>
				))}
			</StyledAttributeSection>

			{/* Knowledge Section */}
			<StyledKnowledgeTradesSection>
				<StyledSectionTitle>KNOWLEDGE</StyledSectionTitle>
				<StyledSectionSubtitle>Intelligence-based knowledge trades</StyledSectionSubtitle>
				{knowledge.map((knowledgeItem) => (
					<StyledAttributeSkillRow key={knowledgeItem.id}>
						<StyledSkillName>{knowledgeItem.name.toUpperCase()}</StyledSkillName>
						<StyledProficiencyDots>
							{[1, 2, 3, 4, 5].map((level) => (
								<StyledDot key={level} $filled={level <= knowledgeItem.proficiency} />
							))}
						</StyledProficiencyDots>
					</StyledAttributeSkillRow>
				))}
			</StyledKnowledgeTradesSection>

			{/* Trades Section */}
			<StyledKnowledgeTradesSection>
				<StyledSectionTitle>TRADES</StyledSectionTitle>
				<StyledSectionSubtitle>Selected practical trades & crafts</StyledSectionSubtitle>
				{trades.length > 0 ? (
					trades.map((trade) => (
						<StyledAttributeSkillRow key={trade.id}>
							<StyledSkillName>{trade.name.toUpperCase()}</StyledSkillName>
							<StyledProficiencyDots>
								{[1, 2, 3, 4, 5].map((level) => (
									<StyledDot key={level} $filled={level <= trade.proficiency} />
								))}
							</StyledProficiencyDots>
						</StyledAttributeSkillRow>
					))
				) : (
					<StyledNoItemsMessage>No trades selected</StyledNoItemsMessage>
				)}
			</StyledKnowledgeTradesSection>

			{/* Languages Section */}
			<StyledKnowledgeTradesSection>
				<StyledSectionTitle>LANGUAGES</StyledSectionTitle>
				<StyledSectionSubtitle>
					LANGUAGE CHECK = d20 + Intelligence or Charisma
				</StyledSectionSubtitle>
				{languages.map((language) => (
					<StyledLanguageRow key={language.id}>
						<StyledLanguageName>{language.name.toUpperCase()}</StyledLanguageName>
						<StyledFluencyControls>
							<StyledFluencyBox active={language.fluency === 'limited'} />
							<StyledFluencyLabel>LIMITED</StyledFluencyLabel>
							<StyledFluencyBox active={language.fluency === 'fluent'} />
							<StyledFluencyLabel>FLUENT</StyledFluencyLabel>
						</StyledFluencyControls>
					</StyledLanguageRow>
				))}
			</StyledKnowledgeTradesSection>
		</StyledAttributesSectionsContainer>
	);
};

export default AttributesSections;
```

## File: src/routes/character-sheet/components/Currency.tsx
```typescript
import React from 'react';
import {
	CurrencyContainer,
	CurrencyTitle,
	CurrencyRow,
	CurrencyIconContainer,
	CurrencyIcon,
	CurrencyLabel,
	CurrencyInput
} from '../styles/Currency';
import { useCharacterInventory, useCharacterSheet } from '../hooks/CharacterSheetProvider';

interface CurrencyProps {
	// No props needed - uses context
}

const Currency: React.FC<CurrencyProps> = () => {
	const { updateCurrency } = useCharacterSheet();
	const inventory = useCharacterInventory();

	if (!inventory) {
		return (
			<div style={{ padding: '1rem', color: '#666', textAlign: 'center' }}>
				<p>Loading currency...</p>
			</div>
		);
	}

	const currency = inventory.currency;

	const handleInputChange = (currencyType: string, value: string) => {
		const numValue = parseInt(value) || 0;
		
		switch (currencyType) {
			case 'goldPieces':
				updateCurrency(numValue, currency.silver, currency.copper);
				break;
			case 'silverPieces':
				updateCurrency(currency.gold, numValue, currency.copper);
				break;
			case 'copperPieces':
				updateCurrency(currency.gold, currency.silver, numValue);
				break;
		}
	};

	const currencyTypes = [
		{
			key: 'goldPieces',
			label: 'Gold',
			color: '#ffd700',
			borderColor: '#b8860b',
			value: currency.gold || 0
		},
		{
			key: 'silverPieces',
			label: 'Silver',
			color: '#c0c0c0',
			borderColor: '#a0a0a0',
			value: currency.silver || 0
		},
		{
			key: 'copperPieces',
			label: 'Copper',
			color: '#b87333',
			borderColor: '#8b4513',
			value: currency.copper || 0
		}
	];

	return (
		<CurrencyContainer>
			<CurrencyTitle>CURRENCY</CurrencyTitle>

			{currencyTypes.map(({ key, label, color, borderColor, value }) => (
				<CurrencyRow key={key}>
					<CurrencyIconContainer>
						<CurrencyIcon color={color} borderColor={borderColor} />
						<CurrencyLabel>{label}</CurrencyLabel>
					</CurrencyIconContainer>
					<CurrencyInput
						type="number"
						min="0"
						value={value}
						onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
							handleInputChange(key, e.target.value)
						}
					/>
				</CurrencyRow>
			))}
		</CurrencyContainer>
	);
};

export default Currency;
```

## File: src/routes/character-sheet/components/DiceRoller.tsx
```typescript
import React, { useState } from 'react';
import { StyledDiceRollerContainer } from '../styles/DiceRoller';
import {
	StyledDiceContainer,
	StyledDiceIcon,
	StyledDiceControls,
	StyledModeButton,
	StyledAddDiceSection,
	StyledDiceTypeButton,
	StyledRollButton,
	StyledResultsDisplay,
	StyledDiceResult,
	StyledTotalResult,
	StyledDiceHistory,
	StyledCollapseButton,
	StyledDiceList,
	StyledDiceItem,
	StyledRemoveDiceButton
} from '../styles/DiceRoller';

type DiceType = 'd4' | 'd6' | 'd8' | 'd10' | 'd12' | 'd20';
type RollMode = 'normal' | 'advantage' | 'disadvantage' | 'no-d20';

interface DiceRollResult {
	type: DiceType;
	value: number;
	isMax: boolean;
	isMin: boolean;
	id: string;
	isChosen?: boolean; // For advantage/disadvantage tracking
	isCriticalSuccess?: boolean;
	isCriticalFail?: boolean;
}

interface AdditionalDice {
	type: DiceType;
	count: number;
}

interface DiceRollerProps {
	onRoll?: (results: DiceRollResult[], total: number, rollMode: RollMode) => void;
}

const DiceRoller: React.FC<DiceRollerProps> = ({ onRoll }) => {
	const [rollMode, setRollMode] = useState<RollMode>('normal');
	const [advantageCount, setAdvantageCount] = useState<number>(2);
	const [disadvantageCount, setDisadvantageCount] = useState<number>(2);
	const [additionalDice, setAdditionalDice] = useState<AdditionalDice[]>([]);
	const [isRolling, setIsRolling] = useState(false);
	const [lastResults, setLastResults] = useState<DiceRollResult[]>([]);
	const [total, setTotal] = useState<number | null>(null);
	const [isExpanded, setIsExpanded] = useState(false);
	const [rollHistory, setRollHistory] = useState<{ results: DiceRollResult[]; total: number; mode: RollMode; timestamp: Date }[]>([]);

	const rollDice = (sides: number): number => {
		return Math.floor(Math.random() * sides) + 1;
	};

	const getDiceMax = (type: DiceType): number => {
		const sideMap: Record<DiceType, number> = {
			'd4': 4,
			'd6': 6,
			'd8': 8,
			'd10': 10,
			'd12': 12,
			'd20': 20
		};
		return sideMap[type];
	};

	const getDiceIcon = (type: DiceType): string => {
		// Using dice symbols
		const iconMap: Record<DiceType, string> = {
			'd4': '⚃',
			'd6': '⚅',
			'd8': '🎲',
			'd10': '🎯',
			'd12': '⭐',
			'd20': '🔥'
		};
		return iconMap[type];
	};

	const addDice = (type: DiceType) => {
		setAdditionalDice(prev => {
			const existing = prev.find(d => d.type === type);
			if (existing) {
				return prev.map(d => 
					d.type === type ? { ...d, count: d.count + 1 } : d
				);
			} else {
				return [...prev, { type, count: 1 }];
			}
		});
	};

	const removeDice = (type: DiceType) => {
		setAdditionalDice(prev => {
			const existing = prev.find(d => d.type === type);
			if (existing && existing.count > 1) {
				return prev.map(d => 
					d.type === type ? { ...d, count: d.count - 1 } : d
				);
			} else {
				return prev.filter(d => d.type !== type);
			}
		});
	};

	const handleRoll = async () => {
		if (isRolling) return;

		setIsRolling(true);
		
		// Simulate rolling animation duration
		await new Promise(resolve => setTimeout(resolve, 1200));
		
		const results: DiceRollResult[] = [];

		// Only roll D20 if not in 'no-d20' mode
		if (rollMode !== 'no-d20') {
			// Roll main d20(s)
			const d20Results: number[] = [];
			let rollCount = 1;
			
			// Determine how many D20s to roll based on mode
			if (rollMode === 'advantage') {
				rollCount = advantageCount;
			} else if (rollMode === 'disadvantage') {
				rollCount = disadvantageCount;
			}
			
			for (let i = 0; i < rollCount; i++) {
				d20Results.push(rollDice(20));
			}

			if (rollMode === 'normal') {
				// Single D20 roll
				const value = d20Results[0];
				results.push({
					type: 'd20',
					value,
					isMax: value === 20,
					isMin: value === 1,
					isCriticalSuccess: value === 20,
					isCriticalFail: value === 1,
					isChosen: true,
					id: `d20-main-${Date.now()}`
				});
			} else {
				// Advantage/Disadvantage - show all dice, choose best/worst
				const chosenValue = rollMode === 'advantage' ? Math.max(...d20Results) : Math.min(...d20Results);
				
				d20Results.forEach((value, index) => {
					const isChosen = value === chosenValue && (index === d20Results.indexOf(chosenValue));
					results.push({
						type: 'd20',
						value,
						isMax: value === 20,
						isMin: value === 1,
						isCriticalSuccess: value === 20 && isChosen,
						isCriticalFail: value === 1 && isChosen,
						isChosen,
						id: `d20-${rollMode}-${index}-${Date.now()}`
					});
				});
			}
		}

		// Roll additional dice
		additionalDice.forEach(({ type, count }) => {
			const maxValue = getDiceMax(type);
			for (let i = 0; i < count; i++) {
				const value = rollDice(maxValue);
				results.push({
					type,
					value,
					isMax: value === maxValue,
					isMin: value === 1,
					id: `${type}-${i}-${Date.now()}`
				});
			}
		});

		const totalValue = results.reduce((sum, result) => {
			// For D20s in advantage/disadvantage, only count the chosen one
			if (result.type === 'd20' && (rollMode === 'advantage' || rollMode === 'disadvantage')) {
				return sum + (result.isChosen ? result.value : 0);
			}
			// For all other dice, count normally
			return sum + result.value;
		}, 0);

		setLastResults(results);
		setTotal(totalValue);
		setIsRolling(false);

		// Add to history
		setRollHistory(prev => [
			{ results, total: totalValue, mode: rollMode, timestamp: new Date() },
			...prev.slice(0, 9) // Keep last 10 rolls
		]);

		// Call callback if provided
		onRoll?.(results, totalValue, rollMode);
	};

	const clearDice = () => {
		setAdditionalDice([]);
	};

	return (
		<StyledDiceRollerContainer $isExpanded={isExpanded}>
			<StyledCollapseButton 
				onClick={() => setIsExpanded(!isExpanded)}
				$isExpanded={isExpanded}
			>
				🎲
			</StyledCollapseButton>

			{isExpanded && (
				<>
					{/* Roll Mode Controls */}
					<StyledDiceControls>
						<div className="section-label">
							Roll Mode
						</div>
						<div style={{ display: 'flex', gap: '0.25rem', flexWrap: 'wrap' }}>
							<StyledModeButton
								$active={rollMode === 'normal'}
								onClick={() => setRollMode('normal')}
							>
								Normal
							</StyledModeButton>
							<StyledModeButton
								$active={rollMode === 'advantage'}
								onClick={() => setRollMode('advantage')}
							>
								Advantage
							</StyledModeButton>
							<StyledModeButton
								$active={rollMode === 'disadvantage'}
								onClick={() => setRollMode('disadvantage')}
							>
								Disadvantage
							</StyledModeButton>
							<StyledModeButton
								$active={rollMode === 'no-d20'}
								onClick={() => setRollMode('no-d20')}
							>
								No D20
							</StyledModeButton>
						</div>
						
						{/* Advantage/Disadvantage Count Controls */}
						{(rollMode === 'advantage' || rollMode === 'disadvantage') && (
							<div style={{ 
								marginTop: '0.5rem',
								display: 'flex', 
								alignItems: 'center', 
								gap: '0.5rem',
								fontSize: '0.8rem',
								color: '#ffd700'
							}}>
								<span style={{ textShadow: '1px 1px 2px rgba(0, 0, 0, 0.8)' }}>
									{rollMode === 'advantage' ? 'Advantage' : 'Disadvantage'} Count:
								</span>
								<button
									onClick={() => {
										if (rollMode === 'advantage') {
											setAdvantageCount(Math.max(2, advantageCount - 1));
										} else {
											setDisadvantageCount(Math.max(2, disadvantageCount - 1));
										}
									}}
									style={{
										width: '20px',
										height: '20px',
										background: '#8b4513',
										color: 'white',
										border: '1px solid #654321',
										borderRadius: '3px',
										cursor: 'pointer',
										fontSize: '0.8rem',
										display: 'flex',
										alignItems: 'center',
										justifyContent: 'center'
									}}
								>
									−
								</button>
								<span style={{ 
									minWidth: '20px', 
									textAlign: 'center',
									fontWeight: 'bold',
									textShadow: '1px 1px 2px rgba(0, 0, 0, 0.8)'
								}}>
									{rollMode === 'advantage' ? advantageCount : disadvantageCount}
								</span>
								<button
									onClick={() => {
										if (rollMode === 'advantage') {
											setAdvantageCount(Math.min(4, advantageCount + 1));
										} else {
											setDisadvantageCount(Math.min(3, disadvantageCount + 1));
										}
									}}
									style={{
										width: '20px',
										height: '20px',
										background: '#8b4513',
										color: 'white',
										border: '1px solid #654321',
										borderRadius: '3px',
										cursor: 'pointer',
										fontSize: '0.8rem',
										display: 'flex',
										alignItems: 'center',
										justifyContent: 'center'
									}}
								>
									+
								</button>
								<span style={{ 
									fontSize: '0.7rem', 
									color: 'rgba(255, 255, 255, 0.8)',
									marginLeft: '0.25rem'
								}}>
									(Roll {rollMode === 'advantage' ? advantageCount : disadvantageCount} dice, take {rollMode === 'advantage' ? 'highest' : 'lowest'})
								</span>
							</div>
						)}
					</StyledDiceControls>

					{/* Additional Dice Section */}
					<StyledAddDiceSection>
						<div className="section-label">
							Add Dice
						</div>
						<div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '0.25rem', marginBottom: '0.5rem' }}>
							{(['d4', 'd6', 'd8', 'd10', 'd12'] as DiceType[]).map(type => (
								<StyledDiceTypeButton
									key={type}
									onClick={() => addDice(type)}
								>
									{type.toUpperCase()}
								</StyledDiceTypeButton>
							))}
						</div>
					</StyledAddDiceSection>

					{/* Current Dice Display */}
					{additionalDice.length > 0 && (
						<StyledDiceList>
							<div className="section-label">
								Current Dice
							</div>
							{additionalDice.map(({ type, count }) => (
								<StyledDiceItem key={type}>
									<span>{count}x {type.toUpperCase()}</span>
									<StyledRemoveDiceButton onClick={() => removeDice(type)}>
										×
									</StyledRemoveDiceButton>
								</StyledDiceItem>
							))}
							<button
								onClick={clearDice}
								style={{
									fontSize: '0.7rem',
									padding: '0.2rem 0.4rem',
									background: '#d32f2f',
									color: 'white',
									border: 'none',
									borderRadius: '3px',
									cursor: 'pointer',
									marginTop: '0.25rem'
								}}
							>
								Clear All
							</button>
						</StyledDiceList>
					)}

					{/* Main Dice Display */}
					<StyledDiceContainer>
						{rollMode !== 'no-d20' && (
							<>
								<StyledDiceIcon $isRolling={isRolling} $type="d20">
									{isRolling ? '🌪️' : '🔥'}
								</StyledDiceIcon>
								{rollMode !== 'normal' && (
									<div style={{ fontSize: '0.7rem', color: '#ffd700', textAlign: 'center', marginTop: '0.25rem', textShadow: '1px 1px 2px rgba(0, 0, 0, 0.8)' }}>
										{rollMode === 'advantage' && `${advantageCount}x ADVANTAGE`}
										{rollMode === 'disadvantage' && `${disadvantageCount}x DISADVANTAGE`}
									</div>
								)}
							</>
						)}
						{rollMode === 'no-d20' && additionalDice.length === 0 && (
							<div style={{ fontSize: '0.8rem', color: '#ffd700', textAlign: 'center', padding: '1rem', textShadow: '1px 1px 2px rgba(0, 0, 0, 0.8)' }}>
								Add dice to roll!
							</div>
						)}
						{additionalDice.map(({ type, count }) => (
							<div key={type} style={{ display: 'flex', alignItems: 'center', gap: '0.25rem', marginTop: '0.25rem' }}>
								{Array.from({ length: count }).map((_, index) => (
									<StyledDiceIcon key={index} $isRolling={isRolling} $type={type} $size="small">
										{isRolling ? '💫' : getDiceIcon(type)}
									</StyledDiceIcon>
								))}
							</div>
						))}
					</StyledDiceContainer>

					{/* Roll Button */}
					<StyledRollButton
						onClick={handleRoll}
						disabled={isRolling || (rollMode === 'no-d20' && additionalDice.length === 0)}
						$isRolling={isRolling}
					>
						{isRolling ? 'Rolling...' : 'ROLL DICE'}
					</StyledRollButton>

					{/* Results Display */}
					{total !== null && !isRolling && (
						<StyledResultsDisplay>
							<StyledTotalResult $isHighRoll={total >= 15}>
								Total: {total}
								{lastResults.some(r => r.isCriticalSuccess && r.isChosen !== false) && ' 🌟'}
								{lastResults.some(r => r.isCriticalFail && r.isChosen !== false) && ' 💀'}
							</StyledTotalResult>
							<div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.25rem', marginTop: '0.5rem' }}>
								{lastResults.map((result) => (
									<StyledDiceResult
										key={result.id}
										$isMax={result.isMax}
										$isMin={result.isMin}
										$isChosen={result.isChosen}
										$isCriticalSuccess={result.isCriticalSuccess}
										$isCriticalFail={result.isCriticalFail}
									>
										{result.type.toUpperCase()}: {result.value}
									</StyledDiceResult>
								))}
							</div>
						</StyledResultsDisplay>
					)}

					{/* Roll History */}
					{rollHistory.length > 0 && (
						<StyledDiceHistory>
							<div className="section-label">
								Recent Rolls
							</div>
							{rollHistory.slice(0, 3).map((roll, index) => (
								<div key={index} style={{ fontSize: '0.7rem', color: 'rgba(255, 255, 255, 0.9)', marginBottom: '0.1rem' }}>
									{roll.mode !== 'normal' && `${roll.mode} `}Total: {roll.total}
								</div>
							))}
						</StyledDiceHistory>
					)}
				</>
			)}
		</StyledDiceRollerContainer>
	);
};

export default DiceRoller;
```

## File: src/routes/character-sheet/components/EnhancedFeatures.tsx
```typescript
/**
 * Enhanced Features Display with Source Attribution
 * 
 * This component displays character abilities organized by type
 * with clear source attribution and categorization.
 */

import React from 'react';
import styled from '@emotion/styled';
import type { EnhancedCalculationResult } from '../../../lib/types/effectSystem';

// Styled components
const FeaturesContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
`;

const SectionHeader = styled.h3`
  margin: 0 0 1rem 0;
  color: #1f2937;
  font-size: 1.1rem;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding-bottom: 0.5rem;
  border-bottom: 2px solid #e5e7eb;
`;

const FeatureCard = styled.div`
  background-color: #ffffff;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  padding: 1rem;
  margin-bottom: 0.75rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  transition: all 0.2s ease;

  &:hover {
    border-color: #d1d5db;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }
`;

const FeatureHeader = styled.div`
  display: flex;
  justify-content: between;
  align-items: flex-start;
  margin-bottom: 0.5rem;
`;

const FeatureName = styled.h4`
  margin: 0;
  color: #1f2937;
  font-size: 1rem;
  font-weight: 600;
  flex: 1;
`;

const FeatureType = styled.span<{ $type: 'passive' | 'active' | 'resistance' | 'advantage' }>`
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-size: 0.75rem;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.025em;
  
  ${props => {
    switch (props.$type) {
      case 'passive':
        return `
          background-color: #dbeafe;
          color: #1e40af;
        `;
      case 'active':
        return `
          background-color: #dcfce7;
          color: #166534;
        `;
      case 'resistance':
        return `
          background-color: #fed7d7;
          color: #9b2c2c;
        `;
      case 'advantage':
        return `
          background-color: #fef3c7;
          color: #92400e;
        `;
      default:
        return `
          background-color: #f3f4f6;
          color: #374151;
        `;
    }
  }}
`;

const FeatureDescription = styled.p`
  margin: 0.5rem 0;
  color: #4b5563;
  font-size: 0.875rem;
  line-height: 1.4;
`;

const FeatureSource = styled.div`
  display: flex;
  justify-content: between;
  align-items: center;
  margin-top: 0.75rem;
  padding-top: 0.5rem;
  border-top: 1px solid #f3f4f6;
  font-size: 0.75rem;
  color: #6b7280;
`;

const SourceBadge = styled.span<{ $sourceType: string }>`
  padding: 0.125rem 0.375rem;
  border-radius: 4px;
  font-weight: 500;
  
  ${props => {
    switch (props.$sourceType) {
      case 'ancestry_default':
        return `
          background-color: #fef3c7;
          color: #92400e;
        `;
      case 'trait':
        return `
          background-color: #e0e7ff;
          color: #3730a3;
        `;
      case 'class_feature':
        return `
          background-color: #dcfce7;
          color: #166534;
        `;
      case 'choice':
        return `
          background-color: #fce7f3;
          color: #9d174d;
        `;
      default:
        return `
          background-color: #f3f4f6;
          color: #374151;
        `;
    }
  }}
`;

const ConditionalTag = styled.span`
  padding: 0.125rem 0.375rem;
  background-color: #fbbf24;
  color: #78350f;
  border-radius: 4px;
  font-size: 0.7rem;
  font-weight: 500;
  margin-left: 0.5rem;
`;

const ConditionalSection = styled.div`
  margin-top: 1.5rem;
  padding: 1rem;
  background-color: #fffbeb;
  border: 1px solid #fed7aa;
  border-radius: 8px;
`;

const ConditionalHeader = styled.h4`
  margin: 0 0 0.75rem 0;
  color: #92400e;
  font-size: 0.9rem;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  
  &:before {
    content: '⚠️';
  }
`;

const ConditionalItem = styled.div`
  display: flex;
  justify-content: between;
  align-items: center;
  padding: 0.5rem;
  background-color: #ffffff;
  border: 1px solid #fed7aa;
  border-radius: 4px;
  margin-bottom: 0.5rem;
  font-size: 0.875rem;
  
  &:last-child {
    margin-bottom: 0;
  }
`;

const ConditionTag = styled.span`
  padding: 0.25rem 0.5rem;
  background-color: #f59e0b;
  color: #ffffff;
  border-radius: 4px;
  font-size: 0.75rem;
  font-weight: 500;
  text-transform: lowercase;
`;

interface EnhancedFeaturesProps {
  calculationResult: EnhancedCalculationResult;
}

const EnhancedFeatures: React.FC<EnhancedFeaturesProps> = ({ calculationResult }) => {
  // Group abilities by type
  const passiveAbilities = calculationResult.grantedAbilities.filter(
    ability => ability.type === 'passive' && !ability.isConditional
  );
  
  const activeAbilities = calculationResult.grantedAbilities.filter(
    ability => ability.type === 'active' && !ability.isConditional
  );
  
  const resistances = calculationResult.grantedAbilities.filter(
    ability => ability.type === 'resistance'
  );
  
  const advantages = calculationResult.grantedAbilities.filter(
    ability => ability.type === 'advantage'
  );
  
  // Helper function to get icon for section
  const getSectionIcon = (type: string) => {
    switch (type) {
      case 'passive': return '🛡️';
      case 'active': return '⚡';
      case 'resistance': return '🛡️';
      case 'advantage': return '🎯';
      default: return '✨';
    }
  };
  
  // Helper function to format source category
  const formatSourceCategory = (category?: string) => {
    if (!category) return '';
    return category.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
  };
  
  return (
    <FeaturesContainer>
      {/* Passive Abilities */}
      {passiveAbilities.length > 0 && (
        <div>
          <SectionHeader>
            {getSectionIcon('passive')} Passive Abilities
          </SectionHeader>
          {passiveAbilities.map((ability, index) => (
            <FeatureCard key={`passive-${index}`}>
              <FeatureHeader>
                <FeatureName>{ability.name}</FeatureName>
                <FeatureType $type="passive">Passive</FeatureType>
              </FeatureHeader>
              
              <FeatureDescription>{ability.description}</FeatureDescription>
              
              <FeatureSource>
                <span>
                  Source: <strong>{ability.source.name}</strong>
                  {ability.source.category && ` • ${formatSourceCategory(ability.source.category)}`}
                </span>
                <SourceBadge $sourceType={ability.source.type}>
                  {ability.source.type.replace('_', ' ')}
                </SourceBadge>
              </FeatureSource>
            </FeatureCard>
          ))}
        </div>
      )}
      
      {/* Active Abilities */}
      {activeAbilities.length > 0 && (
        <div>
          <SectionHeader>
            {getSectionIcon('active')} Active Abilities
          </SectionHeader>
          {activeAbilities.map((ability, index) => (
            <FeatureCard key={`active-${index}`}>
              <FeatureHeader>
                <FeatureName>{ability.name}</FeatureName>
                <FeatureType $type="active">Active</FeatureType>
              </FeatureHeader>
              
              <FeatureDescription>{ability.description}</FeatureDescription>
              
              <FeatureSource>
                <span>
                  Source: <strong>{ability.source.name}</strong>
                  {ability.source.category && ` • ${formatSourceCategory(ability.source.category)}`}
                </span>
                <SourceBadge $sourceType={ability.source.type}>
                  {ability.source.type.replace('_', ' ')}
                </SourceBadge>
              </FeatureSource>
            </FeatureCard>
          ))}
        </div>
      )}
      
      {/* Resistances */}
      {(resistances.length > 0 || calculationResult.resistances.length > 0) && (
        <div>
          <SectionHeader>
            {getSectionIcon('resistance')} Resistances & Immunities
          </SectionHeader>
          {resistances.map((ability, index) => (
            <FeatureCard key={`resistance-${index}`}>
              <FeatureHeader>
                <FeatureName>{ability.name}</FeatureName>
                <FeatureType $type="resistance">Resistance</FeatureType>
              </FeatureHeader>
              
              <FeatureDescription>{ability.description}</FeatureDescription>
              
              <FeatureSource>
                <span>
                  Source: <strong>{ability.source.name}</strong>
                  {ability.source.category && ` • ${formatSourceCategory(ability.source.category)}`}
                </span>
                <SourceBadge $sourceType={ability.source.type}>
                  {ability.source.type.replace('_', ' ')}
                </SourceBadge>
              </FeatureSource>
            </FeatureCard>
          ))}
          
          {/* Direct resistances from effects */}
          {calculationResult.resistances.map((resistance, index) => (
            <FeatureCard key={`direct-resistance-${index}`}>
              <FeatureHeader>
                <FeatureName>{resistance.type} Resistance</FeatureName>
                <FeatureType $type="resistance">Resistance</FeatureType>
              </FeatureHeader>
              
              <FeatureDescription>
                Resistance ({resistance.value}) to {resistance.type} damage
              </FeatureDescription>
              
              <FeatureSource>
                <span>
                  Source: <strong>{resistance.source.name}</strong>
                  {resistance.source.category && ` • ${formatSourceCategory(resistance.source.category)}`}
                </span>
                <SourceBadge $sourceType={resistance.source.type}>
                  {resistance.source.type.replace('_', ' ')}
                </SourceBadge>
              </FeatureSource>
            </FeatureCard>
          ))}
        </div>
      )}
      
      {/* Advantages */}
      {advantages.length > 0 && (
        <div>
          <SectionHeader>
            {getSectionIcon('advantage')} Advantages & Bonuses
          </SectionHeader>
          {advantages.map((ability, index) => (
            <FeatureCard key={`advantage-${index}`}>
              <FeatureHeader>
                <FeatureName>{ability.name}</FeatureName>
                <FeatureType $type="advantage">Advantage</FeatureType>
              </FeatureHeader>
              
              <FeatureDescription>{ability.description}</FeatureDescription>
              
              <FeatureSource>
                <span>
                  Source: <strong>{ability.source.name}</strong>
                  {ability.source.category && ` • ${formatSourceCategory(ability.source.category)}`}
                </span>
                <SourceBadge $sourceType={ability.source.type}>
                  {ability.source.type.replace('_', ' ')}
                </SourceBadge>
              </FeatureSource>
            </FeatureCard>
          ))}
        </div>
      )}
      
      {/* Conditional Modifiers */}
      {calculationResult.conditionalModifiers.length > 0 && (
        <ConditionalSection>
          <ConditionalHeader>Conditional Bonuses</ConditionalHeader>
          {calculationResult.conditionalModifiers.map((modifier, index) => (
            <ConditionalItem key={`conditional-${index}`}>
              <span>{modifier.description}</span>
              <ConditionTag>{modifier.condition.replace('_', ' ')}</ConditionTag>
            </ConditionalItem>
          ))}
        </ConditionalSection>
      )}
    </FeaturesContainer>
  );
};

export default EnhancedFeatures;
```

## File: src/routes/character-sheet/components/EnhancedStatTooltips.tsx
```typescript
/**
 * Enhanced Stat Tooltips with Effect Attribution
 * 
 * This component creates detailed tooltips that show exactly where
 * each stat bonus comes from, replacing the simplified version.
 */

import React from 'react';
import type { EnhancedStatBreakdown } from '../../../lib/types/effectSystem';
import type { CharacterSheetData } from '../../../types/character';

const tooltipStyles = {
  margin: '8px 0 0 0',
  fontFamily: 'monospace',
  fontSize: '0.75rem',
  lineHeight: '1.2',
  whiteSpace: 'pre-line' as const
};

const conditionalStyle = {
  marginTop: '8px',
  padding: '4px 8px',
  backgroundColor: 'rgba(59, 130, 246, 0.1)',
  borderLeft: '3px solid #3b82f6',
  fontSize: '0.7rem',
  fontStyle: 'italic' as const
};

/**
 * Create enhanced tooltip with detailed breakdown
 */
export function createEnhancedTooltip(
  statName: string,
  breakdown: EnhancedStatBreakdown
): React.ReactNode {
  const formatBreakdown = () => {
    const lines: string[] = [];
    
    // Main total
    lines.push(breakdown.total.toString());
    lines.push('');
    
    // Base value
    lines.push(`├─ Base: ${breakdown.base}`);
    
    // Effect breakdown
    breakdown.effects.forEach((effect, index) => {
      const isLast = index === breakdown.effects.length - 1;
      const prefix = isLast ? '└─' : '├─';
      const sign = effect.value >= 0 ? '+' : '';
      lines.push(`${prefix} ${effect.source.name}: ${sign}${effect.value}`);
    });
    
    return lines.join('\n');
  };

  const conditionalEffects = breakdown.effects.filter(effect => effect.condition);
  
  return (
    <div>
      <strong>{breakdown.statName}</strong>
      <pre style={tooltipStyles}>
        {formatBreakdown()}
      </pre>
      
      {/* Show conditional effects separately */}
      {conditionalEffects.length > 0 && (
        <div style={conditionalStyle}>
          <strong>Conditional Bonuses:</strong><br />
          {conditionalEffects.map((effect, index) => (
            <span key={index}>
              • {effect.description}<br />
            </span>
          ))}
        </div>
      )}
      
      {/* Show potential total if conditionals were active */}
      {breakdown.conditionalTotal && breakdown.conditionalTotal !== breakdown.total && (
        <div style={{ ...conditionalStyle, backgroundColor: 'rgba(34, 197, 94, 0.1)', borderLeftColor: '#22c55e' }}>
          <strong>Maximum Potential:</strong> {breakdown.conditionalTotal} (if all conditions met)
        </div>
      )}
    </div>
  );
}

/**
 * Enhanced HP tooltip with detailed sources
 */
export const createEnhancedHPTooltip = (
  characterData: CharacterSheetData,
  breakdown?: EnhancedStatBreakdown
): React.ReactNode => {
  if (breakdown) {
    return createEnhancedTooltip('Hit Points', breakdown);
  }
  
  // Fallback to simple calculation if breakdown not available
  const mightBonus = characterData.finalMight || 0;
  const simpleBreakdown: EnhancedStatBreakdown = {
    statName: 'Hit Points',
    base: mightBonus,
    effects: [
      {
        source: { type: 'class_feature', id: 'class_hp', name: 'Class HP', category: 'Base' },
        value: characterData.finalHPMax - mightBonus,
        description: `Class base: +${characterData.finalHPMax - mightBonus}`,
        isActive: true
      }
    ],
    total: characterData.finalHPMax
  };
  
  return createEnhancedTooltip('Hit Points', simpleBreakdown);
};

/**
 * Enhanced Speed tooltip with movement details
 */
export const createEnhancedSpeedTooltip = (
  characterData: CharacterSheetData,
  breakdown?: EnhancedStatBreakdown
): React.ReactNode => {
  if (breakdown) {
    return createEnhancedTooltip('Movement Speed', breakdown);
  }
  
  // Fallback calculation
  const simpleBreakdown: EnhancedStatBreakdown = {
    statName: 'Movement Speed',
    base: 5, // DC20 base speed
    effects: [
      {
        source: { type: 'class_feature', id: 'speed_bonus', name: 'Modifiers', category: 'Various' },
        value: characterData.finalMoveSpeed - 5,
        description: `Speed modifiers: ${characterData.finalMoveSpeed - 5 > 0 ? '+' : ''}${characterData.finalMoveSpeed - 5}`,
        isActive: true
      }
    ],
    total: characterData.finalMoveSpeed
  };
  
  return createEnhancedTooltip('Movement Speed', simpleBreakdown);
};

/**
 * Enhanced Defense tooltip (PD/AD) with formula breakdown
 */
export const createEnhancedDefenseTooltip = (
  defenseName: 'PD' | 'AD',
  characterData: CharacterSheetData,
  breakdown?: EnhancedStatBreakdown
): React.ReactNode => {
  if (breakdown) {
    return createEnhancedTooltip(defenseName === 'PD' ? 'Precision Defense' : 'Area Defense', breakdown);
  }
  
  // Fallback calculation with DC20 formula
  const combatMastery = 1; // Would get from character data
  let baseFormula, baseValue;
  
  if (defenseName === 'PD') {
    baseFormula = '8 + CM + AGI + INT';
    baseValue = 8 + combatMastery + (characterData.finalAgility || 0) + (characterData.finalIntelligence || 0);
  } else {
    baseFormula = '8 + CM + MIG + CHA';
    baseValue = 8 + combatMastery + (characterData.finalMight || 0) + (characterData.finalCharisma || 0);
  }
  
  const finalValue = defenseName === 'PD' ? characterData.finalPD : characterData.finalAD;
  const modifiers = finalValue - baseValue;
  
  const simpleBreakdown: EnhancedStatBreakdown = {
    statName: defenseName === 'PD' ? 'Precision Defense' : 'Area Defense',
    base: baseValue,
    effects: modifiers !== 0 ? [
      {
        source: { type: 'trait', id: 'defense_modifiers', name: 'Modifiers', category: 'Various' },
        value: modifiers,
        description: `Defense modifiers: ${modifiers > 0 ? '+' : ''}${modifiers}`,
        isActive: true
      }
    ] : [],
    total: finalValue
  };
  
  return (
    <div>
      <strong>{defenseName === 'PD' ? 'Precision Defense' : 'Area Defense'}</strong>
      <div style={{ fontSize: '0.7rem', color: '#9ca3af', marginBottom: '4px' }}>
        Formula: {baseFormula}
      </div>
      <pre style={tooltipStyles}>
        {finalValue}
        
        ├─ Base ({baseFormula}): {baseValue}
        {modifiers !== 0 && `└─ Modifiers: ${modifiers > 0 ? '+' : ''}${modifiers}`}
      </pre>
    </div>
  );
};

/**
 * Enhanced MP tooltip
 */
export const createEnhancedMPTooltip = (
  characterData: CharacterSheetData,
  breakdown?: EnhancedStatBreakdown
): React.ReactNode => {
  if (breakdown) {
    return createEnhancedTooltip('Mana Points', breakdown);
  }
  
  const intelligenceBonus = characterData.finalIntelligence || 0;
  const simpleBreakdown: EnhancedStatBreakdown = {
    statName: 'Mana Points',
    base: intelligenceBonus,
    effects: [
      {
        source: { type: 'class_feature', id: 'class_mp', name: 'Class MP', category: 'Base' },
        value: characterData.finalMPMax - intelligenceBonus,
        description: `Class base: +${characterData.finalMPMax - intelligenceBonus}`,
        isActive: true
      }
    ],
    total: characterData.finalMPMax
  };
  
  return createEnhancedTooltip('Mana Points', simpleBreakdown);
};

/**
 * Enhanced Jump Distance tooltip
 */
export const createEnhancedJumpTooltip = (
  characterData: CharacterSheetData,
  breakdown?: EnhancedStatBreakdown
): React.ReactNode => {
  if (breakdown) {
    return createEnhancedTooltip('Jump Distance', breakdown);
  }
  
  const agilityBase = characterData.finalAgility || 0;
  const simpleBreakdown: EnhancedStatBreakdown = {
    statName: 'Jump Distance',
    base: agilityBase,
    effects: [
      {
        source: { type: 'base', id: 'jump_formula', name: 'Modifiers', category: 'Various' },
        value: characterData.finalJumpDistance - agilityBase,
        description: `Jump modifiers: ${characterData.finalJumpDistance - agilityBase > 0 ? '+' : ''}${characterData.finalJumpDistance - agilityBase}`,
        isActive: true
      }
    ],
    total: characterData.finalJumpDistance
  };
  
  return (
    <div>
      <strong>Jump Distance</strong>
      <div style={{ fontSize: '0.7rem', color: '#9ca3af', marginBottom: '4px' }}>
        Formula: AGI + modifiers
      </div>
      <pre style={tooltipStyles}>
        {characterData.finalJumpDistance}
        
        ├─ Base (AGI): {agilityBase}
        {characterData.finalJumpDistance !== agilityBase && 
          `└─ Modifiers: ${characterData.finalJumpDistance - agilityBase > 0 ? '+' : ''}${characterData.finalJumpDistance - agilityBase}`
        }
      </pre>
    </div>
  );
};
```

## File: src/routes/character-sheet/components/FeaturePopup.tsx
```typescript
import React from 'react';
import type { FeatureData } from '../../../types';
import {
	StyledFeaturePopupOverlay,
	StyledFeaturePopupContent,
	StyledFeaturePopupHeader,
	StyledFeaturePopupTitle,
	StyledFeaturePopupClose,
	StyledFeaturePopupDescription,
	StyledFeaturePopupSourceInfo
} from '../styles/FeaturePopup';

interface FeaturePopupProps {
	feature: FeatureData | null;
	onClose: () => void;
}

const FeaturePopup: React.FC<FeaturePopupProps> = ({ feature, onClose }) => {
	if (!feature) return null;

	return (
		<StyledFeaturePopupOverlay onClick={onClose}>
			<StyledFeaturePopupContent onClick={(e) => e.stopPropagation()}>
				<StyledFeaturePopupHeader>
					<StyledFeaturePopupTitle>{feature.name}</StyledFeaturePopupTitle>
					<StyledFeaturePopupClose onClick={onClose}>×</StyledFeaturePopupClose>
				</StyledFeaturePopupHeader>
				<StyledFeaturePopupDescription>
					{feature.description}
				</StyledFeaturePopupDescription>
				{feature.sourceDetail && (
					<StyledFeaturePopupSourceInfo>
						Source: {feature.sourceDetail}
					</StyledFeaturePopupSourceInfo>
				)}
			</StyledFeaturePopupContent>
		</StyledFeaturePopupOverlay>
	);
};

export default FeaturePopup;
```

## File: src/routes/character-sheet/components/Features.tsx
```typescript
import React from 'react';
import type { FeatureData } from '../../../types';
import { useCharacterSheet } from '../hooks/CharacterSheetProvider';
import {
	StyledFeaturesContainer,
	StyledFeaturesTitle,
	StyledFeatureCategory,
	StyledFeatureCategoryTitle,
	StyledFeatureGrid,
	StyledFeatureItem,
	StyledFeatureName,
	StyledFeatureReadMore,
	StyledNoFeaturesMessage,
	StyledFeaturesContent
} from '../styles/Features.styles';

interface FeaturesProps {
	onFeatureClick: (feature: FeatureData) => void;
}

const Features: React.FC<FeaturesProps> = ({ onFeatureClick }) => {
	const { state } = useCharacterSheet();
	
	if (!state.character) {
		return <div>Loading features...</div>;
	}
	
	// Get features from character data (this might need adjustment based on actual data structure)
	const features = state.character.features || [];
	// Organize features by source
	const ancestryFeatures = features.filter((f) => f.source === 'ancestry');
	const classFeatures = features.filter((f) => f.source === 'class');
	const choiceFeatures = features.filter((f) => f.source === 'choice');

	return (
		<StyledFeaturesContainer>
			<StyledFeaturesTitle>FEATURES</StyledFeaturesTitle>

			<StyledFeaturesContent>
				{/* Ancestry Traits */}
				{ancestryFeatures.length > 0 && (
					<StyledFeatureCategory>
						<StyledFeatureCategoryTitle>Ancestry Traits</StyledFeatureCategoryTitle>
						<StyledFeatureGrid>
							{ancestryFeatures.map((feature) => (
								<StyledFeatureItem key={feature.id}>
									<StyledFeatureName>{feature.name}</StyledFeatureName>
									<StyledFeatureReadMore onClick={() => onFeatureClick(feature)}>
										Info
									</StyledFeatureReadMore>
								</StyledFeatureItem>
							))}
						</StyledFeatureGrid>
					</StyledFeatureCategory>
				)}

				{/* Class Features */}
				{classFeatures.length > 0 && (
					<StyledFeatureCategory>
						<StyledFeatureCategoryTitle>Class Features</StyledFeatureCategoryTitle>
						<StyledFeatureGrid>
							{classFeatures.map((feature) => (
								<StyledFeatureItem key={feature.id}>
									<StyledFeatureName>{feature.name}</StyledFeatureName>
									<StyledFeatureReadMore onClick={() => onFeatureClick(feature)}>
										Info
									</StyledFeatureReadMore>
								</StyledFeatureItem>
							))}
						</StyledFeatureGrid>
					</StyledFeatureCategory>
				)}

				{/* Feature Choices */}
				{choiceFeatures.length > 0 && (
					<StyledFeatureCategory>
						<StyledFeatureCategoryTitle>Selected Features</StyledFeatureCategoryTitle>
						<StyledFeatureGrid>
							{choiceFeatures.map((feature) => (
								<StyledFeatureItem key={feature.id}>
									<StyledFeatureName>{feature.name}</StyledFeatureName>
									<StyledFeatureReadMore onClick={() => onFeatureClick(feature)}>
										Info
									</StyledFeatureReadMore>
								</StyledFeatureItem>
							))}
						</StyledFeatureGrid>
					</StyledFeatureCategory>
				)}

				{/* No features message */}
				{features.length === 0 && (
					<StyledNoFeaturesMessage>No features available</StyledNoFeaturesMessage>
				)}
			</StyledFeaturesContent>
		</StyledFeaturesContainer>
	);
};

export default Features;
```

## File: src/routes/character-sheet/components/InventoryPopup.tsx
```typescript
import React from 'react';
import type { InventoryItemData } from '../../../types';
import type { InventoryItem } from '../../../lib/rulesdata/inventoryItems';
import {
	StyledFeaturePopupOverlay,
	StyledFeaturePopupContent,
	StyledFeaturePopupHeader,
	StyledFeaturePopupTitle,
	StyledFeaturePopupClose,
	StyledFeaturePopupDescription
} from '../styles/FeaturePopup';

interface InventoryPopupProps {
	selectedInventoryItem: {
		inventoryData: InventoryItemData;
		item: InventoryItem | null;
	} | null;
	onClose: () => void;
}

const InventoryPopup: React.FC<InventoryPopupProps> = ({ selectedInventoryItem, onClose }) => {
	if (!selectedInventoryItem) return null;

	return (
		<StyledFeaturePopupOverlay onClick={onClose}>
			<StyledFeaturePopupContent onClick={(e) => e.stopPropagation()}>
				<StyledFeaturePopupHeader>
					<StyledFeaturePopupTitle>
						{selectedInventoryItem.item?.name ||
							selectedInventoryItem.inventoryData.itemName ||
							'Unknown Item'}
					</StyledFeaturePopupTitle>
					<StyledFeaturePopupClose onClick={onClose}>×</StyledFeaturePopupClose>
				</StyledFeaturePopupHeader>
				<StyledFeaturePopupDescription>
					{selectedInventoryItem.item ? (
						<>
							<strong>Type:</strong> {selectedInventoryItem.item.itemType}
							<br />
							{selectedInventoryItem.item.itemType === 'Weapon' && (
								<>
									<strong>Weapon Type:</strong> {(selectedInventoryItem.item as any).type}
									<br />
									<strong>Style:</strong> {(selectedInventoryItem.item as any).style}
									<br />
									<strong>Handedness:</strong> {(selectedInventoryItem.item as any).handedness}
									<br />
									<strong>Damage:</strong> {(selectedInventoryItem.item as any).damage}
									<br />
									{(selectedInventoryItem.item as any).properties && (
										<>
											<strong>Properties:</strong>{' '}
											{(selectedInventoryItem.item as any).properties.join(', ')}
											<br />
										</>
									)}
									{(selectedInventoryItem.item as any).price && (
										<>
											<strong>Price:</strong> {(selectedInventoryItem.item as any).price}
											<br />
										</>
									)}
								</>
							)}
							{selectedInventoryItem.item.itemType === 'Armor' && (
								<>
									<strong>Type:</strong> {(selectedInventoryItem.item as any).type}
									<br />
									<strong>PDR:</strong> {(selectedInventoryItem.item as any).pdr}
									<br />
									<strong>AD Modifier:</strong> {(selectedInventoryItem.item as any).adModifier}
									<br />
									{(selectedInventoryItem.item as any).agilityCap && (
										<>
											<strong>Agility Cap:</strong>{' '}
											{(selectedInventoryItem.item as any).agilityCap}
											<br />
										</>
									)}
									{(selectedInventoryItem.item as any).price && (
										<>
											<strong>Price:</strong> {(selectedInventoryItem.item as any).price}
											<br />
										</>
									)}
								</>
							)}
							{selectedInventoryItem.item.itemType === 'Shield' && (
								<>
									<strong>PDR:</strong> {(selectedInventoryItem.item as any).pdr}
									<br />
									<strong>AD Modifier:</strong> {(selectedInventoryItem.item as any).adModifier}
									<br />
									{(selectedInventoryItem.item as any).price && (
										<>
											<strong>Price:</strong> {(selectedInventoryItem.item as any).price}
											<br />
										</>
									)}
								</>
							)}
							{selectedInventoryItem.item.itemType === 'Potion' && (
								<>
									<strong>Level:</strong> {(selectedInventoryItem.item as any).level}
									<br />
									<strong>Healing:</strong> {(selectedInventoryItem.item as any).healing}
									<br />
									<strong>Price:</strong> {(selectedInventoryItem.item as any).price}g<br />
								</>
							)}
							{selectedInventoryItem.item.itemType === 'Adventuring Supply' && (
								<>
									{(selectedInventoryItem.item as any).description && (
										<>
											<strong>Description:</strong>{' '}
											{(selectedInventoryItem.item as any).description}
											<br />
										</>
									)}
									{(selectedInventoryItem.item as any).price && (
										<>
											<strong>Price:</strong> {(selectedInventoryItem.item as any).price}
											<br />
										</>
									)}
								</>
							)}
							<br />
							<strong>Count:</strong> {selectedInventoryItem.inventoryData.count}
							<br />
							{selectedInventoryItem.inventoryData.cost && (
								<>
									<strong>Cost:</strong> {selectedInventoryItem.inventoryData.cost}
								</>
							)}
						</>
					) : (
						<>
							<strong>Custom Item</strong>
							<br />
							<strong>Type:</strong> {selectedInventoryItem.inventoryData.itemType}
							<br />
							<strong>Count:</strong> {selectedInventoryItem.inventoryData.count}
							<br />
							{selectedInventoryItem.inventoryData.cost && (
								<>
									<strong>Cost:</strong> {selectedInventoryItem.inventoryData.cost}
								</>
							)}
						</>
					)}
				</StyledFeaturePopupDescription>
			</StyledFeaturePopupContent>
		</StyledFeaturePopupOverlay>
	);
};

export default InventoryPopup;
```

## File: src/routes/character-sheet/components/LeftColumn.tsx
```typescript
import React from 'react';
import type { SkillData, TradeData, LanguageData, CharacterSheetData } from '../../../types';
import type { EnhancedStatBreakdown } from '../../../lib/types/effectSystem';
import { StyledLeftColumn } from '../styles/Layout';
import Attributes from './Attributes';
import KnowledgeTrades from './KnowledgeTrades';
import Languages from './Languages';

interface LeftColumnProps {
	characterData: CharacterSheetData;
	skillsByAttribute: {
		prime: SkillData[];
		might: SkillData[];
		agility: SkillData[];
		charisma: SkillData[];
		intelligence: SkillData[];
	};
	knowledge: TradeData[];
	trades: TradeData[];
	languages: LanguageData[];
	breakdowns?: Record<string, EnhancedStatBreakdown>;
}

const LeftColumn: React.FC<LeftColumnProps> = ({
	characterData,
	skillsByAttribute,
	knowledge,
	trades,
	languages,
	breakdowns
}) => {
	return (
		<StyledLeftColumn>
			<Attributes 
				characterData={characterData} 
				skillsByAttribute={skillsByAttribute} 
				breakdowns={breakdowns}
			/>
			<KnowledgeTrades knowledge={knowledge} trades={trades} />
			<Languages languages={languages} />
		</StyledLeftColumn>
	);
};

export default LeftColumn;
```

## File: src/routes/character-sheet/components/Resources.tsx.backup
```
import React from 'react';
import {
	ResourcesContainer,
	ResourceColumn,
	ResourceLabel,
	ResourceControls,
	TempHPControls,
	TempHPLabel,
	TempHPInputSmall
} from '../styles/Resources';
import { StyledResourceButton } from '../styles/Resources';
import {
	StyledPotionContainer,
	StyledPotionFill,
	StyledPotionBubbles,
	StyledPotionValue,
	StyledLargePotionContainer,
	StyledLargePotionValue
} from '../styles/Potions';

interface ResourcesProps {
	characterData: {
		finalSPMax: number;
		finalMPMax: number;
		finalHPMax: number;
	};
	currentValues: {
		currentSP: number;
		currentMP: number;
		currentHP: number;
		tempHP: number;
	};
	onAdjustResource: (
		resource: 'currentSP' | 'currentMP' | 'currentHP' | 'tempHP',
		amount: number
	) => void;
	onResourceInputChange: (resource: 'tempHP', value: string) => void;
	getFillPercentage: (current: number, max: number) => number;
	getHPFillPercentage: (current: number, max: number, tempHP: number) => number;
	isMobile?: boolean;
}

const Resources: React.FC<ResourcesProps> = ({
	characterData,
	currentValues,
	onAdjustResource,
	onResourceInputChange,
	getFillPercentage,
	getHPFillPercentage,
	isMobile = false
}) => {
	return (
		<ResourcesContainer $isMobile={isMobile}>
			{/* Stamina Points */}
			<ResourceColumn $isMobile={isMobile}>
				<ResourceLabel>STAMINA POINTS</ResourceLabel>
				<ResourceControls>
					<StyledResourceButton onClick={() => onAdjustResource('currentSP', -1)}>
						-
					</StyledResourceButton>
					<StyledPotionContainer style={{ borderColor: '#22c55e' }}>
						<StyledPotionFill
							fillPercentage={getFillPercentage(currentValues.currentSP, characterData.finalSPMax)}
							color="#22c55e"
						/>
						<StyledPotionBubbles
							color="#22c55e"
							fillPercentage={getFillPercentage(currentValues.currentSP, characterData.finalSPMax)}
						/>
						<StyledPotionValue>{currentValues.currentSP}</StyledPotionValue>
					</StyledPotionContainer>
					<StyledResourceButton onClick={() => onAdjustResource('currentSP', 1)}>
						+
					</StyledResourceButton>
				</ResourceControls>
				<div
					style={{
						fontSize: '1.1rem',
						fontWeight: '300',
						color: '#666',
						marginTop: '0.3rem',
						fontStyle: 'italic'
					}}
				>
					{characterData.finalSPMax}
				</div>
			</ResourceColumn>

			{/* Mana Points */}
			<ResourceColumn $isMobile={isMobile}>
				<ResourceLabel>MANA POINTS</ResourceLabel>
				<ResourceControls>
					<StyledResourceButton onClick={() => onAdjustResource('currentMP', -1)}>
						-
					</StyledResourceButton>
					<StyledPotionContainer style={{ borderColor: '#3b82f6' }}>
						<StyledPotionFill
							fillPercentage={getFillPercentage(currentValues.currentMP, characterData.finalMPMax)}
							color="#3b82f6"
						/>
						<StyledPotionBubbles
							color="#3b82f6"
							fillPercentage={getFillPercentage(currentValues.currentMP, characterData.finalMPMax)}
						/>
						<StyledPotionValue>{currentValues.currentMP}</StyledPotionValue>
					</StyledPotionContainer>
					<StyledResourceButton onClick={() => onAdjustResource('currentMP', 1)}>
						+
					</StyledResourceButton>
				</ResourceControls>
				<div
					style={{
						fontSize: '1.1rem',
						fontWeight: '300',
						color: '#666',
						marginTop: '0.3rem',
						fontStyle: 'italic'
					}}
				>
					{characterData.finalMPMax}
				</div>
			</ResourceColumn>

			{/* Hit Points */}
			<ResourceColumn $isMobile={isMobile}>
				<ResourceLabel>HIT POINTS</ResourceLabel>
				<ResourceControls>
					<StyledResourceButton onClick={() => onAdjustResource('currentHP', -1)}>
						-
					</StyledResourceButton>
					<StyledLargePotionContainer style={{ borderColor: '#dc2626' }}>
						<StyledPotionFill
							fillPercentage={getHPFillPercentage(
								currentValues.currentHP,
								characterData.finalHPMax,
								currentValues.tempHP
							)}
							color="#dc2626"
						/>
						<StyledPotionBubbles
							color="#dc2626"
							fillPercentage={getHPFillPercentage(
								currentValues.currentHP,
								characterData.finalHPMax,
								currentValues.tempHP
							)}
						/>
						<StyledLargePotionValue>{currentValues.currentHP}</StyledLargePotionValue>
					</StyledLargePotionContainer>
					<StyledResourceButton onClick={() => onAdjustResource('currentHP', 1)}>
						+
					</StyledResourceButton>
				</ResourceControls>
				<div
					style={{
						fontSize: '1.1rem',
						fontWeight: '300',
						color: '#666',
						marginTop: '0.3rem',
						fontStyle: 'italic',
						display: 'flex',
						alignItems: 'center',
						justifyContent: 'center',
						gap: '0.5rem'
					}}
				>
					<span>{characterData.finalHPMax}</span>
					{currentValues.tempHP > 0 && (
						<span style={{ color: '#dc2626', fontWeight: 'bold', fontSize: '0.9rem' }}>
							(+{currentValues.tempHP} temp)
						</span>
					)}
				</div>

				{/* Temp HP Controls */}
				<TempHPControls>
					<TempHPLabel>TEMP HP:</TempHPLabel>
					<StyledResourceButton
						onClick={() => onAdjustResource('tempHP', -1)}
						style={{ fontSize: '0.7rem', width: '20px', height: '20px', padding: '0' }}
					>
						-
					</StyledResourceButton>
					<TempHPInputSmall
						type="number"
						value={currentValues.tempHP}
						onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
							onResourceInputChange('tempHP', e.target.value)
						}
					/>
					<StyledResourceButton
						onClick={() => onAdjustResource('tempHP', 1)}
						style={{ fontSize: '0.7rem', width: '20px', height: '20px', padding: '0' }}
					>
						+
					</StyledResourceButton>
				</TempHPControls>
			</ResourceColumn>
		</ResourcesContainer>
	);
};

export default Resources;
```

## File: src/routes/character-sheet/components/SpellPopup.tsx
```typescript
import React from 'react';
import type { Spell } from '../../../lib/rulesdata/spells-data/types/spell.types';
import {
	StyledFeaturePopupOverlay,
	StyledFeaturePopupContent,
	StyledFeaturePopupHeader,
	StyledFeaturePopupTitle,
	StyledFeaturePopupClose,
	StyledFeaturePopupDescription,
	StyledFeaturePopupSourceInfo
} from '../styles/FeaturePopup';

interface SpellPopupProps {
	spell: Spell | null;
	onClose: () => void;
}

const SpellPopup: React.FC<SpellPopupProps> = ({ spell, onClose }) => {
	if (!spell) return null;

	return (
		<StyledFeaturePopupOverlay onClick={onClose}>
			<StyledFeaturePopupContent onClick={(e) => e.stopPropagation()}>
				<StyledFeaturePopupHeader>
					<StyledFeaturePopupTitle>{spell.name}</StyledFeaturePopupTitle>
					<StyledFeaturePopupClose onClick={onClose}>×</StyledFeaturePopupClose>
				</StyledFeaturePopupHeader>
				<StyledFeaturePopupDescription>
					<strong>School:</strong> {spell.school}
					<br />
					<strong>AP Cost:</strong> {spell.cost.ap}
					<br />
					{spell.cost.mp && (
						<>
							<strong>MP Cost:</strong> {spell.cost.mp}
							<br />
						</>
					)}
					<strong>Range:</strong> {spell.range}
					<br />
					<strong>Duration:</strong> {spell.duration}
					<br />
					{spell.isCantrip && (
						<>
							<strong>Type:</strong> Cantrip
							<br />
						</>
					)}
					{spell.isRitual && (
						<>
							<strong>Ritual:</strong> Yes
							<br />
						</>
					)}
					<br />
					{spell.effects?.[0]?.description || 'No description available.'}
					{spell.cantripPassive && (
						<>
							<br />
							<br />
							<strong>Cantrip Passive:</strong> {spell.cantripPassive}
						</>
					)}
				</StyledFeaturePopupDescription>
				{spell.enhancements?.length > 0 && (
					<StyledFeaturePopupSourceInfo>
						Enhancements Available: {spell.enhancements.length}
					</StyledFeaturePopupSourceInfo>
				)}
			</StyledFeaturePopupContent>
		</StyledFeaturePopupOverlay>
	);
};

export default SpellPopup;
```

## File: src/routes/character-sheet/components/Tooltip.tsx
```typescript
import React, { useState } from 'react';
import styled, { css } from 'styled-components';

interface TooltipProps {
  content: React.ReactNode;
  children: React.ReactNode;
  position?: 'top' | 'bottom' | 'left' | 'right';
  maxWidth?: string;
}

const TooltipContainer = styled.div`
  position: relative;
  display: inline-block;
`;

const TooltipContent = styled.div<{ 
  $visible: boolean; 
  $position: 'top' | 'bottom' | 'left' | 'right';
  $maxWidth: string;
}>`
  position: absolute;
  z-index: 1000;
  padding: 8px 12px;
  background: #1a1a1a;
  color: #ffffff;
  border-radius: 6px;
  font-size: 0.8rem;
  line-height: 1.3;
  white-space: pre-line;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  border: 1px solid #333;
  max-width: ${props => props.$maxWidth};
  width: max-content;
  min-width: 150px;
  
  opacity: ${props => props.$visible ? 1 : 0};
  visibility: ${props => props.$visible ? 'visible' : 'hidden'};
  transition: opacity 0.2s ease, visibility 0.2s ease;
  
  ${props => {
    switch (props.$position) {
      case 'top':
        return css`
          bottom: 100%;
          left: 50%;
          transform: translateX(-50%);
          margin-bottom: 8px;
          
          &::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #1a1a1a;
          }
        `;
      case 'bottom':
        return css`
          top: 100%;
          left: 50%;
          transform: translateX(-50%);
          margin-top: 8px;
          
          &::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-bottom-color: #1a1a1a;
          }
        `;
      case 'left':
        return css`
          right: 100%;
          top: 50%;
          transform: translateY(-50%);
          margin-right: 8px;
          
          &::after {
            content: '';
            position: absolute;
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            border: 6px solid transparent;
            border-left-color: #1a1a1a;
          }
        `;
      case 'right':
        return css`
          left: 100%;
          top: 50%;
          transform: translateY(-50%);
          margin-left: 8px;
          
          &::after {
            content: '';
            position: absolute;
            right: 100%;
            top: 50%;
            transform: translateY(-50%);
            border: 6px solid transparent;
            border-right-color: #1a1a1a;
          }
        `;
      default:
        return css``;
    }
  }}
`;

const TriggerWrapper = styled.div`
  display: inline-block;
  cursor: help;
`;

const Tooltip: React.FC<TooltipProps> = ({ 
  content, 
  children, 
  position = 'top',
  maxWidth = '250px'
}) => {
  const [visible, setVisible] = useState(false);

  return (
    <TooltipContainer>
      <TriggerWrapper
        onMouseEnter={() => setVisible(true)}
        onMouseLeave={() => setVisible(false)}
      >
        {children}
      </TriggerWrapper>
      <TooltipContent 
        $visible={visible} 
        $position={position}
        $maxWidth={maxWidth}
      >
        {content}
      </TooltipContent>
    </TooltipContainer>
  );
};

export default Tooltip;
```

## File: src/routes/character-sheet/styles/DesktopLayout.ts
```typescript
import styled from 'styled-components';

// Desktop-specific layout components
export const StyledDesktopWrapper = styled.div`
	padding: 2rem;
	background-color: rgba(255, 255, 255, 0.9);
	margin: 2rem;
	border-radius: 8px;
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
`;

export const StyledDesktopHeader = styled.div`
	text-align: center;
	margin-bottom: 2rem;
	border-bottom: 3px solid #8b4513;
	padding-bottom: 1.5rem;
`;

export const StyledCharacterName = styled.h1`
	margin: 0;
	color: #8b4513;
	font-size: 2.5rem;
	font-family: 'Georgia', serif;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
`;

export const StyledCharacterSubtitle = styled.h2`
	margin: 0.5rem 0;
	color: #666;
	font-size: 1.3rem;
	font-weight: normal;
	font-family: 'Georgia', serif;
`;

// Character Stats Grid
export const StyledAttributesGrid = styled.div`
	display: grid;
	grid-template-columns: repeat(5, 1fr);
	gap: 1rem;
	margin-bottom: 2rem;
`;

export const StyledAttributeCard = styled.div`
	text-align: center;
	padding: 1rem;
	background-color: #f5f5f5;
	border-radius: 8px;
	border: 2px solid #e0e0e0;
	transition: all 0.2s ease;

	&:hover {
		border-color: #8b4513;
		box-shadow: 0 2px 8px rgba(139, 69, 19, 0.2);
	}
`;

export const StyledAttributeLabel = styled.div`
	font-size: 0.8rem;
	color: #666;
	margin-bottom: 0.25rem;
	text-transform: uppercase;
	font-weight: bold;
	letter-spacing: 0.5px;
`;

export const StyledAttributeValue = styled.div`
	font-size: 1.5rem;
	font-weight: bold;
	color: #8b4513;
	font-family: 'Georgia', serif;
`;

// Section Components
export const StyledSection = styled.div`
	margin-bottom: 2rem;
`;

export const StyledSectionTitle = styled.h3`
	color: #8b4513;
	border-bottom: 2px solid #8b4513;
	padding-bottom: 0.5rem;
	margin-bottom: 1rem;
	font-size: 1.4rem;
	font-family: 'Georgia', serif;
	font-weight: bold;
`;

// Resource Components
export const StyledResourceRow = styled.div`
	display: flex;
	align-items: center;
	gap: 1rem;
	margin-bottom: 1rem;
	padding: 1rem;
	background-color: #f9f9f9;
	border-radius: 6px;
	border: 1px solid #e0e0e0;
`;

export const StyledResourceLabel = styled.div`
	font-weight: bold;
	min-width: 120px;
	color: #8b4513;
	font-family: 'Georgia', serif;
`;

export const StyledResourceValue = styled.div`
	min-width: 100px;
	font-weight: bold;
	color: #333;
`;

export const StyledResourceBar = styled.div`
	flex: 1;
	height: 20px;
	background-color: #ddd;
	border-radius: 10px;
	overflow: hidden;
	border: 1px solid #ccc;
`;

export const StyledResourceFill = styled.div<{ fillPercent: number; color: string }>`
	height: 100%;
	background-color: ${props => props.color};
	width: ${props => props.fillPercent}%;
	transition: width 0.3s ease;
	border-radius: 9px;
`;

export const StyledResourceControls = styled.div`
	display: flex;
	gap: 0.5rem;
	align-items: center;
`;

export const StyledResourceButton = styled.button`
	width: 32px;
	height: 32px;
	border: 2px solid #8b4513;
	border-radius: 4px;
	background: #f5f3f0;
	color: #8b4513;
	cursor: pointer;
	font-weight: bold;
	font-size: 1.1rem;
	transition: all 0.2s ease;

	&:hover {
		background: #8b4513;
		color: #f5f3f0;
	}

	&:active {
		transform: scale(0.95);
	}
`;

export const StyledResourceInput = styled.input`
	width: 60px;
	text-align: center;
	padding: 0.5rem;
	border: 2px solid #ddd;
	border-radius: 4px;
	font-weight: bold;
	font-family: 'Georgia', serif;

	&:focus {
		border-color: #8b4513;
		outline: none;
	}
`;

// Features Grid
export const StyledFeaturesGrid = styled.div`
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
	gap: 0.75rem;
`;

export const StyledFeatureCard = styled.div`
	padding: 0.75rem;
	background-color: #f9f9f9;
	border-radius: 6px;
	cursor: pointer;
	border: 2px solid #e0e0e0;
	transition: all 0.2s ease;

	&:hover {
		background-color: #f0f0f0;
		border-color: #8b4513;
		box-shadow: 0 2px 8px rgba(139, 69, 19, 0.2);
	}
`;

export const StyledFeatureName = styled.div`
	font-weight: bold;
	color: #8b4513;
	margin-bottom: 0.25rem;
	font-family: 'Georgia', serif;
`;

export const StyledFeatureSource = styled.div`
	font-size: 0.9rem;
	color: #666;
	font-style: italic;
`;

// Currency Grid
export const StyledCurrencyGrid = styled.div`
	display: grid;
	grid-template-columns: repeat(5, 1fr);
	gap: 1rem;
`;

export const StyledCurrencyColumn = styled.div`
	text-align: center;
`;

export const StyledCurrencyLabel = styled.div`
	font-size: 0.9rem;
	margin-bottom: 0.5rem;
	color: #8b4513;
	font-weight: bold;
	text-transform: uppercase;
	letter-spacing: 0.5px;
`;

export const StyledCurrencyInput = styled.input`
	width: 100%;
	text-align: center;
	padding: 0.75rem 0.5rem;
	border: 2px solid #ddd;
	border-radius: 4px;
	font-weight: bold;
	font-family: 'Georgia', serif;
	font-size: 1rem;

	&:focus {
		border-color: #8b4513;
		outline: none;
		box-shadow: 0 0 0 2px rgba(139, 69, 19, 0.2);
	}
`;
```

## File: src/routes/character-sheet/styles/FeaturePopup.ts
```typescript
import styled from 'styled-components';

export const StyledFeaturePopupOverlay = styled.div`
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background: rgba(0, 0, 0, 0.5);
	display: flex;
	align-items: center;
	justify-content: center;
	z-index: 1000;
`;

export const StyledFeaturePopupContent = styled.div`
	background: white;
	border: 3px solid #8b4513;
	border-radius: 12px;
	padding: 2rem;
	max-width: 600px;
	max-height: 80vh;
	overflow-y: auto;
	margin: 1rem;
	box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
	box-sizing: border-box;
	
	@media (max-width: 768px) {
		width: calc(100vw - 10rem);
		margin: 5rem 1rem 1rem 1rem;
		padding: 1.5rem;
	}
`;

export const StyledFeaturePopupHeader = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 1.5rem;
	border-bottom: 2px solid #8b4513;
	padding-bottom: 1rem;

	/* Mobile responsive styling */
	@media (max-width: 768px) {
		margin-bottom: 1rem;
		padding-bottom: 0.75rem;
		align-items: flex-start;
		gap: 0.5rem;
	}
`;

export const StyledFeaturePopupTitle = styled.h2`
	margin: 0;
	color: #8b4513;
	font-size: 1.5rem;
	font-weight: bold;
	flex: 1;
	word-wrap: break-word;

	/* Mobile responsive styling */
	@media (max-width: 768px) {
		font-size: 1.2rem;
		line-height: 1.3;
		margin-right: 0.5rem;
	}

	@media (max-width: 480px) {
		font-size: 1.1rem;
	}
`;

export const StyledFeaturePopupClose = styled.button`
	background: #8b4513;
	color: white;
	border: none;
	border-radius: 50%;
	width: 30px;
	height: 30px;
	cursor: pointer;
	font-size: 1.2rem;
	display: flex;
	align-items: center;
	justify-content: center;
	flex-shrink: 0;

	&:hover {
		background: #654321;
	}

	/* Mobile responsive styling */
	@media (max-width: 768px) {
		width: 36px;
		height: 36px;
		font-size: 1.4rem;
		margin-top: 2px;
	}
`;

export const StyledFeaturePopupDescription = styled.div`
	color: #333;
	line-height: 1.6;
	font-size: 1rem;
	word-wrap: break-word;
	overflow-wrap: break-word;

	/* Mobile responsive styling */
	@media (max-width: 768px) {
		font-size: 0.9rem;
		line-height: 1.5;
	}

	@media (max-width: 480px) {
		font-size: 0.85rem;
		line-height: 1.4;
	}
`;

export const StyledFeaturePopupSourceInfo = styled.div`
	margin-top: 1rem;
	padding-top: 1rem;
	border-top: 1px solid #e5e5e5;
	font-size: 0.9rem;
	color: #666;
	font-style: italic;
`;
```

## File: src/routes/character-sheet/styles/Potions.ts
```typescript
import styled from 'styled-components';

interface PotionCircleProps {
	$fillPercentage: number;
	$color: string;
}

export const StyledPotionContainer = styled.div`
	position: relative;
	width: 80px;
	height: 80px;
	border: 3px solid;
	border-radius: 50%;
	background: white;
	overflow: hidden;
	display: flex;
	align-items: center;
	justify-content: center;
`;

export const StyledPotionFill = styled.div<PotionCircleProps>`
	position: absolute;
	bottom: 0;
	left: 0;
	right: 0;
	height: ${(props) => Math.max(0, props.$fillPercentage)}%;
	background: linear-gradient(to top, ${(props) => props.$color}dd, ${(props) => props.$color}aa);
	border-radius: 0 0 50px 50px;
	transition: height 0.3s ease-in-out;
`;

export const StyledPotionBubbles = styled.div<{ $color: string; $fillPercentage: number }>`
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	pointer-events: none;
	opacity: ${(props) => (props.$fillPercentage > 20 ? 0.3 : 0)};
	transition: opacity 0.3s ease-in-out;

	&::before {
		content: '';
		position: absolute;
		top: 60%;
		left: 20%;
		width: 8px;
		height: 8px;
		background: rgba(255, 255, 255, 0.8);
		border-radius: 50%;
		animation: bubble1 2s infinite ease-in-out;
	}

	&::after {
		content: '';
		position: absolute;
		top: 30%;
		right: 25%;
		width: 6px;
		height: 6px;
		background: rgba(255, 255, 255, 0.6);
		border-radius: 50%;
		animation: bubble2 2.5s infinite ease-in-out;
	}

	@keyframes bubble1 {
		0%,
		100% {
			transform: translateY(0px) scale(1);
			opacity: 0.3;
		}
		50% {
			transform: translateY(-10px) scale(1.1);
			opacity: 0.8;
		}
	}

	@keyframes bubble2 {
		0%,
		100% {
			transform: translateY(0px) scale(1);
			opacity: 0.2;
		}
		50% {
			transform: translateY(-8px) scale(1.2);
			opacity: 0.6;
		}
	}
`;

export const StyledPotionValue = styled.div`
	position: relative;
	z-index: 10;
	font-size: 1.4rem;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
	color: #333;
`;

export const StyledLargePotionContainer = styled.div`
	position: relative;
	width: 100px;
	height: 100px;
	border: 3px solid;
	border-radius: 50%;
	background: white;
	overflow: hidden;
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
`;

export const StyledLargePotionValue = styled.div`
	position: relative;
	z-index: 10;
	font-size: 1.6rem;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
	color: #333;
`;

export const StyledTempHPDisplay = styled.div`
	position: relative;
	z-index: 10;
	font-size: 0.7rem;
	color: #333;
	display: flex;
	align-items: center;
	gap: 0.2rem;
	text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
`;
```

## File: src/routes/character-sheet/styles/Skills.ts
```typescript
import styled from 'styled-components';

export const StyledSkillsSection = styled.div`
	border: 2px solid #8b4513;
	border-radius: 8px;
	padding: 1rem;
	background: rgba(245, 243, 240, 0.5);
	flex: 1;
`;

export const StyledSkillItem = styled.div`
	display: grid;
	grid-template-columns: auto 1fr auto;
	gap: 0.5rem;
	align-items: center;
	margin-bottom: 0.3rem;
	font-size: 0.8rem;
`;

export const StyledProficiencyDots = styled.div`
	display: flex;
	gap: 2px;
`;

export const StyledDot = styled.div<{ $filled: boolean }>`
	width: 8px;
	height: 8px;
	border-radius: 50%;
	border: 1px solid #8b4513;
	background: ${(props) => (props.$filled ? '#8b4513' : 'white')};
`;
```

## File: src/components/styled.ts
```typescript
import styled from 'styled-components';
// Import static assets
import mainBgImage from '/Main.png';

export const StyledContainer = styled.div`
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	min-height: 100vh;
	padding: 2rem;
	background: url('${mainBgImage}') center/cover no-repeat;
`;

export const StyledTitle = styled.h1`
	margin-bottom: 0.2rem;
	color: #fbbf24;
	text-align: center;
	font-size: 3rem;
	font-weight: bold;
	font-family: 'Cinzel', 'Georgia', 'Times New Roman', serif;
	letter-spacing: 2px;
	margin-top: 16rem;
`;

export const StyledSubtitle = styled.p`
	margin-top: 0rem;
	margin-bottom: 2rem;
	color: #e5e7eb;
	text-align: center;
	font-size: 1.3rem;
	font-family: 'Urbanist', 'Georgia', 'Times New Roman', serif;
	font-weight: 400;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	max-width: 600px;
	line-height: 1.6;
`;

export const StyledMenuGrid = styled.div`
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
	gap: 1.5rem;
	max-width: 900px;
	width: 100%;
`;

export const StyledMenuCard = styled.button`
	border: 1px solid #ffffff;
	padding: 1.5rem 2rem;
	border-radius: 8px;
	background: transparent;
	cursor: pointer;
	transition: all 0.3s ease;
	text-align: left;
	box-shadow: none;
	backdrop-filter: none;
	height: 120px;
	display: flex;
	flex-direction: row;
	justify-content: space-between;
	align-items: center;

	&:hover {
		border-color: #fbbf24;
	}
`;

export const StyledIcon = styled.div`
	font-size: 3rem;
	background: transparent;
	border-radius: 0;
	width: auto;
	height: auto;
	display: flex;
	align-items: center;
	justify-content: center;
	margin: 0;
	box-shadow: none;
	transition: all 0.3s ease;
	color: #e5e7eb;
	font-weight: 300;

	${StyledMenuCard}:hover & {
		color: #fbbf24;
		transform: scale(1.1);
	}
`;

export const StyledCardTitle = styled.h2`
	margin: 0 0 0.3rem 0;
	color: #fbbf24;
	font-size: 1.6rem;
	font-weight: bold;
	font-family: 'Cinzel', 'Georgia', 'Times New Roman', serif;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
	transition: all 0.3s ease;
	text-align: left;
	letter-spacing: 1px;

	${StyledMenuCard}:hover & {
		color: #f59e0b;
	}
`;

export const StyledCardDescription = styled.p`
	margin: 0;
	color: #e5e7eb;
	font-size: 1.1rem;
	font-family: 'Urbanist', 'Georgia', 'Times New Roman', serif;
	font-weight: 400;
	line-height: 1.3;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	opacity: 0.9;
	text-align: left;
	letter-spacing: 1px;
`;

export const StyledTextContent = styled.div`
	display: flex;
	flex-direction: column;
	align-items: flex-start;
	flex: 1;
`;
```

## File: src/lib/rulesdata/_new_schema/ancestries.ts
```typescript
import type { Ancestry } from '../schemas/character.schema';

// This file mirrors the full modular content from src/lib/rulesdata/ancestries.ts
// while preserving the stricter typing from the new schema.
export const ancestriesData: Ancestry[] = [
  {
    id: 'human',
    name: 'Human',
    description:
      'Humans are the most common ancestry in the world, known for their adaptability and resilience.',
    defaultTraitIds: [
      'human_attribute_increase',
      'human_skill_expertise',
      'human_resolve',
      'human_undying'
    ],
    expandedTraitIds: [
      'human_trade_expertise',
      'human_determination',
      'human_unbreakable',
      'human_attribute_decrease'
    ]
  },
  {
    id: 'elf',
    name: 'Elf',
    description: 'Elves are graceful and long-lived beings with a deep connection to nature.',
    defaultTraitIds: ['elf_elven_will', 'elf_nimble', 'elf_agile_explorer', 'elf_discerning_sight'],
    expandedTraitIds: [
      'elf_quick_reactions',
      'elf_peerless_sight',
      'elf_climb_speed',
      'elf_speed_increase',
      'elf_trade_expertise_elf',
      'elf_plant_knowledge',
      'elf_brittle',
      'elf_frail',
      'elf_might_decrease'
    ]
  },
  {
    id: 'dwarf',
    name: 'Dwarf',
    description:
      'Dwarves are a stout and resilient folk, known for their craftsmanship and deep connection to the earth.',
    defaultTraitIds: [
      'dwarf_tough',
      'dwarf_toxic_fortitude',
      'dwarf_physically_sturdy',
      'dwarf_iron_stomach'
    ],
    expandedTraitIds: [
      'dwarf_thick_skinned',
      'dwarf_natural_combatant',
      'dwarf_stone_blood',
      'dwarf_minor_tremorsense',
      'dwarf_stubborn',
      'dwarf_earthen_knowledge',
      'dwarf_charisma_attribute_decrease',
      'dwarf_short_legged'
    ]
  },
  {
    id: 'halfling',
    name: 'Halfling',
    description:
      'Halflings are a small and nimble folk, known for their bravery and love of comfort.',
    defaultTraitIds: [
      'halfling_small_sized',
      'halfling_elusive',
      'halfling_bravery',
      'halfling_endurance',
      'halfling_deft_footwork',
      'halfling_beast_whisperer'
    ],
    expandedTraitIds: [
      'halfling_beast_insight',
      'halfling_burst_of_bravery',
      'halfling_trade_expertise',
      'halfling_critter_knowledge',
      'halfling_brittle',
      'halfling_intelligence_attribute_decrease',
      'halfling_short_legged'
    ]
  },
  {
    id: 'gnome',
    name: 'Gnome',
    description:
      'Gnomes are small and energetic folk, known for their inventiveness and connection to the feywild.',
    defaultTraitIds: [
      'gnome_small_sized',
      'gnome_escape_artist',
      'gnome_magnified_vision',
      'gnome_mental_clarity',
      'gnome_strong_minded',
      'gnome_predict_weather'
    ],
    expandedTraitIds: [
      'gnome_mana_increase',
      'gnome_trapper',
      'gnome_lightning_insulation',
      'gnome_trade_expertise',
      'gnome_storm_knowledge',
      'gnome_agility_attribute_decrease',
      'gnome_short_legged'
    ]
  },
  {
    id: 'orc',
    name: 'Orc',
    description:
      'Orcs are a strong and fierce folk, known for their martial prowess and intimidating presence.',
    defaultTraitIds: [
      'orc_cursed_mind',
      'orc_rush',
      'orc_brutal_strikes',
      'orc_tough',
      'orc_orcish_resolve',
      'orc_already_cursed'
    ],
    expandedTraitIds: [
      'orc_intimidating_shout',
      'orc_dash',
      'orc_finishing_blow',
      'orc_imposing_presence',
      'orc_provocation',
      'orc_reckless'
    ]
  },
  {
    id: 'dragonborn',
    name: 'Dragonborn',
    description:
      'Dragonborn are a proud and powerful folk, who trace their lineage back to dragons.',
    defaultTraitIds: [
      'dragonborn_darkvision',
      'dragonborn_draconic_resistance',
      'dragonborn_draconic_breath_weapon',
      'dragonborn_reptilian_superiority'
    ],
    expandedTraitIds: [
      'dragonborn_mana_increase',
      'dragonborn_thick_skinned',
      'dragonborn_second_breath',
      'dragonborn_concussive_breath',
      'dragonborn_draconic_affinity',
      'dragonborn_dying_breath',
      'dragonborn_draconic_ward',
      'dragonborn_draconic_protection',
      'dragonborn_glide_speed',
      'dragonborn_guardians_bond'
    ],
    origin: {
      prompt: 'Choose a Draconic Origin:',
      options: [
        'cold',
        'corrosion',
        'fire',
        'lightning',
        'poison',
        'sonic',
        'psychic',
        'radiant',
        'umbral'
      ]
    }
  },
  {
    id: 'giantborn',
    name: 'Giantborn',
    description: 'Giantborn are a large and powerful folk, who trace their lineage back to giants.',
    defaultTraitIds: [
      'giantborn_tough',
      'giantborn_powerful_build',
      'giantborn_unstoppable',
      'giantborn_giants_resolve',
      'giantborn_unyielding_movement'
    ],
    expandedTraitIds: [
      'giantborn_giants_fortitude',
      'giantborn_strong_body',
      'giantborn_mighty_hurl',
      'giantborn_titanic_toss',
      'giantborn_mighty_leap',
      'giantborn_brute',
      'giantborn_heavy_riser',
      'giantborn_clumsiness',
      'giantborn_intelligence_attribute_decrease'
    ]
  },
  {
    id: 'angelborn',
    name: 'Angelborn',
    description: 'Angelborn are a celestial folk, known for their grace and divine connection.',
    defaultTraitIds: [
      'angelborn_radiant_resistance',
      'angelborn_celestial_magic',
      'angelborn_healing_touch',
      'angelborn_divine_glow'
    ],
    expandedTraitIds: [
      'angelborn_mana_increase',
      'angelborn_celestial_clarity',
      'angelborn_angelic_insight',
      'angelborn_gift_of_the_angels',
      'angelborn_blinding_light',
      'angelborn_glide_speed',
      'angelborn_pacifist',
      'angelborn_umbral_weakness'
    ],
    variantTraits: [
      {
        id: 'angelborn_fallen',
        name: 'Fallen',
        cost: 0,
        description: 'You can now spend your Ancestry Points on Fiendborn Traits.',
        effects: []
      }
    ]
  },
  {
    id: 'fiendborn',
    name: 'Fiendborn',
    description: 'Fiendborn are a fiendish folk, known for their cunning and infernal connection.',
    defaultTraitIds: [
      'fiendborn_fiendish_resistance',
      'fiendborn_fiendish_magic',
      'fiendborn_darkvision',
      'fiendborn_lights_bane'
    ],
    expandedTraitIds: [
      'fiendborn_mana_increase',
      'fiendborn_silver_tongued',
      'fiendborn_fiendish_aura',
      'fiendborn_superior_darkvision',
      'fiendborn_infernal_bravery',
      'fiendborn_intimidator',
      'fiendborn_charming_gaze',
      'fiendborn_glide_speed',
      'fiendborn_radiant_weakness',
      'fiendborn_divine_dampening'
    ],
    origin: {
      prompt: 'Choose a Fiendish Origin:',
      options: ['cold', 'corrosion', 'fire', 'poison', 'umbral']
    },
    variantTraits: [
      {
        id: 'fiendborn_redeemed',
        name: 'Redeemed',
        cost: 0,
        description: 'You can now spend your Ancestry Points on Angelborn Traits.',
        effects: []
      }
    ]
  },
  {
    id: 'beastborn',
    name: 'Beastborn',
    description: 'Beastborn are a diverse folk, who take on the characteristics of various beasts.',
    defaultTraitIds: [],
    expandedTraitIds: [
      // Senses
      'beastborn_darkvision',
      'beastborn_echolocation',
      'beastborn_keen_sense',
      'beastborn_sunlight_sensitivity',
      // Mobility
      'beastborn_quick_reactions',
      'beastborn_climb_speed',
      'beastborn_spider_climb',
      'beastborn_web_walk',
      'beastborn_water_breathing',
      'beastborn_swim_speed',
      'beastborn_speed_increase',
      'beastborn_sprint',
      'beastborn_charge',
      'beastborn_burrow_speed',
      // Jumping
      'beastborn_jumper',
      'beastborn_strong_jumper',
      // Flying
      'beastborn_glide_speed',
      'beastborn_limited_flight',
      'beastborn_full_flight',
      'beastborn_flyby',
      'beastborn_stealth_feathers',
      'beastborn_winged_arms',
      // Body
      'beastborn_tough',
      'beastborn_thick_skinned',
      'beastborn_powerful_build',
      'beastborn_long_limbed',
      'beastborn_secondary_arms',
      'beastborn_prehensile_appendage',
      'beastborn_hazardous_hide',
      'beastborn_natural_armor',
      'beastborn_hard_shell',
      'beastborn_shell_retreat',
      'beastborn_camouflage',
      'beastborn_prowler',
      'beastborn_cold_resistance',
      'beastborn_fire_resistance',
      'beastborn_short_legged',
      'beastborn_small_sized',
      'beastborn_reckless',
      // Natural Weapons
      'beastborn_natural_weapon',
      'beastborn_extended_natural_weapon',
      'beastborn_natural_projectile',
      'beastborn_natural_weapon_passive',
      'beastborn_rend',
      'beastborn_retractable_natural_weapon',
      'beastborn_venomous_natural_weapon',
      // Miscellaneous
      'beastborn_fast_reflexes',
      'beastborn_mimicry',
      'beastborn_intimidating_shout',
      'beastborn_toxic_fortitude',
      'beastborn_shoot_webs'
    ],
    origin: {
      prompt: 'Choose a type of Beast you are modeled after:',
      options: []
    }
  }
];

// Helper functions for accessing ancestry data
export const getAncestryData = (id: string): Ancestry | undefined => {
  return ancestriesData.find((ancestry) => ancestry.id === id);
};
```

## File: src/lib/rulesdata/_new_schema/cleric_features.ts
```typescript
/**
 * Cleric Class Definition - New Effect Schema
 * Based on the DC20 rule analysis from classAndAncestryAndCalcRefactor.md
 */

import type { ClassDefinition } from '../schemas/character.schema';

export const clericClass: ClassDefinition = {
  className: 'Cleric',
  startingStats: {
    hp: 8,
    sp: 0,
    mp: 6,
    skillPoints: 3,
    tradePoints: 3,
    languagePoints: 2,
    maneuversKnown: 0,
    techniquesKnown: 0,
    cantripsKnown: 2,
    spellsKnown: 3
  },
  coreFeatures: [
    {
      featureName: 'Spellcasting Path',
      levelGained: 1,
      description: 'You gain the ability to cast spells and use divine magic.',
      effects: [
        { type: 'GRANT_COMBAT_TRAINING', target: 'Light_Armor', value: true },
        { type: 'GRANT_COMBAT_TRAINING', target: 'Light_Shields', value: true }
      ]
    },
    {
      featureName: 'Cleric Order',
      levelGained: 1,
      description: 'Your connection to your deity grants you divine powers.',
      choices: [
        {
          id: 'cleric_cleric_order_0',
          prompt: 'Choose your Divine Damage type',
          count: 1,
          options: [
            {
              name: 'Cold',
              description: 'Your divine damage is Cold.',
              effects: [{ type: 'GRANT_ABILITY', target: 'divine_damage_cold', value: 'Your Divine Damage type is Cold.' }]
            },
            {
              name: 'Fire',
              description: 'Your divine damage is Fire.',
              effects: [{ type: 'GRANT_ABILITY', target: 'divine_damage_fire', value: 'Your Divine Damage type is Fire.' }]
            },
            {
              name: 'Lightning',
              description: 'Your divine damage is Lightning.',
              effects: [{ type: 'GRANT_ABILITY', target: 'divine_damage_lightning', value: 'Your Divine Damage type is Lightning.' }]
            },
            {
              name: 'Acid',
              description: 'Your divine damage is Acid.',
              effects: [{ type: 'GRANT_ABILITY', target: 'divine_damage_acid', value: 'Your Divine Damage type is Acid.' }]
            },
            {
              name: 'Poison',
              description: 'Your divine damage is Poison.',
              effects: [{ type: 'GRANT_ABILITY', target: 'divine_damage_poison', value: 'Your Divine Damage type is Poison.' }]
            },
            {
              name: 'Psychic',
              description: 'Your divine damage is Psychic.',
              effects: [{ type: 'GRANT_ABILITY', target: 'divine_damage_psychic', value: 'Your Divine Damage type is Psychic.' }]
            }
          ]
        },
        {
          id: 'cleric_cleric_order_1',
          prompt: 'Choose 2 Divine Domains',
          count: 2,
          options: [
            {
              name: 'Magic',
              description: 'Your Maximum MP increases by 1. You also learn 1 additional Spell with the Restoration Spell Tag.',
              effects: [
                { type: 'MODIFY_STAT', target: 'mpMax', value: 1 },
                { type: 'GRANT_SPELL', target: 'restoration_tag', value: 1 }
              ]
            },
            {
              name: 'Peace',
              description: 'You gain Combat Training with Heavy Armor, Heavy Shields, and Weapons. Additionally, you learn 2 Defensive Maneuvers of your choice.',
              effects: [
                { type: 'GRANT_COMBAT_TRAINING', target: 'Heavy_Armor', value: true },
                { type: 'GRANT_COMBAT_TRAINING', target: 'Heavy_Shields', value: true },
                { type: 'GRANT_COMBAT_TRAINING', target: 'Weapons', value: true },
                { type: 'GRANT_CHOICE', target: 'defensive_maneuver', value: 2 }
              ]
            },
            {
              name: 'War',
              description: 'You gain Combat Training with Heavy Armor, Heavy Shields, and Weapons. Additionally, you learn 2 Attack Maneuvers of your choice.',
              effects: [
                { type: 'GRANT_COMBAT_TRAINING', target: 'Heavy_Armor', value: true },
                { type: 'GRANT_COMBAT_TRAINING', target: 'Heavy_Shields', value: true },
                { type: 'GRANT_COMBAT_TRAINING', target: 'Weapons', value: true },
                { type: 'GRANT_CHOICE', target: 'attack_maneuver', value: 2 }
              ]
            },
            {
              name: 'Life',
              description: 'Your Maximum HP increases by 1. You also learn 1 additional Spell with the Restoration Spell Tag.',
              effects: [
                { type: 'MODIFY_STAT', target: 'hpMax', value: 1 },
                { type: 'GRANT_SPELL', target: 'restoration_tag', value: 1 }
              ]
            },
            {
              name: 'Death',
              description: 'You gain 1 Skill Point. You also learn 1 additional Cantrip with the Restoration Spell Tag.',
              effects: [
                { type: 'MODIFY_STAT', target: 'skillPoints', value: 1 },
                { type: 'GRANT_CANTRIP', target: 'restoration_tag', value: 1 }
              ]
            },
            {
              name: 'Nature',
              description: 'You learn 1 additional Spell with the Elemental Spell Tag. You also gain 1 Trade Point.',
              effects: [
                { type: 'GRANT_SPELL', target: 'elemental_tag', value: 1 },
                { type: 'MODIFY_STAT', target: 'tradePoints', value: 1 }
              ]
            },
            {
              name: 'Ancestral',
              description: 'You gain 2 Ancestry Points, which you can spend on Traits for your chosen Ancestry.',
              effects: [
                { type: 'MODIFY_STAT', target: 'ancestryPoints', value: 2 }
              ]
            },
            {
              name: 'Knowledge',
              description: 'Your Mastery Limit increases by 1 for all Knowledge Trades. You also gain 2 Skill Points.',
              effects: [
                { type: 'MODIFY_STAT', target: 'knowledgeMasteryLimit', value: 1 },
                { type: 'MODIFY_STAT', target: 'skillPoints', value: 2 }
              ]
            },
            {
              name: 'Trickery',
              description: 'You learn 1 additional Cantrip with the Illusion Spell Tag. Your Mastery Limit for one Skill of your choice increases by 1.',
              effects: [
                { type: 'GRANT_CANTRIP', target: 'illusion_tag', value: 1 },
                { type: 'GRANT_SKILL_EXPERTISE', target: 'any_skill', value: { capIncrease: 1, levelIncrease: 0 }, userChoice: { prompt: 'Choose a Skill for increased Mastery Limit' } }
              ]
            },
            {
              name: 'Light',
              description: 'You learn 1 additional Cantrip with the Holy Spell Tag. Additionally, you learn the Light Cantrip.',
              effects: [
                { type: 'GRANT_CANTRIP', target: 'holy_tag', value: 1 },
                { type: 'GRANT_CANTRIP', target: 'light_cantrip', value: 1 }
              ]
            }
          ]
        }
      ]
    },
    {
      featureName: 'Knowledge',
      levelGained: 1,
      description: 'Your divine connection enhances your understanding.',
      effects: [
        { type: 'MODIFY_STAT', target: 'knowledgeMasteryLimit', value: 1 },
        { type: 'MODIFY_STAT', target: 'skillPoints', value: 2 }
      ]
    },
    {
      featureName: 'Divine Blessing',
      levelGained: 2,
      description: 'You can spend 2 AP to grant a creature within 5 Spaces a d8 Help Die for any d20 Check, Attack, or Save. You can do this a number of times equal to your Charisma (minimum 1), and you regain all uses when you finish a Long Rest.',
      effects: [
        { type: 'GRANT_ABILITY', target: 'divine_blessing', value: 'Spend 2 AP to grant d8 Help Die within 5 Spaces, uses = Charisma (min 1) per Long Rest.' }
      ]
    }
  ],
  subclasses: []
};
```

## File: src/lib/rulesdata/_new_schema/monk_features.ts
```typescript
import type { ClassDefinition } from '../schemas/character.schema';

export const monkClass: ClassDefinition = {
	className: 'Monk',
	startingEquipment: {
		weaponsOrShields: ['2 Weapons', '3 Weapons with the Toss or Thrown Property'],
		armor: '1 set of Light Armor',
		packs: 'X or Y Packs (Adventuring Packs Coming Soon)'
	},
	martialPath: {
		combatTraining: {
			weapons: ['Weapons'],
			armor: ['Light Armor']
		},
		maneuvers: {
			learnsAllAttack: true,
			additionalKnown: 'Maneuvers Known column of the Monk Class Table'
		},
		techniques: {
			additionalKnown: 'Techniques Known column of the Monk Class Table'
		},
		staminaPoints: {
			maximumIncreasesBy: 'Stamina Points column of the Monk Class Table'
		},
		staminaRegen: {
			description: 'Once per round, you can regain up to half your maximum SP when you succeed on an Attack Check, Athletics Check, or Acrobatics Check.',
			conditions: []
		}
	},
	coreFeatures: [
		{
			id: 'monk_training',
			featureName: 'Monk Training',
			levelGained: 1,
			description: 'Your martial arts training grants you greater offense, defense, and movement.',
			effects: [
				{
					type: 'GRANT_ABILITY',
					target: 'iron_palm',
					value: 'Your limbs are considered Natural Weapons with the Impact Property that deal 1 Bludgeoning damage.'
				},
				{
					type: 'MODIFY_STAT',
					target: 'pd',
					value: 2,
					condition: 'not_wearing_armor'
				},
				{
					type: 'MODIFY_STAT',
					target: 'moveSpeed',
					value: 1,
					condition: 'not_wearing_armor'
				},
				{
					type: 'MODIFY_STAT',
					target: 'jumpDistance',
					value: 1,
					condition: 'not_wearing_armor'
				},
				{
					type: 'GRANT_ABILITY',
					target: 'step_of_wind',
					value: 'While not wearing Armor: move on vertical surfaces and across liquids, use Prime Modifier for Jump Distance and Fall damage.'
				}
			]
		},
		{
			id: 'monk_stance',
			featureName: 'Monk Stance',
			levelGained: 1,
			description: 'You learn 2 Monk Stances. You can enter/swap stances at the start of your turn or spend 1 SP to swap during your turn.',
			effects: [
				{
					type: 'GRANT_CHOICE',
					target: 'monk_stances',
					value: {
						prompt: 'Learn 2 Monk Stances',
						count: 2,
						options: [
							'bear_stance',
							'bull_stance', 
							'cobra_stance',
							'gazelle_stance',
							'tiger_stance',
							'turtle_stance'
						]
					},
					userChoice: {
						prompt: 'Choose 2 Monk Stances to learn',
						options: [
							'Bear Stance (Big Hits)',
							'Bull Stance (Knockback)',
							'Cobra Stance (Counter)',
							'Gazelle Stance (Nimble)',
							'Tiger Stance (Mobility)',
							'Turtle Stance (Defense)'
						]
					}
				}
			]
		},
		{
			id: 'mastery_progression',
			featureName: 'Mastery Progression',
			levelGained: 1,
			description: 'You gain Combat Mastery progression as shown on the class table.',
			effects: [
				{
					type: 'MODIFY_STAT',
					target: 'combatMastery',
					value: 'level_based'
				}
			]
		}
	]
};
```

## File: src/lib/rulesdata/_new_schema/rogue_features.ts
```typescript
import type { ClassDefinition } from '../schemas/character.schema';

export const rogueClass: ClassDefinition = {
	className: 'Rogue',
	startingEquipment: {
		weaponsOrShields: ['3 Weapons', '1 Shield'],
		armor: '1 set of Light Armor',
		packs: 'X or Y Packs (Adventuring Packs Coming Soon)'
	},
	martialPath: {
		combatTraining: {
			weapons: ['Weapons'],
			armor: ['Light Armor']
		},
		maneuvers: {
			learnsAllAttack: true,
			additionalKnown: 'Maneuvers Known column of the Rogue Class Table'
		},
		techniques: {
			additionalKnown: 'Techniques Known column of the Rogue Class Table'
		},
		staminaPoints: {
			maximumIncreasesBy: 'Stamina Points column of the Rogue Class Table'
		}
	},
	coreFeatures: [
		{
			id: 'rogue_expertise',
			featureName: 'Expertise',
			levelGained: 1,
			description: 'Choose 2 Skills. Your Mastery Cap and Mastery Level in those Skills both increase by 1.',
			effects: [
				{
					type: 'GRANT_SKILL_EXPERTISE',
					target: 'any_skill',
					value: { capIncrease: 1, levelIncrease: 1 },
					userChoice: {
						prompt: 'Choose 2 Skills for Expertise',
						count: 2
					}
				}
			]
		},
		{
			id: 'sneak_attack',
			featureName: 'Sneak Attack',
			levelGained: 1,
			description: 'Once per turn, you can deal extra damage when you have ADV on an Attack Check or when you Flank the target.',
			effects: [
				{
					type: 'GRANT_ABILITY',
					target: 'sneak_attack',
					value: 'Once per turn: extra damage on attacks with ADV or when Flanking.'
				}
			]
		},
		{
			id: 'thieves_cant',
			featureName: 'Thieves\' Cant',
			levelGained: 1,
			description: 'You know a secret mix of dialect, jargon, and code that allows you to hide messages in seemingly normal conversation.',
			effects: [
				{
					type: 'GRANT_ABILITY',
					target: 'thieves_cant',
					value: 'Secret language for hiding messages in normal conversation.'
				}
			]
		},
		{
			id: 'cunning_action',
			featureName: 'Cunning Action',
			levelGained: 2,
			description: 'You can use your Minor Action to take the Disengage, Hide, or Dash action.',
			effects: [
				{
					type: 'GRANT_ABILITY',
					target: 'cunning_action',
					value: 'Use Minor Action for Disengage, Hide, or Dash.'
				}
			]
		}
	]
};
```

## File: src/lib/rulesdata/_new_schema/sorcerer_features.ts
```typescript
import type { ClassDefinition } from '../schemas/character.schema';

export const sorcererClass: ClassDefinition = {
	className: 'Sorcerer',
	startingEquipment: {
		weaponsOrShields: ['2 Weapons'],
		armor: '1 set of Light Armor',
		packs: 'X or Y Packs (Adventuring Packs Coming Soon)'
	},
	spellcasterPath: {
		spellcastingProgression: 'full',
		spellcastingAttribute: 'charisma',
		spellsKnown: {
			description: 'Spells Known column of the Sorcerer Class Table'
		},
		ritualCasting: false,
		spellPreparation: false
	},
	coreFeatures: [
		{
			id: 'draconic_bloodline',
			featureName: 'Draconic Bloodline',
			levelGained: 1,
			description: 'Choose a draconic ancestor. You gain resistance to the associated damage type and bonus spells.',
			effects: [
				{
					type: 'GRANT_CHOICE',
					target: 'draconic_bloodline',
					value: {
						prompt: 'Choose your Draconic Bloodline',
						options: ['red', 'blue', 'green', 'black', 'white', 'gold', 'silver', 'bronze', 'copper', 'brass']
					},
					userChoice: {
						prompt: 'Choose your Draconic Ancestor',
						options: [
							'Red Dragon (Fire)',
							'Blue Dragon (Lightning)', 
							'Green Dragon (Poison)',
							'Black Dragon (Acid)',
							'White Dragon (Cold)',
							'Gold Dragon (Fire)',
							'Silver Dragon (Cold)',
							'Bronze Dragon (Lightning)',
							'Copper Dragon (Acid)',
							'Brass Dragon (Fire)'
						]
					}
				}
			]
		},
		{
			id: 'draconic_resilience',
			featureName: 'Draconic Resilience',
			levelGained: 1,
			description: 'Your hit point maximum increases by 1, and it increases by 1 again whenever you gain a level in this class.',
			effects: [
				{
					type: 'MODIFY_STAT',
					target: 'hpMax',
					value: 1
				}
			]
		},
		{
			id: 'sorcery_points',
			featureName: 'Sorcery Points',
			levelGained: 2,
			description: 'You have sorcery points equal to your sorcerer level. You can use these to cast additional spells or enhance your magic.',
			effects: [
				{
					type: 'GRANT_RESOURCE',
					target: 'sorcery_points',
					value: 'level'
				}
			]
		},
		{
			id: 'metamagic',
			featureName: 'Metamagic',
			levelGained: 3,
			description: 'You gain the ability to twist your spells to suit your needs. You learn metamagic options that you can use with sorcery points.',
			effects: [
				{
					type: 'GRANT_CHOICE',
					target: 'metamagic_options',
					value: {
						prompt: 'Choose 2 Metamagic options',
						count: 2,
						options: ['careful_spell', 'distant_spell', 'empowered_spell', 'extended_spell', 'heightened_spell', 'quickened_spell', 'subtle_spell', 'twinned_spell']
					},
					userChoice: {
						prompt: 'Choose 2 Metamagic options',
						options: [
							'Careful Spell',
							'Distant Spell',
							'Empowered Spell',
							'Extended Spell',
							'Heightened Spell',
							'Quickened Spell',
							'Subtle Spell',
							'Twinned Spell'
						]
					}
				}
			]
		}
	]
};
```

## File: src/lib/rulesdata/_new_schema/spellblade_features.ts
```typescript
import type { ClassDefinition } from '../schemas/character.schema';

export const spellbladeClass: ClassDefinition = {
	className: 'Spellblade',
	startingEquipment: {
		weaponsOrShields: ['3 Weapons', '1 Shield'],
		armor: '1 set of Light Armor',
		packs: 'X or Y Packs (Adventuring Packs Coming Soon)'
	},
	hybridPath: {
		martialAspect: {
			combatTraining: {
				weapons: ['Weapons'],
				armor: ['Light Armor', 'Heavy Armor'],
				shields: ['All Shields']
			},
			maneuvers: {
				learnsAllAttack: true,
				additionalKnown: 'Maneuvers Known column of the Spellblade Class Table'
			},
			techniques: {
				additionalKnown: 'Techniques Known column of the Spellblade Class Table'
			},
			staminaPoints: {
				maximumIncreasesBy: 'Stamina Points column of the Spellblade Class Table'
			}
		},
		spellcastingAspect: {
			spellcastingProgression: 'half',
			spellcastingAttribute: 'intelligence',
			spellsKnown: {
				description: 'Spells Known column of the Spellblade Class Table'
			},
			ritualCasting: true,
			spellPreparation: true
		}
	},
	coreFeatures: [
		{
			id: 'fighting_style',
			featureName: 'Fighting Style',
			levelGained: 1,
			description: 'You adopt a particular style of fighting as your specialty. Choose one Fighting Style.',
			effects: [
				{
					type: 'GRANT_CHOICE',
					target: 'fighting_style',
					value: {
						prompt: 'Choose a Fighting Style',
						options: ['defense', 'dueling', 'great_weapon_fighting', 'protection', 'two_weapon_fighting']
					},
					userChoice: {
						prompt: 'Choose your Fighting Style',
						options: [
							'Defense (+1 AD while wearing armor)',
							'Dueling (+2 damage with one-handed weapons)',
							'Great Weapon Fighting (reroll 1s and 2s on damage)',
							'Protection (use reaction to impose DisADV)',
							'Two-Weapon Fighting (add ability modifier to off-hand damage)'
						]
					}
				}
			]
		},
		{
			id: 'spellstrike',
			featureName: 'Spellstrike',
			levelGained: 2,
			description: 'When you cast a spell that requires a Spell Attack, you can deliver the spell through a weapon attack.',
			effects: [
				{
					type: 'GRANT_ABILITY',
					target: 'spellstrike',
					value: 'Deliver touch spells through weapon attacks.'
				}
			]
		},
		{
			id: 'arcane_weapon',
			featureName: 'Arcane Weapon',
			levelGained: 2,
			description: 'You can use a bonus action to imbue a weapon you\'re holding with magical energy.',
			effects: [
				{
					type: 'GRANT_ABILITY',
					target: 'arcane_weapon',
					value: 'Imbue weapons with magical energy for enhanced damage.'
				}
			]
		}
	]
};
```

## File: src/lib/rulesdata/_new_schema/warlock_features.ts
```typescript
import type { ClassDefinition } from '../schemas/character.schema';

export const warlockClass: ClassDefinition = {
	className: 'Warlock',
	startingEquipment: {
		weaponsOrShields: ['2 Weapons'],
		armor: '1 set of Light Armor',
		packs: 'X or Y Packs (Adventuring Packs Coming Soon)'
	},
	spellcasterPath: {
		spellcastingProgression: 'warlock',
		spellcastingAttribute: 'charisma',
		spellsKnown: {
			description: 'Spells Known column of the Warlock Class Table'
		},
		ritualCasting: false,
		spellPreparation: false
	},
	coreFeatures: [
		{
			id: 'otherworldly_patron',
			featureName: 'Otherworldly Patron',
			levelGained: 1,
			description: 'You have struck a pact with an otherworldly being. Choose your patron type.',
			effects: [
				{
					type: 'GRANT_CHOICE',
					target: 'warlock_patron',
					value: {
						prompt: 'Choose your Otherworldly Patron',
						options: ['archfey', 'fiend', 'great_old_one', 'celestial', 'hexblade']
					},
					userChoice: {
						prompt: 'Choose your Otherworldly Patron',
						options: [
							'The Archfey',
							'The Fiend',
							'The Great Old One',
							'The Celestial',
							'The Hexblade'
						]
					}
				}
			]
		},
		{
			id: 'pact_magic',
			featureName: 'Pact Magic',
			levelGained: 1,
			description: 'Your arcane research and magic bestowed by your patron have given you facility with spells.',
			effects: [
				{
					type: 'GRANT_SPELLCASTING',
					target: 'warlock_spellcasting',
					value: 'Pact Magic: short rest spell slot recovery'
				}
			]
		},
		{
			id: 'eldritch_invocations',
			featureName: 'Eldritch Invocations',
			levelGained: 2,
			description: 'You learn eldritch invocations, fragments of forbidden knowledge that imbue you with an abiding magical ability.',
			effects: [
				{
					type: 'GRANT_CHOICE',
					target: 'eldritch_invocations',
					value: {
						prompt: 'Choose 2 Eldritch Invocations',
						count: 2,
						options: ['agonizing_blast', 'armor_of_shadows', 'beast_speech', 'beguiling_influence', 'devil_sight', 'eldritch_sight', 'eyes_of_rune_keeper', 'fiendish_vigor']
					},
					userChoice: {
						prompt: 'Choose 2 Eldritch Invocations',
						options: [
							'Agonizing Blast',
							'Armor of Shadows',
							'Beast Speech',
							'Beguiling Influence',
							'Devil\'s Sight',
							'Eldritch Sight',
							'Eyes of the Rune Keeper',
							'Fiendish Vigor'
						]
					}
				}
			]
		},
		{
			id: 'pact_boon',
			featureName: 'Pact Boon',
			levelGained: 3,
			description: 'Your otherworldly patron bestows a gift upon you for your loyal service.',
			effects: [
				{
					type: 'GRANT_CHOICE',
					target: 'pact_boon',
					value: {
						prompt: 'Choose your Pact Boon',
						options: ['chain', 'blade', 'tome']
					},
					userChoice: {
						prompt: 'Choose your Pact Boon',
						options: [
							'Pact of the Chain (familiar)',
							'Pact of the Blade (magical weapon)',
							'Pact of the Tome (ritual spells)'
						]
					}
				}
			]
		}
	]
};
```

## File: src/lib/rulesdata/_new_schema/wizard_features.ts
```typescript
/**
 * Wizard Class Definition - New Effect Schema
 * Based on DC20 Wizard features with spell school specialization
 */

import type { ClassDefinition } from '../schemas/character.schema';

export const wizardClass: ClassDefinition = {
  className: 'Wizard',
  startingStats: {
    hp: 6,
    sp: 0,
    mp: 6,
    skillPoints: 4,
    tradePoints: 3,
    languagePoints: 2,
    maneuversKnown: 0,
    techniquesKnown: 0,
    cantripsKnown: 3,
    spellsKnown: 4
  },
  coreFeatures: [
    {
      featureName: 'Spellcasting Path',
      levelGained: 1,
      description: 'You gain the ability to cast arcane spells.',
      effects: [
        { type: 'GRANT_COMBAT_TRAINING', target: 'Light_Armor', value: true }
      ]
    },
    {
      featureName: 'Spell School Initiate',
      levelGained: 1,
      description: 'You have completed training in a specialized School of Magic.',
      choices: [
        {
          id: 'wizard_spell_school_initiate_0',
          prompt: 'Choose your specialized Spell School',
          count: 1,
          options: [
            {
              name: 'Fire & Flames',
              description: 'Specialize in fire magic and flame manipulation.',
              effects: [
                { type: 'GRANT_CANTRIP', target: 'fire_flames_school', value: 1 },
                { type: 'GRANT_SPELL', target: 'fire_flames_school', value: 1 },
                { type: 'GRANT_ABILITY', target: 'signature_school_fire', value: 'Reduce MP cost by 1 for Fire & Flames spells (once per Long Rest, regain on Initiative).' }
              ]
            },
            {
              name: 'Ice & Illusions',
              description: 'Specialize in ice magic and illusion spells.',
              effects: [
                { type: 'GRANT_CANTRIP', target: 'ice_illusions_school', value: 1 },
                { type: 'GRANT_SPELL', target: 'ice_illusions_school', value: 1 },
                { type: 'GRANT_ABILITY', target: 'signature_school_ice', value: 'Reduce MP cost by 1 for Ice & Illusions spells (once per Long Rest, regain on Initiative).' }
              ]
            },
            {
              name: 'Lightning & Teleportation',
              description: 'Specialize in lightning magic and teleportation spells.',
              effects: [
                { type: 'GRANT_CANTRIP', target: 'lightning_teleportation_school', value: 1 },
                { type: 'GRANT_SPELL', target: 'lightning_teleportation_school', value: 1 },
                { type: 'GRANT_ABILITY', target: 'signature_school_lightning', value: 'Reduce MP cost by 1 for Lightning & Teleportation spells (once per Long Rest, regain on Initiative).' }
              ]
            },
            {
              name: 'Psychic & Enchantment',
              description: 'Specialize in psychic magic and enchantment spells.',
              effects: [
                { type: 'GRANT_CANTRIP', target: 'psychic_enchantment_school', value: 1 },
                { type: 'GRANT_SPELL', target: 'psychic_enchantment_school', value: 1 },
                { type: 'GRANT_ABILITY', target: 'signature_school_psychic', value: 'Reduce MP cost by 1 for Psychic & Enchantment spells (once per Long Rest, regain on Initiative).' }
              ]
            }
          ]
        }
      ]
    },
    {
      featureName: 'Arcane Sigil',
      levelGained: 1,
      description: 'You can spend 1 AP and 1 MP to create a 1 Space diameter Arcane Sigil on the ground beneath you that lasts for 1 minute.',
      effects: [
        { type: 'GRANT_ABILITY', target: 'arcane_sigil', value: 'Create Arcane Sigil (1 AP + 1 MP): 1 Space area, choose School/Tag, creatures within have ADV on Spell Checks for that type. Can teleport sigil 1 AP within 10 spaces.' }
      ]
    },
    {
      featureName: 'Ritual Caster',
      levelGained: 1,
      description: 'You learn Arcane Spells with the Ritual Spell Tag and can cast them as rituals.',
      isFlavor: true,
      effects: [
        { type: 'GRANT_ABILITY', target: 'ritual_caster', value: 'Learn 1 Ritual Spell per Wizard level. Can study and learn Ritual Spells from external sources (hours = MP cost).' }
      ]
    },
    {
      featureName: 'Prepared Spell',
      levelGained: 2,
      description: 'When you complete a Long Rest, choose 1 Spell you know to become your Prepared Spell.',
      effects: [
        { type: 'GRANT_ABILITY', target: 'prepared_spell', value: 'Choose 1 Prepared Spell per Long Rest: Mana Limit Break (+1 to Spend Limit once per Long Rest, regain on Initiative) and Rehearsed Casting (opponents have DisADV in Spell Duels).' }
      ]
    }
  ],
  subclasses: [
    {
      subclassName: 'Portal Mage',
      description: 'Masters of dimensional magic and teleportation.',
      features: [
        {
          featureName: 'Portal Magic',
          levelGained: 3,
          description: 'You gain advanced teleportation abilities.',
          effects: [
            { type: 'GRANT_ABILITY', target: 'portal_magic', value: 'Advanced teleportation and dimensional magic abilities.' }
          ]
        }
      ]
    }
  ]
};
```

## File: src/lib/rulesdata/loaders/class.loader.ts
```typescript
import { classesDataSchema, type IClassDefinition } from '../schemas/class.schema';

// Use Vite's import.meta.glob to import only the class table JSON files.
// The `eager: true` option imports the modules directly, so they are available synchronously.
const tableModules = import.meta.glob('../_new_schema/*_table.json', { eager: true });

// Extract the default export (the class object) from each module.
const tableData = Object.values(tableModules).map((module: any) => module.default);

// Create progression data structure from table files (stats only, no features)
const compatibleData = tableData.map((classTable: any) => {
	const className = classTable.className;
	
	// Map class names to their descriptions
	const classDescriptions: { [key: string]: string } = {
		'Barbarian': 'A fierce warrior who channels primal rage to gain strength and resist harm in combat.',
		'Bard': 'A charismatic performer whose songs and stories inspire allies and manipulate enemies through magic.',
		'Champion': 'A martial master focused on critical strikes, resilience, and battlefield leadership.',
		'Cleric': 'A divine spellcaster empowered by a god to heal, protect, and smite enemies with holy might.',
		'Commander': 'A tactical leader who inspires and directs allies with strategic maneuvers and commanding presence.',
		'Druid': 'A nature-bound spellcaster who wields primal magic and transforms into beasts to protect the wilds.',
		'Hunter': 'A skilled tracker and marksman who specializes in slaying monsters and surviving the wilderness.',
		'Monk': 'A disciplined martial artist who channels inner energy for rapid strikes and supernatural movement.',
		'Rogue': 'A stealthy and cunning adventurer who excels in ambushes, trickery, and precise strikes.',
		'Sorcerer': 'A natural-born spellcaster who harnesses raw arcane or elemental power from an innate source.',
		'Spellblade': 'A warrior-mage hybrid who combines martial prowess with arcane magic to enchant weapons and defend.',
		'Warlock': 'A spellcaster who draws power from a pact with a mysterious or dark patron, gaining unique abilities.',
		'Wizard': 'A scholarly arcane caster who learns spells through study and masters a broad range of magical effects.'
	};

	return {
		id: className.toLowerCase(),
		name: className,
		description: classDescriptions[className] || `${className} class progression table`,
		baseHpContribution: classTable.levelProgression?.[0]?.healthPoints || 0,
		startingSP: classTable.levelProgression?.[0]?.staminaPoints || 0,
		startingMP: classTable.levelProgression?.[0]?.manaPoints || 0,
		// Add other required fields with default values
		skillPointGrantLvl1: classTable.levelProgression?.[0]?.skillPoints || 0,
		tradePointGrantLvl1: classTable.levelProgression?.[0]?.tradePoints || 0,
		combatTraining: [],
		maneuversKnownLvl1: classTable.levelProgression?.[0]?.maneuversKnown || 0,
		techniquesKnownLvl1: classTable.levelProgression?.[0]?.techniquesKnown || 0,
		saveDCBase: 8,
		deathThresholdBase: 10,
		moveSpeedBase: 5, // DC20: Base movement speed is 5 spaces
		restPointsBase: 4,
		gritPointsBase: 2,
		initiativeBonusBase: 0,
		cantripsKnownLvl1: classTable.levelProgression?.[0]?.cantripsKnown || 0,
		spellsKnownLvl1: classTable.levelProgression?.[0]?.spellsKnown || 0,
		// Store the full level progression for future level gaining
		levelProgression: classTable.levelProgression,
		// Empty arrays for features - these should be handled by class-features.loader.ts
		level1Features: [],
		featureChoicesLvl1: []
	};
});

// Validate the combined data against the Zod schema.
// The parse method will throw a detailed error if validation fails.
const validatedData = classesDataSchema.parse(compatibleData);

// Export the validated data with the correct type.
export const classesData: IClassDefinition[] = validatedData;
```

## File: src/lib/rulesdata/schemas/character.schema.ts
```typescript
/**
 * @file src/lib/rulesdata/schemas/character.schema.ts
 * @description The definitive schema for all character creation data, designed for robust, machine-readable processing.
 */

// ================================================================= //
// I. CORE EFFECT MODEL - The Heart of the System
// ================================================================= //

/**
 * A universal, machine-readable representation of a single mechanical effect.
 * This can be attached to traits, class features, choices, items, etc.
 */
export interface Effect {
  /** The action to be performed by the calculation engine. */
  type:
    // --- Stat & Attribute Modification ---
    | 'MODIFY_ATTRIBUTE'        // Modifies a core attribute (Might, Agility, etc.).
    | 'MODIFY_STAT'             // Modifies a derived or resource stat (hpMax, pd, moveSpeed, etc.).
    | 'SET_VALUE'               // Overrides a stat with a specific value or another stat's value.

    // --- Grants & Abilities ---
    | 'GRANT_ABILITY'           // Grants a descriptive, in-game ability or feature.
    | 'GRANT_RESISTANCE'        // Grants resistance to damage types or conditions.
    | 'GRANT_VULNERABILITY'     // Grants vulnerability to a damage type.
    | 'GRANT_ADV_ON_SAVE'       // Grants advantage on saves against specific conditions or types.
    | 'GRANT_ADV_ON_CHECK'      // Grants advantage on specific skill/ability checks.
    | 'GRANT_COMBAT_TRAINING'   // Grants proficiency with armor, weapons, or shields.
    | 'GRANT_MOVEMENT'          // Grants a special movement type like Climb or Swim.
    | 'GRANT_SENSE'             // Grants a sense like Darkvision or Tremorsense.

    // --- Choices & Progression ---
    | 'GRANT_CHOICE'            // Grants the player a choice (e.g., learn 2 maneuvers).
    | 'GRANT_SKILL_EXPERTISE'   // A specific effect for Human/Rogue skill expertise.
    | 'GRANT_TRADE_EXPERTISE'   // A specific effect for Human trade expertise.
    | 'GRANT_SPELL'             // Grants a known spell.
    | 'GRANT_CANTRIP'           // Grants a known cantrip.
    | 'GRANT_MANEUVERS'         // Grants knowledge of maneuvers.
    | 'GRANT_TECHNIQUES'        // Grants knowledge of techniques.
    ;

  /** The specific stat, attribute, or item being affected. Standardized for the calculator. */
  target: string; // e.g., 'might', 'hpMax', 'pd', 'ad', 'moveSpeed', 'jumpDistance', 'deathThresholdModifier', 'skillPoints', 'attributePoints', 'ancestryPoints', 'maneuver', 'technique', 'Poison', 'Charmed', 'Heavy_Armor', 'climb', 'darkvision', 'any_attribute', 'any_skill'

  /** The value of the effect. Can be a number, string, or complex object. */
  value: number | string | boolean | { [key: string]: any }; // e.g., 1, -1, 'half', 'equal_to_speed', true, { capIncrease: 1, levelIncrease: 1 }

  /** An optional condition under which this effect is active. */
  condition?: string; // e.g., 'not_wearing_armor', 'bloodied'

  /** If this effect requires a choice from the player to be resolved. */
  userChoice?: {
    prompt: string;
    options?: string[]; // e.g., ['might', 'agility', 'charisma', 'intelligence']
  };
}


// ================================================================= //
// II. ANCESTRY & TRAIT SCHEMAS
// ================================================================= //

export interface Trait {
  id: string;
  name: string;
  description: string;
  cost: number;
  isMinor?: boolean;
  isNegative?: boolean;
  prerequisites?: string[];
  effects: Effect[]; // Every mechanical benefit is now an Effect.
}

export interface Ancestry {
  id: string;
  name: string;
  description: string;
  defaultTraitIds: string[];
  expandedTraitIds: string[];
  origin?: {
    prompt: string;
    options: string[];
  };
  variantTraits?: Trait[];
}


// ================================================================= //
// III. CLASS & FEATURE SCHEMAS
// ================================================================= //

/** A named benefit within a larger class feature, containing its own effects. */
export interface FeatureBenefit {
  name: string;
  description: string;
  effects: Effect[];
}

/** An option a player can select as part of a feature choice. */
export interface FeatureChoiceOption {
  name: string;      // The value/ID of the option.
  description: string;
  effects: Effect[]; // Effects granted if this specific option is chosen.
}

/** A choice presented to the player by a class feature. */
export interface FeatureChoice {
  id: string; // A unique ID for this choice, e.g., "cleric_divine_domain_choice"
  prompt: string;
  count: number; // Number of options the player must select.
  options: FeatureChoiceOption[];
}

/** A single class feature, either core or from a subclass. */
export interface ClassFeature {
  featureName: string;
  levelGained: number;
  description: string;
  isFlavor?: boolean;
  /** Direct effects of the feature, applied automatically. */
  effects?: Effect[];
  /** Named sub-sections of a feature, each with its own effects. */
  benefits?: FeatureBenefit[];
  /** Choices the player must make to fully define the feature. */
  choices?: FeatureChoice[];
}

/** A subclass option for a given class. */
export interface Subclass {
  subclassName: string;
  description?: string;
  features: ClassFeature[];
}

/** The complete, robust definition for a single class. */
export interface ClassDefinition {
  className: string;
  // This section contains data derived from the level progression table for easy access at Lvl 1.
  startingStats: {
      hp: number;
      sp: number;
      mp: number;
      skillPoints: number;
      tradePoints: number;
      languagePoints: number;
      maneuversKnown: number;
      techniquesKnown: number;
      cantripsKnown: number;
      spellsKnown: number;
  };
  coreFeatures: ClassFeature[];
  subclasses: Subclass[];
}

// ================================================================= //
// IV. CALCULATION DATA STRUCTURES
// ================================================================= //

/** Aggregated stat modifiers from all effects */
export interface StatModifiers {
  // Attributes
  might: number;
  agility: number;
  charisma: number;
  intelligence: number;

  // Core Stats
  hpMax: number;
  spMax: number;
  mpMax: number;
  pd: number;
  ad: number;
  pdr: number;
  
  // Movement & Combat
  moveSpeed: number;
  jumpDistance: number;
  deathThresholdModifier: number;
  saveDC: number;
  initiativeBonus: number;
  
  // Resource Stats
  skillPoints: number;
  tradePoints: number;
  languagePoints: number;
  attributePoints: number;
  ancestryPoints: number;
  restPoints: number;
  gritPoints: number;
  
  // Learning Stats
  maneuversKnown: number;
  techniquesKnown: number;
  cantripsKnown: number;
  spellsKnown: number;
  skillMasteryLimit: number;
  tradeMasteryLimit: number;
  knowledgeMasteryLimit: number;
}

/** Conditional modifiers that depend on circumstances */
export interface ConditionalModifier {
  effect: Effect;
  condition: string;
  description: string;
}

/** Abilities granted to the character (displayed as features) */
export interface GrantedAbility {
  name: string;
  description: string;
  source: string; // e.g., "Human Trait: Determination"
  type: 'passive' | 'active' | 'resistance' | 'advantage';
}

/** Result of effect processing */
export interface EffectProcessingResult {
  statModifiers: StatModifiers;
  conditionalModifiers: ConditionalModifier[];
  grantedAbilities: GrantedAbility[];
  combatTraining: string[];
  resistances: Array<{ type: string; value: string }>;
  vulnerabilities: Array<{ type: string; value: string }>;
  senses: Array<{ type: string; range: number }>;
  movements: Array<{ type: string; speed: string }>;
}
```

## File: src/lib/services/spellAssignment.ts
```typescript
import { allSpells } from '../rulesdata/spells-data/spells';
import { SpellSchool, type ClassName } from '../rulesdata/spells-data/types/spell.types';
import type { SpellData } from '../../types/character';
import { findClassByName } from '../rulesdata/loaders/class-features.loader';
import { classesData } from '../rulesdata/loaders/class.loader';

export interface SpellAssignmentOptions {
	className: string;
	level: number;
	selectedFeatureChoices: Record<string, string>; // Typed feature choices
}

/**
 * Automatically assigns spells to a character based on their class and level
 */
export const assignSpellsToCharacter = (options: SpellAssignmentOptions): SpellData[] => {
	const { className, level, selectedFeatureChoices } = options;
	
	// Get class data
	const classData = classesData.find(c => c.name === className);
	if (!classData) {
		console.warn(`Class data not found for: ${className}`);
		return [];
	}

	// Get class features
	const classFeatures = findClassByName(className);
	if (!classFeatures) {
		console.warn(`Class features not found for: ${className}`);
		return [];
	}

	// Use feature choices directly
	const featureChoices: { [key: string]: string } = selectedFeatureChoices || {};

	// Get available spell schools for this class
	let availableSchools = getAvailableSpellSchools(classFeatures, featureChoices);
	
	// If no schools were determined from feature choices, use default schools
	if (availableSchools.length === 0) {
		availableSchools = getDefaultSpellSchools(className);
		console.log(`No spell schools determined from choices, using defaults for ${className}:`, availableSchools);
	}
	
	// Get spell counts for this level
	const levelData = classData.levelProgression?.find(l => l.level === level);
	if (!levelData) {
		console.warn(`Level data not found for ${className} level ${level}`);
		return [];
	}

	const cantripsToAssign = levelData.cantripsKnown || 0;
	const spellsToAssign = levelData.spellsKnown || 0;

	console.log(`Assigning spells for ${className} level ${level}:`, {
		cantripsToAssign,
		spellsToAssign,
		availableSchools
	});

	// Get available spells for this class and schools
	const availableSpells = getAvailableSpellsForClass(className, availableSchools);
	
	console.log(`Found ${availableSpells.length} available spells for ${className} with schools ${availableSchools}:`, 
		availableSpells.map(s => ({ name: s.name, school: s.school, isCantrip: s.isCantrip })));
	
	// Separate cantrips and spells
	const availableCantrips = availableSpells.filter(spell => spell.isCantrip);
	const availableRegularSpells = availableSpells.filter(spell => !spell.isCantrip);

	console.log(`Available cantrips: ${availableCantrips.length}`, availableCantrips.map(s => s.name));
	console.log(`Available regular spells: ${availableRegularSpells.length}`, availableRegularSpells.map(s => s.name));

	// Assign cantrips first
	const assignedSpells: SpellData[] = [];
	
	// Assign cantrips
	for (let i = 0; i < cantripsToAssign && i < availableCantrips.length; i++) {
		const cantrip = availableCantrips[i];
		assignedSpells.push(createSpellData(cantrip));
	}

	// Assign regular spells
	for (let i = 0; i < spellsToAssign && i < availableRegularSpells.length; i++) {
		const spell = availableRegularSpells[i];
		assignedSpells.push(createSpellData(spell));
	}

	console.log(`Assigned ${assignedSpells.length} spells:`, assignedSpells.map(s => s.spellName));
	
	return assignedSpells;
};

/**
 * Get available spell schools for a class based on feature choices
 */
function getAvailableSpellSchools(classFeatures: any, featureChoices: { [key: string]: string }): SpellSchool[] {
	const schools: SpellSchool[] = [];
	
	// Check if class has spellcasting
	if (!classFeatures.spellcastingPath?.spellList) {
		return schools;
	}

	const spellList = classFeatures.spellcastingPath.spellList;

	// Handle different spell list types
	if (spellList.type === 'all_schools' && spellList.schoolCount) {
		// Warlock-style: get chosen schools from feature choices
		const choiceId = `${classFeatures.className.toLowerCase()}_spell_schools`;
		const choice = featureChoices[choiceId];
		if (choice) {
			try {
				const selectedSchools = JSON.parse(choice);
				schools.push(...selectedSchools);
			} catch (e) {
				console.warn('Failed to parse spell school choices:', choice);
			}
		}
	} else if (spellList.type === 'schools') {
		// Spellblade-style: specific schools + additional chosen schools
		if (spellList.specificSchools) {
			schools.push(...spellList.specificSchools);
		}
		
		if (spellList.schoolCount && spellList.schoolCount > 0) {
			const choiceId = `${classFeatures.className.toLowerCase()}_additional_spell_schools`;
			const choice = featureChoices[choiceId];
			if (choice) {
				try {
					const additionalSchools = spellList.schoolCount > 1 ? JSON.parse(choice) : [choice];
					schools.push(...additionalSchools);
				} catch (e) {
					console.warn('Failed to parse additional spell school choices:', choice);
				}
			}
		}
	} else if (spellList.type === 'any') {
		// Sorcerer-style: any spell list (Arcane, Divine, Primal)
		// For now, default to Arcane spells
		schools.push(SpellSchool.Arcane);
	}

	// Add schools from feature-based choices (like Wizard's Spell School Initiate)
	classFeatures.coreFeatures?.forEach((feature: any) => {
		if (feature.levelGained === 1) {
			const description = feature.description.toLowerCase();
			const isCharacterCreationChoice =
				(description.includes('choose a spell school') ||
					description.includes('choose 1 spell school')) &&
				!description.includes('when you create') &&
				!description.includes('when you cast') &&
				!description.includes('you can spend') &&
				(description.includes('training') ||
					description.includes('specialize') ||
					description.includes('initiate') ||
					description.includes('you gain the following benefits'));

			if (isCharacterCreationChoice) {
				const choiceId = `${classFeatures.className.toLowerCase()}_${feature.featureName.toLowerCase().replace(/\s+/g, '_')}_school`;
				const choice = featureChoices[choiceId];
				if (choice) {
					schools.push(choice as SpellSchool);
				}
			}
		}
	});

	return schools;
}

/**
 * Get available spells for a class and spell schools
 */
function getAvailableSpellsForClass(className: string, schools: SpellSchool[]): any[] {
	// Filter spells by class and schools
	return allSpells.filter(spell => {
		// Check if spell is available to this class
		// Since many spells have empty availableClasses arrays, we'll use a more flexible approach
		const isAvailableToClass = spell.availableClasses.length === 0 || spell.availableClasses.includes(className as ClassName);
		
		// Check if spell is in one of the available schools
		const isInAvailableSchool = schools.includes(spell.school);
		
		return isAvailableToClass && isInAvailableSchool;
	});
}

/**
 * Create SpellData from Spell
 */
function createSpellData(spell: any): SpellData {
	return {
		id: `spell_${Date.now()}_${Math.random()}`,
		spellName: spell.name,
		school: spell.school,
		isCantrip: spell.isCantrip,
		cost: spell.cost,
		range: spell.range,
		duration: spell.duration,
		isPrepared: false,
		notes: ''
	};
}

/**
 * Get default spell schools for a class when no choices have been made
 */
export const getDefaultSpellSchools = (className: string): SpellSchool[] => {
	switch (className.toLowerCase()) {
		case 'wizard':
			return [SpellSchool.Arcane];
		case 'sorcerer':
			return [SpellSchool.Arcane]; // Default to Arcane for Sorcerer
		case 'cleric':
			return [SpellSchool.Restoration];
		case 'druid':
			return [SpellSchool.Restoration];
		case 'warlock':
			return [SpellSchool.Arcane]; // Default to Arcane, but should be chosen
		case 'spellblade':
			return [SpellSchool.Arcane]; // Default schools + chosen additional
		default:
			return [];
	}
};
```

## File: src/lib/utils/storageUtils.spec.ts
```typescript
import { describe, test, expect, beforeEach } from 'vitest';
import { deserializeCharacterFromStorage, serializeCharacterForStorage } from './storageUtils';

describe('storageUtils', () => {
  beforeEach(() => {
    // Clear localStorage before each test
    localStorage.clear();
  });

  test('deserializeCharacterFromStorage auto-migrates old schema versions', () => {
    const oldCharacterJson = JSON.stringify({
      id: 'test-char',
      schemaVersion: 1,
      selectedTraitIds: '["trait1"]', // Old stringified format
      finalName: 'Test Character'
    });

    const result = deserializeCharacterFromStorage(oldCharacterJson);
    
    expect(result).not.toBeNull(); // Should auto-migrate, not drop
    expect(result?.schemaVersion).toBe(2); // Should be migrated to current version
    expect(result?.id).toBe('test-char');
    expect(result?.finalName).toBe('Test Character');
  });

  test('deserializeCharacterFromStorage handles current schema', () => {
    const currentCharacterJson = JSON.stringify({
      id: 'test-char',
      schemaVersion: 2,
      selectedTraitIds: ['trait1'], // New native array format
      selectedFeatureChoices: { choice1: 'value1' },
      skillsData: { athletics: 2 },
      finalName: 'Test Character'
    });

    const result = deserializeCharacterFromStorage(currentCharacterJson);
    
    expect(result).not.toBeNull();
    expect(result?.id).toBe('test-char');
    expect(result?.selectedTraitIds).toEqual(['trait1']);
    expect(result?.selectedFeatureChoices).toEqual({ choice1: 'value1' });
    expect(result?.skillsData).toEqual({ athletics: 2 });
  });

  test('serializeCharacterForStorage adds schemaVersion', () => {
    const character = {
      id: 'test-char',
      selectedTraitIds: ['trait1'],
      selectedFeatureChoices: {},
      skillsData: {},
      tradesData: {},
      languagesData: { common: { fluency: 'fluent' } }
    } as any;

    const serialized = serializeCharacterForStorage(character);
    const parsed = JSON.parse(serialized);
    
    expect(parsed.schemaVersion).toBe(2);
    expect(parsed.selectedTraitIds).toEqual(['trait1']);
  });
});
```

## File: src/routes/character-creation/styles/CharacterCreation.styles.ts
```typescript
// Styled components for CharacterCreation component
import styled from 'styled-components';

export const StyledContainer = styled.div`
	display: flex;
	flex-direction: column;
	gap: 2rem;
	padding: 6rem 1rem 1rem 1rem;
	min-height: 100vh;
	background: transparent;
`;

export const StyledTitle = styled.h1`
	margin: 0rem 0;
	color: #fbbf24;
	text-align: center;
	font-size: 3rem;
	font-weight: bold;
	font-family: 'Cinzel', 'Georgia', 'Times New Roman', serif;
	letter-spacing: 2px;
`;

export const StyledStepIndicator = styled.div`
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 2rem 1.5rem;
	background: rgba(0, 0, 0, 0.9);
	backdrop-filter: blur(10px);
	border-bottom: 2px solid #fbbf24;
	z-index: 100;
`;

export const StyledStepsContainer = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	flex: 1;
	max-width: 600px;
	margin: 0 auto;
`;

export const StyledStep = styled.div<{ $active: boolean; $completed: boolean }>`
	display: flex;
	flex-direction: column;
	align-items: center;
	gap: 0.5rem;
	cursor: pointer;
	transition: all 0.3s ease;
	flex: 1;
	max-width: 120px;
`;

export const StyledStepNumber = styled.div<{ $active: boolean; $completed: boolean }>`
	width: 40px;
	height: 40px;
	border-radius: 50%;
	display: flex;
	align-items: center;
	justify-content: center;
	font-weight: bold;
	font-size: 1.2rem;
	transition: all 0.3s ease;

	${(props) =>
		props.$completed &&
		`
    background: linear-gradient(145deg, #10b981 0%, #059669 100%);
    color: white;
    border: 1px solid #10b981;
  `}

	${(props) =>
		props.$active &&
		!props.$completed &&
		`
    background: linear-gradient(145deg, #fbbf24 0%, #f59e0b 100%);
    color: #1e1b4b;
    border: 1px solid #fbbf24;
  `}
  
  ${(props) =>
		!props.$active &&
		!props.$completed &&
		`
    background: transparent;
    color: #9ca3af;
    border: 1px solid #9ca3af;
  `}
`;

export const StyledStepLabel = styled.span<{ $active: boolean; $completed: boolean }>`
	font-size: 0.9rem;
	font-weight: 600;
	text-align: center;

	${(props) =>
		props.$completed &&
		`
    color: #10b981;
  `}

	${(props) =>
		props.$active &&
		!props.$completed &&
		`
    color: #fbbf24;
  `}
  
  ${(props) =>
		!props.$active &&
		!props.$completed &&
		`
    color: #9ca3af;
  `}
`;

export const StyledNavigationButtons = styled.div`
	display: flex;
	gap: 1rem;
`;

export const StyledButton = styled.button<{ $variant?: 'primary' | 'secondary' }>`
	padding: 0.5rem 1rem;
	border-radius: 6px;
	font-weight: bold;
	font-size: 0.9rem;
	cursor: pointer;
	transition: all 0.3s ease;
	border: none;
	min-width: 80px;

	${(props) =>
		props.$variant === 'primary' &&
		`
    background: linear-gradient(145deg, #fbbf24 0%, #f59e0b 100%);
    color: #1e1b4b;
    
    &:hover {
      background: linear-gradient(145deg, #f59e0b 0%, #d97706 100%);
      box-shadow: 0 4px 12px rgba(251, 191, 36, 0.4);
    }
  `}

	${(props) =>
		props.$variant === 'secondary' &&
		`
    background: transparent;
    color: #9ca3af;
    border: 1px solid #9ca3af;
    
    &:hover {
      color: #fbbf24;
      border-color: #fbbf24;
    }
  `}
  
  &:disabled {
		opacity: 0.5;
		cursor: not-allowed;
		transform: none;
	}
`;
```

## File: src/routes/character-creation/styles/LoadCharacter.styles.ts
```typescript
// Styled components for LoadCharacter component
import styled from 'styled-components';

export const StyledContainer = styled.div`
	padding: 2rem;
	min-height: 100vh;
	background: linear-gradient(135deg, #0f0f23 0%, #1e1b4b 50%, #312e81 100%);
`;

export const StyledTitle = styled.h1`
	margin-bottom: 2rem;
	color: #fbbf24;
	text-align: center;
	font-size: 2.2rem;
	font-weight: bold;
	font-family: 'Cinzel', 'Georgia', 'Times New Roman', serif;
	text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7);
	letter-spacing: 2px;
`;

export const StyledCharacterGrid = styled.div`
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
	gap: 1.5rem;
	max-width: 1200px;
	margin: 0 auto;
`;

export const StyledCharacterCard = styled.div`
	border: 2px solid #8b5cf6;
	border-radius: 12px;
	padding: 1.5rem;
	background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
	box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3);
	transition: all 0.3s ease;

	&:hover {
		transform: translateY(-4px);
		box-shadow: 0 12px 40px rgba(139, 92, 246, 0.4);
		border-color: #fbbf24;
	}
`;

export const StyledCardActions = styled.div`
	display: grid;
	grid-template-columns: 1fr 1fr;
	gap: 0.5rem;
	margin-top: 1rem;
`;

export const StyledActionButton = styled.button<{ variant?: 'primary' | 'secondary' | 'danger' }>`
	flex: 1;
	padding: 0.6rem 1rem;
	border: 2px solid ${(props) => {
		if (props.variant === 'primary') return '#fbbf24';
		if (props.variant === 'danger') return '#ef4444';
		return '#8b5cf6';
	}};
	border-radius: 6px;
	background: ${(props) => {
		if (props.variant === 'primary') return '#fbbf24';
		if (props.variant === 'danger') return 'transparent';
		return 'transparent';
	}};
	color: ${(props) => {
		if (props.variant === 'primary') return '#1e1b4b';
		if (props.variant === 'danger') return '#ef4444';
		return '#8b5cf6';
	}};
	cursor: pointer;
	transition: all 0.3s ease;
	font-size: 0.9rem;
	font-weight: bold;
	outline: none; /* Remove default focus outline */

	&:hover {
		background: ${(props) => {
			if (props.variant === 'primary') return '#f59e0b';
			if (props.variant === 'danger') return '#ef4444';
			return '#8b5cf6';
		}};
		color: ${(props) => {
			if (props.variant === 'primary') return '#1e1b4b';
			if (props.variant === 'danger') return 'white';
			return 'white';
		}};
		transform: translateY(-1px);
	}

	&:focus {
		outline: none;
		box-shadow: 0 0 0 2px ${(props) => {
			if (props.variant === 'primary') return '#fbbf24';
			if (props.variant === 'danger') return '#ef4444';
			return '#8b5cf6';
		}};
	}
`;

export const StyledCharacterName = styled.h2`
	margin: 0 0 1rem 0;
	color: #fbbf24;
	font-size: 1.5rem;
	font-weight: bold;
	text-align: center;
`;

export const StyledPlayerName = styled.p`
	margin: 0 0 1rem 0;
	color: #e5e7eb;
	font-size: 1rem;
	text-align: center;
	opacity: 0.8;
`;

export const StyledCharacterDetails = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 1rem;
`;

export const StyledDetailItem = styled.div`
	text-align: center;
`;

export const StyledDetailLabel = styled.div`
	color: #a855f7;
	font-size: 0.8rem;
	font-weight: bold;
	text-transform: uppercase;
	letter-spacing: 1px;
`;

export const StyledDetailValue = styled.div`
	color: #e5e7eb;
	font-size: 1rem;
	font-weight: bold;
	margin-top: 0.25rem;
`;

export const StyledCompletedDate = styled.p`
	margin: 0;
	color: #6b7280;
	font-size: 0.875rem;
	text-align: center;
	font-style: italic;
`;

export const StyledEmptyState = styled.div`
	text-align: center;
	padding: 4rem 2rem;
	color: #6b7280;
`;

export const StyledEmptyTitle = styled.h2`
	color: #a855f7;
	font-size: 1.5rem;
	margin-bottom: 1rem;
`;

export const StyledEmptyText = styled.p`
	font-size: 1rem;
	line-height: 1.6;
`;

export const StyledBackButton = styled.button`
	padding: 0.75rem 1.5rem;
	margin-bottom: 2rem;
	border: none;
	border-radius: 8px;
	background: linear-gradient(145deg, #6b7280 0%, #4b5563 100%);
	color: white;
	font-weight: bold;
	cursor: pointer;
	transition: all 0.3s ease;

	&:hover {
		background: linear-gradient(145deg, #4b5563 0%, #374151 100%);
		transform: translateY(-2px);
	}
`;

// Modal styles for delete confirmation
export const StyledModalOverlay = styled.div`
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background: rgba(0, 0, 0, 0.7);
	display: flex;
	justify-content: center;
	align-items: center;
	z-index: 1000;
`;

export const StyledModalContent = styled.div`
	background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%);
	border: 2px solid #ef4444;
	border-radius: 12px;
	padding: 2rem;
	max-width: 400px;
	width: 90%;
	text-align: center;
	box-shadow: 0 8px 32px rgba(239, 68, 68, 0.3);
`;

export const StyledModalTitle = styled.h3`
	color: #ef4444;
	font-size: 1.5rem;
	margin-bottom: 1rem;
	font-weight: bold;
`;

export const StyledModalMessage = styled.p`
	color: #e5e7eb;
	font-size: 1rem;
	margin-bottom: 2rem;
	line-height: 1.5;
`;

export const StyledModalActions = styled.div`
	display: flex;
	gap: 1rem;
	justify-content: center;
`;

export const StyledModalButton = styled.button<{ variant: 'cancel' | 'delete' }>`
	padding: 0.75rem 1.5rem;
	border: 2px solid ${(props) => (props.variant === 'delete' ? '#ef4444' : '#6b7280')};
	border-radius: 6px;
	background: ${(props) => (props.variant === 'delete' ? '#ef4444' : 'transparent')};
	color: ${(props) => (props.variant === 'delete' ? 'white' : '#6b7280')};
	cursor: pointer;
	transition: all 0.3s ease;
	font-size: 0.9rem;
	font-weight: bold;

	&:hover {
		background: ${(props) => (props.variant === 'delete' ? '#dc2626' : '#6b7280')};
		color: white;
		transform: translateY(-1px);
	}
`;
```

## File: src/routes/character-creation/ClassSelector.tsx
```typescript
import { useCharacter } from '../../lib/stores/characterContext';
import { classesData } from '../../lib/rulesdata/loaders/class.loader';
import {
	StyledContainer,
	StyledTitle,
	StyledGrid,
	StyledCard,
	StyledCardHeader,
	StyledClassIcon,
	StyledCardTitle,
	StyledCardDescription
} from './styles/ClassSelector.styles';

// Class-specific icons using Unicode symbols and emojis
const classIcons: { [key: string]: string } = {
	fighter: '⚔️',
	wizard: '🧙‍♂️',
	rogue: '🗡️',
	cleric: '✨',
	ranger: '🏹',
	barbarian: '🪓',
	bard: '🎭',
	druid: '🌿',
	monk: '👊',
	paladin: '🛡️',
	sorcerer: '🔥',
	warlock: '👹',
	default: '⚡'
};

function ClassSelector() {
	const { state, dispatch } = useCharacter();
	const selectedClassId = state.classId;

	function handleSelectClass(classId: string) {
		if (state.classId?.toLowerCase() === classId.toLowerCase()) {
			dispatch({ type: 'SET_CLASS', classId: null }); // Deselect if already selected
		} else {
			dispatch({ type: 'SET_CLASS', classId }); // Select new class
		}
	}

	function getClassIcon(classId: string): string {
		return classIcons[classId.toLowerCase()] || classIcons.default;
	}

	return (
		<StyledContainer>
			<StyledTitle>Choose Your Class</StyledTitle>
			<StyledGrid>
				{classesData.map((classDef) => (
					<StyledCard
						key={classDef.id}
						type="button"
						$selected={selectedClassId === classDef.id}
						onClick={() => handleSelectClass(classDef.id)}
					>
						<StyledCardHeader>
							<StyledClassIcon>{getClassIcon(classDef.id)}</StyledClassIcon>
							<StyledCardTitle>{classDef.name}</StyledCardTitle>
						</StyledCardHeader>
						<StyledCardDescription>{classDef.description}</StyledCardDescription>
					</StyledCard>
				))}
			</StyledGrid>
		</StyledContainer>
	);
}

export default ClassSelector;
```

## File: src/routes/character-creation/LoadCharacter.tsx
```typescript
import { useState, useEffect } from 'react';
import type { SavedCharacter } from '../../lib/utils/characterEdit';
import { getAllSavedCharacters, saveAllCharacters } from '../../lib/utils/storageUtils';
import {
	StyledContainer,
	StyledTitle,
	StyledCharacterGrid,
	StyledCharacterCard,
	StyledCardActions,
	StyledActionButton,
	StyledCharacterName,
	StyledPlayerName,
	StyledCharacterDetails,
	StyledDetailItem,
	StyledDetailLabel,
	StyledDetailValue,
	StyledCompletedDate,
	StyledEmptyState,
	StyledEmptyTitle,
	StyledEmptyText,
	StyledBackButton,
	StyledModalOverlay,
	StyledModalContent,
	StyledModalTitle,
	StyledModalMessage,
	StyledModalActions,
	StyledModalButton
} from './styles/LoadCharacter.styles';

interface LoadCharacterProps {
	onBack: () => void;
	onLoadCharacter?: (character: SavedCharacter) => void;
	onSelectCharacter?: (characterId: string) => void;
	onEditCharacter?: (character: SavedCharacter) => void;
	onLevelUp?: (character: SavedCharacter) => void;
}

function LoadCharacter({
	onBack,
	onLoadCharacter,
	onSelectCharacter,
	onEditCharacter,
	onLevelUp
}: LoadCharacterProps) {
	const [savedCharacters, setSavedCharacters] = useState<SavedCharacter[]>([]);
	const [deleteModalOpen, setDeleteModalOpen] = useState(false);
	const [characterToDelete, setCharacterToDelete] = useState<SavedCharacter | null>(null);

	useEffect(() => {
		const characters = getAllSavedCharacters();
		setSavedCharacters(characters);
	}, []);

	const handleCharacterClick = (character: SavedCharacter) => {
		if (onEditCharacter) {
			onEditCharacter(character);
		} else if (onLoadCharacter) {
			onLoadCharacter(character);
		} else {
			console.log('Loading character:', character);
			// TODO: Implement character loading logic
		}
	};

	const handleViewCharacterSheet = (character: SavedCharacter, event: React.MouseEvent) => {
		event.stopPropagation();
		if (onSelectCharacter) {
			onSelectCharacter(character.id);
		}
	};

	const handleLevelUp = (character: SavedCharacter, event: React.MouseEvent) => {
		event.stopPropagation();
		if (onLevelUp) {
			onLevelUp(character);
		}
	};

	const handleDeleteClick = (character: SavedCharacter, event: React.MouseEvent) => {
		event.stopPropagation();
		setCharacterToDelete(character);
		setDeleteModalOpen(true);
	};

	const handleConfirmDelete = () => {
		if (characterToDelete) {
			// Remove character from localStorage
			const characters = getAllSavedCharacters();
			const updatedCharacters = characters.filter((char: SavedCharacter) => char.id !== characterToDelete.id);
			saveAllCharacters(updatedCharacters);
			
			// Update state
			setSavedCharacters(updatedCharacters);
			
			// Close modal
			setDeleteModalOpen(false);
			setCharacterToDelete(null);
		}
	};

	const handleCancelDelete = () => {
		setDeleteModalOpen(false);
		setCharacterToDelete(null);
	};

	const formatDate = (dateString: string) => {
		try {
			const date = new Date(dateString);
			// Check if the date is valid
			if (isNaN(date.getTime())) {
				return 'Unknown Date';
			}
			return date.toLocaleDateString('en-US', {
				year: 'numeric',
				month: 'short',
				day: 'numeric',
				hour: '2-digit',
				minute: '2-digit'
			});
		} catch (error) {
			return 'Unknown Date';
		}
	};

	const formatAncestry = (ancestry1: string, ancestry2?: string) => {
		if (ancestry2) {
			return `${ancestry1}/${ancestry2}`;
		}
		return ancestry1;
	};

	return (
		<StyledContainer>
			<StyledBackButton onClick={onBack}>← Back to Menu</StyledBackButton>

			<StyledTitle>Load Character</StyledTitle>

			{savedCharacters.length === 0 ? (
				<StyledEmptyState>
					<StyledEmptyTitle>No Saved Characters</StyledEmptyTitle>
					<StyledEmptyText>
						You haven't created any characters yet.
						<br />
						Go back to the menu and create your first character!
					</StyledEmptyText>
				</StyledEmptyState>
			) : (
				<StyledCharacterGrid>
					{savedCharacters.map((character) => (
						<StyledCharacterCard key={character.id}>
							<StyledCharacterName>
								{character.finalName || 'Unnamed Character'}
							</StyledCharacterName>

							<StyledPlayerName>Player: {character.finalPlayerName || 'Unknown'}</StyledPlayerName>

							<StyledCharacterDetails>
								<StyledDetailItem>
									<StyledDetailLabel>Race</StyledDetailLabel>
									<StyledDetailValue>
										{formatAncestry(
											character.ancestry1Name || character.ancestry1Id || 'Unknown',
											character.ancestry2Name || character.ancestry2Id
										)}
									</StyledDetailValue>
								</StyledDetailItem>

								<StyledDetailItem>
									<StyledDetailLabel>Class</StyledDetailLabel>
									<StyledDetailValue>
										{character.className || character.classId || 'Unknown'}
									</StyledDetailValue>
								</StyledDetailItem>
							</StyledCharacterDetails>

							<StyledCompletedDate>
								Created: {formatDate(character.createdAt || character.completedAt)}
							</StyledCompletedDate>

							<StyledCardActions>
								<StyledActionButton
									variant="primary"
									onClick={(e) => handleViewCharacterSheet(character, e)}
								>
									View Sheet
								</StyledActionButton>
								<StyledActionButton
									variant="secondary"
									onClick={() => handleCharacterClick(character)}
								>
									Edit
								</StyledActionButton>
								<StyledActionButton
									variant="secondary"
									onClick={(e) => handleLevelUp(character, e)}
								>
									Level Up
								</StyledActionButton>
								<StyledActionButton
									variant="danger"
									onClick={(e) => handleDeleteClick(character, e)}
								>
									Delete
								</StyledActionButton>
							</StyledCardActions>
						</StyledCharacterCard>
					))}
				</StyledCharacterGrid>
			)}

			{/* Delete Confirmation Modal */}
			{deleteModalOpen && characterToDelete && (
				<StyledModalOverlay>
					<StyledModalContent>
						<StyledModalTitle>Delete Character</StyledModalTitle>
						<StyledModalMessage>
							Are you sure you want to delete "{characterToDelete.finalName || 'Unnamed Character'}"?
							<br />
							This action cannot be undone.
						</StyledModalMessage>
						<StyledModalActions>
							<StyledModalButton variant="cancel" onClick={handleCancelDelete}>
								Cancel
							</StyledModalButton>
							<StyledModalButton variant="delete" onClick={handleConfirmDelete}>
								Delete
							</StyledModalButton>
						</StyledModalActions>
					</StyledModalContent>
				</StyledModalOverlay>
			)}
		</StyledContainer>
	);
}

export default LoadCharacter;
```

## File: src/routes/character-sheet/components/DeathExhaustion.tsx
```typescript
import React from 'react';
import type { CharacterSheetData, CurrentValues } from '../../../types';
import { useCharacterResources, useCharacterSheet } from '../hooks/CharacterSheetProvider';
import {
	StyledDeathExhaustionContainer,
	StyledExhaustionOnlyContainer,
	StyledExhaustionOnlyTitle
} from '../styles/DeathExhaustion.styles';

import {
	StyledDeathContainer,
	StyledDeathTitle,
	StyledHealthStatus,
	StyledDeathThreshold,
	StyledDeathStepsContainer,
	StyledDeathStepsTitle,
	StyledDeathStepsGrid,
	StyledDeathStep,
	StyledDeathStepTooltip,
	StyledHealthStatusTooltip
} from '../styles/Death';

import {
	StyledExhaustionContainer,
	StyledExhaustionLevel,
	StyledExhaustionTooltip
} from '../styles/Exhaustion';

import {
	getHealthStatus,
	calculateDeathThreshold,
	getDeathSteps
} from '../../../lib/rulesdata/death';

interface DeathExhaustionProps {
	// No props needed - data comes from context
}

const DeathExhaustion: React.FC<DeathExhaustionProps> = () => {
	const { state, updateExhaustion } = useCharacterSheet();
	const resources = useCharacterResources();
	
	if (!state.character) {
		return <div>Loading...</div>;
	}
	
	const characterData = state.character;
	const currentValues = resources.current;
	
	const onExhaustionChange = (level: number) => {
		updateExhaustion(level);
	};
	
	const onDeathStepChange = (step: number) => {
		// TODO: Add death step handling to reducer
		console.log('Death step change:', step);
	};
	// Exhaustion level descriptions (based on DC20 rules)
	const exhaustionLevels = [
		{ level: 1, description: 'Fatigued: -1 to all Checks and Saves' },
		{ level: 2, description: 'Exhausted: -2 to all Checks and Saves' },
		{ level: 3, description: 'Debilitated: -3 to all Checks and Saves, Speed halved' },
		{ level: 4, description: 'Incapacitated: -4 to all Checks and Saves, Speed quartered' },
		{ level: 5, description: 'Unconscious: Helpless, cannot take actions' }
	];

	return (
		<StyledDeathExhaustionContainer>
			<StyledDeathContainer>
				<StyledDeathTitle>DEATH & HEALTH STATUS</StyledDeathTitle>

				{/* Health Status */}
				{(() => {
					const deathThreshold = calculateDeathThreshold(
						characterData.finalPrimeModifierValue,
						characterData.finalCombatMastery
					);
					const healthStatus = getHealthStatus(
						currentValues.currentHP,
						characterData.finalHPMax,
						deathThreshold
					);
					const deathSteps = getDeathSteps(currentValues.currentHP, deathThreshold);

					return (
						<>
							<StyledHealthStatusTooltip data-tooltip={healthStatus.effects.join('\n')}>
								<StyledHealthStatus status={healthStatus.status}>
									{healthStatus.description.toUpperCase()}
								</StyledHealthStatus>
							</StyledHealthStatusTooltip>

							<div style={{ fontSize: '0.8rem', color: '#8b4513', marginBottom: '0.3rem' }}>
								DEATH THRESHOLD
							</div>
							<StyledDeathThreshold>{deathThreshold}</StyledDeathThreshold>

							{/* Death Steps - only show when on Death's Door */}
							{healthStatus.status === 'deaths-door' && (
								<StyledDeathStepsContainer>
									<StyledDeathStepsTitle>
										DEATH STEPS ({deathSteps.currentStep}/{deathSteps.maxSteps})
									</StyledDeathStepsTitle>
									<StyledDeathStepsGrid>
										{Array.from({ length: deathSteps.maxSteps }, (_, index) => {
											const step = index + 1;
											const isFilled = step <= deathSteps.currentStep;
											const isDead = deathSteps.isDead && step === deathSteps.maxSteps;

											return (
												<StyledDeathStep
													key={step}
													filled={isFilled}
													isDead={isDead}
													onClick={() => onDeathStepChange(step)}
												>
													{!isDead && step}
													<StyledDeathStepTooltip>
														{isDead ? 'Dead' : `${step} HP below 0`}
													</StyledDeathStepTooltip>
												</StyledDeathStep>
											);
										})}
									</StyledDeathStepsGrid>
								</StyledDeathStepsContainer>
							)}
						</>
					);
				})()}
			</StyledDeathContainer>

			<StyledExhaustionOnlyContainer>
				<StyledExhaustionOnlyTitle>EXHAUSTION</StyledExhaustionOnlyTitle>
				<StyledExhaustionContainer>
					{exhaustionLevels.map(({ level, description }) => (
						<StyledExhaustionLevel
							key={level}
							filled={level <= currentValues.exhaustionLevel}
							onClick={() => onExhaustionChange(level)}
						>
							{level}
							<StyledExhaustionTooltip>{description}</StyledExhaustionTooltip>
						</StyledExhaustionLevel>
					))}
				</StyledExhaustionContainer>
			</StyledExhaustionOnlyContainer>
		</StyledDeathExhaustionContainer>
	);
};

export default DeathExhaustion;
```

## File: src/routes/character-sheet/components/Inventory.tsx
```typescript
import React from 'react';
import type { InventoryItemData } from '../../../types';
import { allItems, type InventoryItem } from '../../../lib/rulesdata/inventoryItems';
import { useCharacterInventory, useCharacterSheet } from '../hooks/CharacterSheetProvider';
import {
	StyledInventorySection,
	StyledInventoryTitle,
	StyledAddItemButton,
	StyledInventoryContainer,
	StyledInventoryHeaderRow,
	StyledInventoryHeaderColumn,
	StyledInventoryRow,
	StyledRemoveItemButton,
	StyledInventorySelect,
	StyledInventoryInput,
	StyledInventoryInfoIcon,
	StyledInventoryCost,
	StyledEmptyInventory
} from '../styles/Inventory';

export interface InventoryProps {
	onItemClick: (inventoryData: InventoryItemData, item: InventoryItem | null) => void;
}

const Inventory: React.FC<InventoryProps> = ({ onItemClick }) => {
	const { updateInventory } = useCharacterSheet();
	const inventoryData = useCharacterInventory();
	const inventory = inventoryData.items;
	const addInventorySlot = () => {
		const newInventoryItem: InventoryItemData = {
			id: `inventory_${Date.now()}`,
			itemType: '',
			itemName: '',
			count: 1,
			cost: '-'
		};
		updateInventory([...inventory, newInventoryItem]);
	};

	const removeInventorySlot = (inventoryIndex: number) => {
		const updatedInventory = inventory.filter((_, index) => index !== inventoryIndex);
		updateInventory(updatedInventory);
	};

	const handleInventoryItemSelect = (
		inventoryIndex: number,
		itemTypeOrName: string,
		isItemName: boolean = false
	) => {
		if (!isItemName) {
			// Selecting item type
			const itemType = itemTypeOrName as InventoryItemData['itemType'];
			const updatedInventory = inventory.map((item, index) =>
				index === inventoryIndex ? { ...item, itemType, itemName: '', cost: '-' } : item
			);
			updateInventory(updatedInventory);
		} else {
			// Selecting item name
			const selectedItem = allItems.find((i: any) => i.name === itemTypeOrName);
			const updatedInventory = inventory.map((item, index) =>
				index === inventoryIndex
					? {
							...item,
							itemName: itemTypeOrName,
							itemType: selectedItem?.itemType || item.itemType,
							cost: getItemCost(selectedItem)
						}
					: item
			);
			updateInventory(updatedInventory);
		}
	};

	const handleInventoryCountChange = (inventoryIndex: number, count: number) => {
		const updatedInventory = inventory.map((item, index) =>
			index === inventoryIndex ? { ...item, count: Math.max(1, count) } : item
		);
		updateInventory(updatedInventory);
	};

	const getItemCost = (item: InventoryItem | undefined | null, count: number = 1): string => {
		if (!item || !('price' in item)) return '-';

		let basePrice = 0;
		let currency = 'g';

		if (typeof item.price === 'string') {
			// Parse string prices like "10g", "5s", etc.
			const match = item.price.match(/(\d+)([gs]?)/);
			if (match) {
				basePrice = parseInt(match[1]);
				currency = match[2] || 'g';
			}
		} else if (typeof item.price === 'number') {
			basePrice = item.price;
		}

		if (basePrice === 0) return '-';

		const totalPrice = basePrice * count;
		return `${totalPrice}${currency}`;
	};

	return (
		<StyledInventorySection>
			<StyledInventoryTitle>INVENTORY</StyledInventoryTitle>

			{/* Add Item Button */}
			<StyledAddItemButton onClick={addInventorySlot}>+ Add Item</StyledAddItemButton>

			<StyledInventoryContainer>
				<StyledInventoryHeaderRow>
					<span></span> {/* Empty column for remove button */}
					<StyledInventoryHeaderColumn>Type</StyledInventoryHeaderColumn>
					<StyledInventoryHeaderColumn>Item</StyledInventoryHeaderColumn>
					<StyledInventoryHeaderColumn align="center">Count</StyledInventoryHeaderColumn>
					<StyledInventoryHeaderColumn align="center">
						<StyledInventoryInfoIcon>i</StyledInventoryInfoIcon>
					</StyledInventoryHeaderColumn>
					<StyledInventoryHeaderColumn align="center">Cost</StyledInventoryHeaderColumn>
				</StyledInventoryHeaderRow>

				{inventory.length === 0 ? (
					<StyledEmptyInventory>
						No items added. Click "Add Item" to add your first item.
					</StyledEmptyInventory>
				) : (
					inventory.map((item, index) => {
						const selectedItem = item.itemName
							? allItems.find((i) => i.name === item.itemName)
							: null;

						return (
							<StyledInventoryRow key={item.id}>
								{/* Remove Button */}
								<StyledRemoveItemButton
									onClick={() => removeInventorySlot(index)}
									title="Remove item"
								>
									×
								</StyledRemoveItemButton>

								{/* Item Type */}
								<StyledInventorySelect
									value={item.itemType}
									onChange={(e) => handleInventoryItemSelect(index, e.target.value, false)}
								>
									<option value="">Select Type</option>
									<option value="Weapon">Weapon</option>
									<option value="Armor">Armor</option>
									<option value="Shield">Shield</option>
									<option value="Adventuring Supply">Adventuring Supply</option>
									<option value="Potion">Healing Potion</option>
								</StyledInventorySelect>

								{/* Item Name */}
								<StyledInventorySelect
									value={item.itemName}
									onChange={(e) => handleInventoryItemSelect(index, e.target.value, true)}
									disabled={!item.itemType}
								>
									<option value="">Select Item</option>
									{item.itemType &&
										allItems
											.filter((i) => i.itemType === item.itemType)
											.map((itemData) => (
												<option key={itemData.name} value={itemData.name}>
													{itemData.name}
												</option>
											))}
								</StyledInventorySelect>

								{/* Count */}
								<StyledInventoryInput
									type="number"
									min="1"
									value={item.count}
									onChange={(e) => handleInventoryCountChange(index, parseInt(e.target.value) || 1)}
								/>

								{/* Info Indicator */}
								<div style={{ textAlign: 'center' }}>
									{selectedItem ? (
										<StyledInventoryInfoIcon
											onClick={() => onItemClick(item, selectedItem)}
										>
											i
										</StyledInventoryInfoIcon>
									) : (
										'-'
									)}
								</div>

								{/* Cost */}
								<StyledInventoryCost>{getItemCost(selectedItem, item.count)}</StyledInventoryCost>
							</StyledInventoryRow>
						);
					})
				)}
			</StyledInventoryContainer>
		</StyledInventorySection>
	);
};

export default Inventory;
```

## File: src/routes/character-sheet/components/KnowledgeTrades.tsx
```typescript
import React from 'react';
import type { TradeData } from '../../../types';
import {
	KnowledgeTradesSection,
	SectionTitle,
	SectionDescription,
	EmptyMessage
} from '../styles/KnowledgeTrades';
import { SkillRow, SkillName } from '../styles/Attributes';
import { StyledProficiencyDots, StyledDot } from '../styles/Skills';

interface KnowledgeTradesProps {
	knowledge: TradeData[];
	trades: TradeData[];
}

const KnowledgeTrades: React.FC<KnowledgeTradesProps> = ({ knowledge, trades }) => {
	return (
		<>
			{/* Knowledge Section */}
			<KnowledgeTradesSection>
				<SectionTitle>KNOWLEDGE</SectionTitle>
				<SectionDescription>Intelligence-based knowledge trades</SectionDescription>
							{knowledge.map((knowledgeItem) => (
				<SkillRow key={knowledgeItem.id}>
					<SkillName>{knowledgeItem.name.toUpperCase()}</SkillName>
					<div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
						<StyledProficiencyDots>
							{[1, 2, 3, 4, 5].map((level) => (
								<StyledDot key={level} $filled={level <= knowledgeItem.proficiency} />
							))}
						</StyledProficiencyDots>
						{knowledgeItem.bonus !== undefined && (
							<span style={{
								fontSize: '0.875rem',
								fontWeight: '600',
								color: knowledgeItem.bonus >= 0 ? '#059669' : '#dc2626',
								minWidth: '2rem',
								textAlign: 'center'
							}}>
								{knowledgeItem.bonus >= 0 ? '+' : ''}{knowledgeItem.bonus}
							</span>
						)}
					</div>
				</SkillRow>
			))}
		</KnowledgeTradesSection>

			{/* Trades Section */}
			<KnowledgeTradesSection>
				<SectionTitle>TRADES</SectionTitle>
				<SectionDescription>Selected practical trades & crafts</SectionDescription>
				{trades.length > 0 ? (
									trades.map((trade) => (
					<SkillRow key={trade.id}>
						<SkillName>{trade.name.toUpperCase()}</SkillName>
						<div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
							<StyledProficiencyDots>
								{[1, 2, 3, 4, 5].map((level) => (
									<StyledDot key={level} $filled={level <= trade.proficiency} />
								))}
							</StyledProficiencyDots>
							{trade.bonus !== undefined && (
								<span style={{
									fontSize: '0.875rem',
									fontWeight: '600',
									color: trade.bonus >= 0 ? '#059669' : '#dc2626',
									minWidth: '2rem',
									textAlign: 'center'
								}}>
									{trade.bonus >= 0 ? '+' : ''}{trade.bonus}
								</span>
							)}
						</div>
					</SkillRow>
				))
				) : (
					<EmptyMessage>No trades selected</EmptyMessage>
				)}
			</KnowledgeTradesSection>
		</>
	);
};

export default KnowledgeTrades;
```

## File: src/routes/character-sheet/components/Maneuvers.tsx
```typescript
import React, { useState, useMemo } from 'react';
import type { ManeuverData, CharacterSheetData } from '../../../types';
import type { Maneuver } from '../../../lib/rulesdata/maneuvers';
import { maneuvers as allManeuvers } from '../../../lib/rulesdata/maneuvers';
import { useCharacterManeuvers, useCharacterSheet } from '../hooks/CharacterSheetProvider';
import {
	StyledSpellsSection,
	StyledSpellsHeader,
	StyledSpellsTitle,
	StyledSpellsControls,
	StyledAddSpellButton,
	StyledSpellsContainer,
	StyledSpellsHeaderRow,
	StyledHeaderColumn,
	StyledEmptyState,
	StyledSpellRow,
	StyledRemoveButton,
	StyledSpellSelect,
	StyledSchoolFilter,
	StyledSpellCell,
	StyledInfoIcon
} from '../styles/Spells';

export interface ManeuversProps {
	onManeuverClick: (maneuver: Maneuver) => void;
	readOnly?: boolean;
}

const Maneuvers: React.FC<ManeuversProps> = ({ onManeuverClick, readOnly = false }) => {
	const { addManeuver, removeManeuver, state } = useCharacterSheet();
	const maneuvers = useCharacterManeuvers();
	
	if (!state.character) {
		return <div>Loading maneuvers...</div>;
	}
	
	const characterData = state.character;
	const [typeFilter, setTypeFilter] = useState<string>('all');
	const [expandedManeuvers, setExpandedManeuvers] = useState<Set<string>>(() => {
		const expanded = new Set<string>();
		// Expand all maneuvers by default
		maneuvers.forEach(maneuver => {
			expanded.add(maneuver.id);
		});
		return expanded;
	});

	console.log('🔍 Maneuvers component received:', {
		maneuversCount: maneuvers.length,
		maneuvers: maneuvers.map(m => ({ id: m.id, name: m.name, type: m.type }))
	});

	// Filter maneuvers based on selected type
	const filteredManeuvers = useMemo(() => {
		if (typeFilter === 'all') {
			return allManeuvers;
		}
		return allManeuvers.filter(maneuver => maneuver.type === typeFilter);
	}, [typeFilter]);

	const addManeuverSlot = () => {
		const newManeuver: ManeuverData = {
			id: `maneuver_${Date.now()}`,
			name: '',
			type: 'Attack',
			cost: { ap: 0 },
			description: '',
			isReaction: false,
			notes: ''
		};
		addManeuver(newManeuver);
	};

	const removeManeuverSlot = (maneuverIndex: number) => {
		const maneuverToRemove = maneuvers[maneuverIndex];
		if (maneuverToRemove) {
			removeManeuver(maneuverToRemove.id);
		}
	};

	const updateManeuver = (index: number, field: keyof ManeuverData, value: any) => {
		setManeuvers((prev) => {
			const updated = [...prev];
			if (field === 'name' && value) {
				// When maneuver is selected, populate all fields from maneuver data
				const selectedManeuver = allManeuvers.find(maneuver => maneuver.name === value);
				if (selectedManeuver) {
					updated[index] = {
						...updated[index],
						name: selectedManeuver.name,
						type: selectedManeuver.type,
						cost: selectedManeuver.cost,
						description: selectedManeuver.description,
						isReaction: selectedManeuver.isReaction
					};
				}
			} else {
				updated[index] = { ...updated[index], [field]: value };
			}
			return updated;
		});
	};

	const toggleManeuverExpansion = (maneuverId: string) => {
		setExpandedManeuvers(prev => {
			const newSet = new Set(prev);
			if (newSet.has(maneuverId)) {
				newSet.delete(maneuverId);
			} else {
				newSet.add(maneuverId);
			}
			return newSet;
		});
	};

	const getUniqueTypes = () => {
		const types = new Set(allManeuvers.map(maneuver => maneuver.type));
		return Array.from(types).sort();
	};

	return (
		<StyledSpellsSection>
			<StyledSpellsHeader>
				<StyledSpellsTitle>Maneuvers</StyledSpellsTitle>
				<StyledSpellsControls>
					{!readOnly && (
						<>
							<StyledSchoolFilter
								value={typeFilter}
								onChange={(e) => setTypeFilter(e.target.value)}
							>
								<option value="all">All Types</option>
								{getUniqueTypes().map(type => (
									<option key={type} value={type}>{type}</option>
								))}
							</StyledSchoolFilter>
							<StyledAddSpellButton onClick={addManeuverSlot}>
								+ Add Maneuver
							</StyledAddSpellButton>
						</>
					)}
				</StyledSpellsControls>
			</StyledSpellsHeader>

			<StyledSpellsContainer>
				{maneuvers.length === 0 ? (
					<StyledEmptyState>
						{readOnly ? 'No maneuvers selected' : 'No maneuvers added yet. Click "Add Maneuver" to get started.'}
					</StyledEmptyState>
				) : (
					<>
						<StyledSpellsHeaderRow>
							<StyledHeaderColumn>Maneuver</StyledHeaderColumn>
							<StyledHeaderColumn>Type</StyledHeaderColumn>
							<StyledHeaderColumn>Cost</StyledHeaderColumn>
							<StyledHeaderColumn>Description</StyledHeaderColumn>
							{!readOnly && <StyledHeaderColumn>Actions</StyledHeaderColumn>}
						</StyledSpellsHeaderRow>

						{maneuvers.map((maneuver, index) => (
							<StyledSpellRow key={maneuver.id}>
								<StyledSpellCell>
									{readOnly ? (
										<span onClick={() => {
											const fullManeuver = allManeuvers.find(m => m.name === maneuver.name);
											if (fullManeuver) onManeuverClick(fullManeuver);
										}} style={{ cursor: 'pointer', color: '#2563eb' }}>
											{maneuver.name || 'Unnamed Maneuver'}
										</span>
									) : (
										<StyledSpellSelect
											value={maneuver.name || ''}
											onChange={(e) => updateManeuver(index, 'name', e.target.value)}
										>
											<option value="">Select a maneuver...</option>
											{filteredManeuvers.map(m => (
												<option key={m.name} value={m.name}>{m.name}</option>
											))}
										</StyledSpellSelect>
									)}
								</StyledSpellCell>
								<StyledSpellCell>{maneuver.type || '-'}</StyledSpellCell>
								<StyledSpellCell>{maneuver.cost?.ap ? `${maneuver.cost.ap} AP` : '-'}</StyledSpellCell>
								<StyledSpellCell>
									{maneuver.description ? (
										<div>
											<span 
												onClick={() => toggleManeuverExpansion(maneuver.id)}
												style={{ cursor: 'pointer', color: '#2563eb' }}
											>
												{expandedManeuvers.has(maneuver.id) ? '▼' : '▶'} 
												{maneuver.description.length > 50 
													? `${maneuver.description.substring(0, 50)}...` 
													: maneuver.description
												}
											</span>
											{expandedManeuvers.has(maneuver.id) && (
												<div style={{ marginTop: '5px', fontSize: '0.9em', color: '#666' }}>
													{maneuver.description}
												</div>
											)}
										</div>
									) : '-'}
								</StyledSpellCell>
								{!readOnly && (
									<StyledSpellCell>
										<StyledRemoveButton onClick={() => removeManeuverSlot(index)}>
											Remove
										</StyledRemoveButton>
									</StyledSpellCell>
								)}
							</StyledSpellRow>
						))}
					</>
				)}
			</StyledSpellsContainer>
		</StyledSpellsSection>
	);
};

export default Maneuvers;
```

## File: src/routes/character-sheet/components/Movement.tsx
```typescript
import React from 'react';
import type { CharacterSheetData } from '../../../types';
import type { EnhancedStatBreakdown } from '../../../lib/types/effectSystem';
import {
	StyledMovementContainer,
	StyledMovementGrid,
	StyledMovementStat,
	StyledMovementLabel,
	StyledMovementValue
} from '../styles/Movement.styles';
import Tooltip from './Tooltip';
import { createSpeedTooltip, createJumpTooltip } from './StatTooltips';
import { createEnhancedTooltip } from './EnhancedStatTooltips';

interface MovementProps {
	characterData: CharacterSheetData;
	breakdowns?: Record<string, EnhancedStatBreakdown>;
}

const Movement: React.FC<MovementProps> = ({ characterData, breakdowns }) => {
	return (
		<StyledMovementContainer>
			<StyledMovementGrid>
				<StyledMovementStat>
					<StyledMovementLabel>MOVE SPEED</StyledMovementLabel>
					<Tooltip
						content={
							breakdowns?.move_speed
								? createEnhancedTooltip('Move Speed', breakdowns.move_speed)
							: createSpeedTooltip(characterData)
						}
						position="top"
					>
						<StyledMovementValue>{characterData.finalMoveSpeed}</StyledMovementValue>
					</Tooltip>
				</StyledMovementStat>
				<StyledMovementStat>
					<StyledMovementLabel>JUMP DISTANCE</StyledMovementLabel>
					<Tooltip
						content={
							breakdowns?.jump_distance
								? createEnhancedTooltip('Jump Distance', breakdowns.jump_distance)
							: createJumpTooltip(characterData)
						}
						position="top"
					>
						<StyledMovementValue>{characterData.finalJumpDistance}</StyledMovementValue>
					</Tooltip>
				</StyledMovementStat>
			</StyledMovementGrid>
		</StyledMovementContainer>
	);
};

export default Movement;
```

## File: src/routes/character-sheet/components/PlayerNotes.tsx
```typescript
import React from 'react';
import { useCharacterSheet } from '../hooks/CharacterSheetProvider';
import {
	StyledPlayerNotesContainer,
	StyledPlayerNotesTitle,
	StyledNotesContent
} from '../styles/PlayerNotes.styles';

interface PlayerNotesProps {
	// No props needed - uses context
}

const PlayerNotes: React.FC<PlayerNotesProps> = () => {
	const { updateNotes, state } = useCharacterSheet();
	
	if (!state.character) {
		return (
			<div style={{ padding: '1rem', color: '#666', textAlign: 'center' }}>
				<p>Loading notes...</p>
			</div>
		);
	}

	const currentNotes = state.character.characterState?.notes?.playerNotes || '';

	const handleNotesChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {
		updateNotes(event.target.value);
	};

	return (
		<StyledPlayerNotesContainer>
			<StyledPlayerNotesTitle>
				Player Notes
			</StyledPlayerNotesTitle>
			
			<StyledNotesContent>
				<textarea
					value={currentNotes}
					onChange={handleNotesChange}
					placeholder="Write your notes here..."
					style={{
						width: '100%',
						minHeight: '200px',
						padding: '0.75rem',
						border: '1px solid #555',
						borderRadius: '4px',
						backgroundColor: '#1a1a1a',
						color: '#fff',
						fontFamily: 'inherit',
						fontSize: '0.9rem',
						resize: 'vertical'
					}}
				/>
			</StyledNotesContent>
		</StyledPlayerNotesContainer>
	);
};

export default PlayerNotes;
```

## File: src/routes/character-sheet/components/StatTooltips.tsx
```typescript
import React from 'react';
import type { CharacterSheetData } from '../../../types';

interface StatBreakdown {
  base: number;
  classBonus?: number;
  ancestryBonus?: number;
  otherBonuses?: Array<{name: string, value: number}>;
  total: number;
}

const formatBreakdown = (breakdown: StatBreakdown): React.ReactNode => {
  const lines: string[] = [];
  
  lines.push(`${breakdown.total}`);
  lines.push('');
  lines.push(`├─ Base: ${breakdown.base}`);
  
  if (breakdown.classBonus && breakdown.classBonus !== 0) {
    lines.push(`├─ Class: ${breakdown.classBonus > 0 ? '+' : ''}${breakdown.classBonus}`);
  }
  
  if (breakdown.ancestryBonus && breakdown.ancestryBonus !== 0) {
    lines.push(`├─ Ancestry: ${breakdown.ancestryBonus > 0 ? '+' : ''}${breakdown.ancestryBonus}`);
  }
  
  if (breakdown.otherBonuses && breakdown.otherBonuses.length > 0) {
    breakdown.otherBonuses.forEach((bonus, index) => {
      const isLast = index === breakdown.otherBonuses!.length - 1 && !breakdown.ancestryBonus && !breakdown.classBonus;
      const prefix = isLast ? '└─' : '├─';
      lines.push(`${prefix} ${bonus.name}: ${bonus.value > 0 ? '+' : ''}${bonus.value}`);
    });
  }
  
  return lines.join('\n');
};

export const createSpeedTooltip = (characterData: CharacterSheetData): React.ReactNode => {
  // Calculate breakdown - this is simplified since we don't have detailed source tracking yet
  const breakdown: StatBreakdown = {
    base: 5, // Default base speed
    classBonus: characterData.finalMoveSpeed - 5, // Assume difference is from class for now
    total: characterData.finalMoveSpeed
  };
  
  return (
    <div>
      <strong>Movement Speed</strong>
      <pre style={{ 
        margin: '8px 0 0 0', 
        fontFamily: 'monospace', 
        fontSize: '0.75rem',
        lineHeight: '1.2'
      }}>
        {formatBreakdown(breakdown)}
      </pre>
    </div>
  );
};

export const createJumpTooltip = (characterData: CharacterSheetData): React.ReactNode => {
  const breakdown: StatBreakdown = {
    base: characterData.finalAgility || 0, // Jump = Agility + modifiers
    total: characterData.finalJumpDistance
  };
  
  if (characterData.finalJumpDistance !== breakdown.base) {
    breakdown.otherBonuses = [{
      name: 'Other',
      value: characterData.finalJumpDistance - breakdown.base
    }];
  }
  
  return (
    <div>
      <strong>Jump Distance</strong>
      <pre style={{ 
        margin: '8px 0 0 0', 
        fontFamily: 'monospace', 
        fontSize: '0.75rem',
        lineHeight: '1.2'
      }}>
        {formatBreakdown(breakdown)}
      </pre>
    </div>
  );
};

export const createHPTooltip = (characterData: CharacterSheetData): React.ReactNode => {
  const mightBonus = characterData.finalMight || 0;
  const breakdown: StatBreakdown = {
    base: mightBonus,
    classBonus: characterData.finalHPMax - mightBonus, // Assume difference is from class/other
    total: characterData.finalHPMax
  };
  
  return (
    <div>
      <strong>Hit Points</strong>
      <pre style={{ 
        margin: '8px 0 0 0', 
        fontFamily: 'monospace', 
        fontSize: '0.75rem',
        lineHeight: '1.2'
      }}>
        {formatBreakdown(breakdown)}
      </pre>
    </div>
  );
};

export const createMPTooltip = (characterData: CharacterSheetData): React.ReactNode => {
  const breakdown: StatBreakdown = {
    base: 0, // Base MP is usually 0
    classBonus: characterData.finalMPMax,
    total: characterData.finalMPMax
  };
  
  return (
    <div>
      <strong>Mana Points</strong>
      <pre style={{ 
        margin: '8px 0 0 0', 
        fontFamily: 'monospace', 
        fontSize: '0.75rem',
        lineHeight: '1.2'
      }}>
        {formatBreakdown(breakdown)}
      </pre>
    </div>
  );
};

export const createSPTooltip = (characterData: CharacterSheetData): React.ReactNode => {
  const breakdown: StatBreakdown = {
    base: 0, // Base SP is usually 0
    classBonus: characterData.finalSPMax,
    total: characterData.finalSPMax
  };
  
  return (
    <div>
      <strong>Stamina Points</strong>
      <pre style={{ 
        margin: '8px 0 0 0', 
        fontFamily: 'monospace', 
        fontSize: '0.75rem',
        lineHeight: '1.2'
      }}>
        {formatBreakdown(breakdown)}
      </pre>
    </div>
  );
};
```

## File: src/routes/character-sheet/styles/DiceRoller.ts
```typescript
import styled, { keyframes, css } from 'styled-components';

// Draconic fire animations
const fireGlow = keyframes`
	0% { box-shadow: 0 0 5px #ff4500, 0 0 10px #ff4500, 0 0 15px #ff4500; }
	50% { box-shadow: 0 0 10px #ff6347, 0 0 20px #ff6347, 0 0 30px #ff6347; }
	100% { box-shadow: 0 0 5px #ff4500, 0 0 10px #ff4500, 0 0 15px #ff4500; }
`;

const rollAnimation = keyframes`
	0% { transform: rotate(0deg) scale(1); }
	25% { transform: rotate(90deg) scale(1.1); }
	50% { transform: rotate(180deg) scale(1.2); }
	75% { transform: rotate(270deg) scale(1.1); }
	100% { transform: rotate(360deg) scale(1); }
`;

const emberFloat = keyframes`
	0% { transform: translateY(0px); opacity: 1; }
	100% { transform: translateY(-20px); opacity: 0; }
`;

// Main container positioned in bottom right
export const StyledDiceRollerContainer = styled.div<{ $isExpanded: boolean }>`
	position: fixed;
	bottom: 1rem;
	right: 1rem;
	width: ${props => props.$isExpanded ? '380px' : '60px'};
	height: ${props => props.$isExpanded ? 'auto' : '60px'};
	background: linear-gradient(135deg, #2c1810 0%, #4a2c20 50%, #6b3e30 100%);
	border: 3px solid #8b4513;
	border-radius: 12px;
	padding: ${props => props.$isExpanded ? '1rem' : '0'};
	z-index: 1000;
	box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
	transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
	overflow: hidden;
	
	&::before {
		content: '';
		position: absolute;
		top: -2px;
		left: -2px;
		right: -2px;
		bottom: -2px;
		background: linear-gradient(45deg, #ff4500, #ff6347, #ff8c00, #ffa500);
		border-radius: 15px;
		z-index: -1;
		opacity: 0.3;
		animation: ${fireGlow} 2s infinite;
	}

	@media (max-width: 768px) {
		bottom: 4.5rem; /* Give 10-20px clearance above mobile nav */
		right: 0.5rem;
		width: ${props => props.$isExpanded ? '260px' : '50px'};
		height: ${props => props.$isExpanded ? 'auto' : '50px'};
		z-index: 999; /* Below mobile nav to prevent conflicts */
	}
`;

// Collapse/expand button
export const StyledCollapseButton = styled.button<{ $isExpanded: boolean }>`
	position: ${props => props.$isExpanded ? 'absolute' : 'static'};
	top: ${props => props.$isExpanded ? '0.5rem' : 'auto'};
	right: ${props => props.$isExpanded ? '0.5rem' : 'auto'};
	width: ${props => props.$isExpanded ? '30px' : '100%'};
	height: ${props => props.$isExpanded ? '30px' : '100%'};
	background: linear-gradient(135deg, #ff4500, #ff6347);
	border: 2px solid #8b4513;
	border-radius: ${props => props.$isExpanded ? '6px' : '12px'};
	color: white;
	font-size: ${props => props.$isExpanded ? '1rem' : '1.5rem'};
	cursor: pointer;
	display: flex;
	align-items: center;
	justify-content: center;
	transition: all 0.2s ease;
	
	&:hover {
		background: linear-gradient(135deg, #ff6347, #ff8c00);
		transform: scale(1.05);
		animation: ${fireGlow} 1s infinite;
	}
`;

// Dice controls section
export const StyledDiceControls = styled.div`
	margin-bottom: 1rem;
	padding-bottom: 0.5rem;
	border-bottom: 1px solid #8b4513;
	
	.section-label {
		margin-bottom: 0.5rem;
		font-size: 0.8rem;
		font-weight: bold;
		color: #ffd700;
		text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
		text-transform: uppercase;
		letter-spacing: 0.5px;
	}
`;

// Mode buttons (Normal, Advantage, Disadvantage, No D20)
export const StyledModeButton = styled.button<{ $active: boolean }>`
	padding: 0.3rem 0.5rem;
	font-size: 0.65rem;
	background: ${props => props.$active ? 
		'linear-gradient(135deg, #ff4500, #ff6347)' : 
		'linear-gradient(135deg, #4a2c20, #6b3e30)'};
	color: white;
	border: 1px solid #8b4513;
	border-radius: 4px;
	cursor: pointer;
	transition: all 0.2s ease;
	font-weight: bold;
	flex: 1;
	min-width: 0;
	text-align: center;
	
	&:hover {
		background: linear-gradient(135deg, #ff6347, #ff8c00);
		transform: translateY(-1px);
	}
`;

// Add dice section
export const StyledAddDiceSection = styled.div`
	margin-bottom: 1rem;
	padding-bottom: 0.5rem;
	border-bottom: 1px solid #8b4513;
	
	.section-label {
		margin-bottom: 0.5rem;
		font-size: 0.8rem;
		font-weight: bold;
		color: #ffd700;
		text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
		text-transform: uppercase;
		letter-spacing: 0.5px;
	}
`;

// Dice type buttons (d4, d6, etc.)
export const StyledDiceTypeButton = styled.button`
	padding: 0.4rem;
	font-size: 0.7rem;
	background: linear-gradient(135deg, #8b4513, #a0522d);
	color: white;
	border: 1px solid #654321;
	border-radius: 4px;
	cursor: pointer;
	transition: all 0.2s ease;
	font-weight: bold;
	
	&:hover {
		background: linear-gradient(135deg, #a0522d, #cd853f);
		transform: translateY(-1px);
		box-shadow: 0 2px 8px rgba(255, 69, 0, 0.3);
	}
`;

// Dice counter component
export const StyledDiceCounter = styled.div`
	display: flex;
	align-items: center;
	gap: 0.5rem;
	padding: 0.3rem;
	background: rgba(255, 255, 255, 0.1);
	border-radius: 4px;
	border: 1px solid #8b4513;
`;

// Current dice list
export const StyledDiceList = styled.div`
	margin-bottom: 1rem;
	padding-bottom: 0.5rem;
	border-bottom: 1px solid #8b4513;
	
	.section-label {
		margin-bottom: 0.5rem;
		font-size: 0.8rem;
		font-weight: bold;
		color: #ffd700;
		text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
		text-transform: uppercase;
		letter-spacing: 0.5px;
	}
`;

// Individual dice item in list
export const StyledDiceItem = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0.2rem 0.4rem;
	margin-bottom: 0.2rem;
	background: rgba(255, 255, 255, 0.1);
	border-radius: 4px;
	font-size: 0.7rem;
	color: white;
`;

// Remove dice button
export const StyledRemoveDiceButton = styled.button`
	width: 20px;
	height: 20px;
	background: #d32f2f;
	color: white;
	border: none;
	border-radius: 50%;
	cursor: pointer;
	font-size: 0.8rem;
	display: flex;
	align-items: center;
	justify-content: center;
	
	&:hover {
		background: #b71c1c;
		transform: scale(1.1);
	}
`;

// Main dice container
export const StyledDiceContainer = styled.div`
	display: flex;
	flex-direction: column;
	align-items: center;
	margin: 1rem 0;
	padding: 1rem;
	background: radial-gradient(circle, rgba(255, 69, 0, 0.1) 0%, rgba(139, 69, 19, 0.1) 100%);
	border-radius: 8px;
	border: 1px solid rgba(255, 69, 0, 0.3);
`;

// Individual dice icons
export const StyledDiceIcon = styled.div<{ 
	$isRolling: boolean; 
	$type: string;
	$size?: 'small' | 'normal';
}>`
	font-size: ${props => props.$size === 'small' ? '1.2rem' : '2rem'};
	width: ${props => props.$size === 'small' ? '30px' : '50px'};
	height: ${props => props.$size === 'small' ? '30px' : '50px'};
	display: flex;
	align-items: center;
	justify-content: center;
	background: ${props => props.$type === 'd20' ? 
		'radial-gradient(circle, #ff4500 0%, #ff6347 50%, #8b0000 100%)' :
		'radial-gradient(circle, #8b4513 0%, #a0522d 50%, #654321 100%)'};
	border: 2px solid #654321;
	border-radius: 8px;
	color: white;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	transition: all 0.3s ease;
	
	${props => props.$isRolling && css`
		animation: ${rollAnimation} 0.3s linear infinite;
	`}
	
	&::after {
		content: '';
		position: absolute;
		width: 4px;
		height: 4px;
		background: #ffa500;
		border-radius: 50%;
		animation: ${emberFloat} 1.5s infinite;
		margin-left: 10px;
		margin-top: -5px;
		opacity: ${props => props.$isRolling ? 1 : 0};
	}
`;

// Dice value display
export const StyledDiceValue = styled.div<{ $isMax?: boolean; $isMin?: boolean }>`
	font-size: 1.2rem;
	font-weight: bold;
	color: ${props => 
		props.$isMax ? '#ffd700' : 
		props.$isMin ? '#ff4500' : 
		'white'};
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
	margin-top: 0.5rem;
`;

// Roll button
export const StyledRollButton = styled.button<{ $isRolling: boolean }>`
	width: 100%;
	padding: 0.8rem;
	font-size: 1rem;
	font-weight: bold;
	background: ${props => props.$isRolling ? 
		'linear-gradient(135deg, #666, #888)' :
		'linear-gradient(135deg, #ff4500, #ff6347, #ff8c00)'};
	color: white;
	border: 2px solid #8b4513;
	border-radius: 8px;
	cursor: ${props => props.$isRolling ? 'not-allowed' : 'pointer'};
	transition: all 0.3s ease;
	text-transform: uppercase;
	letter-spacing: 1px;
	
	${props => !props.$isRolling && css`
		&:hover {
			background: linear-gradient(135deg, #ff6347, #ff8c00, #ffa500);
			transform: translateY(-2px);
			box-shadow: 0 6px 20px rgba(255, 69, 0, 0.4);
			animation: ${fireGlow} 1s infinite;
		}
	`}
	
	&:active {
		transform: translateY(0);
	}
`;

// Results display
export const StyledResultsDisplay = styled.div`
	margin-top: 1rem;
	padding: 1rem 0.8rem 1.5rem 0.8rem;
	background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 69, 0, 0.1));
	border: 2px solid rgba(255, 215, 0, 0.3);
	border-radius: 8px;
	position: relative;
`;

// Individual dice result
export const StyledDiceResult = styled.div<{ 
	$isMax: boolean; 
	$isMin: boolean; 
	$isChosen?: boolean;
	$isCriticalSuccess?: boolean;
	$isCriticalFail?: boolean;
}>`
	padding: 0.2rem 0.4rem;
	background: ${props => 
		props.$isCriticalSuccess ? 'linear-gradient(135deg, #ffd700, #ffed4e)' :
		props.$isCriticalFail ? 'linear-gradient(135deg, #dc143c, #ff0000)' :
		props.$isMax ? 'linear-gradient(135deg, #32cd32, #90ee90)' :
		props.$isMin ? 'linear-gradient(135deg, #ff4500, #ff6347)' :
		props.$isChosen === false ? 'linear-gradient(135deg, #4a4a4a, #6a6a6a)' :
		'linear-gradient(135deg, #8b4513, #a0522d)'};
	color: ${props => 
		props.$isCriticalSuccess || props.$isCriticalFail || props.$isMax || props.$isMin ? 'black' : 
		props.$isChosen === false ? '#e0e0e0' :
		'white'};
	border-radius: 4px;
	font-size: 0.7rem;
	font-weight: bold;
	border: 2px solid ${props => 
		props.$isCriticalSuccess ? '#b8860b' :
		props.$isCriticalFail ? '#8b0000' :
		props.$isChosen === false ? '#888' :
		props.$isMax ? '#228b22' :
		props.$isMin ? '#8b0000' :
		'#654321'};
	position: relative;
	opacity: ${props => props.$isChosen === false ? 0.8 : 1};
	
	${props => props.$isCriticalSuccess && css`
		animation: ${fireGlow} 1.5s infinite;
		box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
		&::after {
			content: '✨ CRIT SUCCESS';
			position: absolute;
			top: -20px;
			left: 50%;
			transform: translateX(-50%);
			font-size: 0.6rem;
			color: #ffd700;
			font-weight: bold;
			text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
			white-space: nowrap;
		}
	`}
	
	${props => props.$isCriticalFail && css`
		animation: ${fireGlow} 1.5s infinite;
		box-shadow: 0 0 15px rgba(220, 20, 60, 0.8);
		&::after {
			content: '💀 CRIT FAIL';
			position: absolute;
			top: -20px;
			left: 50%;
			transform: translateX(-50%);
			font-size: 0.6rem;
			color: #dc143c;
			font-weight: bold;
			text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
			white-space: nowrap;
		}
	`}
	
	${props => props.$isChosen === false && css`
		&::before {
			content: 'NOT USED';
			position: absolute;
			bottom: -16px;
			left: 50%;
			transform: translateX(-50%);
			font-size: 0.5rem;
			color: #ccc;
			font-weight: bold;
			white-space: nowrap;
			text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
		}
	`}
`;

// Total result display
export const StyledTotalResult = styled.div<{ $isHighRoll: boolean }>`
	font-size: 1.2rem;
	font-weight: bold;
	color: ${props => props.$isHighRoll ? '#ffd700' : 'white'};
	text-align: center;
	margin-bottom: 0.5rem;
	text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
	
	${props => props.$isHighRoll && css`
		animation: ${fireGlow} 2s infinite;
		text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
	`}
`;

// Roll history
export const StyledDiceHistory = styled.div`
	margin-top: 0.8rem;
	padding-top: 0.5rem;
	border-top: 1px solid #8b4513;
	color: rgba(255, 255, 255, 0.9);
	
	.section-label {
		font-size: 0.8rem;
		font-weight: bold;
		color: #ffd700;
		text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
		margin-bottom: 0.25rem;
		text-transform: uppercase;
		letter-spacing: 0.5px;
	}
`;
```

## File: src/styles/App.styles.ts
```typescript
// Styled components for App component
import styled from 'styled-components';

export const StyledApp = styled.div`
	height: 100vh;
	position: relative;
	display: flex;
	flex-direction: column;
`;

export const StyledHeader = styled.header`
	position: absolute;
	top: 1rem;
	right: 1rem;
	color: #fbbf24;
	font-size: 0.9rem;
	font-weight: bold;
	text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
	z-index: 10;
	display: flex;
	align-items: center;
	gap: 1rem;
`;

export const StyledBackButton = styled.button`
	padding: 0.5rem 1rem;
	border: 1px solid #fbbf24;
	border-radius: 6px;
	background: transparent;
	color: #fbbf24;
	cursor: pointer;
	transition: all 0.3s ease;
	font-size: 0.9rem;
	font-weight: bold;

	&:hover {
		background: #fbbf24;
		color: #1e1b4b;
	}
`;

export const StyledMain = styled.main`
	flex: 1;
	display: flex;
	flex-direction: column;
	min-height: 0;
`;

export const StyledFooter = styled.footer`
	padding: 0.5rem;
	text-align: center;
	color: #9ca3af;
	font-size: 0.8rem;
	font-family: 'Urbanist', 'Georgia', 'Times New Roman', serif;
	font-weight: 400;
	border-top: none;
	background: transparent;
`;
```

## File: src/lib/rulesdata/loaders/class-features.loader.ts
```typescript
/**
 * @file class-features.loader.ts
 * @description Loader for the new class features JSON structure
 */

import { SpellSchool, SpellList } from '../spells-data/types/spell.types';

// Define interfaces for the new class features structure
export interface ClassFeatureChoice {
	prompt: string;
	count: number;
	options?: {
		name: string;
		description: string;
	}[];
}

export interface ClassFeatureBenefit {
	name: string;
	description: string;
	effects?: {
		type: string;
		target?: string;
		value?: any;
		condition?: string;
	}[];
}

export interface ClassFeature {
	featureName: string;
	levelGained: number;
	description: string;
	isFlavor?: boolean;
	choices?: ClassFeatureChoice[];
	benefits?: ClassFeatureBenefit[];
}

export interface ClassSubclass {
	subclassName: string;
	description?: string;
	features: ClassFeature[];
}

export interface ClassDefinition {
	className: string;
	startingEquipment?: {
		weaponsOrShields?: string[];
		rangedWeapon?: string;
		alternativeWeapons?: string;
		armor?: string;
		packs?: string;
	};
	martialPath?: {
		combatTraining?: {
			weapons?: string[];
			armor?: string[];
			shields?: string[];
		};
		maneuvers?: {
			learnsAllAttack?: boolean;
			additionalKnown?: string;
		};
		techniques?: {
			additionalKnown?: string;
		};
		staminaPoints?: {
			maximumIncreasesBy?: string;
		};
		staminaRegen?: {
			description?: string;
			conditions?: string[];
		};
	};
	spellcastingPath?: {
		combatTraining?: {
			armor?: string[];
			shields?: string[];
		};
		spellList?: {
			type?: 'specific' | 'schools' | 'any' | 'all_schools';
			listName?: string;
			specificSchools?: SpellSchool[];
			spellTags?: string[];
			schoolCount?: number; // For classes that choose X schools
			description?: string;
			betaNote?: string;
		};
		cantrips?: {
			knownIncreasesBy?: string;
			description?: string;
		};
		spells?: {
			knownIncreasesBy?: string;
			description?: string;
		};
		manaPoints?: {
			maximumIncreasesBy?: string;
		};
	};
	coreFeatures: ClassFeature[];
	subclasses: ClassSubclass[];
}

// Import all the new schema class definitions
import { barbarianClass } from '../_new_schema/barbarian_features';
import { clericClass } from '../_new_schema/cleric_features';
import { hunterClass } from '../_new_schema/hunter_features';
import { championClass } from '../_new_schema/champion_features';
import { wizardClass } from '../_new_schema/wizard_features';
import { monkClass } from '../_new_schema/monk_features';
import { rogueClass } from '../_new_schema/rogue_features';
import { sorcererClass } from '../_new_schema/sorcerer_features';
import { spellbladeClass } from '../_new_schema/spellblade_features';
import { warlockClass } from '../_new_schema/warlock_features';
import { bardClass } from '../_new_schema/bard_features';
import { druidClass } from '../_new_schema/druid_features';
import { commanderClass } from '../_new_schema/commander_features';

// Use the new schema class definitions
const rawClassFeatures = [
	barbarianClass,
	clericClass,
	hunterClass,
	championClass,
	wizardClass,
	monkClass,
	rogueClass,
	sorcererClass,
	spellbladeClass,
	warlockClass,
	bardClass,
	druidClass,
	commanderClass
];

// Debug logging
console.log('🔍 Class Features Debug:', {
	totalClasses: rawClassFeatures.length,
	classNames: rawClassFeatures.map(c => c?.className || 'undefined')
});

// Export the class features data
export const classFeaturesData: ClassDefinition[] = rawClassFeatures;

// Helper function to get available spell schools for a class
export function getAvailableSpellSchools(classData: ClassDefinition): SpellSchool[] {
	const spellList = classData.spellcastingPath?.spellList;
	if (!spellList) return [];

	switch (spellList.type) {
		case 'all_schools':
			// Return all schools from the enum
			return Object.values(SpellSchool);
		case 'schools':
			// Return specific schools
			return spellList.specificSchools || [];
		default:
			return [];
	}
}

// Helper function to find a class by name
export function findClassByName(className: string): ClassDefinition | undefined {
	console.log('🔍 findClassByName called with:', className);
	console.log('🔍 Available classes:', classFeaturesData.map(c => c.className));
	const result = classFeaturesData.find((cls) => 
		cls.className.toLowerCase() === className.toLowerCase()
	);
	console.log('🔍 findClassByName result:', result ? 'found' : 'not found');
	return result;
}

// Helper function to find a specific feature in a class
export function findFeatureInClass(
	className: string,
	featureName: string
): ClassFeature | undefined {
	const classData = findClassByName(className);
	if (!classData) return undefined;

	return classData.coreFeatures.find((feature) => feature.featureName === featureName);
}

// Helper function to find a choice option in a feature
export function findChoiceOption(
	className: string,
	featureName: string,
	choiceIndex: number,
	optionName: string
): { name: string; description: string } | undefined {
	const feature = findFeatureInClass(className, featureName);
	if (!feature?.choices?.[choiceIndex]?.options) return undefined;

	return feature.choices[choiceIndex].options.find((option) => option.name === optionName);
}

// Generic function to extract class-specific display information
export function getClassSpecificInfo(
	className: string,
	selectedFeatureChoices?: Record<string, string>
): { displayInfo: { label: string; value: string }[] } {
	const displayInfo: { label: string; value: string }[] = [];

	if (!selectedFeatureChoices) {
		return { displayInfo };
	}

	try {
		const selectedChoices: { [key: string]: string } = selectedFeatureChoices;
		const classData = findClassByName(className);

		if (!classData) {
			return { displayInfo };
		}

		// Process each core feature that has choices
		classData.coreFeatures.forEach((feature) => {
			if (feature.choices) {
				feature.choices.forEach((choice, choiceIndex) => {
					// Create a mapping for legacy choice IDs based on class and feature
					const legacyChoiceId = getLegacyChoiceId(className, feature.featureName, choiceIndex);
					const selectedValue = selectedChoices[legacyChoiceId];

					if (selectedValue && choice.options) {
						if (choice.count > 1) {
							// Handle multiple selections
							try {
								const selectedValues: string[] = JSON.parse(selectedValue);
								if (selectedValues.length > 0) {
									const label = getDisplayLabel(className, feature.featureName, choiceIndex);
									displayInfo.push({
										label,
										value: selectedValues.join(', ')
									});
								}
							} catch (error) {
								console.error('Error parsing multiple selection:', error);
							}
						} else {
							// Handle single selections
							const label = getDisplayLabel(className, feature.featureName, choiceIndex);
							displayInfo.push({
								label,
								value: selectedValue.charAt(0).toUpperCase() + selectedValue.slice(1)
							});
						}
					}
				});
			}

			// Also check for benefits that might have user choices (like Divine Damage)
			if (feature.benefits) {
				feature.benefits.forEach((benefit) => {
					const legacyBenefitId = getLegacyBenefitId(className, feature.featureName, benefit.name);
					const selectedValue = selectedChoices[legacyBenefitId];

					if (selectedValue) {
						displayInfo.push({
							label: benefit.name,
							value: selectedValue.charAt(0).toUpperCase() + selectedValue.slice(1)
						});
					}
				});
			}
		});
	} catch (error) {
		console.error('Error parsing selected feature choices:', error);
	}

	return { displayInfo };
}

// Helper function to map class/feature combinations to legacy choice IDs
export function getLegacyChoiceId(
	className: string,
	featureName: string,
	choiceIndex: number
): string {
	// Generic mapping: className_featureName_choiceIndex
	return `${className.toLowerCase()}_${featureName.toLowerCase().replace(/\s+/g, '_')}_${choiceIndex}`;
}

// Helper function to map class/feature combinations to legacy benefit IDs
export function getLegacyBenefitId(
	className: string,
	featureName: string,
	benefitName: string
): string {
	// Generic mapping: className_featureName_benefitName
	return `${className.toLowerCase()}_${featureName.toLowerCase().replace(/\s+/g, '_')}_${benefitName.toLowerCase().replace(/\s+/g, '_')}`;
}

// Helper function to get display labels for different choice types
export function getDisplayLabel(
	_className: string,
	featureName: string,
	_choiceIndex: number
): string {
	// Generic: just use the feature name as the label
	return featureName;
}
```

## File: src/lib/utils/characterState.ts
```typescript
// Comprehensive character state management utility
// Handles all character data persistence with original/current value separation

import type {
    CharacterState,
    CharacterSheetData,
    AttackData,
    SpellData,
    InventoryItemData,
    CurrentValues
} from '../../types';
import { assignSpellsToCharacter } from '../services/spellAssignment';
import { getAllSavedCharacters, saveAllCharacters, getCharacterById } from './storageUtils';

// Get character state from localStorage - OPTIMIZED: Uses typed storage utility
export const getCharacterState = (characterId: string): CharacterState | null => {
	try {
		const character = getCharacterById(characterId);
		
		if (!character) return null;

		// Return the character's state, or null if not found
		return character.characterState || null;
	} catch (error) {
		console.error('Error getting character state:', error);
		return null;
	}
};

// Initialize character state from character data
export const initializeCharacterState = (
	characterData: CharacterSheetData,
	existingState?: CharacterState | null
): CharacterState => {
	// Calculate original values from character data
	const originalResources = {
		maxHP: characterData.finalHPMax || 0,
		maxSP: characterData.finalSPMax || 0,
		maxMP: characterData.finalMPMax || 0,
		maxGritPoints: characterData.finalGritPoints || 0,
		maxRestPoints: characterData.finalRestPoints || 0
	};

	const originalCurrency = {
		goldPieces: 0,
		silverPieces: 0,
		copperPieces: 0,
		electrumPieces: 0,
		platinumPieces: 0
	};

	const originalAttacks: AttackData[] = [
		{
			id: '1',
			weaponId: '',
			name: '',
			attackBonus: 0,
			damage: '',
			damageType: '',
			critRange: '',
			critDamage: '',
			brutalDamage: '',
			heavyHitEffect: ''
		},
		{
			id: '2',
			weaponId: '',
			name: '',
			attackBonus: 0,
			damage: '',
			damageType: '',
			critRange: '',
			critDamage: '',
			brutalDamage: '',
			heavyHitEffect: ''
		},
		{
			id: '3',
			weaponId: '',
			name: '',
			attackBonus: 0,
			damage: '',
			damageType: '',
			critRange: '',
			critDamage: '',
			brutalDamage: '',
			heavyHitEffect: ''
		}
	];

	const originalInventory: InventoryItemData[] = [];
	
	// Use spells from character data if they exist, otherwise auto-assign
	let originalSpells: SpellData[] = [];
	console.log('🔍 initializeCharacterState: Processing spells for character:', {
		hasSpellsProperty: !!characterData.spells,
		spellsLength: characterData.spells?.length || 0,
		className: characterData.className,
		hasSelectedSpells: !!characterData.selectedSpells
	});
	
	if (characterData.spells && characterData.spells.length > 0) {
		// Use the spells that were saved with the character
		originalSpells = characterData.spells;
		console.log('🔍 Using saved spells from character data:', originalSpells.map(s => s.spellName));
	} else if (characterData.className) {
		// Fallback to auto-assignment if no spells were saved
		console.log('🔍 No saved spells found, attempting auto-assignment for class:', characterData.className);
		try {
			originalSpells = assignSpellsToCharacter({
				className: characterData.className,
				level: characterData.level || 1,
				selectedFeatureChoices: characterData.selectedFeatureChoices || '{}'
			});
			console.log('🔍 Auto-assigned spells (no saved spells):', originalSpells.map(s => s.spellName));
		} catch (error) {
			console.warn('🔍 Error auto-assigning spells:', error);
			originalSpells = [];
		}
	} else {
		console.log('🔍 No className found, no spells will be assigned');
	}

	// Use existing state if available, otherwise initialize with defaults
    const finalState: CharacterState = {
		resources: {
			original: originalResources,
			current: existingState?.resources.current || {
				currentHP:
					characterData.currentHP !== undefined ? characterData.currentHP : originalResources.maxHP,
				currentSP:
					characterData.currentSP !== undefined ? characterData.currentSP : originalResources.maxSP,
				currentMP:
					characterData.currentMP !== undefined ? characterData.currentMP : originalResources.maxMP,
				currentGritPoints:
					characterData.currentGritPoints !== undefined
						? characterData.currentGritPoints
						: originalResources.maxGritPoints,
				currentRestPoints:
					characterData.currentRestPoints !== undefined
						? characterData.currentRestPoints
						: originalResources.maxRestPoints,
				tempHP: characterData.tempHP || 0,
				actionPointsUsed: characterData.actionPointsUsed || 0,
				exhaustionLevel: characterData.exhaustionLevel || 0
			}
		},
		currency: {
			original: originalCurrency,
			current: existingState?.currency.current || {
				goldPieces: 0,
				silverPieces: 0,
				copperPieces: 0,
				electrumPieces: 0,
				platinumPieces: 0
			}
		},
		attacks: {
			original: originalAttacks,
			current: existingState?.attacks.current || [...originalAttacks]
		},
		spells: {
			original: originalSpells,
			current: originalSpells // Always use the spells from character data, not existing state
		},
		maneuvers: {
			original: characterData.maneuvers || [],
			current: characterData.maneuvers || [] // Always use maneuvers from character data
		},
		inventory: {
			original: originalInventory,
			current: existingState?.inventory.current || []
		},
        defenseNotes: existingState?.defenseNotes,
        manualDefenses: existingState?.manualDefenses || {
            manualPD: (characterData as any).manualPD,
            manualPDR: (characterData as any).manualPDR,
            manualAD: (characterData as any).manualAD
        },
        calculation: (characterData as any).breakdowns
            ? { breakdowns: (characterData as any).breakdowns }
            : existingState?.calculation
	};
	
	console.log('🔍 initializeCharacterState: Final state created:', {
		spellsOriginal: finalState.spells.original.length,
		spellsCurrent: finalState.spells.current.length,
		spellsOriginalNames: finalState.spells.original.map(s => s.spellName),
		spellsCurrentNames: finalState.spells.current.map(s => s.spellName)
	});
	
	return finalState;
};

// Save complete character state to localStorage - OPTIMIZED: No duplicate fields
export const saveCharacterState = (characterId: string, state: CharacterState): void => {
	try {
		const characters = getAllSavedCharacters();
		const characterIndex = characters.findIndex(char => char.id === characterId);

		if (characterIndex === -1) {
			console.warn(`Character ${characterId} not found for state update`);
			return;
		}

		// Update ONLY the characterState - no duplicates
		// CharacterState is now the single source of truth
		characters[characterIndex] = {
			...characters[characterIndex],
			characterState: state,
			lastModified: new Date().toISOString()
		};

		saveAllCharacters(characters);
		console.log('🚀 OPTIMIZED: Character state saved (no duplicate fields)');
	} catch (error) {
		console.error('Error saving character state:', error);
	}
};

// Update a specific part of character state
export const updateCharacterState = (
	characterId: string,
	updates: Partial<CharacterState>
): void => {
	let currentState = getCharacterState(characterId);

	// If no character state exists, try to create a minimal one from character data
	if (!currentState) {
		console.log('No character state found for ID:', characterId, '- creating minimal state');

		// Get character data using typed storage utility
		const character = getCharacterById(characterId);
		
		if (!character) {
			console.error('No character found for ID:', characterId);
			return;
		}

		// Create minimal character state with default values
		currentState = {
				resources: {
					original: {
						maxHP: character.finalHPMax || 0,
						maxSP: character.finalSPMax || 0,
						maxMP: character.finalMPMax || 0,
						maxGritPoints: character.finalGritPoints || 0,
						maxRestPoints: character.finalRestPoints || 0
					},
					current: {
						currentHP:
							character.currentHP !== undefined ? character.currentHP : character.finalHPMax || 0,
						currentSP:
							character.currentSP !== undefined ? character.currentSP : character.finalSPMax || 0,
						currentMP:
							character.currentMP !== undefined ? character.currentMP : character.finalMPMax || 0,
						currentGritPoints:
							character.currentGritPoints !== undefined
								? character.currentGritPoints
								: character.finalGritPoints || 0,
						currentRestPoints:
							character.currentRestPoints !== undefined
								? character.currentRestPoints
								: character.finalRestPoints || 0,
						tempHP: character.tempHP || 0,
						actionPointsUsed: character.actionPointsUsed || 0,
						exhaustionLevel: character.exhaustionLevel || 0
					}
				},
				currency: {
					original: {
						goldPieces: 0,
						silverPieces: 0,
						copperPieces: 0,
						electrumPieces: 0,
						platinumPieces: 0
					},
					current: {
						goldPieces: character.goldPieces || 0,
						silverPieces: character.silverPieces || 0,
						copperPieces: character.copperPieces || 0,
						electrumPieces: character.electrumPieces || 0,
						platinumPieces: character.platinumPieces || 0
					}
				},
				attacks: {
					original: character.attacks || [],
					current: character.attacks || []
				},
				spells: {
					original: character.spells || [],
					current: character.spells || []
				},
				maneuvers: {
					original: character.maneuvers || [],
					current: character.maneuvers || []
				},
				inventory: {
					original: character.inventory || [],
					current: character.inventory || []
				},
				defenseNotes: character.defenseNotes
			};
	}

    const newState: CharacterState = {
		...currentState,
		...updates,
		// Deep merge nested objects
		resources: updates.resources
			? {
					...currentState.resources,
					...updates.resources,
					current: updates.resources.current
						? {
								...currentState.resources.current,
								...updates.resources.current
							}
						: currentState.resources.current,
					original: updates.resources.original
						? {
								...currentState.resources.original,
								...updates.resources.original
							}
						: currentState.resources.original
				}
			: currentState.resources,
		currency: updates.currency
			? {
					...currentState.currency,
					...updates.currency,
					current: updates.currency.current
						? {
								...currentState.currency.current,
								...updates.currency.current
							}
						: currentState.currency.current,
					original: updates.currency.original
						? {
								...currentState.currency.original,
								...updates.currency.original
							}
						: currentState.currency.original
				}
			: currentState.currency,
		attacks: updates.attacks
			? {
					...currentState.attacks,
					...updates.attacks
				}
			: currentState.attacks,
		spells: updates.spells
			? {
					...currentState.spells,
					...updates.spells
				}
			: currentState.spells,
		maneuvers: updates.maneuvers
			? {
					...currentState.maneuvers,
					...updates.maneuvers
				}
			: currentState.maneuvers,
		inventory: updates.inventory
			? {
					...currentState.inventory,
					...updates.inventory
				}
			: currentState.inventory
        ,
        manualDefenses: updates.manualDefenses
            ? {
                ...currentState.manualDefenses,
                ...updates.manualDefenses
            }
            : currentState.manualDefenses,
        calculation: updates.calculation
            ? {
                breakdowns: {
                    ...(currentState.calculation?.breakdowns || {}),
                    ...(updates.calculation?.breakdowns || {})
                }
            }
            : currentState.calculation
	};

	saveCharacterState(characterId, newState);
};

// Revert a specific data type to original values
export const revertToOriginal = (
	characterId: string,
	dataType: 'resources' | 'currency' | 'attacks' | 'spells' | 'maneuvers' | 'inventory'
): void => {
	const currentState = getCharacterState(characterId);
	if (!currentState) {
		console.log('No character state found for revert operation on ID:', characterId);
		// Try to initialize the state first, then revert won't be needed since it will be at defaults
		return;
	}

	const updates: Partial<CharacterState> = {};

	switch (dataType) {
		case 'resources':
			updates.resources = {
				...currentState.resources,
				current: {
					currentHP: currentState.resources.original.maxHP,
					currentSP: currentState.resources.original.maxSP,
					currentMP: currentState.resources.original.maxMP,
					currentGritPoints: currentState.resources.original.maxGritPoints,
					currentRestPoints: currentState.resources.original.maxRestPoints,
					tempHP: 0,
					actionPointsUsed: 0,
					exhaustionLevel: 0
				}
			};
			break;
		case 'currency':
			updates.currency = {
				...currentState.currency,
				current: { ...currentState.currency.original }
			};
			break;
		case 'attacks':
			updates.attacks = {
				...currentState.attacks,
				current: [...currentState.attacks.original]
			};
			break;
		case 'spells':
			updates.spells = {
				...currentState.spells,
				current: [...currentState.spells.original]
			};
			break;
		case 'maneuvers':
			updates.maneuvers = {
				...currentState.maneuvers,
				current: [...currentState.maneuvers.original]
			};
			break;
		case 'inventory':
			updates.inventory = {
				...currentState.inventory,
				current: [...currentState.inventory.original]
			};
			break;
	}

	updateCharacterState(characterId, updates);
};

// Convert new CharacterState to legacy CurrentValues format for backwards compatibility
export const characterStateToCurrentValues = (state: CharacterState): CurrentValues => {
	return {
		currentHP: state.resources.current.currentHP,
		currentSP: state.resources.current.currentSP,
		currentMP: state.resources.current.currentMP,
		currentGritPoints: state.resources.current.currentGritPoints,
		currentRestPoints: state.resources.current.currentRestPoints,
		tempHP: state.resources.current.tempHP,
		actionPointsUsed: state.resources.current.actionPointsUsed,
		exhaustionLevel: state.resources.current.exhaustionLevel,
		goldPieces: state.currency.current.goldPieces,
		silverPieces: state.currency.current.silverPieces,
		copperPieces: state.currency.current.copperPieces,
		electrumPieces: state.currency.current.electrumPieces,
		platinumPieces: state.currency.current.platinumPieces
	};
};

// Helpers for manual defenses centralized storage
export const setManualDefense = (
    characterId: string,
    field: 'manualPD' | 'manualPDR' | 'manualAD',
    value: number | undefined
): void => {
    const current = getCharacterState(characterId)?.manualDefenses || {};
    updateCharacterState(characterId, {
        manualDefenses: {
            ...current,
            [field]: value
        }
    });
};

export const getManualDefense = (
    characterId: string,
    field: 'manualPD' | 'manualPDR' | 'manualAD'
): number | undefined => {
    return getCharacterState(characterId)?.manualDefenses?.[field];
};
```

## File: src/lib/utils/storageUtils.ts
```typescript
/**
 * Centralized Storage Utilities
 * 
 * This is the ONLY place where JSON.stringify and JSON.parse should be used
 * for character data. All other parts of the application should use typed objects.
 */

import { SavedCharacter, CharacterState, LegacyCharacter } from '../types/dataContracts';

const CURRENT_SCHEMA_VERSION = 2;

/**
 * Centralized JSON serialization for localStorage
 * This is the ONLY place JSON.stringify should be used for character data
 */
export const serializeCharacterForStorage = (character: SavedCharacter): string => {
  return JSON.stringify({
    ...character,
    schemaVersion: CURRENT_SCHEMA_VERSION
  });
};

/**
 * Centralized JSON deserialization from localStorage
 * This is the ONLY place JSON.parse should be used for character data
 */
export const deserializeCharacterFromStorage = (jsonString: string): SavedCharacter | null => {
  try {
    const data = JSON.parse(jsonString) as any;
    
    // TEMPORARY: Allow all characters regardless of schema version for debugging
    console.log(`Loading character ${data.id || 'unknown'} with schema version: ${data.schemaVersion || 'undefined'}`);
    
    // Migrate legacy characters automatically
    
    // Migrate character to v2 format
    const migratedCharacter = {
      ...data,
      selectedTraitIds: data.selectedTraitIds || [],
      selectedFeatureChoices: data.selectedFeatureChoices || {},
      skillsData: data.skillsData || {},
      tradesData: data.tradesData || {},
      languagesData: data.languagesData || { common: { fluency: 'fluent' } },
      spells: data.spells || [],
      maneuvers: data.maneuvers || [],
      characterState: data.characterState || getDefaultCharacterState(),
      schemaVersion: CURRENT_SCHEMA_VERSION // Always update to current version
    } as SavedCharacter;
    
    console.log(`Successfully loaded character ${data.id || 'unknown'}`);
    return migratedCharacter;
  } catch (error) {
    console.error("Failed to parse character from storage", error);
    return null;
  }
};

/**
 * Create default character state for new characters
 */
export const getDefaultCharacterState = (): CharacterState => ({
  resources: {
    current: {
      currentHP: 0,
      currentSP: 0,
      currentMP: 0,
      currentGritPoints: 0,
      currentRestPoints: 0,
      tempHP: 0,
      actionPointsUsed: 0,
      exhaustionLevel: 0,
    },
  },
  ui: { manualDefenseOverrides: {} },
  inventory: { 
    items: [], 
    currency: { gold: 0, silver: 0, copper: 0 } 
  },
  notes: { playerNotes: '' },
});

/**
 * Get all saved characters with type safety
 */
export const getAllSavedCharacters = (): SavedCharacter[] => {
  const charactersJson = localStorage.getItem('savedCharacters') || '[]';
  try {
    const rawCharacters = JSON.parse(charactersJson);
    console.log(`Loading ${rawCharacters.length} characters from localStorage`);
    
    const characters = rawCharacters.map((char: any) => 
      deserializeCharacterFromStorage(JSON.stringify(char))
    ).filter(Boolean) as SavedCharacter[];
    
    console.log(`Successfully loaded ${characters.length} characters`);
    return characters;
  } catch (error) {
    console.error("Failed to load saved characters", error);
    return [];
  }
};

/**
 * Save all characters to localStorage
 */
export const saveAllCharacters = (characters: SavedCharacter[]): void => {
  try {
    const serializedCharacters = characters.map(char => JSON.parse(serializeCharacterForStorage(char)));
    localStorage.setItem('savedCharacters', JSON.stringify(serializedCharacters));
  } catch (error) {
    console.error("Failed to save characters", error);
  }
};

/**
 * Get a single character by ID
 */
export const getCharacterById = (characterId: string): SavedCharacter | null => {
  console.log(`Looking for character with ID: ${characterId}`);
  const characters = getAllSavedCharacters();
  const character = characters.find(char => char.id === characterId) || null;
  
  if (character) {
    console.log(`Found character: ${character.finalName || character.id}`);
  } else {
    console.warn(`Character ${characterId} not found`);
    console.log(`Available character IDs: ${characters.map(c => c.id).join(', ')}`);
  }
  
  return character;
};

/**
 * Save a single character's state
 */
export const saveCharacterState = (characterId: string, state: CharacterState): void => {
  const characters = getAllSavedCharacters();
  const characterIndex = characters.findIndex(char => char.id === characterId);
  
  if (characterIndex === -1) {
    console.warn(`Character ${characterId} not found for state update`);
    return;
  }
  
  // Update ONLY the characterState - no duplicates
  characters[characterIndex] = {
    ...characters[characterIndex],
    characterState: state,
    lastModified: new Date().toISOString()
  };
  
  saveAllCharacters(characters);
};

// Migration utilities removed - no backward compatibility support

/**
 * Backup current localStorage before migration
 */
export const backupCharacterData = (): void => {
  const currentData = localStorage.getItem('savedCharacters');
  if (currentData) {
    localStorage.setItem('savedCharacters_backup', currentData);
    localStorage.setItem('savedCharacters_backup_timestamp', new Date().toISOString());
    console.log('Character data backed up successfully');
  }
};

/**
 * Restore from backup if something goes wrong
 */
export const restoreFromBackup = (): boolean => {
  const backup = localStorage.getItem('savedCharacters_backup');
  if (backup) {
    localStorage.setItem('savedCharacters', backup);
    console.log('Character data restored from backup');
    return true;
  }
  console.warn('No backup found to restore from');
  return false;
};
```

## File: src/routes/character-creation/components/SkillsTab.tsx
```typescript
import React from 'react';
import { skillsData } from '../../../lib/rulesdata/skills';
import type {
	BackgroundPointsData,
	PointConversions,
	ConversionActions,
	MasteryLimits,
	MasteryInfo
} from './BackgroundPointsManager';
import {
	getMasteryInfo,
	MASTERY_TABLE
} from './BackgroundPointsManager';
import {
	StyledTabContent,
	StyledSelectionGrid,
	StyledSelectionItem,
	StyledSelectionHeader,
	StyledSelectionName,
	StyledProficiencySelector,
	StyledProficiencyButton,
	StyledPointsRemaining
} from '../styles/Background.styles';

interface SkillsTabProps {
	currentSkills: Record<string, number>;
	currentTrades: Record<string, number>;
	pointsData: BackgroundPointsData;
	conversions: PointConversions;
	actions: ConversionActions;
	masteryLimits: MasteryLimits;
	onSkillChange: (skillId: string, newLevel: number) => void;
}

const SkillsTab: React.FC<SkillsTabProps> = ({
	currentSkills,
	currentTrades,
	pointsData,
	conversions,
	actions,
	masteryLimits,
	onSkillChange
}) => {
	const canIncreaseProficiency = (
		pointCost: number,
		pointsUsed: number,
		availablePoints: number
	) => {
		const canAfford = pointsUsed + pointCost <= availablePoints;
		console.log(`canIncreaseProficiency: cost=${pointCost}, used=${pointsUsed}, available=${availablePoints}, canAfford=${canAfford}`);
		return canAfford;
	};

	// Enhanced validation including mastery limits
	const canSelectMastery = (skillId: string, targetLevel: number): boolean => {
		// Check mastery limit
		if (targetLevel > masteryLimits.maxSkillMastery) {
			console.log(`Skill ${skillId} level ${targetLevel} exceeds mastery limit ${masteryLimits.maxSkillMastery}`);
			return false;
		}
		
		// Check Level 1 special rule for Adept (level 2) - only count skills, not trades
		if (targetLevel === 2) {
			const currentlyAdept = currentSkills[skillId] === 2;
			const skillAdeptCount = Object.values(currentSkills).filter(level => level === 2).length;
			if (!currentlyAdept && skillAdeptCount >= 1) {
				console.log(`Cannot select Adept level 2 for ${skillId} - already have ${skillAdeptCount} Adept skills`);
				return false; // Already have one Adept skill
			}
		}
		
		// Check point availability
		const pointCost = targetLevel - (currentSkills[skillId] || 0);
		const canAfford = canIncreaseProficiency(pointCost, pointsData.skillPointsUsed, pointsData.availableSkillPoints);
		
		if (!canAfford) {
			console.log(`Cannot afford level ${targetLevel} for ${skillId}: cost=${pointCost}, used=${pointsData.skillPointsUsed}, available=${pointsData.availableSkillPoints}`);
		}
		
		return canAfford;
	};

	// Helper function for consistent button styling
	const getButtonStyle = (enabled: boolean, variant: 'primary' | 'danger' = 'primary') => ({
		padding: '0.5rem 1rem',
		backgroundColor: enabled ? (variant === 'primary' ? '#3b82f6' : '#ef4444') : '#6b7280',
		color: 'white',
		border: 'none',
		borderRadius: '6px',
		fontSize: '0.875rem',
		fontWeight: '500',
		cursor: enabled ? 'pointer' : 'not-allowed',
		transition: 'all 0.2s ease',
		opacity: enabled ? 1 : 0.6,
		':hover': enabled
			? {
					backgroundColor: variant === 'primary' ? '#2563eb' : '#dc2626',
					transform: 'translateY(-1px)',
					boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)'
				}
			: {}
	});

	const hasConversions =
		conversions.skillToTradeConversions > 0 ||
		conversions.tradeToSkillConversions > 0 ||
		conversions.tradeToLanguageConversions > 0;

	return (
		<StyledTabContent>
			{/* Level 1 Validation Warning */}
			{(() => {
				const skillAdeptCount = Object.values(currentSkills).filter(level => level === 2).length;
				const isInvalid = skillAdeptCount > 1;
				
				return isInvalid ? (
					<div style={{
						background: '#fee2e2',
						border: '1px solid #fecaca',
						color: '#991b1b',
						padding: '0.75rem',
						borderRadius: '0.5rem',
						marginBottom: '1rem'
					}}>
						⚠️ Level 1 characters can only have ONE Adept (level 2) skill.
						Currently: {skillAdeptCount} Adept skill selections.
					</div>
				) : null;
			})()}
			
			{/* Mastery Limits Info */}
			<div style={{
				background: '#f3f4f6',
				border: '1px solid #d1d5db',
				padding: '0.5rem',
				borderRadius: '0.375rem',
				marginBottom: '1rem',
				fontSize: '0.875rem'
			}}>
				<strong>Mastery Limits:</strong> Max level {masteryLimits.maxSkillMastery} 
				({MASTERY_TABLE[masteryLimits.maxSkillMastery]?.name})
			</div>

			<StyledPointsRemaining>
				Skill Points: {pointsData.availableSkillPoints - pointsData.skillPointsUsed} /{' '}
				{pointsData.availableSkillPoints} remaining
				{hasConversions && (
					<div
						style={{
							fontSize: '0.9rem',
							color: '#6366f1',
							marginTop: '0.5rem',
							padding: '0.25rem 0.5rem',
							backgroundColor: '#6366f11a',
							borderRadius: '4px',
							border: '1px solid #6366f133'
						}}
					>
						Active conversions:{' '}
						{conversions.skillToTradeConversions > 0
							? `${conversions.skillToTradeConversions} skill → ${conversions.skillToTradeConversions * 2} trade`
							: ''}
						{conversions.skillToTradeConversions > 0 &&
						(conversions.tradeToSkillConversions > 0 || conversions.tradeToLanguageConversions > 0)
							? ', '
							: ''}
						{conversions.tradeToSkillConversions > 0
							? `${conversions.tradeToSkillConversions} trade → ${Math.floor(conversions.tradeToSkillConversions / 2)} skill`
							: ''}
						{conversions.tradeToSkillConversions > 0 && conversions.tradeToLanguageConversions > 0
							? ', '
							: ''}
						{conversions.tradeToLanguageConversions > 0
							? `${conversions.tradeToLanguageConversions} trade → ${conversions.tradeToLanguageConversions * 2} language`
							: ''}
					</div>
				)}
				<div
					style={{
						marginTop: '0.75rem',
						display: 'flex',
						gap: '0.5rem',
						flexWrap: 'wrap'
					}}
				>
					<button
						onClick={actions.convertSkillToTrade}
						disabled={pointsData.availableSkillPoints - pointsData.skillPointsUsed < 1}
						style={getButtonStyle(
							pointsData.availableSkillPoints - pointsData.skillPointsUsed >= 1
						)}
						onMouseEnter={(e) => {
							if (pointsData.availableSkillPoints - pointsData.skillPointsUsed >= 1) {
								e.currentTarget.style.backgroundColor = '#2563eb';
								e.currentTarget.style.transform = 'translateY(-1px)';
								e.currentTarget.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
							}
						}}
						onMouseLeave={(e) => {
							if (pointsData.availableSkillPoints - pointsData.skillPointsUsed >= 1) {
								e.currentTarget.style.backgroundColor = '#3b82f6';
								e.currentTarget.style.transform = 'translateY(0)';
								e.currentTarget.style.boxShadow = 'none';
							}
						}}
					>
						Convert 1 Skill → 2 Trade Points
					</button>
					<button
						onClick={actions.resetConversions}
						disabled={!hasConversions}
						style={getButtonStyle(hasConversions, 'danger')}
						onMouseEnter={(e) => {
							if (hasConversions) {
								e.currentTarget.style.backgroundColor = '#dc2626';
								e.currentTarget.style.transform = 'translateY(-1px)';
								e.currentTarget.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
							}
						}}
						onMouseLeave={(e) => {
							if (hasConversions) {
								e.currentTarget.style.backgroundColor = '#ef4444';
								e.currentTarget.style.transform = 'translateY(0)';
								e.currentTarget.style.boxShadow = 'none';
							}
						}}
					>
						Reset Conversions
					</button>
				</div>
			</StyledPointsRemaining>
			<StyledSelectionGrid>
							{skillsData.map((skill) => {
				const currentLevel = currentSkills[skill.id] || 0;
				const masteryInfo = getMasteryInfo(currentLevel, masteryLimits.maxSkillMastery);
				
				return (
					<StyledSelectionItem key={skill.id}>
						<StyledSelectionHeader>
							<StyledSelectionName>{skill.name}</StyledSelectionName>
							<div style={{ fontSize: '0.75rem', color: '#6b7280' }}>
								{masteryInfo.name} (+{masteryInfo.bonus}) • {skill.attributeAssociation}
							</div>
						</StyledSelectionHeader>
						<div style={{ fontSize: '0.9rem', color: '#cbd5e1', marginBottom: '0.5rem' }}>
							{skill.description}
						</div>
						<StyledProficiencySelector>
							{[0, 1, 2, 3, 4, 5].map((level) => {
								const masteryDisplay = getMasteryInfo(level, masteryLimits.maxSkillMastery);
								const canSelect = canSelectMastery(skill.id, level);
								
								return (
									<StyledProficiencyButton
										key={level}
										$active={currentLevel === level}
										$disabled={!canSelect && level !== currentLevel}
										title={`${masteryDisplay.name} (+${masteryDisplay.bonus})`}
										onClick={() => {
											if (canSelect || level === currentLevel) {
												onSkillChange(skill.id, level);
											}
										}}
									>
										{level}
									</StyledProficiencyButton>
								);
							})}
						</StyledProficiencySelector>
					</StyledSelectionItem>
				);
			})}
			</StyledSelectionGrid>
		</StyledTabContent>
	);
};

export default SkillsTab;
```

## File: src/routes/character-creation/components/TraitChoiceSelector.tsx
```typescript
/**
 * Trait Choice Selector Component
 * 
 * This component handles user choices for traits that require input,
 * such as Human Attribute Increase or Skill Expertise.
 */

import React from 'react';
import styled from '@emotion/styled';
import { useCharacter } from '../../../lib/stores/characterContext';
import { useEnhancedCharacterCalculation } from '../../../lib/hooks/useEnhancedCharacterCalculation';
import { useAttributeCalculation, useCanSelectTrait, useTraitPointImpact } from '../../../lib/hooks/useAttributeCalculation';
import { attributesData } from '../../../lib/rulesdata/attributes';
import { skillsData } from '../../../lib/rulesdata/skills';
import { tradesData } from '../../../lib/rulesdata/trades';
import type { ITrait, ITraitEffect } from '../../../lib/rulesdata/types';

// Styled components
const ChoiceContainer = styled.div`
  margin-top: 1rem;
  padding: 1rem;
  background-color: #f8fafc;
  border: 1px solid #e2e8f0;
  border-radius: 8px;
  border-left: 4px solid #3b82f6;
`;

const ChoiceTitle = styled.h4`
  margin: 0 0 0.75rem 0;
  color: #1e40af;
  font-size: 0.9rem;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  
  &:before {
    content: '🎯';
    font-size: 1rem;
  }
`;

const ChoiceGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: 0.75rem;
  margin-top: 0.75rem;
`;

const ChoiceButton = styled.button<{ $selected: boolean; $invalid: boolean }>`
  padding: 0.75rem;
  border: 2px solid ${props => 
    props.$invalid ? '#ef4444' : 
    props.$selected ? '#3b82f6' : '#d1d5db'
  };
  border-radius: 8px;
  background-color: ${props => 
    props.$invalid ? '#fef2f2' :
    props.$selected ? '#dbeafe' : '#ffffff'
  };
  color: ${props => 
    props.$invalid ? '#dc2626' :
    props.$selected ? '#1e40af' : '#374151'
  };
  font-size: 0.875rem;
  font-weight: 500;
  cursor: ${props => props.$invalid ? 'not-allowed' : 'pointer'};
  opacity: ${props => props.$invalid ? 0.6 : 1};
  transition: all 0.2s ease;
  text-align: left;
  position: relative;

  &:hover:not(:disabled) {
    transform: ${props => props.$invalid ? 'none' : 'translateY(-1px)'};
    box-shadow: ${props => props.$invalid ? 'none' : '0 4px 8px rgba(0, 0, 0, 0.1)'};
    border-color: ${props => props.$invalid ? '#ef4444' : '#3b82f6'};
  }
  
  &:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }
`;

const ChoiceButtonTitle = styled.div`
  font-weight: 600;
  margin-bottom: 0.25rem;
`;

const ChoiceButtonSubtitle = styled.div`
  font-size: 0.75rem;
  opacity: 0.7;
  line-height: 1.3;
`;

const ValidationMessage = styled.div`
  color: #dc2626;
  font-size: 0.75rem;
  margin-top: 0.5rem;
  padding: 0.5rem;
  background-color: #fef2f2;
  border: 1px solid #fecaca;
  border-radius: 4px;
  font-style: italic;
`;

const PreviewBox = styled.div`
  margin-top: 0.75rem;
  padding: 0.75rem;
  background-color: #f0f9ff;
  border: 1px solid #bae6fd;
  border-radius: 6px;
  font-size: 0.875rem;
  
  &:before {
    content: '✅ ';
    color: #059669;
    font-weight: bold;
  }
`;

const ClearButton = styled.button`
  margin-top: 0.5rem;
  padding: 0.5rem 1rem;
  background-color: #6b7280;
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 0.75rem;
  cursor: pointer;
  transition: background-color 0.2s ease;
  
  &:hover {
    background-color: #4b5563;
  }
`;

const PointImpactIndicator = styled.div<{ $type: 'positive' | 'negative' | 'neutral' }>`
  display: inline-flex;
  align-items: center;
  gap: 0.25rem;
  font-size: 0.75rem;
  font-weight: 500;
  color: ${props => 
    props.$type === 'positive' ? '#059669' :
    props.$type === 'negative' ? '#dc2626' : '#6b7280'
  };
  
  &:before {
    content: ${props => 
      props.$type === 'positive' ? "'📈'" :
      props.$type === 'negative' ? "'📉'" : "'📊'"
    };
  }
`;

const AttributeEffectsPreview = styled.div`
  margin-top: 0.5rem;
  padding: 0.5rem;
  background-color: #f0f9ff;
  border: 1px solid #bae6fd;
  border-radius: 4px;
  font-size: 0.75rem;
`;

const AttributeEffect = styled.div`
  display: flex;
  justify-content: space-between;
  margin-bottom: 0.25rem;
  
  &:last-child {
    margin-bottom: 0;
  }
`;

const ForcedAdjustmentWarning = styled.div`
  margin-top: 0.5rem;
  padding: 0.5rem;
  background-color: #fef3c7;
  border: 1px solid #fbbf24;
  border-radius: 4px;
  font-size: 0.75rem;
  color: #92400e;
  
  &:before {
    content: '⚠️ ';
    margin-right: 0.25rem;
  }
`;

interface TraitChoiceSelectorProps {
  trait: ITrait;
  effect: ITraitEffect;
  effectIndex: number;
}

const TraitChoiceSelector: React.FC<TraitChoiceSelectorProps> = ({
  trait,
  effect,
  effectIndex
}) => {
  const { state, dispatch } = useCharacter();
  const { 
    validateTraitChoice, 
    getEffectPreview,
    calculationResult 
  } = useEnhancedCharacterCalculation();
  
  // NEW: Enhanced attribute calculation for real-time feedback
  const calculation = useAttributeCalculation(state);
  const canSelectTrait = useCanSelectTrait(state);
  const traitPointImpact = useTraitPointImpact(state, trait.id);
  
  // Get current choice from state
  const currentChoices = state.selectedTraitChoices || {};
  const choiceKey = `${trait.id}-${effectIndex}`;
  const currentChoice = currentChoices[choiceKey] || '';
  
  // Handle choice selection
  const handleChoiceChange = (choice: string) => {
    dispatch({
      type: 'UPDATE_TRAIT_CHOICE',
      traitId: trait.id,
      effectIndex,
      choice: currentChoice === choice ? '' : choice // Toggle selection
    });
  };
  
  // Get options for this effect type
  const getOptions = () => {
    if (effect.userChoiceRequired?.options) {
      return effect.userChoiceRequired.options.map(option => ({
        value: option,
        displayName: option,
        description: ''
      }));
    }
    
    switch (effect.type) {
      case 'MODIFY_ATTRIBUTE':
        return attributesData.map(attr => ({
          value: attr.id,
          displayName: attr.name,
          description: attr.description
        }));
        
      case 'GRANT_SKILL_EXPERTISE':
        return skillsData.map(skill => ({
          value: skill.id,
          displayName: skill.name,
          description: `${skill.attributeAssociation.toUpperCase()} - ${skill.description}`
        }));
        
      case 'GRANT_TRADE_EXPERTISE':
        return tradesData.map(trade => ({
          value: trade.id,
          displayName: trade.name,
          description: `${trade.attributeAssociation.toUpperCase()} - ${trade.description}`
        }));
        
      default:
        return [];
    }
  };
  
  const options = getOptions();
  const prompt = effect.userChoiceRequired?.prompt || `Choose option for ${trait.name}`;
  
  // Get preview for current choice
  const preview = currentChoice ? getEffectPreview(trait.id, effectIndex, currentChoice) : undefined;
  
  // Check if trait has attribute modifying effects
  const hasAttributeEffects = effect.type === 'MODIFY_ATTRIBUTE';
  const selectedTraitIds = state.selectedTraitIds || [];
  const isTraitSelected = selectedTraitIds.includes(trait.id);
  
  return (
    <ChoiceContainer>
      <ChoiceTitle>{prompt}</ChoiceTitle>
      
      {/* NEW: Show attribute effects preview */}
      {hasAttributeEffects && (
        <AttributeEffectsPreview>
          <strong>Attribute Effects:</strong>
          <AttributeEffect>
            <span>{effect.target?.charAt(0).toUpperCase() + effect.target?.slice(1)}</span>
            <span>{(effect.value || 0) > 0 ? '+' : ''}{effect.value || 0}</span>
          </AttributeEffect>
        </AttributeEffectsPreview>
      )}
      
      {/* NEW: Show point cost impact if trait is selected */}
      {isTraitSelected && (
        <PointImpactIndicator 
          $type={traitPointImpact.impact > 0 ? 'positive' : traitPointImpact.impact < 0 ? 'negative' : 'neutral'}
        >
          Points after selection: {traitPointImpact.pointsRemaining}
          {traitPointImpact.impact !== 0 && ` (${traitPointImpact.impact > 0 ? '+' : ''}${traitPointImpact.impact})`}
        </PointImpactIndicator>
      )}
      
      {/* NEW: Show forced adjustments warning */}
      {traitPointImpact.forcedAdjustments && traitPointImpact.forcedAdjustments.length > 0 && (
        <ForcedAdjustmentWarning>
          This trait will require additional attribute point adjustments:
          {traitPointImpact.forcedAdjustments.map((adj, index) => (
            <div key={index} style={{ marginTop: '0.25rem' }}>
              • {adj.attribute.charAt(0).toUpperCase() + adj.attribute.slice(1)}: {adj.pointsCost} extra points
            </div>
          ))}
        </ForcedAdjustmentWarning>
      )}
      
      <ChoiceGrid>
        {options.map(option => {
          const validation = validateTraitChoice(trait.id, effectIndex, option.value);
          const isSelected = currentChoice === option.value;
          const isInvalid = !validation.isValid && !isSelected;
          
          return (
            <div key={option.value}>
              <ChoiceButton
                $selected={isSelected}
                $invalid={isInvalid}
                onClick={() => {
                  if (validation.isValid || isSelected) {
                    handleChoiceChange(option.value);
                  }
                }}
                disabled={isInvalid}
              >
                <ChoiceButtonTitle>{option.displayName}</ChoiceButtonTitle>
                {option.description && (
                  <ChoiceButtonSubtitle>{option.description}</ChoiceButtonSubtitle>
                )}
              </ChoiceButton>
              
              {isInvalid && validation.message && (
                <ValidationMessage>
                  ⚠️ {validation.message}
                </ValidationMessage>
              )}
            </div>
          );
        })}
      </ChoiceGrid>
      
      {/* Show preview of the selected choice */}
      {preview && (
        <PreviewBox>
          <strong>Preview:</strong> {preview.description}
        </PreviewBox>
      )}
      
      {/* Clear selection button */}
      {currentChoice && (
        <ClearButton onClick={() => handleChoiceChange('')}>
          Clear Selection
        </ClearButton>
      )}
    </ChoiceContainer>
  );
};

export default TraitChoiceSelector;
```

## File: src/routes/character-creation/Attributes.tsx
```typescript
import React from 'react';
import { useCharacter } from '../../lib/stores/characterContext';
import { useEnhancedCharacterCalculation } from '../../lib/hooks/useEnhancedCharacterCalculation';
import { useAttributeCalculation } from '../../lib/hooks/useAttributeCalculation';
import { attributesData } from '../../lib/rulesdata/attributes';
import AttributePointsCounter from './AttributePointsCounter';
import styled from '@emotion/styled';
import {
	StyledContainer,
	StyledTitle,
	StyledPointsRemaining,
	StyledGrid,
	StyledCard,
	StyledCardTitle,
	StyledControls,
	StyledButton,
	StyledValue,
	StyledDescription
} from './styles/Attributes.styles';

// Additional styled components for enhanced display
const AttributeHeader = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 0.5rem;
`;

const AttributeTotal = styled.div<{ $exceeded: boolean }>`
	font-size: 1.1rem;
	font-weight: bold;
	color: ${props => props.$exceeded ? '#dc2626' : '#059669'};
`;

const AttributeBreakdown = styled.div`
	background-color: #f8fafc;
	border: 1px solid #e2e8f0;
	border-radius: 6px;
	padding: 0.75rem;
	margin-top: 0.75rem;
	font-size: 0.875rem;
`;

const BreakdownLine = styled.div`
	display: flex;
	justify-content: space-between;
	margin-bottom: 0.25rem;
	
	&:last-child {
		margin-bottom: 0;
		padding-top: 0.25rem;
		border-top: 1px solid #d1d5db;
		font-weight: 600;
	}
`;

const ValidationMessage = styled.div<{ $type: 'error' | 'warning' }>`
	margin-top: 0.5rem;
	padding: 0.5rem;
	border-radius: 4px;
	font-size: 0.75rem;
	background-color: ${props => props.$type === 'error' ? '#fef2f2' : '#fffbeb'};
	border: 1px solid ${props => props.$type === 'error' ? '#fecaca' : '#fed7aa'};
	color: ${props => props.$type === 'error' ? '#dc2626' : '#d97706'};
	
	&:before {
		content: ${props => props.$type === 'error' ? "'⚠️ '" : "'💡 '"};
		margin-right: 0.25rem;
	}
`;

const ForcedAdjustmentIndicator = styled.div`
	margin-top: 0.5rem;
	padding: 0.5rem;
	border-radius: 4px;
	font-size: 0.75rem;
	background-color: #fef3c7;
	border: 1px solid #fbbf24;
	color: #92400e;
	
	&:before {
		content: '⚠️ ';
		margin-right: 0.25rem;
	}
`;

const EffectiveValueDisplay = styled.div`
	display: flex;
	align-items: center;
	gap: 0.5rem;
	margin-top: 0.5rem;
	font-size: 0.875rem;
`;

const BaseValue = styled.span`
	color: #6b7280;
`;

const EffectiveValue = styled.span<{ $different: boolean }>`
	font-weight: ${props => props.$different ? 'bold' : 'normal'};
	color: ${props => props.$different ? '#059669' : '#374151'};
`;

const PointBreakdownSummary = styled.div`
	background-color: #f0f9ff;
	border: 1px solid #0ea5e9;
	border-radius: 6px;
	padding: 0.75rem;
	margin-bottom: 1rem;
	font-size: 0.875rem;
`;

const ForcedAdjustmentsWarning = styled.div`
	background-color: #fffbeb;
	border: 1px solid #f59e0b;
	border-radius: 6px;
	padding: 0.75rem;
	margin-bottom: 1rem;
	font-size: 0.875rem;
	color: #92400e;
	
	&:before {
		content: '⚠️ ';
		margin-right: 0.25rem;
	}
`;

type AttributeState = Record<string, number>;

function Attributes() {
	const { state, dispatch, attributePointsRemaining, attributePointsSpent, totalAttributePoints } = useCharacter();
	const { 
		getAttributeLimit, 
		canIncreaseAttribute, 
		canDecreaseAttribute,
		validateAttributeChange,
		getStatBreakdown
	} = useEnhancedCharacterCalculation();
	
	// NEW: Use intelligent attribute calculation for real-time feedback
	const calculation = useAttributeCalculation(state);
	const typedState = state as unknown as AttributeState;

	function increaseAttribute(attribute: string) {
		if (attributePointsRemaining > 0) {
			const currentValue = typedState[attribute];
			const validation = validateAttributeChange(attribute.replace('attribute_', ''), currentValue + 1);
			
			if (validation.isValid) {
				dispatch({ type: 'UPDATE_ATTRIBUTE', attribute, value: currentValue + 1 });
			}
		}
	}

	function decreaseAttribute(attribute: string) {
		const currentValue = typedState[attribute];
		const validation = validateAttributeChange(attribute.replace('attribute_', ''), currentValue - 1);
		
		if (validation.isValid) {
			dispatch({ type: 'UPDATE_ATTRIBUTE', attribute, value: currentValue - 1 });
		}
	}

	return (
		<StyledContainer>
			<StyledTitle>Attributes</StyledTitle>
			<AttributePointsCounter />
			
			{/* NEW: Enhanced point breakdown summary */}
			<PointBreakdownSummary>
				<BreakdownLine>
					<span>Base Points:</span>
					<span>11</span>
				</BreakdownLine>
				<BreakdownLine>
					<span>Bonus from Traits:</span>
					<span>{calculation.totalPointsAvailable - 11}</span>
				</BreakdownLine>
				<BreakdownLine>
					<span>Spent on Attributes:</span>
					<span>{calculation.pointsSpent - calculation.forcedAdjustments.reduce((sum, adj) => sum + adj.pointsCost, 0)}</span>
				</BreakdownLine>
				{calculation.forcedAdjustments.length > 0 && (
					<BreakdownLine>
						<span>Forced Adjustments:</span>
						<span>{calculation.forcedAdjustments.reduce((sum, adj) => sum + adj.pointsCost, 0)}</span>
					</BreakdownLine>
				)}
				<BreakdownLine>
					<span>Points Remaining:</span>
					<span style={{ color: calculation.pointsRemaining < 0 ? '#dc2626' : '#059669' }}>
						{calculation.pointsRemaining}
					</span>
				</BreakdownLine>
			</PointBreakdownSummary>
			
			{/* NEW: Forced adjustments warning */}
			{calculation.forcedAdjustments.length > 0 && (
				<ForcedAdjustmentsWarning>
					{calculation.forcedAdjustments.length} forced adjustment(s) due to traits:
					{calculation.forcedAdjustments.map((adj, index) => (
						<div key={index} style={{ marginTop: '0.25rem' }}>
							• {adj.attribute.charAt(0).toUpperCase() + adj.attribute.slice(1)}: 
							{adj.originalValue} → {adj.effectiveValue} (costs {adj.pointsCost} points)
						</div>
					))}
				</ForcedAdjustmentsWarning>
			)}
			
			{/* Validation summary */}
			{!calculation.isValid && (
				<ValidationMessage $type="error">
					Invalid build: {Math.abs(calculation.pointsRemaining)} points over budget
				</ValidationMessage>
			)}
			
			<StyledGrid>
				{attributesData.map((attribute) => {
					const attributeKey = `attribute_${attribute.id}`;
					const currentValue = typedState[attributeKey] || 0;
					const limit = getAttributeLimit(attribute.id);
					const breakdown = getStatBreakdown(attribute.id);
					
					// NEW: Get effective value and forced adjustment info
					const effectiveValue = calculation.effectiveAttributes[attribute.id] || currentValue;
					const forcedAdjustment = calculation.forcedAdjustments.find(adj => adj.attribute === attribute.id);
					const hasTraitEffect = effectiveValue !== currentValue;
					
					// Enhanced validation
					const canIncrease = attributePointsRemaining > 0 && canIncreaseAttribute(attribute.id);
					const canDecrease = canDecreaseAttribute(attribute.id);
					
					return (
						<StyledCard key={attribute.id}>
							<AttributeHeader>
								<StyledCardTitle>{attribute.name}</StyledCardTitle>
								<AttributeTotal $exceeded={limit.exceeded}>
									{limit.current}/{limit.max}
								</AttributeTotal>
							</AttributeHeader>
							
							<StyledDescription>{attribute.description}</StyledDescription>
							
							<StyledControls>
								<StyledButton
									onClick={() => decreaseAttribute(attributeKey)}
									disabled={!canDecrease}
									title={!canDecrease ? "Cannot decrease below -2" : ""}
								>
									-
								</StyledButton>
								<StyledValue>{currentValue}</StyledValue>
								<StyledButton
									onClick={() => increaseAttribute(attributeKey)}
									disabled={!canIncrease}
									title={!canIncrease ? (
										attributePointsRemaining <= 0 ? "No points remaining" : 
										"Would exceed maximum with trait bonuses"
									) : ""}
								>
									+
								</StyledButton>
							</StyledControls>
							
							{/* NEW: Display both base and effective values */}
							{hasTraitEffect && (
								<EffectiveValueDisplay>
									<BaseValue>Base: {currentValue}</BaseValue>
									<EffectiveValue $different={hasTraitEffect}>
										Effective: {effectiveValue}
									</EffectiveValue>
								</EffectiveValueDisplay>
							)}
							
							{/* Enhanced breakdown display */}
							{(limit.traitBonuses > 0 || breakdown) && (
								<AttributeBreakdown>
									<BreakdownLine>
										<span>Base Points:</span>
										<span>{currentValue}</span>
									</BreakdownLine>
									{limit.traitBonuses > 0 && (
										<BreakdownLine>
											<span>Trait Bonuses:</span>
											<span>+{limit.traitBonuses}</span>
										</BreakdownLine>
									)}
									<BreakdownLine>
										<span>Total:</span>
										<span>{limit.current}</span>
									</BreakdownLine>
								</AttributeBreakdown>
							)}
							
							{/* NEW: Forced adjustment indicator */}
							{forcedAdjustment && (
								<ForcedAdjustmentIndicator>
									Forced to minimum (-2), cost: {forcedAdjustment.pointsCost} points
								</ForcedAdjustmentIndicator>
							)}
							
							{/* Validation messages */}
							{limit.exceeded && (
								<ValidationMessage $type="error">
									Exceeds maximum limit of +{limit.max}
								</ValidationMessage>
							)}
							
							{!limit.exceeded && !canIncrease && attributePointsRemaining > 0 && (
								<ValidationMessage $type="warning">
									Cannot increase further due to trait bonuses
								</ValidationMessage>
							)}
						</StyledCard>
					);
				})}
			</StyledGrid>
		</StyledContainer>
	);
}

export default Attributes;
```

## File: src/routes/character-creation/ClassFeatures.tsx
```typescript
import { useCharacter } from '../../lib/stores/characterContext';
import { classesData } from '../../lib/rulesdata/loaders/class.loader';
import {
	findClassByName,
	getLegacyChoiceId,
	getAvailableSpellSchools
} from '../../lib/rulesdata/loaders/class-features.loader';
import { SpellSchool } from '../../lib/rulesdata/spells-data/types/spell.types';
import { getDetailedClassFeatureDescription } from '../../lib/utils/classFeatureDescriptions';
import { maneuvers, ManeuverType } from '../../lib/rulesdata/maneuvers';
import { techniques } from '../../lib/rulesdata/techniques';
import {
	StyledContainer,
	StyledTitle,
	StyledSection,
	StyledSectionTitle,
	StyledCard,
	StyledCardTitle,
	StyledCardDescription,
	StyledChoiceOptions,
	StyledLabel,
	StyledRadio,
	StyledOptionDescription,
	StyledNoSelection,
	StyledBenefitsList,
	StyledBenefit,
	StyledBenefitName,
	StyledBenefitDescription
} from './styles/ClassFeatures.styles';

function ClassFeatures() {
	const { state, dispatch } = useCharacter();

	const selectedClass = classesData.find((c) => c.id.toLowerCase() === state.classId?.toLowerCase());
	const selectedClassFeatures = selectedClass ? findClassByName(selectedClass.name) : null;
	// NEW: Use typed data instead of JSON parsing
	const selectedFeatureChoices: { [key: string]: string } = state.selectedFeatureChoices || {};

	function handleFeatureChoice(choiceId: string, value: string) {
		const currentChoices = { ...selectedFeatureChoices };
		currentChoices[choiceId] = value;
		dispatch({
			type: 'SET_FEATURE_CHOICES',
			selectedFeatureChoices: currentChoices
		});
	}

	function handleMultipleFeatureChoice(choiceId: string, value: string, isSelected: boolean) {
		const currentChoices = { ...selectedFeatureChoices };
		// Handle arrays directly (no legacy JSON string support)
		const currentValues: string[] = Array.isArray(currentChoices[choiceId])
			? [...(currentChoices[choiceId] as any)]
			: [];

		if (isSelected) {
			// Add the value if not already present
			if (!currentValues.includes(value)) {
				currentValues.push(value);
			}
		} else {
			// Remove the value
			const index = currentValues.indexOf(value);
			if (index > -1) {
				currentValues.splice(index, 1);
			}
		}

		currentChoices[choiceId] = currentValues;
		dispatch({
			type: 'SET_FEATURE_CHOICES',
			selectedFeatureChoices: currentChoices
		});
	}

	if (!selectedClass || !selectedClassFeatures) {
		return (
			<StyledContainer>
				<StyledNoSelection>Select a Class to see its features.</StyledNoSelection>
			</StyledContainer>
		);
	}

	// Get level 1 features
	const level1Features = selectedClassFeatures.coreFeatures.filter(
		(feature) => feature.levelGained === 1
	);

	// Get all feature choices from level 1 features (excluding in-game tactical choices)
	const inGameChoices = ['Divine Blessing', "Commander's Call", 'Debilitating Strike'];
	const featureChoices: any[] = [];
	level1Features.forEach((feature) => {
		// Skip features that are in-game tactical choices, not character creation choices
		if (feature.choices && !inGameChoices.includes(feature.featureName)) {
			feature.choices.forEach((choice, choiceIndex) => {
				const choiceId = getLegacyChoiceId(
					selectedClassFeatures.className,
					feature.featureName,
					choiceIndex
				);
				featureChoices.push({
					id: choiceId,
					prompt: choice.prompt,
					type: choice.count > 1 ? 'select_multiple' : 'select_one',
					maxSelections: choice.count > 1 ? choice.count : undefined,
					options:
						choice.options?.map((option) => ({
							value: option.name,
							label: option.name,
							description: option.description
						})) || []
				});
			});
		}
	});

	// Add martial choices based on class table and features
	const level1Data = selectedClass.levelProgression?.[0]; // Level 1 data from table
	if (level1Data) {
		// Get base maneuvers from table
		let tableManeuvers = level1Data.maneuversKnown || 0;
		let tableTechniques = level1Data.techniquesKnown || 0;

		// Add class-specific feature bonuses
		let featureManeuvers = 0;
		let featureTechniques = 0;

		// Parse feature descriptions to extract maneuver/technique bonuses
		selectedClassFeatures.coreFeatures.forEach((feature) => {
			if (feature.levelGained === 1) {
				// Check main feature description
				const description = feature.description.toLowerCase();

				// Look for "you learn X maneuvers" pattern (handles "you learn 2 maneuvers")
				const maneuverMatch = description.match(/you learn (\d+) (?:defensive )?maneuvers?/);
				if (maneuverMatch) {
					featureManeuvers += parseInt(maneuverMatch[1]);
				}

				// Look for "you learn 1 of the following maneuvers" pattern
				const specificManeuverMatch = description.match(/you learn 1 of the following maneuvers/);
				if (specificManeuverMatch) {
					featureManeuvers += 1;
				}

				// Look for "you learn X techniques" pattern
				const techniqueMatch = description.match(/you learn (\d+) techniques?/);
				if (techniqueMatch) {
					featureTechniques += parseInt(techniqueMatch[1]);
				}

				// Check benefits for maneuver/technique learning
				feature.benefits?.forEach((benefit) => {
					const benefitDescription = benefit.description.toLowerCase();

					// Look for "you learn X maneuvers" pattern in benefits
					const benefitManeuverMatch = benefitDescription.match(
						/you learn (\d+) (?:defensive )?maneuvers?/
					);
					if (benefitManeuverMatch) {
						featureManeuvers += parseInt(benefitManeuverMatch[1]);
					}

					// Look for "you learn 1 of the following maneuvers" pattern in benefits
					const benefitSpecificManeuverMatch = benefitDescription.match(
						/you learn 1 of the following maneuvers/
					);
					if (benefitSpecificManeuverMatch) {
						featureManeuvers += 1;
					}

					// Look for "you learn X techniques" pattern in benefits
					const benefitTechniqueMatch = benefitDescription.match(/you learn (\d+) techniques?/);
					if (benefitTechniqueMatch) {
						featureTechniques += parseInt(benefitTechniqueMatch[1]);
					}
				});
			}
		});

		const totalManeuvers = tableManeuvers + featureManeuvers;
		const totalTechniques = tableTechniques + featureTechniques;

		// Check if class gets all Attack maneuvers automatically
		const getsAllAttackManeuvers =
			selectedClassFeatures.className === 'Champion' ||
			selectedClassFeatures.martialPath?.maneuvers?.learnsAllAttack === true;

		// Add maneuver choices if needed
		if (totalManeuvers > 0) {
			const availableManeuvers = getsAllAttackManeuvers
				? maneuvers.filter((m) => m.type !== ManeuverType.Attack) // Class gets all Attack maneuvers automatically
				: maneuvers; // Other classes choose from all maneuvers

			const promptText = getsAllAttackManeuvers
				? `Choose ${totalManeuvers} Maneuver${totalManeuvers > 1 ? 's' : ''} (Attack maneuvers are automatic)`
				: `Choose ${totalManeuvers} Maneuver${totalManeuvers > 1 ? 's' : ''}`;

			featureChoices.push({
				id: `${selectedClassFeatures.className.toLowerCase()}_maneuvers`,
				prompt: promptText,
				type: 'select_multiple',
				maxSelections: totalManeuvers,
				options: availableManeuvers.map((maneuver) => ({
					value: maneuver.name,
					label: maneuver.name,
					description: `${maneuver.description}${maneuver.isReaction ? ' (Reaction)' : ''}${maneuver.requirement ? ` Requirement: ${maneuver.requirement}` : ''}`
				}))
			});
		}

		// Add technique choices if needed
		if (totalTechniques > 0) {
			featureChoices.push({
				id: `${selectedClassFeatures.className.toLowerCase()}_techniques`,
				prompt: `Choose ${totalTechniques} Technique${totalTechniques > 1 ? 's' : ''}`,
				type: totalTechniques > 1 ? 'select_multiple' : 'select_one',
				maxSelections: totalTechniques > 1 ? totalTechniques : undefined,
				options: techniques.map((technique) => ({
					value: technique.name,
					label: technique.name,
					description: `${technique.description}${technique.isReaction ? ' (Reaction)' : ''}${technique.requirement ? ` Requirement: ${technique.requirement}` : ''} Cost: ${technique.cost.ap ? `${technique.cost.ap} AP` : ''}${technique.cost.sp ? ` ${technique.cost.sp} SP` : ''}`
				}))
			});
		}
	}

	// Add spell school choices if needed
	if (selectedClassFeatures.spellcastingPath?.spellList) {
		const spellList = selectedClassFeatures.spellcastingPath.spellList;

		if (spellList.type === 'all_schools' && spellList.schoolCount) {
			// Warlock-style: choose X schools from all available
			const availableSchools = Object.values(SpellSchool);
			featureChoices.push({
				id: `${selectedClassFeatures.className.toLowerCase()}_spell_schools`,
				prompt: `Choose ${spellList.schoolCount} Spell School${spellList.schoolCount > 1 ? 's' : ''}`,
				type: 'select_multiple',
				maxSelections: spellList.schoolCount,
				options: availableSchools.map((school) => ({
					value: school,
					label: school,
					description: `Access to all spells from the ${school} school`
				}))
			});
		} else if (spellList.type === 'schools' && spellList.schoolCount && spellList.schoolCount > 0) {
			// Spellblade-style: choose X additional schools (already have specificSchools)
			const availableSchools = Object.values(SpellSchool);
			const alreadyHaveSchools = spellList.specificSchools || [];
			const choosableSchools = availableSchools.filter(
				(school) => !alreadyHaveSchools.includes(school)
			);

			featureChoices.push({
				id: `${selectedClassFeatures.className.toLowerCase()}_additional_spell_schools`,
				prompt: `Choose ${spellList.schoolCount} additional Spell School${spellList.schoolCount > 1 ? 's' : ''} (you already have: ${alreadyHaveSchools.join(', ')})`,
				type: spellList.schoolCount > 1 ? 'select_multiple' : 'select_one',
				maxSelections: spellList.schoolCount > 1 ? spellList.schoolCount : undefined,
				options: choosableSchools.map((school) => ({
					value: school,
					label: school,
					description: `Access to all spells from the ${school} school`
				}))
			});
		}

		// Check for level 1 features that require spell school choices (like Wizard's Spell School Initiate)
		level1Features.forEach((feature) => {
			const description = feature.description.toLowerCase();
			// Only include features that are character creation choices, not in-game tactical choices
			const isCharacterCreationChoice =
				(description.includes('choose a spell school') ||
					description.includes('choose 1 spell school')) &&
				// Exclude in-game features like Arcane Sigil
				!description.includes('when you create') &&
				!description.includes('when you cast') &&
				!description.includes('you can spend') &&
				// Include features that are clearly character creation (like training/specialization)
				(description.includes('training') ||
					description.includes('specialize') ||
					description.includes('initiate') ||
					description.includes('you gain the following benefits'));

			if (isCharacterCreationChoice) {
				const choiceId = `${selectedClassFeatures.className.toLowerCase()}_${feature.featureName.toLowerCase().replace(/\s+/g, '_')}_school`;

				// Only add if not already added
				if (!featureChoices.some((choice) => choice.id === choiceId)) {
					const availableSchools = Object.values(SpellSchool);
					featureChoices.push({
						id: choiceId,
						prompt: `${feature.featureName}: Choose a Spell School`,
						type: 'select_one',
						options: availableSchools.map((school) => ({
							value: school,
							label: school,
							description: `Specialize in the ${school} school of magic`
						}))
					});
				}
			}
		});
	}

	return (
		<StyledContainer>
			<StyledTitle>{selectedClass.name} Features</StyledTitle>

			{/* Starting Equipment Section */}
			{selectedClassFeatures.startingEquipment && (
				<StyledSection>
					<StyledSectionTitle>Starting Equipment</StyledSectionTitle>
					<StyledCard>
						<StyledCardTitle>Equipment Package</StyledCardTitle>
						<StyledBenefitsList>
							{selectedClassFeatures.startingEquipment.weaponsOrShields && (
								<StyledBenefit>
									<StyledBenefitName>Weapons/Shields</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.startingEquipment.weaponsOrShields.join(', ')}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
							{selectedClassFeatures.startingEquipment.rangedWeapon && (
								<StyledBenefit>
									<StyledBenefitName>Ranged Weapon</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.startingEquipment.rangedWeapon}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
							{selectedClassFeatures.startingEquipment.armor && (
								<StyledBenefit>
									<StyledBenefitName>Armor</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.startingEquipment.armor}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
							{selectedClassFeatures.startingEquipment.packs && (
								<StyledBenefit>
									<StyledBenefitName>Adventure Packs</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.startingEquipment.packs}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
						</StyledBenefitsList>
					</StyledCard>
				</StyledSection>
			)}

			{/* Martial Path Section */}
			{selectedClassFeatures.martialPath && (
				<StyledSection>
					<StyledSectionTitle>Martial Training</StyledSectionTitle>
					<StyledCard>
						<StyledCardTitle>Combat Proficiencies</StyledCardTitle>
						<StyledBenefitsList>
							{selectedClassFeatures.martialPath.combatTraining?.weapons && (
								<StyledBenefit>
									<StyledBenefitName>Weapon Training</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.martialPath.combatTraining.weapons.join(', ')}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
							{selectedClassFeatures.martialPath.combatTraining?.armor && (
								<StyledBenefit>
									<StyledBenefitName>Armor Training</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.martialPath.combatTraining.armor.join(', ')}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
							{selectedClassFeatures.martialPath.combatTraining?.shields && (
								<StyledBenefit>
									<StyledBenefitName>Shield Training</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.martialPath.combatTraining.shields.join(', ')}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
						</StyledBenefitsList>
					</StyledCard>

					{selectedClassFeatures.martialPath.staminaRegen && (
						<StyledCard>
							<StyledCardTitle>Stamina Regeneration</StyledCardTitle>
							<StyledCardDescription>
								{selectedClassFeatures.martialPath.staminaRegen.description}
							</StyledCardDescription>
							{selectedClassFeatures.martialPath.staminaRegen.conditions && (
								<StyledBenefitsList>
									{selectedClassFeatures.martialPath.staminaRegen.conditions.map(
										(condition, index) => (
											<StyledBenefit key={index}>
												<StyledBenefitDescription>• {condition}</StyledBenefitDescription>
											</StyledBenefit>
										)
									)}
								</StyledBenefitsList>
							)}
						</StyledCard>
					)}
				</StyledSection>
			)}

			{/* Spellcasting Path Section */}
			{selectedClassFeatures.spellcastingPath && (
				<StyledSection>
					<StyledSectionTitle>Spellcasting Training</StyledSectionTitle>

					{/* Combat Training for Spellcasters */}
					{(selectedClassFeatures.spellcastingPath.combatTraining?.armor ||
						selectedClassFeatures.spellcastingPath.combatTraining?.shields) && (
						<StyledCard>
							<StyledCardTitle>Combat Proficiencies</StyledCardTitle>
							<StyledBenefitsList>
								{selectedClassFeatures.spellcastingPath.combatTraining?.armor && (
									<StyledBenefit>
										<StyledBenefitName>Armor Training</StyledBenefitName>
										<StyledBenefitDescription>
											{selectedClassFeatures.spellcastingPath.combatTraining.armor.join(', ')}
										</StyledBenefitDescription>
									</StyledBenefit>
								)}
								{selectedClassFeatures.spellcastingPath.combatTraining?.shields && (
									<StyledBenefit>
										<StyledBenefitName>Shield Training</StyledBenefitName>
										<StyledBenefitDescription>
											{selectedClassFeatures.spellcastingPath.combatTraining.shields.join(', ')}
										</StyledBenefitDescription>
									</StyledBenefit>
								)}
							</StyledBenefitsList>
						</StyledCard>
					)}

					{/* Spell List Information */}
					{selectedClassFeatures.spellcastingPath.spellList && (
						<StyledCard>
							<StyledCardTitle>Spell List Access</StyledCardTitle>
							<StyledBenefitsList>
								{selectedClassFeatures.spellcastingPath.spellList.listName && (
									<StyledBenefit>
										<StyledBenefitName>Spell List</StyledBenefitName>
										<StyledBenefitDescription>
											{selectedClassFeatures.spellcastingPath.spellList.listName}
										</StyledBenefitDescription>
									</StyledBenefit>
								)}
								{(() => {
									const availableSchools = getAvailableSpellSchools(selectedClassFeatures);
									return availableSchools.length > 0 ? (
										<StyledBenefit>
											<StyledBenefitName>Available Schools</StyledBenefitName>
											<StyledBenefitDescription>
												{selectedClassFeatures.spellcastingPath.spellList?.type === 'all_schools'
													? `Choose ${selectedClassFeatures.spellcastingPath.spellList.schoolCount || 'any'} from: ${availableSchools.join(', ')}`
													: availableSchools.join(', ')}
											</StyledBenefitDescription>
										</StyledBenefit>
									) : null;
								})()}
								{selectedClassFeatures.spellcastingPath.spellList.spellTags && (
									<StyledBenefit>
										<StyledBenefitName>Available Spell Tags</StyledBenefitName>
										<StyledBenefitDescription>
											{selectedClassFeatures.spellcastingPath.spellList.spellTags.join(', ')}
										</StyledBenefitDescription>
									</StyledBenefit>
								)}
								{selectedClassFeatures.spellcastingPath.spellList.description && (
									<StyledBenefit>
										<StyledBenefitName>Selection Method</StyledBenefitName>
										<StyledBenefitDescription>
											{selectedClassFeatures.spellcastingPath.spellList.description}
										</StyledBenefitDescription>
									</StyledBenefit>
								)}
							</StyledBenefitsList>
							{selectedClassFeatures.spellcastingPath.spellList.betaNote && (
								<StyledCardDescription>
									<strong>Beta Note:</strong>{' '}
									{selectedClassFeatures.spellcastingPath.spellList.betaNote}
								</StyledCardDescription>
							)}
						</StyledCard>
					)}

					{/* Spellcasting Progression */}
					<StyledCard>
						<StyledCardTitle>Spellcasting Progression</StyledCardTitle>
						<StyledBenefitsList>
							{selectedClassFeatures.spellcastingPath.cantrips && (
								<StyledBenefit>
									<StyledBenefitName>Cantrips Known</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.spellcastingPath.cantrips.knownIncreasesBy}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
							{selectedClassFeatures.spellcastingPath.spells && (
								<StyledBenefit>
									<StyledBenefitName>Spells Known</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.spellcastingPath.spells.knownIncreasesBy}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
							{selectedClassFeatures.spellcastingPath.manaPoints && (
								<StyledBenefit>
									<StyledBenefitName>Mana Points</StyledBenefitName>
									<StyledBenefitDescription>
										{selectedClassFeatures.spellcastingPath.manaPoints.maximumIncreasesBy}
									</StyledBenefitDescription>
								</StyledBenefit>
							)}
						</StyledBenefitsList>
					</StyledCard>
				</StyledSection>
			)}

			<StyledSection>
				<StyledSectionTitle>Level 1 Features</StyledSectionTitle>
				{level1Features.map((feature, index) => (
					<StyledCard key={index}>
						<StyledCardTitle>{feature.featureName}</StyledCardTitle>
						<StyledCardDescription>{feature.description}</StyledCardDescription>
						{feature.benefits && (
							<StyledBenefitsList>
								{feature.benefits.map((benefit, benefitIndex) => (
									<StyledBenefit key={benefitIndex}>
										<StyledBenefitName>{benefit.name}</StyledBenefitName>
										<StyledBenefitDescription>{benefit.description}</StyledBenefitDescription>
									</StyledBenefit>
								))}
							</StyledBenefitsList>
						)}
					</StyledCard>
				))}
			</StyledSection>

			{/* Automatic Attack Maneuvers Section */}
			{(selectedClassFeatures.className === 'Champion' ||
				selectedClassFeatures.martialPath?.maneuvers?.learnsAllAttack === true) && (
				<StyledSection>
					<StyledSectionTitle>Automatic Maneuvers</StyledSectionTitle>
					<StyledCard>
						<StyledCardTitle>Attack Maneuvers (Automatically Known)</StyledCardTitle>
						<StyledCardDescription>
							{selectedClassFeatures.className === 'Champion'
								? 'As a Champion, you automatically know all Attack maneuvers. You will also choose additional maneuvers and techniques below.'
								: 'This class automatically knows all Attack maneuvers due to their martial training. You will also choose additional maneuvers below.'}
						</StyledCardDescription>
						<StyledBenefitsList>
							{maneuvers
								.filter((m) => m.type === ManeuverType.Attack)
								.map((maneuver, index) => (
									<StyledBenefit key={index}>
										<StyledBenefitName>{maneuver.name}</StyledBenefitName>
										<StyledBenefitDescription>{maneuver.description}</StyledBenefitDescription>
									</StyledBenefit>
								))}
						</StyledBenefitsList>
					</StyledCard>
				</StyledSection>
			)}

			{featureChoices.length > 0 && (
				<StyledSection>
					<StyledSectionTitle>Feature Choices</StyledSectionTitle>
					{featureChoices.map((choice: any) => (
						<StyledCard key={choice.id}>
							<StyledCardTitle>{choice.prompt}</StyledCardTitle>
							{choice.type === 'select_one' && (
								<StyledChoiceOptions>
									{choice.options.map((option: any) => {
										const detailedDescription = getDetailedClassFeatureDescription(
											choice.id,
											option.value
										);
										return (
											<StyledLabel key={option.value}>
												<StyledRadio
													type="radio"
													name={choice.id}
													value={option.value}
													checked={selectedFeatureChoices[choice.id] === option.value}
													onChange={() => handleFeatureChoice(choice.id, option.value)}
												/>
												{option.label}
												{(option.description || detailedDescription) && (
													<StyledOptionDescription>
														{option.description || detailedDescription}
													</StyledOptionDescription>
												)}
											</StyledLabel>
										);
									})}
								</StyledChoiceOptions>
							)}
							{choice.type === 'select_multiple' && (
								<StyledChoiceOptions>
									{choice.options.map((option: any) => {
										// Handle arrays directly (no legacy JSON string support)
										const currentValues: string[] = selectedFeatureChoices[choice.id]
											? (Array.isArray(selectedFeatureChoices[choice.id]) 
												? selectedFeatureChoices[choice.id] as string[]
												: [])
											: [];
										const isSelected = currentValues.includes(option.value);
										const canSelect = currentValues.length < (choice.maxSelections || 999);
										const isDisabled = !isSelected && !canSelect;
										const detailedDescription = getDetailedClassFeatureDescription(
											choice.id,
											option.value
										);

										return (
											<StyledLabel key={option.value} style={{ opacity: isDisabled ? 0.5 : 1 }}>
												<StyledRadio
													type="checkbox"
													name={choice.id}
													value={option.value}
													checked={isSelected}
													disabled={isDisabled}
													onChange={(e) =>
														handleMultipleFeatureChoice(choice.id, option.value, e.target.checked)
													}
												/>
												{option.label}
												{(option.description || detailedDescription) && (
													<StyledOptionDescription>
														{option.description || detailedDescription}
													</StyledOptionDescription>
												)}
											</StyledLabel>
										);
									})}
									{choice.maxSelections && (
										<StyledOptionDescription style={{ marginTop: '8px', fontStyle: 'italic' }}>
											Select up to {choice.maxSelections} options (
											{selectedFeatureChoices[choice.id]
												? (Array.isArray(selectedFeatureChoices[choice.id]) 
													? (selectedFeatureChoices[choice.id] as string[]).length
													: 0)
												: 0}
											/{choice.maxSelections} selected)
										</StyledOptionDescription>
									)}
								</StyledChoiceOptions>
							)}
						</StyledCard>
					))}
				</StyledSection>
			)}
		</StyledContainer>
	);
}

export default ClassFeatures;
```

## File: src/routes/character-sheet/components/Attacks.tsx
```typescript
import React from 'react';
import type { AttackData, CharacterSheetData } from '../../../types';
import { weapons, type Weapon, WeaponType } from '../../../lib/rulesdata/inventoryItems';
import { useCharacterAttacks, useCharacterSheet } from '../hooks/CharacterSheetProvider';
import {
	parseDamage,
	getDamageType,
	isRangedWeapon,
	calculateAttackBonus,
	calculateDamage,
	getVersatileDamage,
	getWeaponFeatures,
	createEmptyAttackData
} from '../../../lib/utils/weaponUtils';
import {
	StyledAttacksSection,
	StyledAttacksHeader,
	StyledAttacksTitle,
	StyledAddWeaponButton,
	StyledAttacksContainer,
	StyledAttacksHeaderRow,
	StyledHeaderColumn,
	StyledEmptyState,
	StyledAttackRow,
	StyledRemoveButton,
	StyledWeaponSelect,
	StyledDamageCell,
	StyledInfoIcon,
	StyledDamageTypeCell
} from '../styles/Attacks';

export interface AttacksProps {
	characterData: CharacterSheetData;
	onAttackClick: (attack: AttackData, weapon: Weapon | null) => void;
}

const Attacks: React.FC<AttacksProps> = ({ characterData, onAttackClick }) => {
	const { addAttack, removeAttack, updateAttack } = useCharacterSheet();
	const attacks = useCharacterAttacks();
	const addWeaponSlot = () => {
		const newAttack: AttackData = {
			id: `attack_${Date.now()}`,
			weaponName: '',
			name: '',
			attackBonus: 0,
			damage: '',
			damageType: 'slashing',
			critRange: '20',
			critDamage: '',
			brutalDamage: '',
			heavyHitEffect: ''
		};
		addAttack(newAttack);
	};

	const removeWeaponSlot = (attackIndex: number) => {
		const attackToRemove = attacks[attackIndex];
		if (attackToRemove) {
			removeAttack(attackToRemove.id);
		}
	};

	const handleWeaponSelect = (attackIndex: number, weaponName: string) => {
		console.log('Selecting weapon:', weaponName);
		const weapon = weapons.find((w) => w.name === weaponName);
		if (!weapon) {
			console.error('Weapon not found:', weaponName);
			return;
		}
		console.log('Found weapon:', weapon);

		const newAttackData = calculateAttackData(weapon);

		const attackToUpdate = attacks[attackIndex];
		if (attackToUpdate) {
			const updatedAttack = { ...newAttackData, id: attackToUpdate.id };
			updateAttack(attackToUpdate.id, updatedAttack);
		}
	};

	const calculateAttackData = (weapon: Weapon): AttackData => {
		if (!weapon || !characterData) {
			return createEmptyAttackData(weapon?.name);
		}

		const mightMod = Math.floor((characterData.finalMight - 10) / 2);
		const agilityMod = Math.floor((characterData.finalAgility - 10) / 2);

		const attackBonus = calculateAttackBonus(
			weapon,
			characterData.finalCombatMastery,
			mightMod,
			agilityMod
		);

		const damageType = getDamageType(weapon.damage);
		const versatileInfo = getVersatileDamage(weapon);
		const damageString = versatileInfo
			? `${versatileInfo.oneHanded} (${versatileInfo.twoHanded} two-handed)`
			: weapon.damage;

		const critRange = '20'; // Default crit range
		const critDamage = calculateDamage(weapon, 'normal');
		const brutalDamage = calculateDamage(weapon, 'brutal');
		const heavyHitEffect = weapon.properties.includes('Impact') ? '+1 damage on Heavy Hit' : '';

		return {
			id: '',
			weaponName: weapon.name,
			name: weapon.name,
			attackBonus,
			damage: damageString,
			damageType,
			critRange,
			critDamage,
			brutalDamage,
			heavyHitEffect
		};
	};

	return (
		<StyledAttacksSection>
			<StyledAttacksHeader>
				<StyledAttacksTitle>ATTACKS</StyledAttacksTitle>
				<StyledAddWeaponButton onClick={addWeaponSlot}>+ Add Weapon</StyledAddWeaponButton>
			</StyledAttacksHeader>

			<StyledAttacksContainer>
				<StyledAttacksHeaderRow>
					<span></span> {/* Empty column for remove button */}
					<StyledHeaderColumn>Weapon</StyledHeaderColumn>
					<StyledHeaderColumn align="center">
						Base
						<br />
						Dmg
					</StyledHeaderColumn>
					<StyledHeaderColumn align="center">
						Heavy
						<br />
						Dmg
					</StyledHeaderColumn>
					<StyledHeaderColumn align="center">
						Brutal
						<br />
						Dmg
					</StyledHeaderColumn>
					<StyledHeaderColumn align="center">Type</StyledHeaderColumn>
					<StyledHeaderColumn align="center">
						<StyledInfoIcon>i</StyledInfoIcon>
					</StyledHeaderColumn>
				</StyledAttacksHeaderRow>

				{attacks.length === 0 ? (
					<StyledEmptyState>
						No weapons added. Click "Add Weapon" to add your first weapon.
					</StyledEmptyState>
				) : (
					attacks.map((attack, index) => {
						const weapon = attack.weaponName
							? weapons.find((w) => w.name === attack.weaponName)
							: null;

						return (
							<StyledAttackRow key={attack.id}>
								{/* Remove Button */}
								<StyledRemoveButton onClick={() => removeWeaponSlot(index)} title="Remove weapon">
									×
								</StyledRemoveButton>

								{/* Weapon Selection */}
								<StyledWeaponSelect
									value={attack.weaponName}
									onChange={(e: any) => handleWeaponSelect(index, e.target.value)}
								>
									<option value="">Select Weapon...</option>
									{weapons.map((weapon) => (
										<option key={weapon.name} value={weapon.name}>
											{weapon.name} ({weapon.handedness})
										</option>
									))}
								</StyledWeaponSelect>

								{/* Base Damage */}
								<StyledDamageCell
									title={
										weapon
											? `Base weapon damage: ${weapon.damage}${getVersatileDamage(weapon) ? ` (${getVersatileDamage(weapon)?.twoHanded} when two-handed)` : ''}`
											: ''
									}
								>
									{weapon ? attack.damage || weapon.damage : '-'}
								</StyledDamageCell>

								{/* Heavy Damage */}
								<StyledDamageCell
									color="#d2691e"
									title={
										weapon
											? weapon.properties.includes('Impact')
												? `Heavy Hit: ${calculateDamage(weapon, 'heavy')} damage (base ${weapon.damage} + 1 heavy + 1 impact) + Target must make Might Save or be knocked Prone and pushed 5 feet`
												: `Heavy Hit: ${calculateDamage(weapon, 'heavy')} damage (base ${weapon.damage} + 1 heavy)`
											: ''
									}
								>
									{weapon ? (
										<>
											{calculateDamage(weapon, 'heavy')}
											{weapon.properties.includes('Impact') && (
												<div style={{ fontSize: '0.6rem' }}>+Prone/Push</div>
											)}
										</>
									) : (
										'-'
									)}
								</StyledDamageCell>

								{/* Brutal Damage */}
								<StyledDamageCell
									color="#dc143c"
									title={
										weapon
											? weapon.properties.includes('Impact')
												? `Brutal Hit: ${calculateDamage(weapon, 'brutal')} damage (base ${weapon.damage} + 2 brutal + 1 impact)`
												: `Brutal Hit: ${calculateDamage(weapon, 'brutal')} damage (base ${weapon.damage} + 2 brutal)`
											: ''
									}
								>
									{weapon ? calculateDamage(weapon, 'brutal') : '-'}
								</StyledDamageCell>

								{/* Damage Type */}
								<StyledDamageTypeCell
									title={weapon ? `${getDamageType(weapon.damage)} damage` : ''}
								>
									{weapon ? parseDamage(weapon.damage).type : '-'}
								</StyledDamageTypeCell>

								{/* Damage Calculation Info */}
								<div style={{ textAlign: 'center', fontSize: '1.1rem' }}>
									{weapon ? (
										<StyledInfoIcon onClick={() => onAttackClick(attack, weapon)}>i</StyledInfoIcon>
									) : (
										'-'
									)}
								</div>
							</StyledAttackRow>
						);
					})
				)}
			</StyledAttacksContainer>
		</StyledAttacksSection>
	);
};

export default Attacks;
```

## File: src/routes/character-sheet/components/Attributes.tsx
```typescript
import React from 'react';
import type { SkillData, CharacterSheetData } from '../../../types';
import type { EnhancedStatBreakdown } from '../../../lib/types/effectSystem';
import Tooltip from './Tooltip';
import { createEnhancedTooltip } from './EnhancedStatTooltips';
import {
	AttributeSection,
	AttributeHeader,
	AttributeBox,
	AttributeAbbreviation,
	AttributeValue,
	AttributeInfo,
	AttributeName,
	AttributeSave,
	SkillRow,
	SkillName,
	PrimeSection,
	PrimeLabel,
	PrimeValue
} from '../styles/Attributes';
import { StyledProficiencyDots, StyledDot } from '../styles/Skills';

interface AttributesProps {
	characterData: CharacterSheetData;
	skillsByAttribute: {
		prime: SkillData[];
		might: SkillData[];
		agility: SkillData[];
		charisma: SkillData[];
		intelligence: SkillData[];
	};
	breakdowns?: Record<string, EnhancedStatBreakdown>;
}

const Attributes: React.FC<AttributesProps> = ({ characterData, skillsByAttribute, breakdowns }) => {
	const renderSkills = (skills: SkillData[]) => {
		return skills.map((skill) => (
			<SkillRow key={skill.id}>
				<SkillName>{skill.name.toUpperCase()}</SkillName>
				<div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
					<StyledProficiencyDots>
						{[1, 2, 3, 4, 5].map((level) => (
							<StyledDot key={level} $filled={level <= skill.proficiency} />
						))}
					</StyledProficiencyDots>
					{skill.bonus !== undefined && (
						<span style={{
							fontSize: '0.875rem',
							fontWeight: '600',
							color: skill.bonus >= 0 ? '#059669' : '#dc2626',
							minWidth: '2rem',
							textAlign: 'center'
						}}>
							{skill.bonus >= 0 ? '+' : ''}{skill.bonus}
						</span>
					)}
				</div>
			</SkillRow>
		));
	};

	return (
		<>
			{/* Prime Modifier & Awareness */}
			<PrimeSection>
				<PrimeLabel>Prime</PrimeLabel>
				<PrimeValue>
					{characterData.finalPrimeModifierAttribute} +{characterData.finalPrimeModifierValue}
				</PrimeValue>
			</PrimeSection>

			{/* Awareness (Prime skill) */}
			{renderSkills(skillsByAttribute.prime)}

			{/* Might Section */}
			<AttributeSection>
				<AttributeHeader>
					<AttributeBox>
						<AttributeAbbreviation>MIG</AttributeAbbreviation>
						<Tooltip 
							content={
								breakdowns?.attribute_might 
									? createEnhancedTooltip('Might', breakdowns.attribute_might)
									: `${characterData.finalMight} Might`
							} 
							position="top"
						>
							<AttributeValue>{characterData.finalMight}</AttributeValue>
						</Tooltip>
					</AttributeBox>
					<AttributeInfo>
						<AttributeName>MIGHT</AttributeName>
						<AttributeSave>SAVE +{characterData.finalSaveMight}</AttributeSave>
					</AttributeInfo>
				</AttributeHeader>

				{renderSkills(skillsByAttribute.might)}
			</AttributeSection>

			{/* Agility Section */}
			<AttributeSection>
				<AttributeHeader>
					<AttributeBox>
						<AttributeAbbreviation>AGI</AttributeAbbreviation>
						<Tooltip 
							content={
								breakdowns?.attribute_agility 
									? createEnhancedTooltip('Agility', breakdowns.attribute_agility)
									: `${characterData.finalAgility} Agility`
							} 
							position="top"
						>
							<AttributeValue>{characterData.finalAgility}</AttributeValue>
						</Tooltip>
					</AttributeBox>
					<AttributeInfo>
						<AttributeName>AGILITY</AttributeName>
						<AttributeSave>SAVE +{characterData.finalSaveAgility}</AttributeSave>
					</AttributeInfo>
				</AttributeHeader>

				{renderSkills(skillsByAttribute.agility)}
			</AttributeSection>

			{/* Charisma Section */}
			<AttributeSection>
				<AttributeHeader>
					<AttributeBox>
						<AttributeAbbreviation>CHA</AttributeAbbreviation>
						<Tooltip 
							content={
								breakdowns?.attribute_charisma 
									? createEnhancedTooltip('Charisma', breakdowns.attribute_charisma)
									: `${characterData.finalCharisma} Charisma`
							} 
							position="top"
						>
							<AttributeValue>{characterData.finalCharisma}</AttributeValue>
						</Tooltip>
					</AttributeBox>
					<AttributeInfo>
						<AttributeName>CHARISMA</AttributeName>
						<AttributeSave>SAVE +{characterData.finalSaveCharisma}</AttributeSave>
					</AttributeInfo>
				</AttributeHeader>

				{renderSkills(skillsByAttribute.charisma)}
			</AttributeSection>

			{/* Intelligence Section */}
			<AttributeSection>
				<AttributeHeader>
					<AttributeBox>
						<AttributeAbbreviation>INT</AttributeAbbreviation>
						<Tooltip 
							content={
								breakdowns?.attribute_intelligence 
									? createEnhancedTooltip('Intelligence', breakdowns.attribute_intelligence)
									: `${characterData.finalIntelligence} Intelligence`
							} 
							position="top"
						>
							<AttributeValue>{characterData.finalIntelligence}</AttributeValue>
						</Tooltip>
					</AttributeBox>
					<AttributeInfo>
						<AttributeName>INTELLIGENCE</AttributeName>
						<AttributeSave>SAVE +{characterData.finalSaveIntelligence}</AttributeSave>
					</AttributeInfo>
				</AttributeHeader>

				{renderSkills(skillsByAttribute.intelligence)}
			</AttributeSection>
		</>
	);
};

export default Attributes;
```

## File: src/routes/character-sheet/components/Combat.tsx
```typescript
import React from 'react';
import type { CharacterSheetData, CurrentValues } from '../../../types';
import type { EnhancedStatBreakdown } from '../../../lib/types/effectSystem';
import { StyledCombatSection, StyledActionPoints, StyledActionPoint } from '../styles/Combat';
import Tooltip from './Tooltip';
import { createEnhancedDefenseTooltip } from './EnhancedStatTooltips';
import { useCharacterResources, useCharacterSheet } from '../hooks/CharacterSheetProvider';

export interface CombatProps {
	breakdowns?: Record<string, EnhancedStatBreakdown>;
}

const Combat: React.FC<CombatProps> = ({ breakdowns }) => {
	const { state, dispatch } = useCharacterSheet();
	const resources = useCharacterResources();
	
	if (!state.character) {
		return <div>Loading combat...</div>;
	}
	
	const characterData = state.character;
	const currentValues = resources.current;
	const renderActionPoints = () => {
		return [0, 1, 2, 3].map((index) => (
			<StyledActionPoint
				key={index}
				used={index < currentValues.actionPointsUsed}
				onClick={() => {
					const newUsed = index < currentValues.actionPointsUsed ? index : index + 1;
					// TODO: Implement action points update through reducer
					console.log('Action points update needed:', newUsed);
				}}
			>
				{index + 1}
			</StyledActionPoint>
		));
	};

	return (
		<StyledCombatSection>
			<div
				style={{
					fontSize: '1.1rem',
					fontWeight: 'bold',
					color: '#8b4513',
					textAlign: 'center',
					marginBottom: '1rem'
				}}
			>
				COMBAT
			</div>

			{/* Action Points */}
			<div style={{ textAlign: 'center', marginBottom: '1rem' }}>
				<div
					style={{
						fontSize: '0.9rem',
						fontWeight: 'bold',
						color: '#8b4513',
						marginBottom: '0.5rem'
					}}
				>
					ACTION POINTS
				</div>
				<StyledActionPoints>{renderActionPoints()}</StyledActionPoints>
			</div>

			{/* Combat Stats */}
			<div style={{ fontSize: '0.9rem', color: '#8b4513' }}>
				<div
					style={{
						display: 'flex',
						justifyContent: 'space-between',
						alignItems: 'center',
						padding: '0.3rem',
						borderBottom: '1px solid #e5e5e5'
					}}
				>
					<div style={{ display: 'flex', alignItems: 'center', gap: '0.3rem' }}>
						<span>ATTACK / SPELL CHECK</span>
						<Tooltip
							tooltipContent={createEnhancedDefenseTooltip(
								breakdowns?.attack_spell_check || { base: 0, effects: [] },
								'Attack / Spell Check'
							)}
							isEnabled={!!breakdowns?.attack_spell_check}
						>
							<span
								style={{
									display: 'inline-flex',
									alignItems: 'center',
									justifyContent: 'center',
									width: '14px',
									height: '14px',
									borderRadius: '50%',
									backgroundColor: '#8b4513',
									color: 'white',
									fontSize: '10px',
									fontWeight: 'bold',
									cursor: 'help',
									verticalAlign: 'middle'
								}}
							>
								i
							</span>
						</Tooltip>
					</div>
					<span style={{ fontWeight: 'bold' }}>
						+{characterData.finalCombatMastery + characterData.finalPrimeModifierValue}
					</span>
				</div>
				<div
					style={{
						display: 'flex',
						justifyContent: 'space-between',
						alignItems: 'center',
						padding: '0.3rem',
						borderBottom: '1px solid #e5e5e5'
					}}
				>
					<div style={{ display: 'flex', alignItems: 'center', gap: '0.3rem' }}>
						<span>SAVE DC</span>
						<Tooltip
							tooltipContent={createEnhancedDefenseTooltip(
								breakdowns?.save_dc || { base: 0, effects: [] },
								'Save DC'
							)}
							isEnabled={!!breakdowns?.save_dc}
						>
							<span
								style={{
									display: 'inline-flex',
									alignItems: 'center',
									justifyContent: 'center',
									width: '14px',
									height: '14px',
									borderRadius: '50%',
									backgroundColor: '#8b4513',
									color: 'white',
									fontSize: '10px',
									fontWeight: 'bold',
									cursor: 'help',
									verticalAlign: 'middle'
								}}
							>
								i
							</span>
						</Tooltip>
					</div>
					<span style={{ fontWeight: 'bold' }}>{characterData.finalSaveDC}</span>
				</div>
				<div
					style={{
						display: 'flex',
						justifyContent: 'space-between',
						alignItems: 'center',
						padding: '0.3rem'
					}}
				>
					<div style={{ display: 'flex', alignItems: 'center', gap: '0.3rem' }}>
						<span>MARTIAL CHECK</span>
						<Tooltip
							tooltipContent={createEnhancedDefenseTooltip(
								breakdowns?.martial_check || { base: 0, effects: [] },
								'Martial Check'
							)}
							isEnabled={!!breakdowns?.martial_check}
						>
							<span
								style={{
									display: 'inline-flex',
									alignItems: 'center',
									justifyContent: 'center',
									width: '14px',
									height: '14px',
									borderRadius: '50%',
									backgroundColor: '#8b4513',
									color: 'white',
									fontSize: '10px',
									fontWeight: 'bold',
									cursor: 'help',
									verticalAlign: 'middle'
								}}
							>
								i
							</span>
						</Tooltip>
					</div>
					<span style={{ fontWeight: 'bold' }}>
						+
						{characterData.finalCombatMastery +
							characterData.finalPrimeModifierValue +
							Math.floor(currentValues.actionPointsUsed / 3)}
					</span>
				</div>
			</div>
		</StyledCombatSection>
	);
};

export default Combat;
```

## File: src/routes/character-sheet/components/Defenses.tsx
```typescript
import React, { useState } from 'react';
import {
	DefensesContainer,
	DefenseItem,
	DefenseLabelContainer,
	DefenseLabel,
	ShieldContainer,
	ShieldValue,
	ShieldInput,
	DefenseFooter,
	AutoCalculatedNote,
	RevertButton
} from '../styles/Defenses';
import DefenseChangeModal from './DefenseChangeModal';
import Tooltip from './Tooltip';
import { createEnhancedDefenseTooltip } from './EnhancedStatTooltips';
import { useCharacterDefenses, useCharacterSheet } from '../hooks/CharacterSheetProvider';
import type { EnhancedStatBreakdown } from '../../../lib/types/effectSystem';
import {
	addDefenseNote,
	getDefenseTooltipWithNotes,
	getDefenseDisplayName,
	clearDefenseNotesForField
} from '../../../lib/utils/defenseNotes';

interface DefensesProps {
	breakdowns?: Record<string, EnhancedStatBreakdown>;
	isMobile?: boolean;
}

const Defenses: React.FC<DefensesProps> = ({
	breakdowns,
	isMobile = false
}) => {
	const { setManualDefense } = useCharacterSheet();
	const defenses = useCharacterDefenses();

	if (!defenses) {
		return (
			<div style={{ padding: '1rem', color: '#666', textAlign: 'center' }}>
				<p>Loading defenses...</p>
			</div>
		);
	}
	const [pendingChange, setPendingChange] = useState<{
		field: 'manualPD' | 'manualPDR' | 'manualAD';
		oldValue: number;
		newValue: number;
	} | null>(null);

	const [originalValue, setOriginalValue] = useState<number | null>(null);

	const getCurrentValue = (field: 'manualPD' | 'manualPDR' | 'manualAD'): number => {
		switch (field) {
			case 'manualPD':
				return defenses.manualOverrides.PD !== undefined
					? defenses.manualOverrides.PD
					: defenses.PD;
			case 'manualPDR':
				return defenses.manualOverrides.PDR !== undefined
					? defenses.manualOverrides.PDR
					: defenses.PDR;
			case 'manualAD':
				return defenses.manualOverrides.AD !== undefined
					? defenses.manualOverrides.AD
					: defenses.AD;
		}
	};

	const handleNoteConfirm = (reason: string) => {
		if (!pendingChange) return;

		// Add the note to storage (will need character ID from context)
		// TODO: Integrate defense notes with new system if needed

		// Apply the defense change using context
		const update: { pd?: number; ad?: number; pdr?: number } = {};
		switch (pendingChange.field) {
			case 'manualPD':
				update.pd = pendingChange.newValue;
				break;
			case 'manualPDR':
				update.pdr = pendingChange.newValue;
				break;
			case 'manualAD':
				update.ad = pendingChange.newValue;
				break;
		}
		setManualDefense(update.pd, update.ad, update.pdr);

		// Clear pending change
		setPendingChange(null);
	};

	const handleNoteCancel = () => {
		// Revert the value back to the original when canceling
		if (pendingChange && onUpdateManualDefense) {
			// If the original value was different from the auto-calculated value,
			// it means it was a manual override, so we need to restore it
			const autoValue =
				pendingChange.field === 'manualPD'
					? characterData.finalPD
					: pendingChange.field === 'manualPDR'
						? characterData.finalPDR || 0
						: characterData.finalAD;

			const valueToRestore =
				pendingChange.oldValue === autoValue ? undefined : pendingChange.oldValue;
			onUpdateManualDefense(pendingChange.field, valueToRestore);
		}
		setPendingChange(null);
	};
	const handleInputChange = (field: 'manualPD' | 'manualPDR' | 'manualAD', value: string) => {
		// Only validate the input, don't trigger the modal yet
		const numValue = value === '' ? undefined : parseInt(value, 10);
		if (value !== '' && (isNaN(numValue!) || numValue! < 0)) return;

		// For now, just update the value directly without the modal
		// The modal will be triggered on blur
		if (!onUpdateManualDefense) return;
		onUpdateManualDefense(field, numValue);
	};

	const handleInputBlur = (field: 'manualPD' | 'manualPDR' | 'manualAD', value: string) => {
		const numValue = value === '' ? undefined : parseInt(value, 10);

		// Get the current value after all changes
		const currentValue = getCurrentValue(field);

		// Use the original value we captured on focus for comparison
		if (originalValue !== null && originalValue !== currentValue && numValue !== undefined) {
			setPendingChange({
				field,
				oldValue: originalValue,
				newValue: currentValue
			});
		}

		// Clear the original value
		setOriginalValue(null);
	};

	const handleInputFocus = (e: React.FocusEvent<HTMLInputElement>) => {
		// Capture the original value for comparison on blur
		const field = e.target.getAttribute('data-field') as 'manualPD' | 'manualPDR' | 'manualAD';
		if (field) {
			setOriginalValue(getCurrentValue(field));
		}

		// Select all text when clicking into the input field
		// Use setTimeout to ensure the selection happens after the focus event
		setTimeout(() => {
			e.target.select();
		}, 0);
	};

	const handleInputClick = (e: React.MouseEvent<HTMLInputElement>) => {
		// Also handle click events to ensure text selection works properly
		const target = e.target as HTMLInputElement;
		setTimeout(() => {
			target.select();
		}, 0);
	};

	const handleRevert = (field: 'manualPD' | 'manualPDR' | 'manualAD') => {
		// Clear all notes for this defense field when reverting to auto
		clearDefenseNotesForField(characterData.id, field);

		// Reverts don't need notes as they're returning to auto-calculated values
		if (!onUpdateManualDefense) return;
		onUpdateManualDefense(field, undefined);
	};

	const getTooltip = (field: 'PD' | 'PDR' | 'AD'): string => {
		if (!calculatedDefenses) return '';

		const isManual =
			field === 'PD'
				? characterData.manualPD !== undefined
				: field === 'PDR'
					? characterData.manualPDR !== undefined
					: characterData.manualAD !== undefined;

		let baseTooltip = '';

		if (isManual) {
			const originalBreakdown =
				field === 'PD'
					? calculatedDefenses.pdBreakdown
					: field === 'PDR'
						? calculatedDefenses.pdrBreakdown
						: calculatedDefenses.adBreakdown;
			baseTooltip = `Manual Override (Original calculation: ${originalBreakdown})`;
		} else {
			baseTooltip =
				field === 'PD'
					? calculatedDefenses.pdBreakdown
					: field === 'PDR'
						? calculatedDefenses.pdrBreakdown
						: calculatedDefenses.adBreakdown;
		}

		// Add defense notes to tooltip
		const defenseField = field === 'PD' ? 'manualPD' : field === 'PDR' ? 'manualPDR' : 'manualAD';
		return getDefenseTooltipWithNotes(characterData.id, defenseField, baseTooltip);
	};

	return (
		<>
			<DefensesContainer $isMobile={isMobile}>
				{/* Precision Defense */}
				<DefenseItem>
					<DefenseLabelContainer>
						<DefenseLabel>PRECISION</DefenseLabel>
						<DefenseLabel>DEFENSE</DefenseLabel>
					</DefenseLabelContainer>
					<ShieldContainer>
                    {onUpdateManualDefense ? (
                            <ShieldInput
								type="number"
								data-field="manualPD"
								value={
									characterData.manualPD !== undefined
										? characterData.manualPD
										: characterData.finalPD
								}
								onChange={(e) => handleInputChange('manualPD', e.target.value)}
								onBlur={(e) => handleInputBlur('manualPD', e.target.value)}
								onFocus={handleInputFocus}
								onClick={handleInputClick}
								placeholder={characterData.finalPD.toString()}
							/>
                        ) : (
                            <Tooltip 
                                content={
                                    breakdowns?.defense_PD
                                        ? createEnhancedDefenseTooltip(breakdowns.defense_PD, 'PD')
                                        : getTooltip('PD')
                                }
                            >
                                <ShieldValue>{characterData.finalPD}</ShieldValue>
                            </Tooltip>
                        )}
					</ShieldContainer>
					<DefenseFooter>
						{characterData.manualPD !== undefined ? (
							<>
								<AutoCalculatedNote>Manual override</AutoCalculatedNote>
								<RevertButton onClick={() => handleRevert('manualPD')}>
									Revert to auto ({calculatedDefenses?.calculatedPD || characterData.finalPD})
								</RevertButton>
							</>
						) : null}
					</DefenseFooter>
				</DefenseItem>

				{/* Precision Damage Reduction */}
				<DefenseItem>
					<DefenseLabelContainer>
						<DefenseLabel>PRECISION</DefenseLabel>
						<DefenseLabel>DMG REDUCTION</DefenseLabel>
					</DefenseLabelContainer>
					<ShieldContainer>
                    {onUpdateManualDefense ? (
                            <ShieldInput
								type="number"
								data-field="manualPDR"
								value={
									characterData.manualPDR !== undefined
										? characterData.manualPDR
										: characterData.finalPDR || 0
								}
								onChange={(e) => handleInputChange('manualPDR', e.target.value)}
								onBlur={(e) => handleInputBlur('manualPDR', e.target.value)}
								onFocus={handleInputFocus}
								onClick={handleInputClick}
								placeholder={(characterData.finalPDR || 0).toString()}
							/>
                        ) : (
                            <Tooltip 
                                content={
                                    breakdowns?.defense_PDR
                                        ? createEnhancedDefenseTooltip(breakdowns.defense_PDR, 'PDR')
                                        : getTooltip('PDR')
                                }
                            >
                                <ShieldValue>{characterData.finalPDR || 0}</ShieldValue>
                            </Tooltip>
                        )}
					</ShieldContainer>
					<DefenseFooter>
						{characterData.manualPDR !== undefined ? (
							<>
								<AutoCalculatedNote>Manual override</AutoCalculatedNote>
								<RevertButton onClick={() => handleRevert('manualPDR')}>
									Revert to auto ({calculatedDefenses?.calculatedPDR || characterData.finalPDR || 0}
									)
								</RevertButton>
							</>
						) : (
							characterData.finalPDR > 0 && <AutoCalculatedNote>Auto-calculated</AutoCalculatedNote>
						)}
					</DefenseFooter>
				</DefenseItem>

				{/* Area Defense */}
				<DefenseItem>
					<DefenseLabelContainer>
						<DefenseLabel>AREA</DefenseLabel>
						<DefenseLabel>DEFENSE</DefenseLabel>
					</DefenseLabelContainer>
					<ShieldContainer>
                    {onUpdateManualDefense ? (
                            <ShieldInput
								type="number"
								data-field="manualAD"
								value={
									characterData.manualAD !== undefined
										? characterData.manualAD
										: characterData.finalAD
								}
								onChange={(e) => handleInputChange('manualAD', e.target.value)}
								onBlur={(e) => handleInputBlur('manualAD', e.target.value)}
								onFocus={handleInputFocus}
								onClick={handleInputClick}
								placeholder={characterData.finalAD.toString()}
							/>
                        ) : (
                            <Tooltip 
                                content={
                                    breakdowns?.defense_AD
                                        ? createEnhancedDefenseTooltip(breakdowns.defense_AD, 'AD')
                                        : getTooltip('AD')
                                }
                            >
                                <ShieldValue>{characterData.finalAD}</ShieldValue>
                            </Tooltip>
                        )}
					</ShieldContainer>
					<DefenseFooter>
						{characterData.manualAD !== undefined ? (
							<>
								<AutoCalculatedNote>Manual override</AutoCalculatedNote>
								<RevertButton onClick={() => handleRevert('manualAD')}>
									Revert to auto ({calculatedDefenses?.calculatedAD || characterData.finalAD})
								</RevertButton>
							</>
						) : null}
					</DefenseFooter>
				</DefenseItem>
			</DefensesContainer>

			{/* Defense Change Modal */}
			{pendingChange && (
				<DefenseChangeModal
					isOpen={true}
					defenseType={getDefenseDisplayName(pendingChange.field)}
					oldValue={pendingChange.oldValue}
					newValue={pendingChange.newValue}
					onConfirm={handleNoteConfirm}
					onCancel={handleNoteCancel}
				/>
			)}
		</>
	);
};

export default Defenses;
```

## File: src/routes/character-sheet/components/Spells.tsx
```typescript
import React, { useState, useMemo } from 'react';
import type { SpellData, CharacterSheetData } from '../../../types';
import type { Spell } from '../../../lib/rulesdata/spells-data/types/spell.types';
import { allSpells } from '../../../lib/rulesdata/spells-data/spells';
import { SpellSchool } from '../../../lib/rulesdata/spells-data/types/spell.types';
import { useCharacterSpells, useCharacterSheet } from '../hooks/CharacterSheetProvider';
import {
	StyledSpellsSection,
	StyledSpellsHeader,
	StyledSpellsTitle,
	StyledSpellsControls,
	StyledAddSpellButton,
	StyledSpellsContainer,
	StyledSpellsHeaderRow,
	StyledHeaderColumn,
	StyledEmptyState,
	StyledSpellRow,
	StyledRemoveButton,
	StyledSpellSelect,
	StyledSchoolFilter,
	StyledSpellCell,
	StyledInfoIcon
} from '../styles/Spells';

export interface SpellsProps {
	onSpellClick: (spell: Spell) => void;
	readOnly?: boolean; // New prop for read-only display
}

const Spells: React.FC<SpellsProps> = ({ onSpellClick, readOnly = false }) => {
	const { addSpell, removeSpell, updateSpell, state } = useCharacterSheet();
	const spells = useCharacterSpells();
	
	if (!state.character) {
		return <div>Loading spells...</div>;
	}
	
	const characterData = state.character;
	const [schoolFilter, setSchoolFilter] = useState<string>('all');
	// Initialize with all spells expanded by default
	const [expandedSpells, setExpandedSpells] = useState<Set<string>>(() => {
		const expanded = new Set<string>();
		spells.forEach(spell => {
			if (spell.spellName) {
				expanded.add(spell.id);
			}
		});
		return expanded;
	});

	console.log('🔍 Spells component received:', {
		spellsCount: spells.length,
		spells: spells.map(s => ({ id: s.id, spellName: s.spellName, school: s.school }))
	});

	// Filter spells based on selected school
	const filteredSpells = useMemo(() => {
		if (schoolFilter === 'all') {
			return allSpells;
		}
		return allSpells.filter(spell => spell.school === schoolFilter);
	}, [schoolFilter]);

	const addSpellSlot = () => {
		const newSpell: SpellData = {
			id: `spell_${Date.now()}`,
			spellName: '',
			school: '',
			isCantrip: false,
			cost: { ap: 0 },
			range: '',
			duration: '',
			isPrepared: false,
			notes: ''
		};
		addSpell(newSpell);
	};

	const removeSpellSlot = (spellIndex: number) => {
		const spellToRemove = spells[spellIndex];
		if (spellToRemove) {
			removeSpell(spellToRemove.id);
		}
	};

	const updateSpellField = (index: number, field: keyof SpellData, value: any) => {
		const spell = spells[index];
		if (!spell) return;
		
		if (field === 'spellName' && value) {
			// When spell is selected, populate all fields from spell data
			const selectedSpell = allSpells.find(spell => spell.name === value);
			if (selectedSpell) {
				updateSpell(spell.id, 'spellName', selectedSpell.name);
				updateSpell(spell.id, 'school', selectedSpell.school);
				updateSpell(spell.id, 'isCantrip', selectedSpell.isCantrip);
				updateSpell(spell.id, 'cost', selectedSpell.cost);
				updateSpell(spell.id, 'range', selectedSpell.range);
				updateSpell(spell.id, 'duration', selectedSpell.duration);
			}
		} else {
			updateSpell(spell.id, field, value);
		}
	};

	const handleSchoolFilterChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
		setSchoolFilter(event.target.value);
	};

	const toggleSpellExpansion = (spellId: string) => {
		setExpandedSpells(prev => {
			const newSet = new Set(prev);
			if (newSet.has(spellId)) {
				newSet.delete(spellId);
			} else {
				newSet.add(spellId);
			}
			return newSet;
		});
	};

	return (
		<StyledSpellsSection>
			<StyledSpellsHeader>
				<StyledSpellsTitle>Spells</StyledSpellsTitle>
				{!readOnly && (
					<StyledSpellsControls>
						<label style={{ fontSize: '0.8rem', color: '#8b4513', marginRight: '0.3rem' }}>
							Filter by School:
						</label>
						<StyledSchoolFilter value={schoolFilter} onChange={handleSchoolFilterChange}>
							<option value="all">All Schools</option>
							{(Object.values(SpellSchool) as string[]).map(school => (
								<option key={school} value={school}>
									{school}
								</option>
							))}
						</StyledSchoolFilter>
						<StyledAddSpellButton onClick={addSpellSlot}>+ Add Spell</StyledAddSpellButton>
					</StyledSpellsControls>
				)}
			</StyledSpellsHeader>

			<StyledSpellsContainer>
				<StyledSpellsHeaderRow>
					<span></span> {/* Empty column for remove button */}
					<StyledHeaderColumn>Spell Name</StyledHeaderColumn>
					<StyledHeaderColumn>School</StyledHeaderColumn>
					<StyledHeaderColumn>Type</StyledHeaderColumn>
					<StyledHeaderColumn>AP Cost</StyledHeaderColumn>
					<StyledHeaderColumn>MP Cost</StyledHeaderColumn>
					<StyledHeaderColumn>Range</StyledHeaderColumn>
					<StyledHeaderColumn>
						<StyledInfoIcon title="Spell details and description">i</StyledInfoIcon>
					</StyledHeaderColumn>
				</StyledSpellsHeaderRow>

				{spells.length === 0 ? (
					<StyledEmptyState>
						{readOnly ? 'No spells known.' : 'No spells selected. Click "Add Spell" to add spells to your character.'}
					</StyledEmptyState>
				) : (
					spells.map((spell, index) => {
						// Get the selected spell details for info display
						const selectedSpell = spell.spellName ? 
							allSpells.find(s => s.name === spell.spellName) : null;
							
						return (
							<React.Fragment key={spell.id}>
								<StyledSpellRow>
									{/* Remove Button - only show in edit mode */}
									{!readOnly && (
										<StyledRemoveButton onClick={() => removeSpellSlot(index)}>
											×
										</StyledRemoveButton>
									)}

									{/* Spell Name - show as text in read-only mode, dropdown in edit mode */}
									{readOnly ? (
										<StyledSpellCell style={{ fontWeight: 'bold', color: '#2c3e50' }}>
											{spell.spellName || 'Unknown Spell'}
										</StyledSpellCell>
									) : (
										<StyledSpellSelect
											value={spell.spellName}
											onChange={(e) => updateSpellField(index, 'spellName', e.target.value)}
										>
											<option value="">Select Spell...</option>
											{filteredSpells.map((spellOption) => (
												<option key={spellOption.name} value={spellOption.name}>
													{spellOption.name}
												</option>
											))}
										</StyledSpellSelect>
									)}

									{/* School */}
									<StyledSpellCell>{spell.school}</StyledSpellCell>

									{/* Type (Cantrip or Spell) */}
									<StyledSpellCell>
										{spell.isCantrip ? 'Cantrip' : 'Spell'}
									</StyledSpellCell>

								{/* AP Cost */}
								<StyledSpellCell>{spell.cost?.ap || '-'}</StyledSpellCell>

								{/* MP Cost */}
								<StyledSpellCell>{spell.cost?.mp || '-'}</StyledSpellCell>

									{/* Range */}
									<StyledSpellCell style={{ fontSize: '0.7rem' }}>
										{spell.range || '-'}
									</StyledSpellCell>

									{/* Spell Info */}
									<StyledSpellCell style={{ fontSize: '0.6rem', textAlign: 'center' }}>
										{selectedSpell ? (
											<StyledInfoIcon onClick={() => onSpellClick(selectedSpell)}>
												i
											</StyledInfoIcon>
										) : (
											'-'
										)}
									</StyledSpellCell>
								</StyledSpellRow>

								{/* Expandable Description Section */}
								{selectedSpell && expandedSpells.has(spell.id) && (
									<div style={{
										padding: '10px',
										backgroundColor: '#f9f9f9',
										border: '1px solid #ddd',
										borderTop: 'none',
										borderRadius: '0 0 4px 4px',
										marginTop: '-0.5rem'
									}}>
										<div style={{ fontSize: '0.8rem' }}>
											<strong>Description:</strong>
											<br />
											{selectedSpell.effects?.map((effect, effectIndex) => (
												<div key={effectIndex} style={{ marginBottom: '0.5rem' }}>
													{effect.title && <strong>{effect.title}:</strong>}
													<br />
													{effect.description}
												</div>
											)) || 'No description available.'}

											{selectedSpell.cantripPassive && (
												<>
													<br />
													<strong>Cantrip Passive:</strong> {selectedSpell.cantripPassive}
												</>
											)}

											{selectedSpell.enhancements?.length > 0 && (
												<>
													<br />
													<br />
													<strong>Enhancements:</strong>
													{selectedSpell.enhancements.map((enhancement, enhancementIndex) => (
														<div key={enhancementIndex} style={{ marginTop: '0.5rem', padding: '0.5rem', backgroundColor: '#f0f0f0', borderRadius: '4px' }}>
															<strong>{enhancement.name}</strong> ({enhancement.type} {enhancement.cost})
															<br />
															{enhancement.description}
														</div>
													))}
												</>
											)}
										</div>
									</div>
								)}

								{/* Toggle Description Button */}
								{selectedSpell && (
									<div style={{
										padding: '5px',
										textAlign: 'center',
										borderTop: '1px solid #eee',
										backgroundColor: '#fafafa',
										borderRadius: '0 0 4px 4px'
									}}>
										<button
											onClick={() => toggleSpellExpansion(spell.id)}
											style={{
												background: 'none',
												border: '1px solid #ccc',
												borderRadius: '4px',
												padding: '2px 8px',
												fontSize: '0.7rem',
												cursor: 'pointer',
												color: '#666'
											}}
										>
											{expandedSpells.has(spell.id) ? 'Hide Description' : 'Show Description'}
										</button>
									</div>
								)}
							</React.Fragment>
						);
					})
				)}
			</StyledSpellsContainer>
		</StyledSpellsSection>
	);
};

export default Spells;
```

## File: src/routes/character-sheet/hooks/useCharacterSheetReducer.test.ts
```typescript
import { describe, it, expect } from 'vitest';
import { useCharacterSheetReducer } from './useCharacterSheetReducer';
import { renderHook, act } from '@testing-library/react';

describe('useCharacterSheetReducer', () => {
  it('should initialize with correct initial state', () => {
    const { result } = renderHook(() => useCharacterSheetReducer());
    
    expect(result.current.state.character).toBe(null);
    expect(result.current.state.loading).toBe(false);
    expect(result.current.state.error).toBe(null);
  });

  it('should handle LOAD_START action', () => {
    const { result } = renderHook(() => useCharacterSheetReducer());
    
    act(() => {
      result.current.dispatch({ type: 'LOAD_START' });
    });
    
    expect(result.current.state.loading).toBe(true);
    expect(result.current.state.error).toBe(null);
  });

  it('should handle LOAD_SUCCESS action', () => {
    const { result } = renderHook(() => useCharacterSheetReducer());
    
    const mockCharacter = {
      id: 'test-id',
      finalName: 'Test Character',
      level: 1,
      classId: 'fighter',
      className: 'Fighter',
      finalMight: 16,
      finalAgility: 14,
      finalCharisma: 12,
      finalIntelligence: 10,
      finalHPMax: 10,
      finalSPMax: 5,
      finalMPMax: 0,
      characterState: {
        resources: {
          current: {
            currentHP: 10,
            currentSP: 5,
            currentMP: 0,
            tempHP: 0,
            exhaustionLevel: 0
          },
          original: {
            maxHP: 10,
            maxSP: 5,
            maxMP: 0
          }
        }
      }
    } as any;
    
    act(() => {
      result.current.dispatch({ type: 'LOAD_SUCCESS', character: mockCharacter });
    });
    
    expect(result.current.state.loading).toBe(false);
    expect(result.current.state.character).toEqual(mockCharacter);
    expect(result.current.state.error).toBe(null);
  });

  it('should handle LOAD_ERROR action', () => {
    const { result } = renderHook(() => useCharacterSheetReducer());
    
    const errorMessage = 'Failed to load character';
    
    act(() => {
      result.current.dispatch({ type: 'LOAD_ERROR', error: errorMessage });
    });
    
    expect(result.current.state.loading).toBe(false);
    expect(result.current.state.error).toBe(errorMessage);
  });

  it('should handle UPDATE_CURRENT_HP action', () => {
    const { result } = renderHook(() => useCharacterSheetReducer());
    
    const mockCharacter = {
      id: 'test-id',
      characterState: {
        resources: {
          current: { currentHP: 10, currentSP: 5, currentMP: 0 },
          original: { maxHP: 10, maxSP: 5, maxMP: 0 }
        }
      }
    } as any;
    
    // First load a character
    act(() => {
      result.current.dispatch({ type: 'LOAD_SUCCESS', character: mockCharacter });
    });
    
    // Then update HP
    act(() => {
      result.current.dispatch({ type: 'UPDATE_CURRENT_HP', hp: 8 });
    });
    
    expect(result.current.state.character?.characterState.resources.current.currentHP).toBe(8);
  });

  it('should handle ADD_ATTACK action', () => {
    const { result } = renderHook(() => useCharacterSheetReducer());
    
    const mockCharacter = {
      id: 'test-id',
      characterState: {
        attacks: []
      }
    } as any;
    
    const newAttack = {
      id: 'attack-1',
      name: 'Sword',
      attackBonus: 5,
      damage: '1d8+3'
    } as any;
    
    // First load a character
    act(() => {
      result.current.dispatch({ type: 'LOAD_SUCCESS', character: mockCharacter });
    });
    
    // Then add an attack
    act(() => {
      result.current.dispatch({ type: 'ADD_ATTACK', attack: newAttack });
    });
    
    expect(result.current.state.character?.characterState.attacks).toHaveLength(1);
    expect(result.current.state.character?.characterState.attacks[0]).toEqual(newAttack);
  });

  it('should handle SET_MANUAL_DEFENSE action', () => {
    const { result } = renderHook(() => useCharacterSheetReducer());
    
    const mockCharacter = {
      id: 'test-id',
      characterState: {
        ui: { manualDefenseOverrides: {} }
      }
    } as any;
    
    // First load a character
    act(() => {
      result.current.dispatch({ type: 'LOAD_SUCCESS', character: mockCharacter });
    });
    
    // Then set manual defense
    act(() => {
      result.current.dispatch({ type: 'SET_MANUAL_DEFENSE', pd: 15, ad: 12 });
    });
    
    expect(result.current.state.character?.characterState.ui.manualDefenseOverrides.PD).toBe(15);
    expect(result.current.state.character?.characterState.ui.manualDefenseOverrides.AD).toBe(12);
  });

  it('should provide helper functions', () => {
    const { result } = renderHook(() => useCharacterSheetReducer());
    
    expect(typeof result.current.updateHP).toBe('function');
    expect(typeof result.current.updateSP).toBe('function');
    expect(typeof result.current.updateMP).toBe('function');
    expect(typeof result.current.setManualDefense).toBe('function');
    expect(typeof result.current.addAttack).toBe('function');
    expect(typeof result.current.removeAttack).toBe('function');
    expect(typeof result.current.updateCurrency).toBe('function');
    expect(typeof result.current.updateNotes).toBe('function');
  });

  it('should handle UPDATE_TEMP_HP action', () => {
    const { result } = renderHook(() => useCharacterSheetReducer());
    
    const mockCharacter = {
      id: 'test-id',
      characterState: {
        resources: {
          current: { tempHP: 0 }
        }
      }
    } as any;
    
    // First load a character
    act(() => {
      result.current.dispatch({ type: 'LOAD_SUCCESS', character: mockCharacter });
    });
    
    // Then update temp HP
    act(() => {
      result.current.dispatch({ type: 'UPDATE_TEMP_HP', tempHP: 5 });
    });
    
    expect(result.current.state.character?.characterState.resources.current.tempHP).toBe(5);
  });

  it('should handle UPDATE_ACTION_POINTS_USED action', () => {
    const { result } = renderHook(() => useCharacterSheetReducer());
    
    const mockCharacter = {
      id: 'test-id',
      characterState: {
        resources: {
          current: { actionPointsUsed: 0 }
        }
      }
    } as any;
    
    // First load a character
    act(() => {
      result.current.dispatch({ type: 'LOAD_SUCCESS', character: mockCharacter });
    });
    
    // Then update action points used
    act(() => {
      result.current.dispatch({ type: 'UPDATE_ACTION_POINTS_USED', ap: 3 });
    });
    
    expect(result.current.state.character?.characterState.resources.current.actionPointsUsed).toBe(3);
  });

  it('should handle UPDATE_EXHAUSTION action', () => {
    const { result } = renderHook(() => useCharacterSheetReducer());
    
    const mockCharacter = {
      id: 'test-id',
      characterState: {
        resources: {
          current: { exhaustionLevel: 0 }
        }
      }
    } as any;
    
    // First load a character
    act(() => {
      result.current.dispatch({ type: 'LOAD_SUCCESS', character: mockCharacter });
    });
    
    // Then update exhaustion
    act(() => {
      result.current.dispatch({ type: 'UPDATE_EXHAUSTION', level: 2 });
    });
    
    expect(result.current.state.character?.characterState.resources.current.exhaustionLevel).toBe(2);
  });

  it('should provide new helper functions', () => {
    const { result } = renderHook(() => useCharacterSheetReducer());
    
    expect(typeof result.current.updateTempHP).toBe('function');
    expect(typeof result.current.updateActionPoints).toBe('function');
    expect(typeof result.current.updateExhaustion).toBe('function');
    expect(typeof result.current.updateAttack).toBe('function');
    expect(typeof result.current.updateInventory).toBe('function');
  });
});
```

## File: src/routes/character-sheet/styles/Layout.ts
```typescript
import styled from 'styled-components';
import backgroundImage from '../../../assets/Desktop.png';

export const StyledContainer = styled.div`
	min-height: 100vh;
	background: url(${backgroundImage}) center/cover no-repeat;
	background-attachment: fixed;
	padding: 1rem;
	font-family: 'Georgia', serif;
	color: #2d2d2d;

	@media (max-width: 768px) {
		padding: 0.5rem;
	}
`;

export const StyledBackButton = styled.button`
	position: fixed;
	top: 1rem;
	left: 1rem;
	padding: 0.5rem 1rem;
	border: 2px solid #8b4513;
	border-radius: 4px;
	background: #f5f3f0;
	color: #8b4513;
	cursor: pointer;
	font-weight: bold;
	z-index: 100;

	.desktop-text {
		display: inline;
	}
	
	.mobile-text {
		display: none;
	}

	@media (max-width: 768px) {
		top: 0.5rem;
		left: 0.5rem;
		padding: 0.3rem 0.5rem;
		font-size: 1.2rem;
		z-index: 1001; /* Above mobile nav */
		width: 40px;
		height: 40px;
		display: flex;
		align-items: center;
		justify-content: center;
		border-radius: 50%; /* Make it circular */
		min-width: 40px; /* Ensure minimum size */
		
		.desktop-text {
			display: none;
		}
		
		.mobile-text {
			display: inline;
		}
	}

	&:hover {
		background: #8b4513;
		color: #f5f3f0;
	}
`;

export const StyledCharacterSheet = styled.div`
	max-width: 1200px;
	margin: 0 auto;
	position: relative;
	/* Outer border */
	border: 2px solid #8b4513;
	height: auto;
	width: 98%;
	padding: 6px;
`;

export const StyledMidBorder = styled.div`
	/* Mid border */
	border: 6px solid #8b4513;
	height: 100%;
	width: 100%;
	padding: 6px;
	margin: auto;
`;

export const StyledInnerBorder = styled.div`
	/* Inner border with content */
	position: relative;
	border: 2px solid #8b4513;
	height: 100%;
	width: 100%;
	margin: auto;
	background: rgba(255, 255, 255, 0.4);
	border-radius: 4px;
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
	padding: 1.5rem;
	display: flex;
	justify-content: center;
	flex-direction: column;

	@media (max-width: 768px) {
		padding-bottom: 7rem; /* Extra space for fixed bottom navigation */
	}
`;

/* Corner decorations using CSS-only approach */
export const StyledCornerDecoration = styled.div<{ position: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' }>`
	position: absolute;
	width: 3em;
	height: 3em;
	margin: -3px;
	z-index: 10;
	
	/* Create decorative corner using CSS */
	position: relative;

	/* Desktop/Mobile Layout Control */
	.desktop-only {
		display: block !important;

		@media (max-width: 768px) {
			display: none !important;
		}
	}

	.mobile-only {
		display: none !important;

		@media (max-width: 768px) {
			display: block !important;
		}

		> div {
			display: flex;
			flex-direction: column;
			gap: 1rem;
		}
	}

	@media (max-width: 768px) {
		padding: 1rem;
		border-width: 2px;
		margin: 0;
		border-radius: 4px;
		overflow-x: hidden;
		width: 100%;
		box-sizing: border-box;
	}

	&::before {
		content: '';
		position: absolute;
		width: 100%;
		height: 100%;
		background: 
			radial-gradient(circle at 20% 20%, #8b4513 0%, #8b4513 15%, transparent 15%),
			linear-gradient(45deg, #8b4513 0%, #8b4513 6px, transparent 6px, transparent 12px, #8b4513 12px, #8b4513 18px, transparent 18px),
			linear-gradient(-45deg, #8b4513 0%, #8b4513 6px, transparent 6px, transparent 12px, #8b4513 12px, #8b4513 18px, transparent 18px);
		border-radius: 4px;
	}
	
	${props => props.position === 'top-left' && `
		left: 0;
		top: 0;
	`}
	
	${props => props.position === 'top-right' && `
		top: 0;
		right: 0;
		transform: scaleX(-1);
	`}
	
	${props => props.position === 'bottom-right' && `
		right: 0;
		bottom: 0;
		transform: scale(-1);
	`}
	
	${props => props.position === 'bottom-left' && `
		left: 0;
		bottom: 0;
		transform: scaleY(-1);
	`}

	@media (min-width: 768px) {
		width: 3.5em;
		height: 3.5em;
		margin: -4px;
	}

	@media (min-width: 992px) {
		width: 4em;
		height: 4em;
		margin: -5px;
	}

	@media (min-width: 1200px) {
		width: 5em;
		height: 5em;
		margin: -6px;
	}
`;

export const StyledMainGrid = styled.div`
	display: grid;
	grid-template-columns: 300px 1fr 250px;
	gap: 1.5rem;
	height: auto;
	width: 100%;
`;

export const StyledLeftColumn = styled.div`
	display: flex;
	flex-direction: column;
	gap: 1rem;
`;

export const StyledMiddleColumn = styled.div`
	display: flex;
	flex-direction: column;
	gap: 1rem;
`;

export const StyledRightColumn = styled.div`
	display: flex;
	flex-direction: column;
	gap: 1rem;
`;

// Mobile Navigation
export const StyledMobileNav = styled.div`
	display: flex;
	background: #8b4513;
	border-radius: 8px;
	overflow: hidden;
	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
	position: fixed !important;
	top: auto !important;
	bottom: 0 !important;
	left: 0;
	right: 0;
	z-index: 1000;
	margin: 0;
	width: 100vw;
	max-width: 100vw;
	box-sizing: border-box;
`;

export const StyledMobileNavButton = styled.button<{ $isActive: boolean }>`
	flex: 1;
	min-width: 0;
	max-width: 25vw;
	padding: 0.75rem 0.25rem;
	border: none;
	background: ${(props) => (props.$isActive ? '#f5f3f0' : 'transparent')};
	color: ${(props) => (props.$isActive ? '#8b4513' : '#f5f3f0')};
	font-weight: bold;
	font-size: 0.7rem;
	cursor: pointer;
	transition: all 0.2s ease;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	box-sizing: border-box;

	&:hover {
		background: ${(props) => (props.$isActive ? '#f5f3f0' : 'rgba(245, 243, 240, 0.1)')};
	}

	&:active {
		transform: translateY(1px);
	}
`;

// Action buttons (Revert/Copy)
export const StyledActionButtons = styled.div`
	position: absolute;
	top: 1rem;
	right: 1rem;
	display: flex;
	gap: 0.5rem;
	z-index: 1000;

	@media (max-width: 768px) {
		display: none;
	}
`;

export const StyledActionButton = styled.button<{ $variant?: 'danger' | 'primary' }>`
	padding: 8px 12px;
	font-size: 0.8rem;
	background-color: ${(props) => (props.$variant === 'danger' ? '#c53030' : '#8b4513')};
	color: white;
	border: none;
	border-radius: 6px;
	cursor: pointer;
	white-space: nowrap;
	font-weight: bold;
	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
	transition: all 0.2s ease;

	&:hover {
		background-color: ${(props) => (props.$variant === 'danger' ? '#b32c2c' : '#7a3e11')};
		transform: translateY(-1px);
	}

	&:active {
		transform: translateY(0);
	}
`;
```

## File: src/components/Menu.tsx
```typescript
export const HeadIcon = () => (
	<svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 595.3 586.9" width="64" height="64" fill="currentColor">
		<path d="M155.6,51c8,1.8,8.5,9.9,13.5,14s12.6,4.6,11.5,15.5c-.9,9-8.4,8.9-12.7,12.8s-3.8,13.2-14.8,13.2-10.2-8.7-14.7-13.2-12.5-3-12.8-13.7,6.9-10.1,12.1-14.9,5.1-11.8,12.9-13.5h5ZM167.6,79.9c1.4-2.1-6.7-5.1-8.5-6.9-2.6-2.5-3.5-6.4-6-9-4.3,6.4-6.9,12.4-15.5,14,6.6,5,11.8,8,15.5,15.9,3.6-6.5,6.9-11.7,14.5-14Z"/>
		<path d="M302.1,79.2c142.9-9.8,200.3,115.9,193.8,240.8-5.9,113.8-107.4,253.6-234.2,198.2C87.9,442.3,95.1,93.4,302.1,79.2ZM305.1,91.2c-150.2,9.7-183.4,205.3-131.4,318.4,49.7,108,165.8,151.7,252.8,53.5,103-116.2,70-384.3-121.5-372Z"/>
		<path d="M458.3,486.4c3.5-3.8,11.6-5.6,14.3-8.6,4.7-5.3,4.8-15.3,15-17.4,16.9-3.6,16.2,10.9,23.7,17.7s20.6,6.9,17.2,23.2c-2,9.9-13.8,11-18.2,15.7s-4.9,15.9-16.3,17.7-15.3-11.6-22.3-18.2c-2.3-2.2-8.1-4-10.9-6.1-8-5.9-9.7-16.5-2.7-24ZM490.6,472.2c-2.5.7-6.9,11.6-9.6,14.4s-15.2,7.5-14.9,10.8,10.9,7.2,14.4,10.6,7.9,15.6,11.8,14.9c4.9-3.6,5.6-10.2,9.6-14.4s15.1-7.9,15-10.9-11.4-7.5-14.5-10.5-7.3-16-11.8-14.9Z"/>
		<path d="M116.3,116.2c3,3.2,5.2,10.6,7.6,13.3,4.9,5.5,15,4.2,18,15.4,4.4,16.6-11.8,16.9-18.3,24.3-6,6.8-6,18.7-20.3,17.4-12.2-1.1-12.5-13.8-17.9-18.6-5.2-4.6-15-5-17.2-14.2-4.4-18.2,10.3-16.7,17.6-24.5s4.6-11.6,10.6-15.3,15-3,19.9,2.2ZM129.4,151.5c4.5-5-11-10.2-14.2-13.6s-7.5-18-12.9-13-4.4,9.8-8.9,14-8.6,4.5-11.9,7.1c-6.8,5.2,9.1,10.3,12.4,13.3s7.2,14.8,11.4,15.1,6.2-9,8-11.5c4.9-6.8,12.7-7.5,16.1-11.3Z"/>
		<path d="M234.2,251.8c29.4-3,68.1,15.3,60.8,49.9s-79.1,46.3-100.4,12.1c-18.6-30,9.6-58.8,39.5-61.9ZM236.2,263.8c-20.5,2.2-44,19.7-31.9,42.3s84.2,21.4,78.9-16.1c-2.8-19.8-29.9-28-47-26.2Z"/>
		<path d="M383.9,251.8c25.6-2.9,59.4,10.1,62.1,39.1,4.5,50-84,62.9-103.6,17.8-12.7-29.3,14-53.8,41.5-57ZM386.9,263.8c-20.6,2-44.6,19.2-32.5,41.9,13.7,25.9,68.3,24.7,77.9-3.5,9.1-26.8-23.7-40.5-45.4-38.4Z"/>
		<path d="M301.1,392.5c8.8-.9,11.1,3.1,15.8,3.5s9.2-4.2,15.8-3.8c10.6.8,34.7,15.3,41.8,23.1,14.1,15.4-14.1,32.4-26.4,37.3-25.2,10-55.7,6.9-77.7-9.1-10.9-7.9-20.7-17.8-8.1-29.9,7.7-7.3,28.2-20.1,38.7-21.2ZM303.9,404.6c-11.3.1-26.6,13.4-35.4,20.1,23.4,28.7,73.1,28.4,97.5.9.4-2-12.7-11-15.2-12.6-5.2-3.2-14.9-9.1-21-8.5s-7.5,4.1-13.2,3.9-8-3.8-12.8-3.7Z"/>
		<path d="M295.8,341.8c3.8,0,12.1,8.9,20.1,9.5,11.5.8,17.8-9.3,23-9.7s8.5,6.5,4.2,11.2c-12,13.3-41.1,14.2-51.8-.9s-1.1-10.1,4.5-10Z"/>
		<path d="M300,417.4c4.4-1,28.8-.9,33.7-.2s6.9,3.6,6.4,7.2c-1,3.7-3.8,5.1-7.4,5.6s-32.1.7-35.3-1.4-2.8-10,2.7-11.2Z"/>
	</svg>
);

export const GroupIcon = () => (
	<svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 595.3 570.7" width="90" height="90" fill="currentColor">
		<path d="M460,488.6c-3.9-3-2.1-7.6-3.8-11.1s-5.7-5.7-2.3-11.4c2.8-4.7,6.8-2.7,10.2-3.8,3.3-1,5.4-6.2,11.4-3.4s3.3,7.3,4.7,10.9,6.1,4.8,3.5,10.7-6.3,3.8-10.4,5c-4.1,1.3-5.8,5.1-10.5,4.1l-2.7-1.3h0ZM460.8,469.8c-1.3.8,2.4,4.5,2.9,5.9.8,2,.3,4.4,1,6.4,4-2.4,6.9-5,12-3.7-2.3-4.4-4.4-7.4-4.4-12.6-3.6,2.6-6.7,4.6-11.5,3.9Z"/>
		<path d="M288.4,171.8c86-5.9,120.5,69.7,116.6,144.8-3.5,68.4-64.6,152.5-140.9,119.2-104.5-45.7-100.2-255.5,24.3-264.1ZM290.2,179c-90.3,5.8-110.3,123.5-79,191.5,29.9,65,99.7,91.2,152.1,32.2,62-69.9,42.1-231.1-73.1-223.8h0Z"/>
		<path d="M154.9,429.1c2.1-2.3,7-3.4,8.6-5.2,2.8-3.2,2.9-9.2,9-10.5,10.2-2.2,9.7,6.6,14.3,10.6s12.4,4.2,10.3,14c-1.2,6-8.3,6.6-10.9,9.4s-2.9,9.6-9.8,10.6-9.2-7-13.4-10.9c-1.4-1.3-4.9-2.4-6.6-3.7-4.8-3.5-5.8-9.9-1.6-14.4h.1ZM174.3,420.5c-1.5.4-4.2,7-5.8,8.7s-9.1,4.5-9,6.5,6.6,4.3,8.7,6.4,4.8,9.4,7.1,9c2.9-2.2,3.4-6.1,5.8-8.7s9.1-4.8,9-6.6-6.9-4.5-8.7-6.3-4.4-9.6-7.1-9h0Z"/>
		<path d="M498,463c-.8-2.5-.1-7.1-.8-9.2-1.3-4.2-7.1-6.1-5.9-13,1.8-10.2,10.7-6.2,16.2-8.6,5-2.2,8-8.7,15.5-4.3,6.4,3.7,3.3,10.7,5,14.7,1.7,3.8,6.9,6.5,5.8,12.1-2.2,11-9.9,6.5-15.8,8.9-6,2.4-5.5,5.2-9.7,5.6-4.2.5-8.9-2.2-10.3-6.3h0ZM499.8,440.5c-3.7,1.6,3.4,8.4,4.3,11s-.5,11.7,3.7,10.4c4.2-1.4,4.9-4.2,8.4-5.4,3.5-1.1,5.8-.3,8.3-.8,5-1.1-2.3-7.9-3.4-10.4s-.2-9.9-2.4-11.1c-2.2-1.2-5.7,3.3-7.3,4.2-4.4,2.5-8.8.9-11.6,2.1h0Z"/>
		<path d="M237.5,161.4c-3.9-3-2.1-7.6-3.8-11.1s-5.7-5.7-2.3-11.4c2.8-4.7,6.8-2.7,10.2-3.8s5.4-6.2,11.4-3.4,3.3,7.3,4.7,10.9,6.1,4.8,3.5,10.7-6.3,3.8-10.4,5-5.8,5.1-10.5,4.1l-2.7-1.3h0ZM238.3,142.6c-1.3.8,2.4,4.5,2.9,5.9.8,2,.3,4.4,1,6.4,4-2.4,6.9-5,12-3.7-2.3-4.4-4.4-7.4-4.4-12.6-3.6,2.6-6.7,4.6-11.5,3.9Z"/>
		<path d="M275.5,135.9c-.8-2.5-.1-7.1-.8-9.2-1.3-4.2-7.1-6.1-5.9-13,1.8-10.2,10.7-6.2,16.2-8.6,5-2.2,8-8.7,15.5-4.3,6.4,3.7,3.3,10.7,5,14.7,1.7,3.8,6.9,6.5,5.8,12.1-2.2,11-9.9,6.5-15.8,8.9s-5.5,5.2-9.7,5.6-8.9-2.2-10.3-6.3h0ZM277.3,113.3c-3.7,1.6,3.4,8.4,4.3,11s-.5,11.7,3.7,10.4,4.9-4.2,8.4-5.4,5.8-.3,8.3-.8c5-1.1-2.3-7.9-3.4-10.4s-.2-9.9-2.4-11.1-5.7,3.3-7.3,4.2c-4.4,2.5-8.8.9-11.6,2.1h0Z"/>
		<path d="M247.6,275.6c17.7-1.8,41,9.2,36.6,30-4.4,20.8-47.6,27.8-60.4,7.3-11.2-18,5.8-35.4,23.8-37.2h0ZM248.8,282.9c-12.3,1.3-26.5,11.8-19.2,25.4s50.6,12.9,47.5-9.7c-1.7-11.9-18-16.8-28.3-15.8h0Z"/>
		<path d="M337.6,275.6c15.4-1.7,35.7,6.1,37.4,23.5,2.7,30.1-50.5,37.8-62.3,10.7-7.6-17.6,8.4-32.4,25-34.3h0ZM339.4,282.9c-12.4,1.2-26.8,11.5-19.5,25.2,8.2,15.6,41.1,14.9,46.9-2.1,5.5-16.1-14.3-24.4-27.3-23.1Z"/>
		<path d="M287.8,360.3c5.3-.5,6.7,1.9,9.5,2.1s5.5-2.5,9.5-2.3c6.4.5,20.9,9.2,25.1,13.9,8.5,9.3-8.5,19.5-15.9,22.4-15.2,6-33.5,4.2-46.7-5.5-6.6-4.8-12.5-10.7-4.9-18,4.6-4.4,17-12.1,23.3-12.8h0ZM289.5,367.5c-6.8,0-16,8.1-21.3,12.1,14.1,17.3,44,17.1,58.6.5.2-1.2-7.6-6.6-9.1-7.6-3.1-1.9-9-5.5-12.6-5.1s-4.5,2.5-7.9,2.3c-3.4-.1-4.8-2.3-7.7-2.2h0Z"/>
		<path d="M284.6,329.8c2.3,0,7.3,5.4,12.1,5.7,6.9.5,10.7-5.6,13.8-5.8s5.1,3.9,2.5,6.7c-7.2,8-24.7,8.5-31.2-.5-6.4-9.1-.7-6.1,2.7-6h0Z"/>
		<path d="M287.2,375.2c2.6-.6,17.3-.5,20.3-.1,2.9.4,4.2,2.2,3.8,4.3-.6,2.2-2.3,3.1-4.5,3.4s-19.3.4-21.2-.8-1.7-6,1.6-6.7h0Z"/>
		<path d="M86.7,239.3c17.7-1.8,41,9.2,36.6,30s-47.6,27.8-60.4,7.3c-11.2-18,5.8-35.4,23.8-37.2h0ZM87.9,246.5c-12.3,1.3-26.5,11.8-19.2,25.4,7.3,13.6,50.6,12.9,47.5-9.7-1.7-11.9-18-16.8-28.3-15.8h0Z"/>
		<path d="M127,323.9c5.3-.5,6.7,1.9,9.5,2.1s5.5-2.5,9.5-2.3c6.4.5,20.9,9.2,25.1,13.9,8.5,9.3-8.5,19.5-15.9,22.4-15.2,6-33.5,4.2-46.7-5.5-6.6-4.8-12.5-10.7-4.9-18,4.6-4.4,17-12.1,23.3-12.8h0ZM128.7,331.2c-6.8,0-16,8.1-21.3,12.1,14.1,17.3,44,17.1,58.6.5.2-1.2-7.6-6.6-9.1-7.6-3.1-1.9-9-5.5-12.6-5.1-3.7.4-4.5,2.5-7.9,2.3-3.4-.1-4.8-2.3-7.7-2.2h0Z"/>
		<path d="M123.8,293.4c2.3,0,7.3,5.4,12.1,5.7,6.9.5,10.7-5.6,13.8-5.8s5.1,3.9,2.5,6.7c-7.2,8-24.7,8.5-31.2-.5s-.7-6.1,2.7-6h0Z"/>
		<path d="M126.3,338.9c2.6-.6,17.3-.5,20.3-.1,2.9.4,4.2,2.2,3.8,4.3-.6,2.2-2.3,3.1-4.5,3.4s-19.3.4-21.2-.8-1.7-6,1.6-6.7h0Z"/>
		<path d="M501.9,239.3c15.4-1.7,35.7,6.1,37.4,23.5,2.7,30.1-50.5,37.8-62.3,10.7-7.6-17.6,8.4-32.4,25-34.3h0ZM503.8,246.5c-12.4,1.2-26.8,11.5-19.5,25.2,8.2,15.6,41.1,14.9,46.9-2.1,5.5-16.1-14.3-24.4-27.3-23.1Z"/>
		<path d="M452.1,323.9c5.3-.5,6.7,1.9,9.5,2.1s5.5-2.5,9.5-2.3c6.4.5,20.9,9.2,25.1,13.9,8.5,9.3-8.5,19.5-15.9,22.4-15.2,6-33.5,4.2-46.7-5.5-6.6-4.8-12.5-10.7-4.9-18,4.6-4.4,17-12.1,23.3-12.8h0ZM453.8,331.2c-6.8,0-16,8.1-21.3,12.1,14.1,17.3,44,17.1,58.6.5.2-1.2-7.6-6.6-9.1-7.6-3.1-1.9-9-5.5-12.6-5.1-3.7.4-4.5,2.5-7.9,2.3-3.4-.1-4.8-2.3-7.7-2.2h0Z"/>
		<path d="M449,293.4c2.3,0,7.3,5.4,12.1,5.7,6.9.5,10.7-5.6,13.8-5.8s5.1,3.9,2.5,6.7c-7.2,8-24.7,8.5-31.2-.5-6.4-9.1-.7-6.1,2.7-6h0Z"/>
		<path d="M451.5,338.9c2.6-.6,17.3-.5,20.3-.1s4.2,2.2,3.8,4.3c-.6,2.2-2.3,3.1-4.5,3.4s-19.3.4-21.2-.8-1.7-6,1.6-6.7h0Z"/>
		<path d="M452.7,135.5c-41.8,2.9-70.1,28.5-85.2,63,2,2,3.9,4,5.8,6.1,13.8-33.6,40.3-59.2,81.3-61.9h0c115.2-7.5,135,153.8,73.1,223.7-43.3,48.9-98.7,39.3-133.4-2.3-1,2.6-2.1,5.1-3.3,7.6,10.3,11.8,22.9,21.5,37.5,27.9,76.3,33.3,137.3-50.8,140.9-119.2,3.9-75.1-30.6-150.7-116.6-144.8Z"/>
		<path d="M202.1,366.7c-52.3,58.6-121.9,32.3-151.7-32.5-31.3-68-11.3-185.7,79-191.5h0c47.8-3.1,79.1,22.8,95.1,59.2,1.8-1.9,3.7-3.8,5.7-5.6-17.2-38-50.4-64.4-102.5-60.8C3.1,144-1.3,353.9,103.3,399.5c40.2,17.6,76.2,2.5,101.8-25.7-1-2.3-2-4.7-3-7.1Z"/>
		<path d="M411.9,239.3h0c-5.7.7-11.3,2.8-15.9,6,.8,2.4,1.6,4.9,2.3,7.4,4.1-3.4,9.7-5.6,14.9-6.2h0c10.3-1.1,26.6,3.8,28.3,15.8,2.5,17.4-22.8,21.8-37.8,16.7.4,2.9.7,5.8.9,8.7,17.6,4.4,40.8-3.4,43.9-18.4,4.4-20.8-18.9-31.8-36.6-30Z"/>
		<path d="M191.1,281.7c-11.8,3.1-26.8-.2-32-10-7.3-13.7,7.2-24,19.5-25.2,5.9-.6,13.1.8,18.8,3.9.7-2.4,1.5-4.7,2.4-7-7-3.6-15.6-4.9-22.9-4.1h0c-16.5,1.9-32.6,16.6-25,34.2,6.2,14.2,23.7,18.8,38.6,15.7.2-2.5.4-5,.6-7.5Z"/>
	</svg>
);

import React from 'react';
import { StyledContainer, StyledTitle, StyledSubtitle, StyledMenuGrid, StyledTextContent, StyledMenuCard, StyledCardTitle
, StyledCardDescription, StyledIcon
} from './styled';


interface MenuProps {
	onCreateCharacter: () => void;
	onLoadCharacter: () => void;
}

function Menu({ onCreateCharacter, onLoadCharacter }: MenuProps) {
	return (
		<StyledContainer>
			<StyledTitle>DC20 Character Creator</StyledTitle>
			<StyledSubtitle>
				Welcome to the ultimate DC20 character creation experience.<br />
				Choose your path to begin your adventure.
			</StyledSubtitle>

			<StyledMenuGrid>
				<StyledMenuCard onClick={onCreateCharacter}>
					<StyledTextContent>
						<StyledCardTitle>Create Character</StyledCardTitle>
						<StyledCardDescription>
							Create a new character. 
						</StyledCardDescription>
					</StyledTextContent>
					<StyledIcon>
						<HeadIcon />
					</StyledIcon>
				</StyledMenuCard>

				<StyledMenuCard onClick={onLoadCharacter}>
					<StyledTextContent>
						<StyledCardTitle>Load Character</StyledCardTitle>
						<StyledCardDescription>
							Load an existing character.
						</StyledCardDescription>
					</StyledTextContent>
					<StyledIcon>
						<GroupIcon />
					</StyledIcon>
				</StyledMenuCard>
			</StyledMenuGrid>
		</StyledContainer>
	);
}

export default Menu;
```

## File: src/routes/character-creation/SpellsAndManeuvers.tsx
```typescript
import React, { useState, useEffect, useRef } from 'react';
import { useCharacter } from '../../lib/stores/characterContext';
import { allSpells } from '../../lib/rulesdata/spells-data/spells';
import { allManeuvers, ManeuverType } from '../../lib/rulesdata/maneuvers';
import { SpellSchool, type ClassName } from '../../lib/rulesdata/spells-data/types/spell.types';
import { classesData } from '../../lib/rulesdata/loaders/class.loader';
import { findClassByName } from '../../lib/rulesdata/loaders/class-features.loader';
import {
	StyledContainer,
	StyledTitle,
	StyledSection,
	StyledSectionTitle,
	StyledGrid,
	StyledCard,
	StyledCardHeader,
	StyledCardTitle,
	StyledCardDescription,
	StyledCardCost,
	StyledCardType,
	StyledCardActions,
	StyledButton,
	StyledTabContainer,
	StyledTabButton,
	StyledEmptyState,
	StyledEmptyTitle,
	StyledEmptyText,
	StyledSelectedCount,
	StyledFilterContainer,
	StyledFilterButton
} from './styles/SpellsAndManeuvers.styles';

// Simple deep equality helper for arrays to replace JSON.stringify comparison
function arraysEqual<T>(a: T[], b: T[]): boolean {
	if (a.length !== b.length) return false;
	return a.every((val, index) => {
		if (Array.isArray(val) && Array.isArray(b[index])) {
			return arraysEqual(val as any[], b[index] as any[]);
		}
		return val === b[index];
	});
}

const SpellsAndManeuvers: React.FC = () => {
	console.log('🚀 SpellsAndManeuvers component is rendering!');
	const { state, dispatch } = useCharacter();
	const [activeTab, setActiveTab] = useState<'spells' | 'maneuvers'>('spells');
	const [selectedSpells, setSelectedSpells] = useState<string[]>([]);
	const [selectedManeuvers, setSelectedManeuvers] = useState<string[]>([]);
	const isInitialLoad = useRef(true);
	const hasInitialized = useRef(false);

	// Load existing selections from state - only run once on mount
	useEffect(() => {
		if (hasInitialized.current) {
			return;
		}
		
		console.log('🔄 SpellsAndManeuvers: Loading selections from state:', {
			selectedSpells: state.selectedSpells,
			selectedManeuvers: state.selectedManeuvers
		});
		
		if (state.selectedSpells && Array.isArray(state.selectedSpells)) {
			console.log('📚 Setting selected spells:', state.selectedSpells);
			setSelectedSpells(state.selectedSpells);
		}

		if (state.selectedManeuvers && Array.isArray(state.selectedManeuvers)) {
			console.log('⚔️ Setting selected maneuvers:', state.selectedManeuvers);
			setSelectedManeuvers(state.selectedManeuvers);
		}
		
		hasInitialized.current = true;
	}, []); // Empty dependency array - only run once

	// Mark initial load as complete after first render
	useEffect(() => {
		isInitialLoad.current = false;
	}, []);
	const [spellFilter, setSpellFilter] = useState<SpellSchool | 'all'>('all');
	const [maneuverFilter, setManeuverFilter] = useState<ManeuverType | 'all'>('all');

	// Get class data
	const classData = classesData.find(c => c.name.toLowerCase() === state.classId?.toLowerCase());
	console.log('🔍 Class data lookup:', { 
		stateClassId: state.classId, 
		availableClasses: classesData.map(c => c.name),
		foundClassData: !!classData,
		classDataName: classData?.name
	});
	const classFeatures = state.classId ? findClassByName(state.classId) : null;

	// Calculate available spells and maneuvers based on class and level
	const availableSpells = React.useMemo(() => {
		console.log('🔍 Starting availableSpells calculation...');
		if (!state.classId || !classFeatures) {
			console.log('❌ No classId or classFeatures:', { classId: state.classId, classFeatures: !!classFeatures });
			return [];
		}

		console.log('SpellsAndManeuvers Debug:', {
			classId: state.classId,
			classFeatures: !!classFeatures,
			selectedFeatureChoices: state.selectedFeatureChoices
		});

		// Use feature choices directly to determine available spell schools
		const featureChoices: { [key: string]: any } = state.selectedFeatureChoices || {};
		let availableSchools: SpellSchool[] = [];

		console.log('Feature choices:', featureChoices);

		// Get available spell schools based on class features
		if (classFeatures.spellcastingPath?.spellList) {
			const spellList = classFeatures.spellcastingPath.spellList;
			console.log('Spellcasting path:', classFeatures.spellcastingPath);

			if (spellList.type === 'all_schools' && spellList.schoolCount) {
				const choiceId = `${classFeatures.className.toLowerCase()}_spell_schools`;
				const choice = featureChoices[choiceId];
				console.log('Looking for choice:', choiceId, 'Found:', choice);
				if (choice) {
					const selectedSchools = Array.isArray(choice) ? choice : [choice];
					availableSchools.push(...selectedSchools);
					console.log('Selected schools from choice:', selectedSchools);
				}
			} else if (spellList.type === 'schools') {
				if (spellList.specificSchools) {
					availableSchools.push(...spellList.specificSchools);
					console.log('Added specific schools:', spellList.specificSchools);
				}
				
				if (spellList.schoolCount && spellList.schoolCount > 0) {
					const choiceId = `${classFeatures.className.toLowerCase()}_additional_spell_schools`;
					const choice = featureChoices[choiceId];
					console.log('Looking for additional choice:', choiceId, 'Found:', choice);
					if (choice) {
						// Handle additional schools (expect arrays directly)
						const additionalSchools = spellList.schoolCount > 1 && Array.isArray(choice) ? choice : [choice];
						availableSchools.push(...additionalSchools);
						console.log('Added additional schools:', additionalSchools);
					}
				}
			} else if (spellList.type === 'any') {
				availableSchools.push(SpellSchool.Astromancy);
				console.log('Added any school (Astromancy)');
			}
		}

		// If no schools determined, use defaults
		if (availableSchools.length === 0) {
			console.log('No schools determined, using defaults for class:', state.classId);
			switch (state.classId.toLowerCase()) {
				case 'wizard':
					availableSchools = [SpellSchool.Astromancy, SpellSchool.Destruction, SpellSchool.Illusion];
					break;
				case 'sorcerer':
					availableSchools = [SpellSchool.Astromancy, SpellSchool.Destruction, SpellSchool.Enchantment];
					break;
				case 'cleric':
					availableSchools = [SpellSchool.Restoration, SpellSchool.Protection, SpellSchool.Divination];
					break;
				case 'druid':
					availableSchools = [SpellSchool.Restoration, SpellSchool.Conjuration, SpellSchool.Transmutation];
					break;
				case 'barbarian':
				case 'fighter':
				case 'monk':
				case 'rogue':
				case 'ranger':
				case 'paladin':
					// Martial classes get access to some utility spells
					availableSchools = [SpellSchool.Protection, SpellSchool.Enchantment, SpellSchool.Transmutation];
					break;
				case 'hunter':
					// Hunter is a pure martial class with no spellcasting
					availableSchools = [];
					break;
				default:
					// For any other class, show all schools
					availableSchools = Object.values(SpellSchool);
			}
		}

		// Filter spells by class and schools
		const filteredSpells = allSpells.filter(spell => {
			// More inclusive class filtering - if no specific class match, show all spells
			const isAvailableToClass = spell.availableClasses.length === 0 || 
				spell.availableClasses.includes(state.classId as ClassName) ||
				spell.availableClasses.some(className => 
					state.classId?.toLowerCase().includes(className.toLowerCase()) ||
					className.toLowerCase().includes(state.classId?.toLowerCase() || '')
				);
			
			// If no schools are available, don't show any spells
			const isInAvailableSchool = availableSchools.length > 0 && availableSchools.includes(spell.school);
			return isAvailableToClass && isInAvailableSchool;
		});

		// Debug logging
		console.log('SpellsAndManeuvers Debug:', {
			classId: state.classId,
			availableSchools,
			totalSpells: allSpells.length,
			filteredSpells: filteredSpells.length,
			sampleSpells: filteredSpells.slice(0, 5).map(s => s.name)
		});

		return filteredSpells;
	}, [state.classId, state.selectedFeatureChoices, classFeatures]);

	const availableManeuvers = React.useMemo(() => {
		console.log('🔍 availableManeuvers calculation:', { classData: !!classData, allManeuversCount: allManeuvers.length });
		if (!classData) return [];

		// All characters can learn maneuvers, but some classes get more
		return allManeuvers;
	}, [classData]);

	// Get spell/maneuver counts for current level
	const spellCounts = React.useMemo(() => {
		if (!classData || !state.level) return { cantrips: 0, spells: 0 };

		const levelData = classData.levelProgression?.find(l => l.level === state.level);
		return {
			cantrips: levelData?.cantripsKnown || 0,
			spells: levelData?.spellsKnown || 0
		};
	}, [classData, state.level]);

	const maneuverCount = React.useMemo(() => {
		console.log('🔍 maneuverCount calculation:', { 
			classData: !!classData, 
			level: state.level, 
			levelProgression: classData?.levelProgression?.length 
		});
		if (!classData || !state.level) return 0;

		const levelData = classData.levelProgression?.find(l => l.level === state.level);
		console.log('🔍 Level data found:', levelData);
		const count = levelData?.maneuversKnown || 0;
		console.log('🔍 maneuverCount result:', count);
		return count;
	}, [classData, state.level]);

	// Filter spells and maneuvers based on active filters
	const filteredSpells = React.useMemo(() => {
		let spells = availableSpells;
		if (spellFilter !== 'all') {
			spells = spells.filter(spell => spell.school === spellFilter);
		}
		return spells;
	}, [availableSpells, spellFilter]);

	const filteredManeuvers = React.useMemo(() => {
		console.log('🔍 filteredManeuvers calculation:', { 
			availableManeuvers: availableManeuvers.length, 
			maneuverFilter 
		});
		let maneuvers = availableManeuvers;
		if (maneuverFilter !== 'all') {
			maneuvers = maneuvers.filter(maneuver => maneuver.type === maneuverFilter);
		}
		console.log('🔍 filteredManeuvers result:', maneuvers.length);
		return maneuvers;
	}, [availableManeuvers, maneuverFilter]);

	// Handle spell selection
	const handleSpellToggle = (spellName: string) => {
		setSelectedSpells(prev => {
			if (prev.includes(spellName)) {
				return prev.filter(name => name !== spellName);
			} else {
				// Check limits
				const spell = availableSpells.find(s => s.name === spellName);
				if (!spell) return prev;

				if (spell.isCantrip) {
					const currentCantrips = prev.filter(name => 
						availableSpells.find(s => s.name === name)?.isCantrip
					).length;
					if (currentCantrips >= spellCounts.cantrips) return prev;
				} else {
					const currentSpells = prev.filter(name => 
						!availableSpells.find(s => s.name === name)?.isCantrip
					).length;
					if (currentSpells >= spellCounts.spells) return prev;
				}
				return [...prev, spellName];
			}
		});
	};

	// Handle maneuver selection
	const handleManeuverToggle = (maneuverName: string) => {
		setSelectedManeuvers(prev => {
			if (prev.includes(maneuverName)) {
				return prev.filter(name => name !== maneuverName);
			} else {
				// Check limits
				if (prev.length >= maneuverCount) return prev;
				return [...prev, maneuverName];
			}
		});
	};

	// Save selections to character state
	useEffect(() => {
		console.log('🔄 Save useEffect triggered:', {
			isInitialLoad: isInitialLoad.current,
			selectedSpells,
			selectedManeuvers,
			stateSelectedSpells: state.selectedSpells,
			stateSelectedManeuvers: state.selectedManeuvers
		});
		
		// Skip on initial load to prevent infinite loops
		if (isInitialLoad.current) {
			console.log('🔄 Skipping save on initial load');
			return;
		}
		
		// Skip if we haven't initialized yet
		if (!hasInitialized.current) {
			console.log('🔄 Skipping save - not initialized yet');
			return;
		}
		
		// Only dispatch if we have actual changes to avoid infinite loops
		// Check if the current selections are different from what's in state
		const currentStateSpells = state.selectedSpells || [];
		const currentStateManeuvers = state.selectedManeuvers || [];
		
		const spellsChanged = !arraysEqual(selectedSpells, currentStateSpells);
		const maneuversChanged = !arraysEqual(selectedManeuvers, currentStateManeuvers);
		
		console.log('🔄 Change detection:', {
			spellsChanged,
			maneuversChanged,
			currentStateSpells,
			currentStateManeuvers,
			selectedSpells,
			selectedManeuvers
		});
		
		if (spellsChanged || maneuversChanged) {
			console.log('🔄 SpellsAndManeuvers: Dispatching update:', {
				spells: selectedSpells,
				maneuvers: selectedManeuvers,
				spellsChanged,
				maneuversChanged
			});
			dispatch({
				type: 'UPDATE_SPELLS_AND_MANEUVERS',
				spells: selectedSpells,
				maneuvers: selectedManeuvers
			});
		} else {
			console.log('🔄 No changes detected, skipping dispatch');
		}
	}, [selectedSpells, selectedManeuvers, dispatch, state.selectedSpells, state.selectedManeuvers]);

	// Auto-switch tabs if no content is available
	useEffect(() => {
		if (availableSpells.length === 0 && activeTab === 'spells') {
			// If no spells, switch to maneuvers if available, otherwise stay on spells
			setActiveTab(maneuverCount > 0 ? 'maneuvers' : 'spells');
		}
		if (maneuverCount === 0 && activeTab === 'maneuvers') {
			// If no maneuvers, switch to spells if available, otherwise stay on maneuvers
			setActiveTab(availableSpells.length > 0 ? 'spells' : 'maneuvers');
		}
	}, [availableSpells.length, maneuverCount, activeTab]);

	if (!state.classId) {
		return (
			<StyledContainer>
				<StyledTitle>Spells & Maneuvers</StyledTitle>
				<StyledEmptyState>
					<StyledEmptyTitle>No Class Selected</StyledEmptyTitle>
					<StyledEmptyText>
						Please select a class first to see available spells and maneuvers.
					</StyledEmptyText>
				</StyledEmptyState>
			</StyledContainer>
		);
	}

	return (
		<StyledContainer>
			<StyledTitle>Spells & Maneuvers</StyledTitle>

			<StyledTabContainer>
				{/* Only show spells tab if there are spells available */}
				{availableSpells.length > 0 && (
					<StyledTabButton
						$active={activeTab === 'spells'}
						onClick={() => setActiveTab('spells')}
					>
						Spells ({selectedSpells.length}/{spellCounts.cantrips + spellCounts.spells})
					</StyledTabButton>
				)}
				{/* Only show maneuvers tab if there are maneuvers available */}
				{maneuverCount > 0 && (
					<StyledTabButton
						$active={activeTab === 'maneuvers'}
						onClick={() => setActiveTab('maneuvers')}
					>
						Maneuvers ({selectedManeuvers.length}/{maneuverCount})
					</StyledTabButton>
				)}
			</StyledTabContainer>

			{activeTab === 'spells' && availableSpells.length > 0 && (
				<StyledSection>
					<StyledSectionTitle>
						Spells for {state.classId} (Level {state.level})
					</StyledSectionTitle>
					
					<StyledSelectedCount>
						Total Selected: {selectedSpells.length}/{spellCounts.cantrips + spellCounts.spells}
					</StyledSelectedCount>

					<StyledFilterContainer>
						<StyledFilterButton
							$active={spellFilter === 'all'}
							onClick={() => setSpellFilter('all')}
						>
							All Schools
						</StyledFilterButton>
						{Object.values(SpellSchool).map(school => (
							<StyledFilterButton
								key={school}
								$active={spellFilter === school}
								onClick={() => setSpellFilter(school)}
							>
								{school}
							</StyledFilterButton>
						))}
					</StyledFilterContainer>

					{filteredSpells.length === 0 ? (
						<StyledEmptyState>
							<StyledEmptyTitle>No Spells Available</StyledEmptyTitle>
							<StyledEmptyText>
								No spells are available for your class and level with the current filter.
							</StyledEmptyText>
						</StyledEmptyState>
					) : (
						<>
							{/* Cantrips Section */}
							{(() => {
								const cantrips = filteredSpells.filter(spell => spell.isCantrip);
								const selectedCantrips = selectedSpells.filter(name => 
									availableSpells.find(s => s.name === name)?.isCantrip
								);
								const currentCantrips = selectedCantrips.length;
								const maxCantrips = spellCounts.cantrips;

								return cantrips.length > 0 ? (
									<div style={{ marginBottom: '2rem' }}>
										<h3 style={{ 
											color: '#fbbf24', 
											marginBottom: '1rem',
											fontSize: '1.2rem',
											fontWeight: 'bold'
										}}>
											Cantrips ({currentCantrips}/{maxCantrips})
										</h3>
										<StyledGrid>
											{cantrips.map(spell => {
												const isSelected = selectedSpells.includes(spell.name);
												const canSelect = currentCantrips < maxCantrips || isSelected;

												return (
													<StyledCard key={spell.name} $selected={isSelected}>
														<StyledCardHeader>
															<StyledCardTitle>{spell.name}</StyledCardTitle>
															<StyledCardType>{spell.school}</StyledCardType>
															<StyledCardCost>
																{spell.cost.ap} AP
																{spell.cost.mp && ` + ${spell.cost.mp} MP`}
															</StyledCardCost>
														</StyledCardHeader>
														<StyledCardDescription>
															{spell.effects[0]?.description || 'No description available.'}
														</StyledCardDescription>
														<StyledCardActions>
															<StyledButton
																$variant={isSelected ? 'danger' : 'primary'}
																onClick={() => handleSpellToggle(spell.name)}
																disabled={!canSelect}
															>
																{isSelected ? 'Remove' : 'Add'}
															</StyledButton>
														</StyledCardActions>
													</StyledCard>
												);
											})}
										</StyledGrid>
									</div>
								) : null;
							})()}

							{/* Regular Spells Section */}
							{(() => {
								const regularSpells = filteredSpells.filter(spell => !spell.isCantrip);
								const selectedRegularSpells = selectedSpells.filter(name => 
									!availableSpells.find(s => s.name === name)?.isCantrip
								);
								const currentSpells = selectedRegularSpells.length;
								const maxSpells = spellCounts.spells;

								return regularSpells.length > 0 ? (
									<div>
										<h3 style={{ 
											color: '#8b5cf6', 
											marginBottom: '1rem',
											fontSize: '1.2rem',
											fontWeight: 'bold'
										}}>
											Spells ({currentSpells}/{maxSpells})
										</h3>
										<StyledGrid>
											{regularSpells.map(spell => {
												const isSelected = selectedSpells.includes(spell.name);
												const canSelect = currentSpells < maxSpells || isSelected;

												return (
													<StyledCard key={spell.name} $selected={isSelected}>
														<StyledCardHeader>
															<StyledCardTitle>{spell.name}</StyledCardTitle>
															<StyledCardType>{spell.school}</StyledCardType>
															<StyledCardCost>
																{spell.cost.ap} AP
																{spell.cost.mp && ` + ${spell.cost.mp} MP`}
															</StyledCardCost>
														</StyledCardHeader>
														<StyledCardDescription>
															{spell.effects[0]?.description || 'No description available.'}
														</StyledCardDescription>
														<StyledCardActions>
															<StyledButton
																$variant={isSelected ? 'danger' : 'primary'}
																onClick={() => handleSpellToggle(spell.name)}
																disabled={!canSelect}
															>
																{isSelected ? 'Remove' : 'Add'}
															</StyledButton>
														</StyledCardActions>
													</StyledCard>
												);
											})}
										</StyledGrid>
									</div>
								) : null;
							})()}
						</>
					)}
				</StyledSection>
			)}

			{activeTab === 'maneuvers' && maneuverCount > 0 && (
				<StyledSection>
					<StyledSectionTitle>
						Maneuvers for {state.classId} (Level {state.level})
					</StyledSectionTitle>
					
					<StyledSelectedCount>
						Selected: {selectedManeuvers.length}/{maneuverCount}
					</StyledSelectedCount>

					<StyledFilterContainer>
						<StyledFilterButton
							$active={maneuverFilter === 'all'}
							onClick={() => setManeuverFilter('all')}
						>
							All Types
						</StyledFilterButton>
						{Object.values(ManeuverType).map(type => (
							<StyledFilterButton
								key={type}
								$active={maneuverFilter === type}
								onClick={() => setManeuverFilter(type)}
							>
								{type}
							</StyledFilterButton>
						))}
					</StyledFilterContainer>

					{filteredManeuvers.length === 0 ? (
						<StyledEmptyState>
							<StyledEmptyTitle>No Maneuvers Available</StyledEmptyTitle>
							<StyledEmptyText>
								No maneuvers are available with the current filter.
							</StyledEmptyText>
						</StyledEmptyState>
					) : (
						<StyledGrid>
							{filteredManeuvers.map(maneuver => {
								const isSelected = selectedManeuvers.includes(maneuver.name);
								const canSelect = selectedManeuvers.length < maneuverCount || isSelected;

								return (
									<StyledCard key={maneuver.name} $selected={isSelected}>
										<StyledCardHeader>
											<StyledCardTitle>{maneuver.name}</StyledCardTitle>
											<StyledCardType>{maneuver.type}</StyledCardType>
											<StyledCardCost>{maneuver.cost.ap} AP</StyledCardCost>
										</StyledCardHeader>
										<StyledCardDescription>
											{maneuver.description}
											{maneuver.requirement && (
												<>
													<br />
													<strong>Requirement:</strong> {maneuver.requirement}
												</>
											)}
											{maneuver.trigger && (
												<>
													<br />
													<strong>Trigger:</strong> {maneuver.trigger}
												</>
											)}
										</StyledCardDescription>
										<StyledCardActions>
											<StyledButton
												$variant={isSelected ? 'danger' : 'primary'}
												onClick={() => handleManeuverToggle(maneuver.name)}
												disabled={!canSelect}
											>
												{isSelected ? 'Remove' : 'Add'}
											</StyledButton>
										</StyledCardActions>
									</StyledCard>
								);
							})}
						</StyledGrid>
					)}
				</StyledSection>
			)}
		</StyledContainer>
	);
};

export default SpellsAndManeuvers;
```

## File: src/routes/character-sheet/CharacterSheetDesktop.tsx
```typescript
import React, { useState } from 'react';

// Import custom hook with all character sheet logic
import { useCharacterSheet, useCharacterResources, useCharacterFeatures, useCharacterCurrency } from './hooks/CharacterSheetProvider';

// Import Modal Components  
import FeaturePopup from './components/FeaturePopup';
import SpellPopup from './components/SpellPopup';
import AttackPopup from './components/AttackPopup';
import InventoryPopup from './components/InventoryPopup';

// Import existing styled components that actually exist
import { StyledContainer, StyledBackButton } from './styles/Layout';

// Import desktop-specific styled components
import {
	StyledDesktopWrapper,
	StyledDesktopHeader,
	StyledCharacterName,
	StyledCharacterSubtitle,
	StyledAttributesGrid,
	StyledAttributeCard,
	StyledAttributeLabel,
	StyledAttributeValue,
	StyledSection,
	StyledSectionTitle,
	StyledResourceRow,
	StyledResourceLabel,
	StyledResourceValue,
	StyledResourceBar,
	StyledResourceFill,
	StyledResourceControls,
	StyledResourceButton,
	StyledResourceInput,
	StyledFeaturesGrid,
	StyledFeatureCard,
	StyledFeatureName,
	StyledFeatureSource,
	StyledCurrencyGrid,
	StyledCurrencyColumn,
	StyledCurrencyLabel,
	StyledCurrencyInput
} from './styles/DesktopLayout';

export const CharacterSheetDesktop: React.FC<{ characterId: string; onBack?: () => void }> = ({ onBack }) => {
	// Use the Context hooks
	const { state, updateHP, updateSP, updateMP, updateTempHP, updateActionPoints, updateCurrency, setManualDefense } = useCharacterSheet();
	const resources = useCharacterResources();
	const features = useCharacterFeatures();
	const currency = useCharacterCurrency();
	
	// Local popup state
	const [selectedFeature, setSelectedFeature] = useState<any>(null);
	const [selectedSpell, setSelectedSpell] = useState<any>(null);
	const [selectedAttack, setSelectedAttack] = useState<any>(null);
	const [selectedInventoryItem, setSelectedInventoryItem] = useState<any>(null);
	
	// Helper functions
	const adjustResource = (resource: string, amount: number) => {
		if (!resources) return;
		const current = resources.current;
		
		switch (resource) {
			case 'currentHP':
				updateHP(Math.max(0, current.currentHP + amount));
				break;
			case 'currentSP':
				updateSP(Math.max(0, current.currentSP + amount));
				break;
			case 'currentMP':
				updateMP(Math.max(0, current.currentMP + amount));
				break;
			case 'tempHP':
				updateTempHP(Math.max(0, current.tempHP + amount));
				break;
		}
	};
	
	const handleResourceInputChange = (resource: string, value: string) => {
		const numValue = parseInt(value) || 0;
		switch (resource) {
			case 'currentHP':
				updateHP(Math.max(0, numValue));
				break;
			case 'currentSP':
				updateSP(Math.max(0, numValue));
				break;
			case 'currentMP':
				updateMP(Math.max(0, numValue));
				break;
			case 'tempHP':
				updateTempHP(Math.max(0, numValue));
				break;
		}
	};
	
	const handleCurrencyChange = (currencyType: string, value: number) => {
		const updates: any = {};
		updates[currencyType.replace('Pieces', '')] = value;
		updateCurrency(updates.gold, updates.silver, updates.copper);
	};
	
	const getFillPercentage = (current: number, max: number) => {
		return max > 0 ? (current / max) * 100 : 0;
	};
	
	const getHPFillPercentage = (current: number, max: number, temp: number) => {
		return max > 0 ? ((current + temp) / max) * 100 : 0;
	};
	
	const openFeaturePopup = (feature: any) => setSelectedFeature(feature);
	const closeFeaturePopup = () => setSelectedFeature(null);
	const closeSpellPopup = () => setSelectedSpell(null);
	const closeAttackPopup = () => setSelectedAttack(null);
	const closeInventoryPopup = () => setSelectedInventoryItem(null);
	
	const loading = state.loading;
	const error = state.error;
	const characterData = state.character;

	// Loading state
	if (loading) {
		return (
			<StyledContainer>
				<div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '50vh' }}>
					Loading character data...
				</div>
			</StyledContainer>
		);
	}

	// Error state
	if (error) {
		return (
			<StyledContainer>
				<div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '50vh', color: 'red' }}>
					Error: {error}
				</div>
			</StyledContainer>
		);
	}

	// No character data
	if (!characterData) {
		return (
			<StyledContainer>
				<div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '50vh' }}>
					Character not found
				</div>
			</StyledContainer>
		);
	}

	return (
		<StyledContainer>
			{onBack && (
				<StyledBackButton onClick={onBack}>
					← Back to Menu
				</StyledBackButton>
			)}
			
			<StyledDesktopWrapper>
				{/* Character Header */}
				<StyledDesktopHeader>
					<StyledCharacterName>{characterData.finalName || 'Unnamed Character'}</StyledCharacterName>
					<StyledCharacterSubtitle>
						Level {characterData.finalLevel || 1} {characterData.className}
						{characterData.ancestry1Name && (
							<span>
								{' • '}
								{characterData.ancestry1Name}
								{characterData.ancestry2Name && ` / ${characterData.ancestry2Name}`}
							</span>
						)}
					</StyledCharacterSubtitle>
				</StyledDesktopHeader>

				{/* Character Stats */}
				<StyledAttributesGrid>
					<StyledAttributeCard>
						<StyledAttributeLabel>Might</StyledAttributeLabel>
						<StyledAttributeValue>{characterData.finalMight}</StyledAttributeValue>
					</StyledAttributeCard>
					<StyledAttributeCard>
						<StyledAttributeLabel>Agility</StyledAttributeLabel>
						<StyledAttributeValue>{characterData.finalAgility}</StyledAttributeValue>
					</StyledAttributeCard>
					<StyledAttributeCard>
						<StyledAttributeLabel>Charisma</StyledAttributeLabel>
						<StyledAttributeValue>{characterData.finalCharisma}</StyledAttributeValue>
					</StyledAttributeCard>
					<StyledAttributeCard>
						<StyledAttributeLabel>Intelligence</StyledAttributeLabel>
						<StyledAttributeValue>{characterData.finalIntelligence}</StyledAttributeValue>
					</StyledAttributeCard>
					<StyledAttributeCard>
						<StyledAttributeLabel>Prime</StyledAttributeLabel>
						<StyledAttributeValue>{characterData.finalPrimeModifierValue}</StyledAttributeValue>
					</StyledAttributeCard>
				</StyledAttributesGrid>

				{/* Resources */}
				<StyledSection>
					<StyledSectionTitle>Resources</StyledSectionTitle>
					
					{/* HP */}
					{resources && (
						<StyledResourceRow>
							<StyledResourceLabel>Hit Points:</StyledResourceLabel>
							<StyledResourceValue>
								{resources.current.currentHP} / {resources.original.maxHP}
								{resources.current.tempHP > 0 && ` (+${resources.current.tempHP} temp)`}
							</StyledResourceValue>
							<StyledResourceBar>
								<StyledResourceFill 
									fillPercent={getHPFillPercentage(resources.current.currentHP, resources.original.maxHP, resources.current.tempHP)}
									color="#4CAF50"
								/>
							</StyledResourceBar>
							<StyledResourceControls>
								<StyledResourceButton onClick={() => adjustResource('currentHP', -1)}>-</StyledResourceButton>
								<StyledResourceInput
									type="number"
									value={resources.current.currentHP}
									onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleResourceInputChange('currentHP', e.target.value)}
								/>
								<StyledResourceButton onClick={() => adjustResource('currentHP', 1)}>+</StyledResourceButton>
							</StyledResourceControls>
						</StyledResourceRow>
					)}

					{/* SP */}
					{resources && resources.original.maxSP > 0 && (
						<StyledResourceRow>
							<StyledResourceLabel>Stamina Points:</StyledResourceLabel>
							<StyledResourceValue>
								{resources.current.currentSP} / {resources.original.maxSP}
							</StyledResourceValue>
							<StyledResourceBar>
								<StyledResourceFill 
									fillPercent={getFillPercentage(resources.current.currentSP, resources.original.maxSP)}
									color="#2196F3"
								/>
							</StyledResourceBar>
							<StyledResourceControls>
								<StyledResourceButton onClick={() => adjustResource('currentSP', -1)}>-</StyledResourceButton>
								<StyledResourceInput
									type="number"
									value={resources.current.currentSP}
									onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleResourceInputChange('currentSP', e.target.value)}
								/>
								<StyledResourceButton onClick={() => adjustResource('currentSP', 1)}>+</StyledResourceButton>
							</StyledResourceControls>
						</StyledResourceRow>
					)}

					{/* MP */}
					{resources && resources.original.maxMP > 0 && (
						<StyledResourceRow>
							<StyledResourceLabel>Mana Points:</StyledResourceLabel>
							<StyledResourceValue>
								{resources.current.currentMP} / {resources.original.maxMP}
							</StyledResourceValue>
							<StyledResourceBar>
								<StyledResourceFill 
									fillPercent={getFillPercentage(resources.current.currentMP, resources.original.maxMP)}
									color="#9C27B0"
								/>
							</StyledResourceBar>
							<StyledResourceControls>
								<StyledResourceButton onClick={() => adjustResource('currentMP', -1)}>-</StyledResourceButton>
								<StyledResourceInput
									type="number"
									value={resources.current.currentMP}
									onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleResourceInputChange('currentMP', e.target.value)}
								/>
								<StyledResourceButton onClick={() => adjustResource('currentMP', 1)}>+</StyledResourceButton>
							</StyledResourceControls>
						</StyledResourceRow>
					)}
				</StyledSection>

				{/* Features */}
				<StyledSection>
					<StyledSectionTitle>Features & Traits</StyledSectionTitle>
					<StyledFeaturesGrid>
						{features.map((feature) => (
							<StyledFeatureCard
								key={feature.id}
								onClick={() => openFeaturePopup(feature)}
							>
								<StyledFeatureName>{feature.name}</StyledFeatureName>
								<StyledFeatureSource>{feature.sourceDetail}</StyledFeatureSource>
							</StyledFeatureCard>
						))}
					</StyledFeaturesGrid>
				</StyledSection>

				{/* Currency */}
				<StyledSection>
					<StyledSectionTitle>Currency</StyledSectionTitle>
					<StyledCurrencyGrid>
						<StyledCurrencyColumn>
							<StyledCurrencyLabel>Gold</StyledCurrencyLabel>
							<StyledCurrencyInput
								type="number"
								value={currency.gold}
								onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleCurrencyChange('goldPieces', parseInt(e.target.value) || 0)}
							/>
						</StyledCurrencyColumn>
						<StyledCurrencyColumn>
							<StyledCurrencyLabel>Silver</StyledCurrencyLabel>
							<StyledCurrencyInput
								type="number"
								value={currency.silver}
								onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleCurrencyChange('silverPieces', parseInt(e.target.value) || 0)}
							/>
						</StyledCurrencyColumn>
						<StyledCurrencyColumn>
							<StyledCurrencyLabel>Copper</StyledCurrencyLabel>
							<StyledCurrencyInput
								type="number"
								value={currency.copper}
								onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleCurrencyChange('copperPieces', parseInt(e.target.value) || 0)}
							/>
						</StyledCurrencyColumn>
					</StyledCurrencyGrid>
				</StyledSection>
			</StyledDesktopWrapper>

			{/* Modal Popups - same as mobile! */}
			{selectedFeature && (
				<FeaturePopup
					feature={selectedFeature}
					onClose={closeFeaturePopup}
				/>
			)}

			{selectedSpell && (
				<SpellPopup
					spell={selectedSpell}
					onClose={closeSpellPopup}
				/>
			)}

			{selectedAttack && (
				<AttackPopup
					selectedAttack={selectedAttack}
					onClose={closeAttackPopup}
				/>
			)}

			{selectedInventoryItem && (
				<InventoryPopup
					selectedInventoryItem={selectedInventoryItem}
					onClose={closeInventoryPopup}
				/>
			)}
		</StyledContainer>
	);
};

export default CharacterSheetDesktop;
```

## File: src/routes/character-sheet/CharacterSheetMobile.tsx
```typescript
import React, { useState } from 'react';
import { useCharacterSheet, useCharacterResources, useCharacterFeatures, useCharacterCurrency, useCharacterAttacks, useCharacterSpells, useCharacterInventory } from './hooks/CharacterSheetProvider';

// Import Modal Components  
import FeaturePopup from './components/FeaturePopup';
import SpellPopup from './components/SpellPopup';
import AttackPopup from './components/AttackPopup';
import InventoryPopup from './components/InventoryPopup';

// Mobile-specific styled components
import styled from 'styled-components';

const MobileContainer = styled.div`
	display: flex;
	flex-direction: column;
	height: 100vh;
	background: #1a1a1a;
	color: white;
	width: 100vw;
	max-width: 100vw;
	overflow-x: hidden;
	box-sizing: border-box;
	contain: layout;
	position: relative;
`;

const MobileHeader = styled.div`
	background: #2a2a2a;
	padding: 1rem;
	text-align: center;
	border-bottom: 2px solid #444;
`;

const MobileCharacterName = styled.h1`
	margin: 0;
	font-size: 1.5rem;
	color: #f5d020;
`;

const MobileCharacterInfo = styled.p`
	margin: 0.5rem 0 0 0;
	font-size: 1rem;
	color: #ccc;
`;

const MobileNavigation = styled.div`
	display: flex;
	background: #333;
	border-top: 1px solid #444;
	position: fixed;
	bottom: 0;
	left: 0;
	right: 0;
	z-index: 1000;
	width: 100%;
	max-width: 100vw;
	box-sizing: border-box;
`;

const MobileNavButton = styled.button<{ $active: boolean }>`
	flex: 1;
	max-width: 25vw;
	padding: 0.75rem 0.25rem;
	background: ${props => props.$active ? '#f5d020' : '#333'};
	color: ${props => props.$active ? '#000' : '#fff'};
	border: none;
	font-size: 0.8rem;
	font-weight: bold;
	cursor: pointer;
	transition: all 0.2s;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	min-width: 0;
	box-sizing: border-box;

	&:hover {
		background: ${props => props.$active ? '#f5d020' : '#444'};
	}
`;

const MobileContent = styled.div`
	flex: 1;
	overflow-y: auto;
	overflow-x: hidden;
	padding: 1rem;
	padding-bottom: 7rem; /* Extra space to account for fixed bottom navigation */
	width: 100vw;
	max-width: 100vw;
	box-sizing: border-box;
	contain: layout;
	position: relative;
`;

const MobileSection = styled.div`
	margin-bottom: 2rem;
	width: 100%;
	max-width: 100vw;
	overflow: hidden;
	box-sizing: border-box;
`;

const MobileSectionTitle = styled.h2`
	color: #f5d020;
	font-size: 1.25rem;
	margin-bottom: 1rem;
	border-bottom: 1px solid #444;
	padding-bottom: 0.5rem;
`;

const MobileStatGrid = styled.div`
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
	gap: 0.5rem;
	margin-bottom: 1.5rem;
	width: 100%;
	max-width: 100vw;
	overflow: hidden;
	box-sizing: border-box;
`;

const MobileStatBox = styled.div`
	background: #2a2a2a;
	padding: 1rem;
	border-radius: 8px;
	text-align: center;
	border: 1px solid #444;
	width: 100%;
	max-width: 100%;
	overflow: hidden;
	box-sizing: border-box;
`;

const MobileStatLabel = styled.div`
	font-size: 0.8rem;
	color: #ccc;
	margin-bottom: 0.25rem;
`;

const MobileStatValue = styled.div`
	font-size: 1.5rem;
	font-weight: bold;
	color: #f5d020;
`;

const MobileResourceBox = styled.div`
	background: #2a2a2a;
	border: 1px solid #444;
	border-radius: 8px;
	padding: 1rem;
	margin-bottom: 1rem;
`;

const MobileResourceHeader = styled.div`
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 0.5rem;
`;

const MobileResourceLabel = styled.div`
	font-weight: bold;
	color: #f5d020;
`;

const MobileResourceValue = styled.div`
	color: #ccc;
`;

const MobileResourceBar = styled.div`
	width: 100%;
	height: 8px;
	background: #444;
	border-radius: 4px;
	overflow: hidden;
	margin-bottom: 0.5rem;
`;

const MobileResourceFill = styled.div<{ $percentage: number }>`
	width: ${props => props.$percentage}%;
	height: 100%;
	background: linear-gradient(90deg, #4CAF50, #8BC34A);
	transition: width 0.3s ease;
`;

const MobileResourceControls = styled.div`
	display: flex;
	gap: 0.5rem;
	align-items: center;
`;

const MobileResourceButton = styled.button`
	width: 40px;
	height: 40px;
	border: none;
	background: #444;
	color: white;
	border-radius: 4px;
	font-size: 1.2rem;
	font-weight: bold;
	cursor: pointer;
	transition: background-color 0.2s;

	&:hover {
		background: #555;
	}

	&:active {
		background: #666;
	}
`;

const MobileResourceInput = styled.input`
	flex: 1;
	padding: 0.5rem;
	background: #333;
	border: 1px solid #555;
	color: white;
	text-align: center;
	border-radius: 4px;
`;

const MobileItemGrid = styled.div`
	display: grid;
	gap: 0.75rem;
	width: 100%;
	max-width: 100%;
	overflow: hidden;
	box-sizing: border-box;
`;

const MobileItem = styled.div`
	background: #2a2a2a;
	border: 1px solid #444;
	border-radius: 8px;
	padding: 1rem;
	cursor: pointer;
	transition: all 0.2s;
	width: 100%;
	max-width: 100%;
	overflow: hidden;
	box-sizing: border-box;

	&:hover {
		background: #333;
		border-color: #f5d020;
	}
`;

const MobileItemName = styled.div`
	font-weight: bold;
	color: #f5d020;
	margin-bottom: 0.25rem;
	word-wrap: break-word;
	overflow-wrap: break-word;
	hyphens: auto;
`;

const MobileItemDetails = styled.div`
	font-size: 0.9rem;
	color: #ccc;
	word-wrap: break-word;
	overflow-wrap: break-word;
	hyphens: auto;
`;

type MobileSectionType = 'character' | 'combat' | 'features' | 'info';

interface CharacterSheetMobileProps {
	characterId: string;
}

export const CharacterSheetMobile: React.FC<CharacterSheetMobileProps> = ({ characterId }) => {
	// Use Context hooks
	const { state, updateHP, updateSP, updateMP, updateTempHP, updateActionPoints, updateCurrency } = useCharacterSheet();
	const resources = useCharacterResources();
	const features = useCharacterFeatures();
	const currency = useCharacterCurrency();
	const attacks = useCharacterAttacks();
	const spells = useCharacterSpells();
	const inventory = useCharacterInventory();
	
	// Local state
	const [activeMobileSection, setActiveMobileSection] = useState<'character' | 'combat' | 'features' | 'info'>('character');
	const [selectedFeature, setSelectedFeature] = useState<any>(null);
	const [selectedSpell, setSelectedSpell] = useState<any>(null);
	const [selectedAttack, setSelectedAttack] = useState<any>(null);
	const [selectedInventoryItem, setSelectedInventoryItem] = useState<any>(null);
	
	// Helper functions
	const adjustResource = (resource: string, amount: number) => {
		if (!resources) return;
		const current = resources.current;
		
		switch (resource) {
			case 'currentHP':
				updateHP(Math.max(0, current.currentHP + amount));
				break;
			case 'currentSP':
				updateSP(Math.max(0, current.currentSP + amount));
				break;
			case 'currentMP':
				updateMP(Math.max(0, current.currentMP + amount));
				break;
			case 'tempHP':
				updateTempHP(Math.max(0, current.tempHP + amount));
				break;
			case 'actionPointsUsed':
				updateActionPoints(Math.max(0, Math.min(4, current.actionPointsUsed + amount)));
				break;
		}
	};
	
	const handleResourceInputChange = (resource: string, value: string) => {
		const numValue = parseInt(value) || 0;
		switch (resource) {
			case 'currentHP':
				updateHP(Math.max(0, numValue));
				break;
			case 'currentSP':
				updateSP(Math.max(0, numValue));
				break;
			case 'currentMP':
				updateMP(Math.max(0, numValue));
				break;
			case 'tempHP':
				updateTempHP(Math.max(0, numValue));
				break;
		}
	};
	
	const handleCurrencyChange = (currencyType: string, value: number) => {
		const updates: any = {};
		updates[currencyType.replace('Pieces', '')] = value;
		updateCurrency(updates.gold, updates.silver, updates.copper);
	};
	
	const getFillPercentage = (current: number, max: number) => {
		return max > 0 ? (current / max) * 100 : 0;
	};
	
	const getHPFillPercentage = (current: number, max: number, temp: number) => {
		return max > 0 ? ((current + temp) / max) * 100 : 0;
	};
	
	// Popup handlers
	const openFeaturePopup = (feature: any) => setSelectedFeature(feature);
	const closeFeaturePopup = () => setSelectedFeature(null);
	const openSpellPopup = (spell: any) => setSelectedSpell(spell);
	const closeSpellPopup = () => setSelectedSpell(null);
	const openAttackPopup = (attack: any) => setSelectedAttack(attack);
	const closeAttackPopup = () => setSelectedAttack(null);
	const openInventoryPopup = (item: any) => setSelectedInventoryItem(item);
	const closeInventoryPopup = () => setSelectedInventoryItem(null);
	
	// Stub handlers for missing functionality
	const handleExhaustionChange = (level: number) => {
		console.log('Exhaustion change:', level);
	};
	const handleDeathStepChange = (step: number) => {
		console.log('Death step change:', step);
	};
	
	const loading = state.loading;
	const error = state.error;
	const characterData = state.character;

	// Loading state
	if (loading) {
		return (
			<MobileContainer>
				<MobileContent>Loading character data...</MobileContent>
			</MobileContainer>
		);
	}

	// Error state
	if (error) {
		return (
			<MobileContainer>
				<MobileContent>Error: {error}</MobileContent>
			</MobileContainer>
		);
	}

	// No character data
	if (!characterData) {
		return (
			<MobileContainer>
				<MobileContent>Character not found</MobileContent>
			</MobileContainer>
		);
	}

	const renderCharacterSection = () => (
		<MobileContent>
			{/* Character Stats */}
			<MobileSection>
				<MobileSectionTitle>Attributes</MobileSectionTitle>
				<MobileStatGrid>
					<MobileStatBox>
						<MobileStatLabel>Might</MobileStatLabel>
						<MobileStatValue>{characterData.finalMight}</MobileStatValue>
					</MobileStatBox>
					<MobileStatBox>
						<MobileStatLabel>Agility</MobileStatLabel>
						<MobileStatValue>{characterData.finalAgility}</MobileStatValue>
					</MobileStatBox>
					<MobileStatBox>
						<MobileStatLabel>Charisma</MobileStatLabel>
						<MobileStatValue>{characterData.finalCharisma}</MobileStatValue>
					</MobileStatBox>
					<MobileStatBox>
						<MobileStatLabel>Intelligence</MobileStatLabel>
						<MobileStatValue>{characterData.finalIntelligence}</MobileStatValue>
					</MobileStatBox>
					<MobileStatBox>
						<MobileStatLabel>Prime</MobileStatLabel>
						<MobileStatValue>{characterData.finalPrimeModifierValue}</MobileStatValue>
					</MobileStatBox>
				</MobileStatGrid>
			</MobileSection>

			{/* Resources */}
			<MobileSection>
				<MobileSectionTitle>Resources</MobileSectionTitle>
				
				{/* HP */}
				<MobileResourceBox>
					<MobileResourceHeader>
						<MobileResourceLabel>Hit Points</MobileResourceLabel>
						<MobileResourceValue>
							{resources?.current.currentHP} / {resources?.original.maxHP}
							{resources?.current.tempHP > 0 && ` (+${resources.current.tempHP} temp)`}
						</MobileResourceValue>
					</MobileResourceHeader>
					<MobileResourceBar>
						<MobileResourceFill
							$percentage={resources ? getHPFillPercentage(
								resources.current.currentHP,
								resources.original.maxHP,
								resources.current.tempHP
							) : 0}
						/>
					</MobileResourceBar>
					<MobileResourceControls>
						<MobileResourceButton onClick={() => adjustResource('currentHP', -1)}>-</MobileResourceButton>
						<MobileResourceInput
							type="number"
							value={resources?.current.currentHP || 0}
							onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleResourceInputChange('currentHP', e.target.value)}
						/>
						<MobileResourceButton onClick={() => adjustResource('currentHP', 1)}>+</MobileResourceButton>
					</MobileResourceControls>
				</MobileResourceBox>

				{/* Temp HP */}
				<MobileResourceBox>
					<MobileResourceHeader>
						<MobileResourceLabel>Temporary HP</MobileResourceLabel>
						<MobileResourceValue>{currentValues.tempHP}</MobileResourceValue>
					</MobileResourceHeader>
					<MobileResourceControls>
						<MobileResourceButton onClick={() => adjustResource('tempHP', -1)}>-</MobileResourceButton>
						<MobileResourceInput
							type="number"
							value={currentValues.tempHP}
							onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleResourceInputChange('tempHP', e.target.value)}
						/>
						<MobileResourceButton onClick={() => adjustResource('tempHP', 1)}>+</MobileResourceButton>
					</MobileResourceControls>
				</MobileResourceBox>

				{/* SP */}
				{characterData.finalSPMax > 0 && (
					<MobileResourceBox>
						<MobileResourceHeader>
							<MobileResourceLabel>Stamina Points</MobileResourceLabel>
							<MobileResourceValue>
								{currentValues.currentSP} / {characterData.finalSPMax}
							</MobileResourceValue>
						</MobileResourceHeader>
						<MobileResourceBar>
							<MobileResourceFill
								$percentage={getFillPercentage(currentValues.currentSP, characterData.finalSPMax)}
							/>
						</MobileResourceBar>
						<MobileResourceControls>
							<MobileResourceButton onClick={() => adjustResource('currentSP', -1)}>-</MobileResourceButton>
							<MobileResourceInput
								type="number"
								value={currentValues.currentSP}
								onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleResourceInputChange('currentSP', e.target.value)}
							/>
							<MobileResourceButton onClick={() => adjustResource('currentSP', 1)}>+</MobileResourceButton>
						</MobileResourceControls>
					</MobileResourceBox>
				)}

				{/* MP */}
				{characterData.finalMPMax > 0 && (
					<MobileResourceBox>
						<MobileResourceHeader>
							<MobileResourceLabel>Mana Points</MobileResourceLabel>
							<MobileResourceValue>
								{currentValues.currentMP} / {characterData.finalMPMax}
							</MobileResourceValue>
						</MobileResourceHeader>
						<MobileResourceBar>
							<MobileResourceFill
								$percentage={getFillPercentage(currentValues.currentMP, characterData.finalMPMax)}
							/>
						</MobileResourceBar>
						<MobileResourceControls>
							<MobileResourceButton onClick={() => adjustResource('currentMP', -1)}>-</MobileResourceButton>
							<MobileResourceInput
								type="number"
								value={currentValues.currentMP}
								onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleResourceInputChange('currentMP', e.target.value)}
							/>
							<MobileResourceButton onClick={() => adjustResource('currentMP', 1)}>+</MobileResourceButton>
						</MobileResourceControls>
					</MobileResourceBox>
				)}
			</MobileSection>

			{/* Currency */}
			<MobileSection>
				<MobileSectionTitle>Currency</MobileSectionTitle>
				<MobileStatGrid>
					<MobileStatBox>
						<MobileStatLabel>Gold</MobileStatLabel>
						<MobileResourceInput
							type="number"
							value={currentValues.goldPieces}
							onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleCurrencyChange('goldPieces', parseInt(e.target.value) || 0)}
						/>
					</MobileStatBox>
					<MobileStatBox>
						<MobileStatLabel>Silver</MobileStatLabel>
						<MobileResourceInput
							type="number"
							value={currentValues.silverPieces}
							onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleCurrencyChange('silverPieces', parseInt(e.target.value) || 0)}
						/>
					</MobileStatBox>
					<MobileStatBox>
						<MobileStatLabel>Copper</MobileStatLabel>
						<MobileResourceInput
							type="number"
							value={currentValues.copperPieces}
							onChange={(e: React.ChangeEvent<HTMLInputElement>) => handleCurrencyChange('copperPieces', parseInt(e.target.value) || 0)}
						/>
					</MobileStatBox>
				</MobileStatGrid>
			</MobileSection>
		</MobileContent>
	);

	const renderCombatSection = () => (
		<MobileContent>
			{/* Attacks */}
			<MobileSection>
				<MobileSectionTitle>Attacks</MobileSectionTitle>
				<MobileItemGrid>
					{attacks.map((attack) => (
						<MobileItem
							key={attack.id}
							onClick={() => openAttackPopup(attack, null)}
						>
							<MobileItemName>{attack.name || 'Unnamed Attack'}</MobileItemName>
							<MobileItemDetails>
								{attack.weaponName && <div>Weapon: {attack.weaponName}</div>}
								{attack.damage && <div>Damage: {attack.damage}</div>}
								{attack.attackBonus !== 0 && <div>Bonus: +{attack.attackBonus}</div>}
							</MobileItemDetails>
						</MobileItem>
					))}
				</MobileItemGrid>
			</MobileSection>

			{/* Action Points */}
			<MobileSection>
				<MobileSectionTitle>Action Points Used</MobileSectionTitle>
				<MobileStatGrid>
					{[1, 2, 3, 4].map((point) => (
						<MobileStatBox
							key={point}
							style={{
								background: currentValues.actionPointsUsed >= point ? '#f5d020' : '#2a2a2a',
								color: currentValues.actionPointsUsed >= point ? '#000' : '#fff',
								cursor: 'pointer'
							}}
							onClick={() =>
								adjustResource(
									'actionPointsUsed',
									currentValues.actionPointsUsed >= point ? -1 : 1
								)
							}
						>
							<MobileStatValue>{point}</MobileStatValue>
						</MobileStatBox>
					))}
				</MobileStatGrid>
			</MobileSection>

			{/* Exhaustion */}
			<MobileSection>
				<MobileSectionTitle>Exhaustion Level</MobileSectionTitle>
				<MobileStatGrid>
					{[1, 2, 3, 4, 5].map((level) => (
						<MobileStatBox
							key={level}
							style={{
								background: currentValues.exhaustionLevel >= level ? '#ff4444' : '#2a2a2a',
								color: currentValues.exhaustionLevel >= level ? '#fff' : '#ccc',
								cursor: 'pointer'
							}}
							onClick={() => handleExhaustionChange(level)}
						>
							<MobileStatValue>{level}</MobileStatValue>
						</MobileStatBox>
					))}
				</MobileStatGrid>
			</MobileSection>

			{/* Health Status / Death Steps */}
			<MobileSection>
				<MobileSectionTitle>Death Steps</MobileSectionTitle>
				<MobileStatGrid>
					{[1, 2, 3, 4, 5].map((step) => (
						<MobileStatBox
							key={step}
							style={{
								background: currentValues.currentHP === -step ? '#ff4444' : '#2a2a2a',
								color: currentValues.currentHP === -step ? '#fff' : '#ccc',
								cursor: 'pointer'
							}}
							onClick={() => handleDeathStepChange(step)}
						>
							<MobileStatLabel>Step</MobileStatLabel>
							<MobileStatValue>{step}</MobileStatValue>
						</MobileStatBox>
					))}
				</MobileStatGrid>
			</MobileSection>
		</MobileContent>
	);

	const renderFeaturesSection = () => (
		<MobileContent>
			{/* Features */}
			<MobileSection>
				<MobileSectionTitle>Features & Traits</MobileSectionTitle>
				<MobileItemGrid>
					{features.map((feature) => (
						<MobileItem
							key={feature.id}
							onClick={() => openFeaturePopup(feature)}
						>
							<MobileItemName>{feature.name}</MobileItemName>
							<MobileItemDetails>{feature.sourceDetail}</MobileItemDetails>
						</MobileItem>
					))}
				</MobileItemGrid>
			</MobileSection>

			{/* Spells */}
			{spells.length > 0 && (
				<MobileSection>
					<MobileSectionTitle>Spells</MobileSectionTitle>
					<MobileItemGrid>
						{spells.map((spell) => (
							<MobileItem
								key={spell.id}
								onClick={() => openSpellPopup(spell as any)}
							>
								<MobileItemName>{(spell as any).name || 'Unnamed Spell'}</MobileItemName>
								<MobileItemDetails>Level: {(spell as any).level || '?'}</MobileItemDetails>
							</MobileItem>
						))}
					</MobileItemGrid>
				</MobileSection>
			)}

			{/* Inventory */}
			{inventory.length > 0 && (
				<MobileSection>
					<MobileSectionTitle>Inventory</MobileSectionTitle>
					<MobileItemGrid>
						{inventory.map((item) => (
							<MobileItem
								key={item.id}
								onClick={() => openInventoryPopup(item, null)}
							>
								<MobileItemName>{item.name}</MobileItemName>
								<MobileItemDetails>
									{item.quantity && <div>Qty: {item.quantity}</div>}
									{item.weight && <div>Weight: {item.weight}</div>}
								</MobileItemDetails>
							</MobileItem>
						))}
					</MobileItemGrid>
				</MobileSection>
			)}
		</MobileContent>
	);

	const renderInfoSection = () => (
		<MobileContent>
			{/* Skills */}
			<MobileSection>
				<MobileSectionTitle>Skills</MobileSectionTitle>
				{Object.entries(skillsByAttribute).map(([attribute, skills]) => (
					<div key={attribute}>
						<h3 style={{ color: '#f5d020', marginBottom: '0.5rem' }}>
							{attribute.charAt(0).toUpperCase() + attribute.slice(1)}
						</h3>
						<MobileItemGrid>
							{skills.map((skill) => (
								<MobileItem key={skill.id}>
									<MobileItemName>{skill.name}</MobileItemName>
									<MobileItemDetails>
										Bonus: {skill.bonus >= 0 ? '+' : ''}{skill.bonus}
									</MobileItemDetails>
								</MobileItem>
							))}
						</MobileItemGrid>
					</div>
				))}
			</MobileSection>

			{/* Trades */}
			{trades.length > 0 && (
				<MobileSection>
					<MobileSectionTitle>Trades</MobileSectionTitle>
					<MobileItemGrid>
						{trades.map((trade) => (
							<MobileItem key={trade.id}>
								<MobileItemName>{trade.name}</MobileItemName>
								<MobileItemDetails>
									Bonus: {trade.bonus >= 0 ? '+' : ''}{trade.bonus}
								</MobileItemDetails>
							</MobileItem>
						))}
					</MobileItemGrid>
				</MobileSection>
			)}

			{/* Knowledge */}
			{knowledge.length > 0 && (
				<MobileSection>
					<MobileSectionTitle>Knowledge</MobileSectionTitle>
					<MobileItemGrid>
						{knowledge.map((know) => (
							<MobileItem key={know.id}>
								<MobileItemName>{know.name}</MobileItemName>
								<MobileItemDetails>
									Bonus: {know.bonus >= 0 ? '+' : ''}{know.bonus}
								</MobileItemDetails>
							</MobileItem>
						))}
					</MobileItemGrid>
				</MobileSection>
			)}

			{/* Languages */}
			{languages.length > 0 && (
				<MobileSection>
					<MobileSectionTitle>Languages</MobileSectionTitle>
					<MobileItemGrid>
						{languages.map((language) => (
							<MobileItem key={language.id}>
								<MobileItemName>{language.name}</MobileItemName>
								<MobileItemDetails>Fluency: {language.fluency}</MobileItemDetails>
							</MobileItem>
						))}
					</MobileItemGrid>
				</MobileSection>
			)}
		</MobileContent>
	);

	return (
		<MobileContainer>
			{/* Header */}
			<MobileHeader>
				<MobileCharacterName>{characterData.name || 'Unnamed Character'}</MobileCharacterName>
				<MobileCharacterInfo>
					Level {characterData.level || 1} {characterData.className}
					{characterData.ancestry1Name && (
						<span>
							{' • '}
							{characterData.ancestry1Name}
							{characterData.ancestry2Name && ` / ${characterData.ancestry2Name}`}
						</span>
					)}
				</MobileCharacterInfo>
			</MobileHeader>

			{/* Navigation */}
			<MobileNavigation>
				<MobileNavButton
					$active={activeMobileSection === 'character'}
					onClick={() => setActiveMobileSection('character')}
				>
					Character
				</MobileNavButton>
				<MobileNavButton
					$active={activeMobileSection === 'combat'}
					onClick={() => setActiveMobileSection('combat')}
				>
					Combat
				</MobileNavButton>
				<MobileNavButton
					$active={activeMobileSection === 'features'}
					onClick={() => setActiveMobileSection('features')}
				>
					Features
				</MobileNavButton>
				<MobileNavButton
					$active={activeMobileSection === 'info'}
					onClick={() => setActiveMobileSection('info')}
				>
					Info
				</MobileNavButton>
			</MobileNavigation>

			{/* Content based on active section */}
			{activeMobileSection === 'character' && renderCharacterSection()}
			{activeMobileSection === 'combat' && renderCombatSection()}
			{activeMobileSection === 'features' && renderFeaturesSection()}
			{activeMobileSection === 'info' && renderInfoSection()}

			{/* Modal Popups - same as desktop! */}
			{selectedFeature && (
				<FeaturePopup
					feature={selectedFeature}
					onClose={closeFeaturePopup}
				/>
			)}

			{selectedSpell && (
				<SpellPopup
					spell={selectedSpell}
					onClose={closeSpellPopup}
				/>
			)}

			{selectedAttack && (
				<AttackPopup
					attack={selectedAttack.attack}
					weapon={selectedAttack.weapon}
					onClose={closeAttackPopup}
				/>
			)}

			{selectedInventoryItem && (
				<InventoryPopup
					inventoryData={selectedInventoryItem.inventoryData}
					item={selectedInventoryItem.item}
					onClose={closeInventoryPopup}
				/>
			)}
		</MobileContainer>
	);
};

export default CharacterSheetMobile;
```

## File: src/routes/character-sheet/CharacterSheetRouter.tsx
```typescript
import React, { useState, useEffect } from 'react';
import CharacterSheetDesktop from './CharacterSheetDesktop';
import CharacterSheetMobile from './CharacterSheetMobile';
import { CharacterSheetProvider } from './hooks/CharacterSheetProvider';

// Breakpoint for mobile vs desktop (matches the existing project's mobile breakpoint)
const MOBILE_BREAKPOINT = 768;

interface CharacterSheetRouterProps {
	characterId: string;
	onBack?: () => void;
}

const CharacterSheetRouter: React.FC<CharacterSheetRouterProps> = ({ characterId, onBack }) => {
	// State for detecting mobile vs desktop
	const [isMobile, setIsMobile] = useState(false);

	// Check screen size to determine mobile vs desktop
	useEffect(() => {
		const checkMobile = () => {
			const width = window.innerWidth;
			const mobile = width <= MOBILE_BREAKPOINT;
			console.log(`Screen width: ${width}px, Mobile: ${mobile}`);
			setIsMobile(mobile);
		};

		// Initial check
		checkMobile();

		// Listen for window resize
		window.addEventListener('resize', checkMobile);

		// Cleanup
		return () => window.removeEventListener('resize', checkMobile);
	}, []);

	console.log(`Rendering: ${isMobile ? 'Mobile' : 'Desktop'} component`);

	// Route to appropriate component based on screen size
	// Both components use the EXACT same useCharacterSheet hook - zero duplication!
	return (
		<CharacterSheetProvider characterId={characterId}>
			{isMobile
				? <CharacterSheetMobile characterId={characterId} />
				: <CharacterSheetDesktop characterId={characterId} onBack={onBack} />}
		</CharacterSheetProvider>
	);
};

export default CharacterSheetRouter;
```

## File: src/lib/rulesdata/_new_schema/hunter_features.ts
```typescript
/**
 * Hunter Class Definition - New Effect Schema
 * Based on the DC20 rule analysis from classAndAncestryAndCalcRefactor.md
 */

import type { ClassDefinition } from '../schemas/character.schema';

export const hunterClass: ClassDefinition = {
  className: 'Hunter',
  startingStats: {
    hp: 9,
    sp: 6,
    mp: 0,
    skillPoints: 5,
    tradePoints: 4,
    languagePoints: 2,
    maneuversKnown: 4,
    techniquesKnown: 1,
    cantripsKnown: 0,
    spellsKnown: 0
  },
  coreFeatures: [
    {
      featureName: 'Martial Path',
      levelGained: 1,
      description: 'You gain training in martial combat.',
      effects: [
        { type: 'GRANT_COMBAT_TRAINING', target: 'Weapons', value: true },
        { type: 'GRANT_COMBAT_TRAINING', target: 'Light_Armor', value: true },
        { type: 'GRANT_COMBAT_TRAINING', target: 'Light_Shields', value: true },
        { type: 'GRANT_ABILITY', target: 'learns_all_attack_maneuvers', value: 'You learn all Attack Maneuvers.' }
      ]
    },
    {
      featureName: "Hunter's Mark",
      levelGained: 1,
      description: 'You can spend 1 AP and 1 SP to focus on and mark a creature you can see within 15 Spaces as your quarry. While marked, you gain ADV on Awareness and Survival Checks to find the target, the first Martial Attack against your target on your turn has ADV and ignores PDR, and Heavy/Critical Hits grant a d8 Help Die to the next Attack against the target. The mark lasts until the target is on a different Plane, you Long Rest, fall Unconscious, or mark another creature.',
      effects: [
        { type: 'GRANT_ABILITY', target: 'hunters_mark', value: "Mark a creature (1 AP + 1 SP): ADV on Awareness/Survival to find, first Martial Attack has ADV and ignores PDR, Heavy/Critical Hits grant d8 Help Die." }
      ]
    },
    {
      featureName: 'Favored Terrain',
      levelGained: 1,
      description: 'You are particularly familiar with specific environments. While in your Favored Terrains, you have ADV on Stealth and Survival Checks and cannot be Surprised.',
      choices: [
        {
          id: 'hunter_favored_terrain_0',
          prompt: 'Choose 2 types of Favored Terrain',
          count: 2,
          options: [
            {
              name: 'Grassland',
              description: 'Your Speed and Jump Distance increases by 1.',
              effects: [
                { type: 'MODIFY_STAT', target: 'moveSpeed', value: 1 },
                { type: 'MODIFY_STAT', target: 'jumpDistance', value: 1 },
                { type: 'GRANT_ABILITY', target: 'favored_terrain_grassland', value: 'In grassland: ADV on Stealth and Survival, cannot be Surprised.' }
              ]
            },
            {
              name: 'Forest',
              description: 'You gain 2 Skill Points to use on up to 2 of the following Skills: Animal, Awareness, Medicine, Survival, and Stealth',
              effects: [
                { type: 'MODIFY_STAT', target: 'skillPoints', value: 2 },
                { type: 'GRANT_ABILITY', target: 'favored_terrain_forest', value: 'In forest: ADV on Stealth and Survival, cannot be Surprised.' }
              ]
            },
            {
              name: 'Desert',
              description: 'You gain Fire Resistance (Half) and Resistance to Exhaustion from hot temperatures',
              effects: [
                { type: 'GRANT_RESISTANCE', target: 'Fire', value: 'half' },
                { type: 'GRANT_ABILITY', target: 'favored_terrain_desert', value: 'In desert: ADV on Stealth and Survival, cannot be Surprised, resistance to hot temperature Exhaustion.' }
              ]
            },
            {
              name: 'Mountain',
              description: 'You gain a Climb Speed equal to your Ground Speed, Resistance to Exhaustion from high altitudes, and Resistance (Half) to damage from Falling',
              effects: [
                { type: 'GRANT_MOVEMENT', target: 'climb', value: 'equal_to_speed' },
                { type: 'GRANT_RESISTANCE', target: 'Falling', value: 'half' },
                { type: 'GRANT_ABILITY', target: 'favored_terrain_mountain', value: 'In mountains: ADV on Stealth and Survival, cannot be Surprised, resistance to altitude Exhaustion.' }
              ]
            },
            {
              name: 'Jungle',
              description: 'You ignore Difficult Terrain, gain Poisoned Resistance, and have ADV on Saves against contracting Diseases',
              effects: [
                { type: 'GRANT_RESISTANCE', target: 'Poisoned', value: true },
                { type: 'GRANT_ADV_ON_SAVE', target: 'disease', value: true },
                { type: 'GRANT_ABILITY', target: 'favored_terrain_jungle', value: 'In jungle: ADV on Stealth and Survival, cannot be Surprised, ignore Difficult Terrain, Poisoned resistance, ADV vs diseases.' }
              ]
            },
            {
              name: 'Swamp',
              description: 'You gain Poison Resistance (Half) and Poisoned Resistance, and have ADV on Saves against contracting Diseases',
              effects: [
                { type: 'GRANT_RESISTANCE', target: 'Poison', value: 'half' },
                { type: 'GRANT_RESISTANCE', target: 'Poisoned', value: true },
                { type: 'GRANT_ADV_ON_SAVE', target: 'disease', value: true },
                { type: 'GRANT_ABILITY', target: 'favored_terrain_swamp', value: 'In swamp: ADV on Stealth and Survival, cannot be Surprised, Poison resistance, Poisoned resistance, ADV vs diseases.' }
              ]
            },
            {
              name: 'Coast',
              description: 'You gain a Swim Speed equal to your Ground Speed (your Weapon Attacks no longer have DisADV as a result of being underwater), you can hold your breath twice as long as normal, and you have ADV on Awareness Checks while underwater.',
              effects: [
                { type: 'GRANT_MOVEMENT', target: 'swim', value: 'equal_to_speed' },
                { type: 'GRANT_ABILITY', target: 'favored_terrain_coast', value: 'In coastal areas: ADV on Stealth and Survival, cannot be Surprised, no underwater weapon penalties, double breath holding, ADV on Awareness underwater.' }
              ]
            },
            {
              name: 'Tundra',
              description: 'You gain Cold Resistance (Half) and Resistance to Exhaustion from cold temperatures',
              effects: [
                { type: 'GRANT_RESISTANCE', target: 'Cold', value: 'half' },
                { type: 'GRANT_ABILITY', target: 'favored_terrain_tundra', value: 'In tundra: ADV on Stealth and Survival, cannot be Surprised, resistance to cold temperature Exhaustion.' }
              ]
            },
            {
              name: 'Subterranean',
              description: 'You gain Darkvision 10 Spaces. If you already have Darkvision, its range is increased by 5 Spaces. Additionally, you also gain a Tremorsense of 3 Spaces. If you already have a Tremorsense, it increases by 2 Spaces.',
              effects: [
                { type: 'GRANT_SENSE', target: 'darkvision', value: 10 },
                { type: 'GRANT_SENSE', target: 'tremorsense', value: 3 },
                { type: 'GRANT_ABILITY', target: 'favored_terrain_subterranean', value: 'Underground: ADV on Stealth and Survival, cannot be Surprised. Conditional bonuses for existing senses handled separately.' }
              ]
            },
            {
              name: 'Urban',
              description: 'You gain 2 Skill Points to use on up to 2 of the following Skills: Influence, Insight, Investigation, Intimidation, and Trickery.',
              effects: [
                { type: 'MODIFY_STAT', target: 'skillPoints', value: 2 },
                { type: 'GRANT_ABILITY', target: 'favored_terrain_urban', value: 'In urban areas: ADV on Stealth and Survival, cannot be Surprised.' }
              ]
            }
          ]
        }
      ]
    },
    {
      featureName: "Hunter's Strike",
      levelGained: 2,
      description: 'When you make a Martial Attack against the target of your Hunter\'s Mark, you can spend 1 SP to deal +1d8 damage of the Weapon\'s damage type. If the Attack was a Heavy Hit, the damage becomes +2d8. If the Attack was a Critical Hit, the damage becomes +3d8.',
      effects: [
        { type: 'GRANT_ABILITY', target: 'hunters_strike', value: "Against Hunter's Mark target: spend 1 SP for +1d8 damage (+2d8 Heavy Hit, +3d8 Critical Hit)." }
      ]
    },
    {
      featureName: 'Bestiary',
      levelGained: 3,
      description: 'Your knowledge of creatures grants you tactical advantages when facing them.',
      effects: [
        { type: 'GRANT_ABILITY', target: 'bestiary', value: 'You have extensive knowledge of creature weaknesses and behaviors for tactical advantage.' }
      ]
    }
  ],
  subclasses: []
};
```

## File: src/lib/utils/characterEdit.ts
```typescript
// Character edit mode utilities
// Handles converting saved characters back to editable format while preserving manual modifications

import type { CharacterInProgressStoreData } from '../stores/characterContext';
import type { SavedCharacter } from '../types/dataContracts';
import { getCharacterState, updateCharacterState } from './characterState';
import { traitsData } from '../rulesdata/traits';
import { getAllSavedCharacters, saveAllCharacters } from './storageUtils';



// Convert a saved character back to character-in-progress format for editing
export const convertCharacterToInProgress = (
	savedCharacter: SavedCharacter
): CharacterInProgressStoreData => {
	// Get attribute values from the correct property names (finalMight, etc. or attribute_might, etc.)
	const getAttribute = (
		finalName: keyof SavedCharacter,
		attributeName: keyof SavedCharacter
	): number => {
		// Try final* first (current format), then attribute_* (legacy format), then default to -2
		if (savedCharacter[finalName] !== undefined) {
			return savedCharacter[finalName] as number;
		}
		if (savedCharacter[attributeName] !== undefined) {
			return savedCharacter[attributeName] as number;
		}
		return -2;
	};

	return {
		id: savedCharacter.id,
		// Basic character build data (what we want to edit)
		attribute_might: getAttribute('finalMight', 'attribute_might'),
		attribute_agility: getAttribute('finalAgility', 'attribute_agility'),
		attribute_charisma: getAttribute('finalCharisma', 'attribute_charisma'),
		attribute_intelligence: getAttribute('finalIntelligence', 'attribute_intelligence'),
		pointsSpent: calculatePointsSpent(savedCharacter),
		level: savedCharacter.level || 1,
		combatMastery: savedCharacter.combatMastery || 1,
		ancestry1Id: savedCharacter.ancestry1Id,
		ancestry2Id: savedCharacter.ancestry2Id || null,
		selectedTraitIds: savedCharacter.selectedTraitIds || [],
		ancestryPointsSpent: calculateAncestryPointsSpent(savedCharacter),
		classId: savedCharacter.classId,
		selectedFeatureChoices: savedCharacter.selectedFeatureChoices || {},
		// Save masteries (default to false, but try to get from saved character if available)
		saveMasteryMight:
			savedCharacter.saveMasteryMight !== undefined ? savedCharacter.saveMasteryMight : false,
		saveMasteryAgility:
			savedCharacter.saveMasteryAgility !== undefined ? savedCharacter.saveMasteryAgility : false,
		saveMasteryCharisma:
			savedCharacter.saveMasteryCharisma !== undefined ? savedCharacter.saveMasteryCharisma : false,
		saveMasteryIntelligence:
			savedCharacter.saveMasteryIntelligence !== undefined
				? savedCharacter.saveMasteryIntelligence
				: false,
		finalName: savedCharacter.finalName,
		finalPlayerName: savedCharacter.finalPlayerName,
		createdAt: new Date(savedCharacter.completedAt),
		updatedAt: new Date(),
		currentStep: 1, // Start from the beginning when editing
		overflowTraitId: null,
		overflowAttributeName: null,
		// Background selections using native objects
		skillsData: savedCharacter.skillsData || {},
		tradesData: savedCharacter.tradesData || {},
		languagesData: savedCharacter.languagesData || { common: { fluency: 'fluent' } },
		selectedTraitChoices: savedCharacter.selectedTraitChoices || {},
		// Spells and Maneuvers selections using native arrays
		selectedSpells: savedCharacter.selectedSpells || [],
		selectedManeuvers: savedCharacter.selectedManeuvers || [],
		schemaVersion: 2
	};
};

// Calculate how many attribute points were spent
const calculatePointsSpent = (character: SavedCharacter): number => {
	const baseCost = 4; // Each attribute starts at -2, costs 4 points to get to 0

	// Helper to get attribute values from either format
	const getAttribute = (
		finalName: keyof SavedCharacter,
		attributeName: keyof SavedCharacter
	): number => {
		if (character[finalName] !== undefined) {
			return character[finalName] as number;
		}
		if (character[attributeName] !== undefined) {
			return character[attributeName] as number;
		}
		return -2;
	};

	const attributes = [
		getAttribute('finalMight', 'attribute_might'),
		getAttribute('finalAgility', 'attribute_agility'),
		getAttribute('finalCharisma', 'attribute_charisma'),
		getAttribute('finalIntelligence', 'attribute_intelligence')
	];

	let totalSpent = 0;
	attributes.forEach((value) => {
		if (value > -2) {
			totalSpent += baseCost + Math.max(0, value * 2); // Each point above 0 costs 2
		}
	});

	return totalSpent;
};

// Calculate how many ancestry points were spent (based on selected traits)
const calculateAncestryPointsSpent = (character: SavedCharacter): number => {
	if (!character.selectedTraitIds) return 0;

	const selectedTraitIds: string[] = Array.isArray(character.selectedTraitIds) 
		? character.selectedTraitIds 
		: [];
	let totalCost = 0;

	selectedTraitIds.forEach((traitId) => {
		const trait = traitsData.find((t: any) => t.id === traitId);
		if (trait) {
			totalCost += trait.cost;
		}
	});

	return totalCost;
};

// Enhanced character completion that preserves manual modifications
export const completeCharacterEdit = async (
	originalCharacterId: string,
	newCharacterState: any,
	characterCalculationFn: (data: any) => Promise<any>
): Promise<void> => {
	try {
		// Get the existing character state (manual modifications)
		const existingState = getCharacterState(originalCharacterId);

		// Calculate new stats based on the edited character build
        const newCalculatedCharacter = await characterCalculationFn({
			id: originalCharacterId, // Keep the same ID
			attribute_might: newCharacterState.attribute_might,
			attribute_agility: newCharacterState.attribute_agility,
			attribute_charisma: newCharacterState.attribute_charisma,
			attribute_intelligence: newCharacterState.attribute_intelligence,
			level: newCharacterState.level || 1,
			combatMastery: newCharacterState.combatMastery || 1,
			classId: newCharacterState.classId,
			ancestry1Id: newCharacterState.ancestry1Id,
			ancestry2Id: newCharacterState.ancestry2Id,
			selectedTraitIds: newCharacterState.selectedTraitIds || '',
			selectedFeatureChoices: newCharacterState.selectedFeatureChoices || '',
			finalName: newCharacterState.finalName,
			finalPlayerName: newCharacterState.finalPlayerName,
			skillsJson: newCharacterState.skillsJson || '',
			tradesJson: newCharacterState.tradesJson || '',
			languagesJson: newCharacterState.languagesJson || '',
			selectedSpells: newCharacterState.selectedSpells || '[]',
			selectedManeuvers: newCharacterState.selectedManeuvers || '[]',
			lastModified: new Date().toISOString()
		});

		console.log('🔄 completeCharacterEdit: Data passed to characterCalculationFn:', {
			selectedSpells: newCharacterState.selectedSpells,
			selectedManeuvers: newCharacterState.selectedManeuvers
		});

        // Update the saved character in storage with NEW CALCULATED VALUES
		const savedCharacters = getAllSavedCharacters();
		const characterIndex = savedCharacters.findIndex(
			(char: any) => char.id === originalCharacterId
		);

		if (characterIndex !== -1) {
			// Update the character with new calculated values, preserving manual modifications
			savedCharacters[characterIndex] = {
				...savedCharacters[characterIndex],
				...newCalculatedCharacter,
                // ensure we carry over latest breakdowns if provided by calculator
                breakdowns: (newCalculatedCharacter as any).breakdowns || savedCharacters[characterIndex].breakdowns,
				lastModified: new Date().toISOString()
			};

			saveAllCharacters(savedCharacters);
		}

        // Update the character state to reflect new original values while preserving current (manual) values
		if (existingState) {
			updateCharacterState(originalCharacterId, {
				resources: {
					// Update original values with new calculated maximums
					original: {
						maxHP: newCalculatedCharacter.finalHPMax || 0,
						maxSP: newCalculatedCharacter.finalSPMax || 0,
						maxMP: newCalculatedCharacter.finalMPMax || 0,
						maxGritPoints: newCalculatedCharacter.finalGritPoints || 0,
						maxRestPoints: newCalculatedCharacter.finalRestPoints || 0
					},
					// Keep existing current values (manual modifications)
					current: existingState.resources.current
				},
				// Currency and other data types keep their existing state
				currency: existingState.currency,
				attacks: existingState.attacks,
				inventory: existingState.inventory,
                defenseNotes: existingState.defenseNotes,
                calculation: (newCalculatedCharacter as any).breakdowns
                    ? { breakdowns: (newCalculatedCharacter as any).breakdowns }
                    : existingState.calculation
			});
		}
	} catch (error) {
		console.error('Error completing character edit:', error);
		throw error;
	}
};
```

## File: src/routes/character-sheet/components/Resources.tsx
```typescript
import React from 'react';
import Tooltip from './Tooltip';
import { createHPTooltip, createMPTooltip, createSPTooltip } from './StatTooltips';
import { createEnhancedTooltip } from './EnhancedStatTooltips';
import { useCharacterResources, useCharacterSheet } from '../hooks/CharacterSheetProvider';
import type { EnhancedStatBreakdown } from '../../../lib/types/effectSystem';
import {
	ResourcesContainer,
	ResourceColumn,
	ResourceLabel,
	ResourceControls,
	TempHPControls,
	TempHPLabel,
	TempHPInputSmall
} from '../styles/Resources';
import { StyledResourceButton } from '../styles/Resources';
import {
	StyledPotionContainer,
	StyledPotionFill,
	StyledPotionBubbles,
	StyledPotionValue,
	StyledLargePotionContainer,
	StyledLargePotionValue
} from '../styles/Potions';

interface ResourcesProps {
	breakdowns?: Record<string, EnhancedStatBreakdown>;
	isMobile?: boolean;
}

const Resources: React.FC<ResourcesProps> = ({
	breakdowns,
	isMobile = false
}) => {
	const { updateHP, updateSP, updateMP, updateTempHP } = useCharacterSheet();
	const resources = useCharacterResources();

	if (!resources) {
		return (
			<div style={{ padding: '1rem', color: '#666', textAlign: 'center' }}>
				<p>Loading character resources...</p>
			</div>
		);
	}

	const { current, original } = resources;

	// Helper functions
	const getFillPercentage = (current: number, max: number) => {
		return max > 0 ? Math.min((current / max) * 100, 100) : 0;
	};

	const getHPFillPercentage = (current: number, max: number, tempHP: number) => {
		const totalCurrent = current + tempHP;
		return max > 0 ? Math.min((totalCurrent / max) * 100, 100) : 0;
	};

	const onAdjustResource = (resource: 'currentSP' | 'currentMP' | 'currentHP' | 'tempHP', amount: number) => {
		switch (resource) {
			case 'currentHP':
				updateHP(Math.max(0, current.currentHP + amount));
				break;
			case 'currentSP':
				updateSP(Math.max(0, current.currentSP + amount));
				break;
			case 'currentMP':
				updateMP(Math.max(0, current.currentMP + amount));
				break;
			case 'tempHP':
				updateTempHP(Math.max(0, current.tempHP + amount));
				break;
		}
	};

	const onResourceInputChange = (resource: 'tempHP', value: string) => {
		const numValue = parseInt(value) || 0;
		if (resource === 'tempHP') {
			updateTempHP(Math.max(0, numValue));
		}
	};
	return (
		<ResourcesContainer $isMobile={isMobile}>
			{/* Stamina Points */}
			<ResourceColumn $isMobile={isMobile}>
				<ResourceLabel>STAMINA POINTS</ResourceLabel>
				<ResourceControls>
					<StyledResourceButton onClick={() => onAdjustResource('currentSP', -1)}>
						-
					</StyledResourceButton>
					<StyledPotionContainer style={{ borderColor: '#22c55e' }}>
						<StyledPotionFill
							$fillPercentage={getFillPercentage(current.currentSP, original.maxSP)}
							$color="#22c55e"
						/>
						<StyledPotionBubbles
							$color="#22c55e"
							$fillPercentage={getFillPercentage(current.currentSP, original.maxSP)}
						/>
						<StyledPotionValue>{current.currentSP}</StyledPotionValue>
					</StyledPotionContainer>
					<StyledResourceButton onClick={() => onAdjustResource('currentSP', 1)}>
						+
					</StyledResourceButton>
				</ResourceControls>
				<div
					style={{
						fontSize: '1.1rem',
						fontWeight: '300',
						color: '#666',
						marginTop: '0.3rem',
						fontStyle: 'italic'
					}}
				>
									<Tooltip 
					content={
						breakdowns?.spMax 
							? createEnhancedTooltip('Stamina Points', breakdowns.spMax)
							: createSPTooltip({ finalSPMax: original.maxSP })
					} 
					position="top"
				>
					<span style={{ cursor: 'help' }}>{original.maxSP}</span>
				</Tooltip>
				</div>
			</ResourceColumn>

			{/* Mana Points */}
			<ResourceColumn $isMobile={isMobile}>
				<ResourceLabel>MANA POINTS</ResourceLabel>
				<ResourceControls>
					<StyledResourceButton onClick={() => onAdjustResource('currentMP', -1)}>
						-
					</StyledResourceButton>
					<StyledPotionContainer style={{ borderColor: '#3b82f6' }}>
						<StyledPotionFill
							$fillPercentage={getFillPercentage(current.currentMP, original.maxMP)}
							$color="#3b82f6"
						/>
						<StyledPotionBubbles
							$color="#3b82f6"
							$fillPercentage={getFillPercentage(current.currentMP, original.maxMP)}
						/>
						<StyledPotionValue>{current.currentMP}</StyledPotionValue>
					</StyledPotionContainer>
					<StyledResourceButton onClick={() => onAdjustResource('currentMP', 1)}>
						+
					</StyledResourceButton>
				</ResourceControls>
				<div
					style={{
						fontSize: '1.1rem',
						fontWeight: '300',
						color: '#666',
						marginTop: '0.3rem',
						fontStyle: 'italic'
					}}
				>
					<Tooltip 
						content={
							breakdowns?.mpMax 
								? createEnhancedTooltip('Mana Points', breakdowns.mpMax)
								: createMPTooltip({ finalMPMax: original.maxMP })
						} 
						position="top"
					>
						<span style={{ cursor: 'help' }}>{original.maxMP}</span>
					</Tooltip>
				</div>
			</ResourceColumn>

			{/* Hit Points */}
			<ResourceColumn $isMobile={isMobile}>
				<ResourceLabel>HIT POINTS</ResourceLabel>
				<ResourceControls>
					<StyledResourceButton onClick={() => onAdjustResource('currentHP', -1)}>
						-
					</StyledResourceButton>
					<StyledLargePotionContainer style={{ borderColor: '#dc2626' }}>
						<StyledPotionFill
							$fillPercentage={getHPFillPercentage(
								current.currentHP,
								original.maxHP,
								current.tempHP
							)}
							$color="#dc2626"
						/>
						<StyledPotionBubbles
							$color="#dc2626"
							$fillPercentage={getHPFillPercentage(
								current.currentHP,
								original.maxHP,
								current.tempHP
							)}
						/>
						<StyledLargePotionValue>{current.currentHP}</StyledLargePotionValue>
					</StyledLargePotionContainer>
					<StyledResourceButton onClick={() => onAdjustResource('currentHP', 1)}>
						+
					</StyledResourceButton>
				</ResourceControls>
				<div
					style={{
						fontSize: '1.1rem',
						fontWeight: '300',
						color: '#666',
						marginTop: '0.3rem',
						fontStyle: 'italic',
						display: 'flex',
						alignItems: 'center',
						justifyContent: 'center',
						gap: '0.5rem'
					}}
				>
					<Tooltip 
						content={
							breakdowns?.hpMax 
								? createEnhancedTooltip('Hit Points', breakdowns.hpMax)
								: createHPTooltip({ finalHPMax: original.maxHP })
						} 
						position="top"
					>
						<span style={{ cursor: 'help' }}>{original.maxHP}</span>
					</Tooltip>
					{current.tempHP > 0 && (
						<span style={{ color: '#dc2626', fontWeight: 'bold', fontSize: '0.9rem' }}>
							(+{current.tempHP} temp)
						</span>
					)}
				</div>

				{/* Temp HP Controls */}
				<TempHPControls>
					<TempHPLabel>TEMP HP:</TempHPLabel>
					<StyledResourceButton
						onClick={() => onAdjustResource('tempHP', -1)}
						style={{ fontSize: '0.7rem', width: '20px', height: '20px', padding: '0' }}
					>
						-
					</StyledResourceButton>
					<TempHPInputSmall
						type="number"
						value={current.tempHP}
						onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
							onResourceInputChange('tempHP', e.target.value)
						}
					/>
					<StyledResourceButton
						onClick={() => onAdjustResource('tempHP', 1)}
						style={{ fontSize: '0.7rem', width: '20px', height: '20px', padding: '0' }}
					>
						+
					</StyledResourceButton>
				</TempHPControls>
			</ResourceColumn>
		</ResourcesContainer>
	);
};

export default Resources;
```

## File: src/routes/character-sheet/hooks/CharacterSheetProvider.tsx
```typescript
import React, { createContext, useContext, useEffect, useCallback, useMemo, useRef } from 'react';
import { useCharacterSheetReducer, type SheetState, type SheetAction } from './useCharacterSheetReducer';
import { getCharacterById, saveCharacterState } from '../../../lib/utils/storageUtils';
import { calculateCharacterWithBreakdowns } from '../../../lib/services/enhancedCharacterCalculator';

// Simple debounce utility
function useDebounce<T extends (...args: any[]) => any>(
  callback: T,
  delay: number
): T & { cancel: () => void } {
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);
  
  const debouncedCallback = useCallback((...args: Parameters<T>) => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    
    timeoutRef.current = setTimeout(() => {
      callback(...args);
    }, delay);
  }, [callback, delay]) as T & { cancel: () => void };
  
  debouncedCallback.cancel = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
  };
  
  return debouncedCallback;
}

// Context type that components will consume
interface CharacterSheetContextType {
  state: SheetState;
  dispatch: React.Dispatch<SheetAction>;
  // Helper functions from the reducer
  updateHP: (hp: number) => void;
  updateSP: (sp: number) => void;
  updateMP: (mp: number) => void;
  updateTempHP: (tempHP: number) => void;
  updateActionPoints: (ap: number) => void;
  updateExhaustion: (level: number) => void;
  setManualDefense: (pd?: number, ad?: number, pdr?: number) => void;
  addAttack: (attack: any) => void;
  removeAttack: (attackId: string) => void;
  updateAttack: (attackId: string, attack: any) => void;
  updateInventory: (items: any[]) => void;
  updateCurrency: (gold?: number, silver?: number, copper?: number) => void;
  updateNotes: (notes: string) => void;
  // Manual save function
  saveNow: () => Promise<void>;
}

const CharacterSheetContext = createContext<CharacterSheetContextType | undefined>(undefined);

interface CharacterSheetProviderProps {
  children: React.ReactNode;
  characterId: string;
}

export function CharacterSheetProvider({ children, characterId }: CharacterSheetProviderProps) {
  const {
    state,
    dispatch,
    updateHP,
    updateSP,
    updateMP,
    updateTempHP,
    updateActionPoints,
    updateExhaustion,
    setManualDefense,
    addAttack,
    removeAttack,
    updateAttack,
    updateInventory,
    updateCurrency,
    updateNotes,
  } = useCharacterSheetReducer();

  // Save function that runs enhanced calculator and persists to storage
  const saveCharacterData = useCallback(async (character: any) => {
    if (!character) return;

    try {
      // Run enhanced calculator to update original stats
      const calculationResult = calculateCharacterWithBreakdowns(character);
      
      // Update the character's original resource values with calculated results
      const updatedCharacter = {
        ...character,
        characterState: {
          ...character.characterState,
          resources: {
            ...character.characterState.resources,
            original: {
              maxHP: calculationResult.finalHPMax || 0,
              maxSP: calculationResult.finalSPMax || 0,
              maxMP: calculationResult.finalMPMax || 0,
              maxGritPoints: calculationResult.finalGritPoints || 0,
              maxRestPoints: calculationResult.finalRestPoints || 0,
            }
          }
        }
      };

      // Save to localStorage via storage utils
      await saveCharacterState(character.id, updatedCharacter.characterState);
      
      console.log('Character sheet data saved successfully');
    } catch (error) {
      console.warn('Calculator error during save, proceeding with last known values:', error);
      // Save anyway with existing character state
      try {
        await saveCharacterState(character.id, character.characterState);
      } catch (saveError) {
        console.error('Failed to save character data:', saveError);
      }
    }
  }, []);

  // Debounced save - runs 750ms after last change
  const debouncedSave = useDebounce(saveCharacterData, 750);

  // Manual save function for explicit save actions
  const saveNow = useCallback(async () => {
    if (state.character) {
      debouncedSave.cancel(); // Cancel any pending debounced save
      await saveCharacterData(state.character);
    }
  }, [state.character, saveCharacterData, debouncedSave]);

  // Load character data on mount or when characterId changes
  useEffect(() => {
    if (!characterId) return;

    dispatch({ type: 'LOAD_START' });

    try {
      const character = getCharacterById(characterId);
      console.log('Raw character data:', character);
      
      if (character) {
        // Ensure the character has a proper characterState structure
        const normalizedCharacter = {
          ...character,
          characterState: character.characterState || {
            resources: {
              current: {
                currentHP: character.finalHPMax || 0,
                currentSP: character.finalSPMax || 0, 
                currentMP: character.finalMPMax || 0,
                currentGritPoints: character.finalGritPoints || 0,
                currentRestPoints: character.finalRestPoints || 0,
                tempHP: 0,
                actionPointsUsed: 0,
                exhaustionLevel: 0,
              },
              original: {
                maxHP: character.finalHPMax || 0,
                maxSP: character.finalSPMax || 0,
                maxMP: character.finalMPMax || 0,
                maxGritPoints: character.finalGritPoints || 0,
                maxRestPoints: character.finalRestPoints || 0,
              }
            },
            ui: { manualDefenseOverrides: {} },
            inventory: { 
              items: [], 
              currency: { gold: 0, silver: 0, copper: 0 } 
            },
            notes: { playerNotes: '' },
            attacks: [],
            spells: character.spells || [],
            maneuvers: character.maneuvers || [],
          }
        };
        
        console.log('Normalized character:', normalizedCharacter);
        dispatch({ type: 'LOAD_SUCCESS', character: normalizedCharacter });
      } else {
        dispatch({ type: 'LOAD_ERROR', error: 'Character not found' });
      }
    } catch (error) {
      console.error('Error loading character:', error);
      dispatch({ type: 'LOAD_ERROR', error: `Failed to load character: ${error instanceof Error ? error.message : 'Unknown error'}` });
    }
  }, [characterId, dispatch]);

  // Auto-save when character data changes
  useEffect(() => {
    if (state.character && !state.loading) {
      debouncedSave(state.character);
    }

    // Cleanup debounced function on unmount
    return () => {
      debouncedSave.cancel();
    };
  }, [state.character, state.loading, debouncedSave]);

  const contextValue: CharacterSheetContextType = {
    state,
    dispatch,
    updateHP,
    updateSP,
    updateMP,
    updateTempHP,
    updateActionPoints,
    updateExhaustion,
    setManualDefense,
    addAttack,
    removeAttack,
    updateAttack,
    updateInventory,
    updateCurrency,
    updateNotes,
    saveNow,
  };

  return (
    <CharacterSheetContext.Provider value={contextValue}>
      {children}
    </CharacterSheetContext.Provider>
  );
}

// Custom hook to consume the context
export function useCharacterSheet() {
  const context = useContext(CharacterSheetContext);
  if (context === undefined) {
    throw new Error('useCharacterSheet must be used within a CharacterSheetProvider');
  }
  return context;
}

// Selector hooks for commonly accessed data
export function useCharacterResources() {
  const { state } = useCharacterSheet();
  
  return useMemo(() => {
    if (!state.character?.characterState?.resources) return null;
    
    const resources = state.character.characterState.resources;
    const current = resources.current;
    
    // Handle cases where original might be missing (legacy data)
    const original = resources.original || {
      maxHP: state.character.finalHPMax || 0,
      maxSP: state.character.finalSPMax || 0,
      maxMP: state.character.finalMPMax || 0,
      maxGritPoints: state.character.finalGritPoints || 0,
      maxRestPoints: state.character.finalRestPoints || 0,
    };
    
    return {
      current,
      original,
      // Derived values
      hpPercentage: original.maxHP > 0 ? (current.currentHP / original.maxHP) * 100 : 0,
      spPercentage: original.maxSP > 0 ? (current.currentSP / original.maxSP) * 100 : 0,
      mpPercentage: original.maxMP > 0 ? (current.currentMP / original.maxMP) * 100 : 0,
    };
  }, [state.character?.characterState?.resources, state.character?.finalHPMax, state.character?.finalSPMax, state.character?.finalMPMax]);
}

export function useCharacterDefenses() {
  const { state } = useCharacterSheet();
  
  return useMemo(() => {
    if (!state.character) return null;
    
    // Get manual overrides from UI state
    const manualOverrides = state.character.characterState?.ui?.manualDefenseOverrides || {};
    
    // Get calculated base values (these would come from character calculation)
    const baseDefenses = {
      PD: state.character.finalPD || 0,
      AD: state.character.finalAD || 0,
      PDR: state.character.finalPDR || 0,
    };
    
    // Return effective values (manual override takes precedence)
    return {
      PD: manualOverrides.PD ?? baseDefenses.PD,
      AD: manualOverrides.AD ?? baseDefenses.AD,
      PDR: manualOverrides.PDR ?? baseDefenses.PDR,
      manualOverrides,
    };
  }, [state.character]);
}

export function useCharacterAttacks() {
  const { state } = useCharacterSheet();
  
  return useMemo(() => {
    return state.character?.characterState?.attacks || [];
  }, [state.character?.characterState?.attacks]);
}

export function useCharacterInventory() {
  const { state } = useCharacterSheet();
  
  return useMemo(() => {
    return state.character?.characterState?.inventory || { items: [], currency: { gold: 0, silver: 0, copper: 0 } };
  }, [state.character?.characterState?.inventory]);
}

export function useCharacterSpells() {
  const { state } = useCharacterSheet();
  return useMemo(() => {
    return state.character?.spells || [];
  }, [state.character?.spells]);
}

export function useCharacterManeuvers() {
  const { state } = useCharacterSheet();
  return useMemo(() => {
    return state.character?.maneuvers || [];
  }, [state.character?.maneuvers]);
}

export function useCharacterFeatures() {
  const { state } = useCharacterSheet();
  return useMemo(() => {
    return state.character?.features || [];
  }, [state.character?.features]);
}

export function useCharacterCurrency() {
  const { state } = useCharacterSheet();
  return useMemo(() => {
    return state.character?.characterState?.inventory?.currency || { gold: 0, silver: 0, copper: 0 };
  }, [state.character?.characterState?.inventory?.currency]);
}
```

## File: src/routes/character-sheet/hooks/useCharacterSheetReducer.ts
```typescript
import { useReducer, useCallback } from 'react';
import type { SavedCharacter } from '../../../lib/types/dataContracts';
import type { Attack } from '../../../lib/types/dataContracts';

// Sheet state - wraps the SavedCharacter
export interface SheetState {
  character: SavedCharacter | null;
  loading: boolean;
  error: string | null;
}

// All possible actions for character sheet editing
export type SheetAction =
  | { type: 'LOAD_START' }
  | { type: 'LOAD_SUCCESS'; character: SavedCharacter }
  | { type: 'LOAD_ERROR'; error: string }
  | { type: 'UPDATE_CURRENT_HP'; hp: number }
  | { type: 'UPDATE_CURRENT_SP'; sp: number }
  | { type: 'UPDATE_CURRENT_MP'; mp: number }
  | { type: 'UPDATE_TEMP_HP'; tempHP: number }
  | { type: 'UPDATE_EXHAUSTION'; level: number }
  | { type: 'UPDATE_ACTION_POINTS_USED'; ap: number }
  | { type: 'SET_MANUAL_DEFENSE'; pd?: number; ad?: number; pdr?: number }
  | { type: 'ADD_ATTACK'; attack: Attack }
  | { type: 'REMOVE_ATTACK'; attackId: string }
  | { type: 'UPDATE_ATTACK'; attackId: string; attack: Attack }
  | { type: 'ADD_SPELL'; spell: any }
  | { type: 'REMOVE_SPELL'; spellId: string }
  | { type: 'UPDATE_SPELL'; spellId: string; field: string; value: any }
  | { type: 'ADD_MANEUVER'; maneuver: any }
  | { type: 'REMOVE_MANEUVER'; maneuverId: string }
  | { type: 'UPDATE_INVENTORY'; items: any[] }
  | { type: 'UPDATE_CURRENCY'; gold?: number; silver?: number; copper?: number }
  | { type: 'UPDATE_NOTES'; notes: string };

const initialState: SheetState = {
  character: null,
  loading: false,
  error: null,
};

// Reducer function
function characterSheetReducer(state: SheetState, action: SheetAction): SheetState {
  switch (action.type) {
    case 'LOAD_START':
      return { ...state, loading: true, error: null };
    
    case 'LOAD_SUCCESS':
      return { ...state, character: action.character, loading: false, error: null };
    
    case 'LOAD_ERROR':
      return { ...state, loading: false, error: action.error };

    case 'UPDATE_CURRENT_HP':
      if (!state.character) return state;
      return {
        ...state,
        character: {
          ...state.character,
          characterState: {
            ...state.character.characterState,
            resources: {
              ...state.character.characterState.resources,
              current: {
                ...state.character.characterState.resources.current,
                currentHP: action.hp
              }
            }
          }
        }
      };

    case 'UPDATE_CURRENT_SP':
      if (!state.character) return state;
      return {
        ...state,
        character: {
          ...state.character,
          characterState: {
            ...state.character.characterState,
            resources: {
              ...state.character.characterState.resources,
              current: {
                ...state.character.characterState.resources.current,
                currentSP: action.sp
              }
            }
          }
        }
      };

    case 'UPDATE_CURRENT_MP':
      if (!state.character) return state;
      return {
        ...state,
        character: {
          ...state.character,
          characterState: {
            ...state.character.characterState,
            resources: {
              ...state.character.characterState.resources,
              current: {
                ...state.character.characterState.resources.current,
                currentMP: action.mp
              }
            }
          }
        }
      };

    case 'UPDATE_TEMP_HP':
      if (!state.character) return state;
      return {
        ...state,
        character: {
          ...state.character,
          characterState: {
            ...state.character.characterState,
            resources: {
              ...state.character.characterState.resources,
              current: {
                ...state.character.characterState.resources.current,
                tempHP: action.tempHP
              }
            }
          }
        }
      };

    case 'UPDATE_EXHAUSTION':
      if (!state.character) return state;
      return {
        ...state,
        character: {
          ...state.character,
          characterState: {
            ...state.character.characterState,
            resources: {
              ...state.character.characterState.resources,
              current: {
                ...state.character.characterState.resources.current,
                exhaustionLevel: action.level
              }
            }
          }
        }
      };

    case 'UPDATE_ACTION_POINTS_USED':
      if (!state.character) return state;
      return {
        ...state,
        character: {
          ...state.character,
          characterState: {
            ...state.character.characterState,
            resources: {
              ...state.character.characterState.resources,
              current: {
                ...state.character.characterState.resources.current,
                actionPointsUsed: action.ap
              }
            }
          }
        }
      };

    case 'SET_MANUAL_DEFENSE':
      if (!state.character) return state;
      return {
        ...state,
        character: {
          ...state.character,
          characterState: {
            ...state.character.characterState,
            ui: {
              ...state.character.characterState.ui,
              manualDefenseOverrides: {
                ...state.character.characterState.ui.manualDefenseOverrides,
                ...(action.pd !== undefined && { PD: action.pd }),
                ...(action.ad !== undefined && { AD: action.ad }),
                ...(action.pdr !== undefined && { PDR: action.pdr })
              }
            }
          }
        }
      };

    case 'ADD_ATTACK':
      if (!state.character) return state;
      const currentAttacks = state.character.characterState.attacks || [];
      return {
        ...state,
        character: {
          ...state.character,
          characterState: {
            ...state.character.characterState,
            attacks: [...currentAttacks, action.attack]
          }
        }
      };

    case 'REMOVE_ATTACK':
      if (!state.character) return state;
      return {
        ...state,
        character: {
          ...state.character,
          characterState: {
            ...state.character.characterState,
            attacks: (state.character.characterState.attacks || []).filter(
              attack => attack.id !== action.attackId
            )
          }
        }
      };

    case 'UPDATE_ATTACK':
      if (!state.character) return state;
      return {
        ...state,
        character: {
          ...state.character,
          characterState: {
            ...state.character.characterState,
            attacks: (state.character.characterState.attacks || []).map(
              attack => attack.id === action.attackId ? action.attack : attack
            )
          }
        }
      };

    case 'ADD_SPELL':
      if (!state.character) return state;
      return {
        ...state,
        character: {
          ...state.character,
          spells: [...(state.character.spells || []), action.spell]
        }
      };

    case 'REMOVE_SPELL':
      if (!state.character) return state;
      return {
        ...state,
        character: {
          ...state.character,
          spells: (state.character.spells || []).filter((s: any) => s.id !== action.spellId)
        }
      };

    case 'UPDATE_SPELL':
      if (!state.character) return state;
      return {
        ...state,
        character: {
          ...state.character,
          spells: (state.character.spells || []).map((s: any) => 
            s.id === action.spellId ? { ...s, [action.field]: action.value } : s
          )
        }
      };

    case 'ADD_MANEUVER':
      if (!state.character) return state;
      return {
        ...state,
        character: {
          ...state.character,
          maneuvers: [...(state.character.maneuvers || []), action.maneuver]
        }
      };

    case 'REMOVE_MANEUVER':
      if (!state.character) return state;
      return {
        ...state,
        character: {
          ...state.character,
          maneuvers: (state.character.maneuvers || []).filter((m: any) => m.id !== action.maneuverId)
        }
      };

    case 'UPDATE_CURRENCY':
      if (!state.character) return state;
      return {
        ...state,
        character: {
          ...state.character,
          characterState: {
            ...state.character.characterState,
            inventory: {
              ...state.character.characterState.inventory,
              currency: {
                ...state.character.characterState.inventory.currency,
                ...(action.gold !== undefined && { gold: action.gold }),
                ...(action.silver !== undefined && { silver: action.silver }),
                ...(action.copper !== undefined && { copper: action.copper })
              }
            }
          }
        }
      };

    case 'UPDATE_INVENTORY':
      if (!state.character) return state;
      return {
        ...state,
        character: {
          ...state.character,
          characterState: {
            ...state.character.characterState,
            inventory: {
              ...state.character.characterState.inventory,
              items: action.items
            }
          }
        }
      };

    case 'UPDATE_NOTES':
      if (!state.character) return state;
      return {
        ...state,
        character: {
          ...state.character,
          characterState: {
            ...state.character.characterState,
            notes: {
              ...state.character.characterState.notes,
              playerNotes: action.notes
            }
          }
        }
      };

    default:
      return state;
  }
}

// Custom hook that exports the reducer
export function useCharacterSheetReducer() {
  const [state, dispatch] = useReducer(characterSheetReducer, initialState);

  // Helper functions for common operations
  const updateHP = useCallback((hp: number) => {
    dispatch({ type: 'UPDATE_CURRENT_HP', hp });
  }, []);

  const updateSP = useCallback((sp: number) => {
    dispatch({ type: 'UPDATE_CURRENT_SP', sp });
  }, []);

  const updateMP = useCallback((mp: number) => {
    dispatch({ type: 'UPDATE_CURRENT_MP', mp });
  }, []);

  const updateTempHP = useCallback((tempHP: number) => {
    dispatch({ type: 'UPDATE_TEMP_HP', tempHP });
  }, []);

  const updateActionPoints = useCallback((ap: number) => {
    dispatch({ type: 'UPDATE_ACTION_POINTS_USED', ap });
  }, []);

  const updateExhaustion = useCallback((level: number) => {
    dispatch({ type: 'UPDATE_EXHAUSTION', level });
  }, []);

  const setManualDefense = useCallback((pd?: number, ad?: number, pdr?: number) => {
    dispatch({ type: 'SET_MANUAL_DEFENSE', pd, ad, pdr });
  }, []);

  const addAttack = useCallback((attack: Attack) => {
    dispatch({ type: 'ADD_ATTACK', attack });
  }, []);

  const removeAttack = useCallback((attackId: string) => {
    dispatch({ type: 'REMOVE_ATTACK', attackId });
  }, []);

  const updateAttack = useCallback((attackId: string, attack: Attack) => {
    dispatch({ type: 'UPDATE_ATTACK', attackId, attack });
  }, []);

  const addSpell = useCallback((spell: any) => {
    dispatch({ type: 'ADD_SPELL', spell });
  }, []);

  const removeSpell = useCallback((spellId: string) => {
    dispatch({ type: 'REMOVE_SPELL', spellId });
  }, []);

  const updateSpell = useCallback((spellId: string, field: string, value: any) => {
    dispatch({ type: 'UPDATE_SPELL', spellId, field, value });
  }, []);

  const addManeuver = useCallback((maneuver: any) => {
    dispatch({ type: 'ADD_MANEUVER', maneuver });
  }, []);

  const removeManeuver = useCallback((maneuverId: string) => {
    dispatch({ type: 'REMOVE_MANEUVER', maneuverId });
  }, []);

  const updateInventory = useCallback((items: any[]) => {
    dispatch({ type: 'UPDATE_INVENTORY', items });
  }, []);

  const updateCurrency = useCallback((gold?: number, silver?: number, copper?: number) => {
    dispatch({ type: 'UPDATE_CURRENCY', gold, silver, copper });
  }, []);

  const updateNotes = useCallback((notes: string) => {
    dispatch({ type: 'UPDATE_NOTES', notes });
  }, []);

  return {
    state,
    dispatch,
    // Helper functions
    updateHP,
    updateSP,
    updateMP,
    updateTempHP,
    updateActionPoints,
    updateExhaustion,
    setManualDefense,
    addAttack,
    removeAttack,
    updateAttack,
    addSpell,
    removeSpell,
    updateSpell,
    addManeuver,
    removeManeuver,
    updateInventory,
    updateCurrency,
    updateNotes,
  };
}
```

## File: src/types/character.ts
```typescript
// Character Sheet Types and Interfaces

import type { EnhancedStatBreakdown } from '../lib/types/effectSystem';

export interface CharacterSheetProps {
	characterId: string;
	onBack: () => void;
}

// Import ManeuverData type
export interface ManeuverData {
	id: string;
	name: string;
	type?: string;
	description?: string;
	cost?: {
		ap: number;
		mp?: number;
	};
	isReaction?: boolean;
	notes?: string;
}

export interface CharacterSheetData {
	// Basic Info
	id: string;
	finalName: string;
	finalPlayerName?: string;
	finalLevel: number;

	// Attributes
	finalMight: number;
	finalAgility: number;
	finalCharisma: number;
	finalIntelligence: number;

	// Calculated Stats
	finalPrimeModifierValue: number;
	finalPrimeModifierAttribute: string;
	finalCombatMastery: number;

	// Saves (Attribute + Combat Mastery)
	finalSaveMight: number;
	finalSaveAgility: number;
	finalSaveCharisma: number;
	finalSaveIntelligence: number;

	// Health & Resources
	finalHPMax: number;
	finalSPMax: number;
	finalMPMax: number;

	// Defenses
	finalPD: number; // Precision Defense
	finalAD: number; // Area Defense

	// Manual Defense Overrides (optional)
	manualPD?: number;
	manualAD?: number;
	manualPDR?: number;

	// PDR (Precision Damage Reduction)
	finalPDR: number;

	// Other Stats
	finalSaveDC: number;
	finalDeathThreshold: number;
	finalMoveSpeed: number;
	finalJumpDistance: number;
	finalRestPoints: number;
	finalGritPoints: number;
	finalInitiativeBonus: number;

	// Class & Ancestry Info
	className: string;
	ancestry1Name?: string;
	ancestry2Name?: string;

	// JSON data fields
	skillsJson?: string;
	tradesJson?: string;
	languagesJson?: string;
	selectedTraitIds?: string; // JSON string of selected trait IDs
	selectedFeatureChoices?: string; // JSON string of selected feature choices

	// Current values (optional, may not exist on first load)
	currentHP?: number;
	currentSP?: number;
	currentMP?: number;
	currentGritPoints?: number;
	currentRestPoints?: number;
	tempHP?: number;
	actionPointsUsed?: number;
	exhaustionLevel?: number;

	// Spells and Maneuvers
	spells?: SpellData[];
	maneuvers?: ManeuverData[];
}

export interface SkillData {
	id: string;
	name: string;
	attribute: string;
	proficiency: number; // 0-5
	bonus?: number; // Calculated bonus: Attribute + Mastery*2
}

export interface TradeData {
	id: string;
	name: string;
	proficiency: number; // 0-5
	bonus?: number; // Calculated bonus: Attribute + Mastery*2
}

export interface LanguageData {
	id: string;
	name: string;
	fluency: 'limited' | 'fluent';
}

export interface FeatureData {
	id: string;
	name: string;
	description: string;
	source: 'ancestry' | 'class' | 'choice';
	sourceDetail?: string; // e.g., "Human (Default)", "Barbarian Lvl 1", etc.
}

export interface CurrentValues {
	currentHP: number;
	currentSP: number;
	currentMP: number;
	currentGritPoints: number;
	currentRestPoints: number;
	tempHP: number;
	actionPointsUsed: number;
	exhaustionLevel: number; // 0-5
	// Currency
	goldPieces: number;
	silverPieces: number;
	copperPieces: number;
	electrumPieces: number;
	platinumPieces: number;
}

// Comprehensive character state that includes both original (calculated) and current (modified) values
export interface CharacterState {
	// Core resource values
	resources: {
		original: {
			maxHP: number;
			maxSP: number;
			maxMP: number;
			maxGritPoints: number;
			maxRestPoints: number;
		};
		current: {
			currentHP: number;
			currentSP: number;
			currentMP: number;
			currentGritPoints: number;
			currentRestPoints: number;
			tempHP: number;
			actionPointsUsed: number;
			exhaustionLevel: number;
		};
	};

	// Currency with original and current values
	currency: {
		original: {
			goldPieces: number;
			silverPieces: number;
			copperPieces: number;
			electrumPieces: number;
			platinumPieces: number;
		};
		current: {
			goldPieces: number;
			silverPieces: number;
			copperPieces: number;
			electrumPieces: number;
			platinumPieces: number;
		};
	};

	// Attacks - original is calculated from character build, current is user-modified
	attacks: {
		original: AttackData[];
		current: AttackData[];
	};

	// Spells - original is empty/default, current is user-selected
	spells: {
		original: SpellData[];
		current: SpellData[];
	};

	// Maneuvers - original is empty/default, current is user-selected
	maneuvers: {
		original: ManeuverData[];
		current: ManeuverData[];
	};

	// Inventory - original is empty/default, current is user-modified
	inventory: {
		original: InventoryItemData[];
		current: InventoryItemData[];
	};

	// Defense notes (already integrated)
	defenseNotes?: {
		manualPD?: { value: number; reason: string; timestamp: string };
		manualPDR?: { value: number; reason: string; timestamp: string };
		manualAD?: { value: number; reason: string; timestamp: string };
	};

	// Centralized manual defense overrides (authoritative values)
	manualDefenses?: {
		manualPD?: number;
		manualPDR?: number;
		manualAD?: number;
	};

	// Persisted calculation breakdowns for drill-down tooltips
	calculation?: {
		breakdowns: Record<string, EnhancedStatBreakdown>;
	};
}

export interface AttackData {
	id: string;
	weaponName: string; // Changed from weaponId to weaponName to match inventory system
	name: string;
	attackBonus: number;
	damage: string;
	damageType: string;
	critRange: string;
	critDamage: string;
	brutalDamage: string;
	heavyHitEffect: string;
}

export interface SpellData {
	id: string;
	spellName: string;
	school: string;
	isCantrip: boolean;
	cost: {
		ap: number;
		mp?: number;
	};
	range: string;
	duration: string;
	isPrepared?: boolean;
	notes?: string;
}

export interface InventoryItemData {
	id: string;
	itemType: 'Weapon' | 'Armor' | 'Shield' | 'Adventuring Supply' | 'Potion' | '';
	itemName: string;
	count: number;
	cost?: string;
}
```

## File: src/routes/character-creation/Background.tsx
```typescript
import React from 'react';
import { useCharacter } from '../../lib/stores/characterContext';
import { useBackgroundPoints } from './components/BackgroundPointsManager';
import { findClassByName } from '../../lib/rulesdata/loaders/class-features.loader';
import { classesData } from '../../lib/rulesdata/loaders/class.loader';
import SkillsTab from './components/SkillsTab';
import TradesTab from './components/TradesTab';
import LanguagesTab from './components/LanguagesTab';
import {
	StyledContainer,
	StyledSubheading,
	StyledDescription,
	StyledTabContainer,
	StyledTab
} from './styles/Background.styles.ts';

type TabType = 'skills' | 'trades' | 'languages';

const Background: React.FC = () => {
	const { state, dispatch } = useCharacter();
	const [activeTab, setActiveTab] = React.useState<TabType>('skills');

	// NEW: Use typed data instead of JSON parsing
	const currentSkills = state.skillsData || {};
	const currentTrades = state.tradesData || {};
	const currentLanguages = state.languagesData || { common: { fluency: 'fluent' } };

	// Calculate points used
	const skillPointsUsed = Object.values(currentSkills).reduce(
		(sum: number, level: any) => sum + level,
		0
	);
	const tradePointsUsed = Object.values(currentTrades).reduce(
		(sum: number, level: any) => sum + level,
		0
	);
	const languagePointsUsed = Object.entries(currentLanguages).reduce(
		(sum, [langId, data]: [string, any]) => {
			if (langId === 'common') return sum; // Common is free
			return sum + (data.fluency === 'limited' ? 1 : data.fluency === 'fluent' ? 2 : 0);
		},
		0
	);

	// Get class features for mastery calculations
	const classData = state.classId ? classesData.find(c => c.id.toLowerCase() === state.classId.toLowerCase()) : null;
	const classFeatures = classData ? findClassByName(classData.name) : null;

	// Use the background points manager hook
  const { pointsData, conversions, actions, masteryLimits } = useBackgroundPoints(
		skillPointsUsed,
		tradePointsUsed,
		languagePointsUsed,
		state.attribute_intelligence,
		state.level,
		classFeatures,
		state.selectedFeatureChoices,
		currentSkills,
		currentTrades,
		state.selectedTraitIds,
		state
	);

	// Persist conversions into context so validation sees the effective available points
	React.useEffect(() => {
		dispatch({
			type: 'SET_CONVERSIONS',
			conversions: {
				skillToTrade: conversions.skillToTradeConversions,
				tradeToSkill: conversions.tradeToSkillConversions,
				tradeToLanguage: conversions.tradeToLanguageConversions
			}
		});
	}, [conversions.skillToTradeConversions, conversions.tradeToSkillConversions, conversions.tradeToLanguageConversions, dispatch]);

	// Handler functions
	const handleSkillChange = (skillId: string, newLevel: number) => {
		const updatedSkills = { ...currentSkills };
		if (newLevel === 0) {
			delete updatedSkills[skillId];
		} else {
			updatedSkills[skillId] = newLevel;
		}

		dispatch({
			type: 'UPDATE_SKILLS',
			skillsData: updatedSkills
		});
	};

	const handleTradeChange = (tradeId: string, newLevel: number) => {
		const updatedTrades = { ...currentTrades };
		if (newLevel === 0) {
			delete updatedTrades[tradeId];
		} else {
			updatedTrades[tradeId] = newLevel;
		}

		dispatch({
			type: 'UPDATE_TRADES',
			tradesData: updatedTrades
		});
	};

	const handleLanguageChange = (languageId: string, fluency: 'limited' | 'fluent' | null) => {
		const updatedLanguages = { ...currentLanguages };
		if (fluency === null) {
			delete updatedLanguages[languageId];
		} else {
			updatedLanguages[languageId] = { fluency };
		}

		dispatch({
			type: 'UPDATE_LANGUAGES',
			languagesData: updatedLanguages
		});
	};

	const renderCurrentTab = () => {
		switch (activeTab) {
			case 'skills':
				return (
					<SkillsTab
						currentSkills={currentSkills}
						currentTrades={currentTrades}
						pointsData={pointsData}
						conversions={conversions}
						actions={actions}
						masteryLimits={masteryLimits}
						onSkillChange={handleSkillChange}
					/>
				);
			case 'trades':
				return (
					<TradesTab
						currentTrades={currentTrades}
						currentSkills={currentSkills}
						pointsData={pointsData}
						conversions={conversions}
						actions={actions}
						masteryLimits={masteryLimits}
						onTradeChange={handleTradeChange}
					/>
				);
			case 'languages':
				return (
					<LanguagesTab
						currentLanguages={currentLanguages}
						pointsData={pointsData}
						conversions={conversions}
						actions={actions}
						onLanguageChange={handleLanguageChange}
					/>
				);
			default:
				return null;
		}
	};

	return (
		<StyledContainer>
			<StyledSubheading>Background (Skills, Trades & Languages)</StyledSubheading>
			<StyledDescription>
				Choose your character's background skills, trades, and languages. You have{' '}
				<span style={{ fontWeight: 'bold', color: '#3b82f6' }}>{pointsData.baseSkillPoints}</span>{' '}
				skill points{' '}
				<span style={{ fontSize: '0.9rem', color: '#6b7280' }}>
					(5 base + {state.attribute_intelligence} Int{pointsData.baseSkillPoints - 5 - state.attribute_intelligence > 0 ? ` + ${pointsData.baseSkillPoints - 5 - state.attribute_intelligence} bonus` : ''})
				</span>,{' '}
				<span style={{ fontWeight: 'bold', color: '#3b82f6' }}>{pointsData.baseTradePoints}</span>{' '}
				trade points{pointsData.baseTradePoints > 3 ? <span style={{ fontSize: '0.9rem', color: '#6b7280' }}> (3 base + {pointsData.baseTradePoints - 3} bonus)</span> : ''}, and{' '}
				<span style={{ fontWeight: 'bold', color: '#3b82f6' }}>
					{pointsData.baseLanguagePoints}
				</span>{' '}
				language points{pointsData.baseLanguagePoints > 2 ? <span style={{ fontSize: '0.9rem', color: '#6b7280' }}> (2 base + {pointsData.baseLanguagePoints - 2} bonus)</span> : ''}. <br />
				<span
					style={{
						marginTop: '0.5rem',
						display: 'inline-block',
						padding: '0.25rem 0.5rem',
						backgroundColor: '#f3f4f6',
						borderRadius: '4px',
						fontSize: '0.9rem',
						color: '#374151'
					}}
				>
					💡 Conversions: 1 skill ↔ 2 trade • 1 trade → 2 language
				</span>
				<br />
				All characters start fluent in Common for free.
			</StyledDescription>

			<StyledTabContainer>
				<StyledTab $active={activeTab === 'skills'} onClick={() => setActiveTab('skills')}>
					Skills ({pointsData.availableSkillPoints - pointsData.skillPointsUsed} left)
				</StyledTab>
				<StyledTab $active={activeTab === 'trades'} onClick={() => setActiveTab('trades')}>
					Trades ({pointsData.availableTradePoints - pointsData.tradePointsUsed} left)
				</StyledTab>
				<StyledTab $active={activeTab === 'languages'} onClick={() => setActiveTab('languages')}>
					Languages ({pointsData.availableLanguagePoints - pointsData.languagePointsUsed} left)
				</StyledTab>
			</StyledTabContainer>

			{renderCurrentTab()}
		</StyledContainer>
	);
};

export default Background;
```

## File: src/routes/character-creation/SelectedAncestries.tsx
```typescript
import { useCharacter } from '../../lib/stores/characterContext';
import { ancestriesData } from '../../lib/rulesdata/ancestries';
import { traitsData } from '../../lib/rulesdata/_new_schema/traits';
import TraitChoiceSelector from './components/TraitChoiceSelector';
import type { IAncestry, ITrait, ITraitEffect } from '../../lib/rulesdata/types';
import {
	StyledOuterContainer,
	StyledMainTitle,
	StyledContainer,
	StyledAncestryDetails,
	StyledTitle,
	StyledSubtitle,
	StyledList,
	StyledListItem,
	StyledLabel,
	StyledCheckbox
} from './styles/SelectedAncestries.styles';

function SelectedAncestries() {
	const { state, dispatch, ancestryPointsRemaining, ancestryPointsSpent, totalAncestryPoints } = useCharacter();

	const selectedAncestry1 = ancestriesData.find((a) => a.id === state.ancestry1Id);
	const selectedAncestry2 = ancestriesData.find((a) => a.id === state.ancestry2Id);
	// NEW: Use typed data instead of JSON parsing
	const selectedTraits: string[] = state.selectedTraitIds || [];

	function getTrait(traitId: string): ITrait | undefined {
		return traitsData.find((t) => t.id === traitId);
	}

	function handleToggleTrait(traitId: string) {
		const trait = getTrait(traitId);
		if (!trait) return;

		let currentTraits = [...selectedTraits];
		const isCurrentlySelected = currentTraits.includes(traitId);

		if (isCurrentlySelected) {
			// Deselect - always allowed
			currentTraits = currentTraits.filter((id) => id !== traitId);
		} else {
			// Select - check if we have enough points
			const newPointsSpent = ancestryPointsSpent + trait.cost;
			if (newPointsSpent > totalAncestryPoints) {
				// Would exceed budget, don't allow selection
				return;
			}
			currentTraits.push(traitId);
		}

		dispatch({ type: 'SET_TRAITS', selectedTraitIds: currentTraits });
	}

	function renderAncestryTraits(ancestry: IAncestry) {
		return (
			<StyledAncestryDetails>
				<StyledTitle>{ancestry.name}</StyledTitle>

				<StyledSubtitle>Default Traits</StyledSubtitle>
				<StyledList>
					{(ancestry.defaultTraitIds || []).map((traitId) => {
						const trait = getTrait(traitId);
						if (!trait) return null;
						const isSelected = selectedTraits.includes(traitId);
						const wouldExceedBudget = !isSelected && ancestryPointsSpent + trait.cost > totalAncestryPoints;

						return (
							<StyledListItem key={traitId}>
								<StyledLabel style={{ opacity: wouldExceedBudget ? 0.5 : 1 }}>
									<StyledCheckbox
										type="checkbox"
										checked={isSelected}
										disabled={wouldExceedBudget}
										onChange={() => handleToggleTrait(traitId)}
									/>
									{trait.name} ({trait.cost} pts) - {trait.description}
									{wouldExceedBudget && (
										<span style={{ color: '#ff4444' }}> (Not enough points)</span>
									)}
								</StyledLabel>
								
								{/* NEW: Render choice selectors if trait is selected and has user choices */}
								{isSelected && trait.effects?.map((effect: ITraitEffect, effectIndex: number) => {
									if (effect.userChoiceRequired) {
										return (
											<TraitChoiceSelector
												key={`${traitId}-${effectIndex}`}
												trait={trait}
												effect={effect}
												effectIndex={effectIndex}
											/>
										);
									}
									return null;
								})}
							</StyledListItem>
						);
					})}
				</StyledList>

				<StyledSubtitle>Expanded Traits</StyledSubtitle>
				<StyledList>
					{(ancestry.expandedTraitIds || []).map((traitId) => {
						const trait = getTrait(traitId);
						if (!trait) return null;
						const isSelected = selectedTraits.includes(traitId);
						const wouldExceedBudget = !isSelected && ancestryPointsSpent + trait.cost > totalAncestryPoints;

						return (
							<StyledListItem key={traitId}>
								<StyledLabel style={{ opacity: wouldExceedBudget ? 0.5 : 1 }}>
									<StyledCheckbox
										type="checkbox"
										checked={isSelected}
										disabled={wouldExceedBudget}
										onChange={() => handleToggleTrait(traitId)}
									/>
									{trait.name} ({trait.cost} pts) - {trait.description}
									{wouldExceedBudget && (
										<span style={{ color: '#ff4444' }}> (Not enough points)</span>
									)}
								</StyledLabel>
								
								{/* NEW: Render choice selectors if trait is selected and has user choices */}
								{isSelected && trait.effects?.map((effect: ITraitEffect, effectIndex: number) => {
									if (effect.userChoiceRequired) {
										return (
											<TraitChoiceSelector
												key={`${traitId}-${effectIndex}`}
												trait={trait}
												effect={effect}
												effectIndex={effectIndex}
											/>
										);
									}
									return null;
								})}
							</StyledListItem>
						);
					})}
				</StyledList>
			</StyledAncestryDetails>
		);
	}

	return (
		<StyledOuterContainer>
			<StyledMainTitle>
				Ancestry Traits
				<div
					style={{
						fontSize: '0.9rem',
						fontWeight: 'normal',
						marginTop: '0.5rem',
						color: ancestryPointsRemaining < 0 ? '#ff4444' : '#d1d5db'
					}}
				>
					Spent: {ancestryPointsSpent} | Remaining: {ancestryPointsRemaining}/
					{ancestryPointsSpent + ancestryPointsRemaining}
					{ancestryPointsRemaining < 0 && <span style={{ color: '#ff4444' }}> (Over budget!)</span>}
				</div>
			</StyledMainTitle>
			<StyledContainer>
				{selectedAncestry1 && renderAncestryTraits(selectedAncestry1)}
				{selectedAncestry2 && renderAncestryTraits(selectedAncestry2)}
			</StyledContainer>
		</StyledOuterContainer>
	);
}

export default SelectedAncestries;
```

## File: src/lib/services/characterCompletion.ts
```typescript
// Shared character completion service - UPDATED: Uses typed data contracts
// Handles the completion flow with proper stat calculation, snackbar, and navigation

import { assignSpellsToCharacter } from './spellAssignment';
import { allSpells } from '../rulesdata/spells-data/spells';
import { allManeuvers } from '../rulesdata/maneuvers';
import { convertToEnhancedBuildData, calculateCharacterWithBreakdowns } from './enhancedCharacterCalculator';
import { getDefaultCharacterState } from '../utils/storageUtils';
import { getAllSavedCharacters, saveAllCharacters } from '../utils/storageUtils';
import type { SavedCharacter } from '../types/dataContracts';

export interface CharacterCompletionCallbacks {
	onShowSnackbar: (message: string) => void;
	onNavigateToLoad: () => void;
}

export const completeCharacter = async (
	characterState: any,
	callbacks: CharacterCompletionCallbacks
): Promise<void> => {
	try {
		// Build the enhanced data for calculation using native objects
		const enhancedData = convertToEnhancedBuildData({
			id: Date.now().toString(),
			attribute_might: characterState.attribute_might,
			attribute_agility: characterState.attribute_agility,
			attribute_charisma: characterState.attribute_charisma,
			attribute_intelligence: characterState.attribute_intelligence,
			level: characterState.level || 1,
			combatMastery: characterState.combatMastery || 1,
			classId: characterState.classId,
			ancestry1Id: characterState.ancestry1Id,
			ancestry2Id: characterState.ancestry2Id,
			selectedTraitIds: characterState.selectedTraitIds || [],
			selectedFeatureChoices: characterState.selectedFeatureChoices || {},
			finalName: characterState.finalName,
			finalPlayerName: characterState.finalPlayerName,
			skillsData: characterState.skillsData || {},
			tradesData: characterState.tradesData || {},
			languagesData: characterState.languagesData || { common: { fluency: 'fluent' } },
			createdAt: new Date(),
			completedAt: new Date().toISOString()
		});

		console.log('Calculating stats for character using enhanced calculator');

		// Run the enhanced calculator
		const calculationResult = calculateCharacterWithBreakdowns(enhancedData);

		// Create the final character with unified 'final*' schema
		const completedCharacter: SavedCharacter = {
			id: Date.now().toString(),
			finalName: characterState.finalName,
			finalPlayerName: characterState.finalPlayerName,
			level: characterState.level || 1,
			classId: characterState.classId,
			className: calculationResult.stats.className || 'Unknown',
			ancestry1Id: characterState.ancestry1Id,
			ancestry1Name: characterState.ancestry1Name || 'Human', // TODO: Get from ancestry data
			ancestry2Id: characterState.ancestry2Id,
			ancestry2Name: calculationResult.stats.ancestry2Name || null,
			
			// Map from calculation result to final* schema
			finalMight: calculationResult.stats.finalMight,
			finalAgility: calculationResult.stats.finalAgility,
			finalCharisma: calculationResult.stats.finalCharisma,
			finalIntelligence: calculationResult.stats.finalIntelligence,
			finalPrimeModifierValue: calculationResult.stats.finalPrimeModifierValue || 0,
			finalPrimeModifierAttribute: calculationResult.stats.finalPrimeModifierAttribute || 'might',
			finalCombatMastery: calculationResult.stats.finalCombatMastery || 1,
			finalSaveMight: calculationResult.stats.finalSaveMight,
			finalSaveAgility: calculationResult.stats.finalSaveAgility,
			finalSaveCharisma: calculationResult.stats.finalSaveCharisma,
			finalSaveIntelligence: calculationResult.stats.finalSaveIntelligence,
			finalHPMax: calculationResult.stats.finalHPMax,
			finalSPMax: calculationResult.stats.finalSPMax,
			finalMPMax: calculationResult.stats.finalMPMax,
			finalPD: calculationResult.stats.finalPD,
			finalAD: calculationResult.stats.finalAD,
			finalPDR: calculationResult.stats.finalPDR,
			finalSaveDC: calculationResult.stats.finalSaveDC,
			finalDeathThreshold: calculationResult.stats.finalDeathThreshold,
			finalMoveSpeed: calculationResult.stats.finalMoveSpeed,
			finalJumpDistance: calculationResult.stats.finalJumpDistance,
			finalRestPoints: calculationResult.stats.finalRestPoints,
			finalGritPoints: calculationResult.stats.finalGritPoints,
			finalInitiativeBonus: calculationResult.stats.finalInitiativeBonus,
			
			// Store typed data directly (no more JSON strings)
			selectedTraitIds: characterState.selectedTraitIds || [],
			selectedFeatureChoices: characterState.selectedFeatureChoices || {},
			skillsData: characterState.skillsData || {},
			tradesData: characterState.tradesData || {},
			languagesData: characterState.languagesData || [],
			spells: [], // Will be populated below
			maneuvers: [], // Will be populated below
			
			// Store calculation breakdowns for transparency
			breakdowns: calculationResult.breakdowns || {},
			
			// Initialize default character state
			characterState: getDefaultCharacterState(),
			
			// Metadata
			createdAt: new Date().toISOString(),
			lastModified: new Date().toISOString(),
			completedAt: new Date().toISOString(),
			schemaVersion: '2.0.0'
		};
		
		console.log('Character stats calculated:', completedCharacter);
		console.log('Class info saved:', {
			classId: completedCharacter.classId,
			className: completedCharacter.className
		});
		console.log('Ancestry info saved:', {
			ancestry1Id: completedCharacter.ancestry1Id,
			ancestry1Name: completedCharacter.ancestry1Name,
			ancestry2Id: completedCharacter.ancestry2Id,
			ancestry2Name: completedCharacter.ancestry2Name
		});

		// Process user-selected spells from character creation
		if (completedCharacter.className && characterState.selectedSpells) {
			console.log('🔄 Processing user-selected spells:', {
				selectedSpells: characterState.selectedSpells,
				className: completedCharacter.className
			});

			try {
							// Use typed arrays directly
			const selectedSpellNames = characterState.selectedSpells || [];
				
				console.log('🔄 Parsed spell names:', selectedSpellNames);

				if (Array.isArray(selectedSpellNames) && selectedSpellNames.length > 0) {
					// Convert selected spell names to SpellData objects
					const userSelectedSpells = selectedSpellNames.map((spellName: string) => {
						const fullSpell = allSpells.find(s => s.name === spellName);
						if (fullSpell) {
							return {
								id: `spell_${Date.now()}_${Math.random()}`,
								spellName: fullSpell.name,
								school: fullSpell.school,
								isCantrip: fullSpell.isCantrip,
								cost: fullSpell.cost,
								range: fullSpell.range,
								duration: fullSpell.duration,
								isPrepared: true,
								notes: ''
							};
						}
						return null;
					}).filter(Boolean);

					// Store typed spells data
					completedCharacter.spells = userSelectedSpells as any;
					console.log('🔄 User selected spells assigned:', userSelectedSpells.map((s: any) => s.spellName));
				} else {
					console.log('🔄 No user spells selected, falling back to auto-assignment');
					// Fallback to auto-assignment if no spells were selected
					const assignedSpells = assignSpellsToCharacter({
						className: completedCharacter.className,
						level: completedCharacter.level || 1,
						selectedFeatureChoices: completedCharacter.selectedFeatureChoices
					});
					completedCharacter.spells = assignedSpells as any;
					console.log('🔄 Auto-assigned spells (no user selection):', assignedSpells.map((s: any) => s.spellName));
				}
			} catch (e) {
				console.warn('🔄 Error parsing selected spells, falling back to auto-assignment:', e);
				// Fallback to auto-assignment
				const assignedSpells = assignSpellsToCharacter({
					className: completedCharacter.className,
					level: completedCharacter.level || 1,
					selectedFeatureChoices: completedCharacter.selectedFeatureChoices
				});
				completedCharacter.spells = assignedSpells as any;
			}
		}

		// Handle user-selected maneuvers
		if (characterState.selectedManeuvers) {
			try {
							// Use typed arrays directly
			const selectedManeuverNames = characterState.selectedManeuvers || [];
					
				if (Array.isArray(selectedManeuverNames) && selectedManeuverNames.length > 0) {
					// Convert selected maneuver names to ManeuverData objects
					const userSelectedManeuvers = selectedManeuverNames.map((maneuverName: string) => {
						const fullManeuver = allManeuvers.find(m => m.name === maneuverName);
						if (fullManeuver) {
							return {
								id: `maneuver_${Date.now()}_${Math.random()}`,
								name: fullManeuver.name,
								type: fullManeuver.type,
								cost: fullManeuver.cost,
								description: fullManeuver.description,
								isReaction: fullManeuver.isReaction,
								notes: ''
							};
						}
						return null;
					}).filter(Boolean);

					// Store typed maneuvers data
					completedCharacter.maneuvers = userSelectedManeuvers as any;
					console.log('🔄 User selected maneuvers assigned:', userSelectedManeuvers.map((m: any) => m.name));
				}
			} catch (e) {
				console.warn('🔄 Error parsing selected maneuvers:', e);
			}
		}

        // OPTIMIZED: Save using new typed storage utilities
        const existingCharacters = getAllSavedCharacters();
        existingCharacters.push(completedCharacter);
        saveAllCharacters(existingCharacters);
        
        console.log('🚀 OPTIMIZED: Character saved using typed contracts. Total characters:', existingCharacters.length);

		// Show success snackbar
		callbacks.onShowSnackbar('Character created successfully!');

		// Navigate to load characters page after a short delay
		setTimeout(() => {
			console.log('Navigating to character load page...');
			callbacks.onNavigateToLoad();
		}, 1500);

		console.log('🚀 Character completed with typed data contracts:', completedCharacter);
	} catch (error) {
		console.error('Error completing character:', error);
		callbacks.onShowSnackbar('Error creating character. Please try again.');
	}
};
```

## File: src/lib/services/enhancedCharacterCalculator.ts
```typescript
/**
 * Enhanced Character Calculator with Effect Attribution
 * 
 * This is the unified calculation engine that provides detailed breakdowns
 * for tooltips and real-time validation for the UI.
 */

import type { 
  EnhancedCalculationResult, 
  EnhancedCharacterBuildData, 
  AttributedEffect, 
  EffectSource, 
  EnhancedStatBreakdown,
  ValidationResult,
  AttributeLimit,
  UnresolvedChoice,
  ChoiceOption,
  EffectPreview,
  TraitChoiceStorage
} from '../types/effectSystem';

import { traitsData } from '../rulesdata/_new_schema/traits';
import { ancestriesData } from '../rulesdata/_new_schema/ancestries';
import { barbarianClass } from '../rulesdata/_new_schema/barbarian_features';
import { clericClass } from '../rulesdata/_new_schema/cleric_features';
import { hunterClass } from '../rulesdata/_new_schema/hunter_features';
import { championClass } from '../rulesdata/_new_schema/champion_features';
import { wizardClass } from '../rulesdata/_new_schema/wizard_features';
import { monkClass } from '../rulesdata/_new_schema/monk_features';
import { rogueClass } from '../rulesdata/_new_schema/rogue_features';
import { sorcererClass } from '../rulesdata/_new_schema/sorcerer_features';
import { spellbladeClass } from '../rulesdata/_new_schema/spellblade_features';
import { warlockClass } from '../rulesdata/_new_schema/warlock_features';
import { bardClass } from '../rulesdata/_new_schema/bard_features';
import { druidClass } from '../rulesdata/_new_schema/druid_features';
import { commanderClass } from '../rulesdata/_new_schema/commander_features';
import barbarianTable from '../rulesdata/_new_schema/barbarian_table.json';
import clericTable from '../rulesdata/_new_schema/cleric_table.json';
import hunterTable from '../rulesdata/_new_schema/hunter_table.json';
import championTable from '../rulesdata/_new_schema/champion_table.json';
import wizardTable from '../rulesdata/_new_schema/wizard_table.json';
import monkTable from '../rulesdata/_new_schema/monk_table.json';
import rogueTable from '../rulesdata/_new_schema/rogue_table.json';
import sorcererTable from '../rulesdata/_new_schema/sorcerer_table.json';
import spellbladeTable from '../rulesdata/_new_schema/spellblade_table.json';
import warlockTable from '../rulesdata/_new_schema/warlock_table.json';
import bardTable from '../rulesdata/_new_schema/bard_table.json';
import druidTable from '../rulesdata/_new_schema/druid_table.json';
import commanderTable from '../rulesdata/_new_schema/commander_table.json';
import { attributesData } from '../rulesdata/attributes';
import { skillsData } from '../rulesdata/skills';
import { tradesData } from '../rulesdata/trades';
import type { Effect, ClassDefinition } from '../rulesdata/schemas/character.schema';

/**
 * Safe JSON parse with fallback
 */
function safeJsonParse<T>(jsonString: string | undefined | null, fallback: T): T {
  if (!jsonString || typeof jsonString !== 'string') {
    return fallback;
  }
  
  try {
    const parsed = JSON.parse(jsonString);
    return parsed !== null && parsed !== undefined ? parsed : fallback;
  } catch (error) {
    console.warn('Failed to parse JSON:', jsonString, 'Error:', error);
    return fallback;
  }
}

/**
 * Convert character context data to enhanced build data
 */
export function convertToEnhancedBuildData(contextData: any): EnhancedCharacterBuildData {
  return {
    id: contextData.id || '',
    finalName: contextData.finalName || '',
    finalPlayerName: contextData.finalPlayerName,
    level: contextData.level || 1,
    
    attribute_might: contextData.attribute_might || 0,
    attribute_agility: contextData.attribute_agility || 0,
    attribute_charisma: contextData.attribute_charisma || 0,
    attribute_intelligence: contextData.attribute_intelligence || 0,
    
    combatMastery: contextData.combatMastery || 1,
    
    classId: contextData.classId || '',
    ancestry1Id: contextData.ancestry1Id,
    ancestry2Id: contextData.ancestry2Id,
    
    selectedTraitIds: safeJsonParse(contextData.selectedTraitIds, []),
    selectedTraitChoices: safeJsonParse(contextData.selectedTraitChoices, {}),
    featureChoices: safeJsonParse(contextData.selectedFeatureChoices, {}),
    
    skillsJson: contextData.skillsJson || '{}',
    tradesJson: contextData.tradesJson || '{}',
    languagesJson: contextData.languagesJson || '{"common": {"fluency": "fluent"}}',
    
    manualPD: contextData.manualPD,
    manualAD: contextData.manualAD,
    manualPDR: contextData.manualPDR,
    
    lastModified: Date.now()
  };
}

/**
 * Get class level progression data by ID
 */
function getClassProgressionData(classId: string): any | null {
  switch (classId) {
    case 'barbarian':
      return barbarianTable;
    case 'cleric':
      return clericTable;
    case 'hunter':
      return hunterTable;
    case 'champion':
      return championTable;
    case 'wizard':
      return wizardTable;
    case 'monk':
      return monkTable;
    case 'rogue':
      return rogueTable;
    case 'sorcerer':
      return sorcererTable;
    case 'spellblade':
      return spellbladeTable;
    case 'warlock':
      return warlockTable;
    case 'bard':
      return bardTable;
    case 'druid':
      return druidTable;
    case 'commander':
      return commanderTable;
    default:
      return null;
  }
}

/**
 * Get class features by ID (for abilities)
 */
function getClassFeatures(classId: string): ClassDefinition | null {
  switch (classId) {
    case 'barbarian':
      return barbarianClass;
    case 'cleric':
      return clericClass;
    case 'hunter':
      return hunterClass;
    case 'champion':
      return championClass;
    case 'wizard':
      return wizardClass;
    case 'monk':
      return monkClass;
    case 'rogue':
      return rogueClass;
    case 'sorcerer':
      return sorcererClass;
    case 'spellblade':
      return spellbladeClass;
    case 'warlock':
      return warlockClass;
    case 'bard':
      return bardClass;
    case 'druid':
      return druidClass;
    case 'commander':
      return commanderClass;
    default:
      return null;
  }
}

/**
 * Aggregate all effects with source attribution
 */
function aggregateAttributedEffects(buildData: EnhancedCharacterBuildData): AttributedEffect[] {
  const effects: AttributedEffect[] = [];
  
  // Add effects from ancestry default traits
  if (buildData.ancestry1Id) {
    const ancestry = ancestriesData.find(a => a.id === buildData.ancestry1Id);
    if (ancestry?.defaultTraitIds) {
      for (const traitId of ancestry.defaultTraitIds) {
        const trait = traitsData.find(t => t.id === traitId);
        if (trait?.effects) {
          for (const [effectIndex, effect] of trait.effects.entries()) {
            effects.push({
              ...effect,
              source: {
                type: 'ancestry_default',
                id: traitId,
                name: trait.name,
                description: trait.description,
                category: `${ancestry.name} (Default)`
              },
              resolved: !effect.userChoice,
              dependsOnChoice: effect.userChoice ? `${traitId}-${effectIndex}` : undefined
            });
          }
        }
      }
    }
  }
  
  // Add effects from selected traits
  for (const traitId of buildData.selectedTraitIds) {
    const trait = traitsData.find(t => t.id === traitId);
    if (trait?.effects) {
      for (const [effectIndex, effect] of trait.effects.entries()) {
        effects.push({
          ...effect,
          source: {
            type: 'trait',
            id: traitId,
            name: trait.name,
            description: trait.description,
            category: 'Selected Trait'
          },
          resolved: !effect.userChoice,
          dependsOnChoice: effect.userChoice ? `${traitId}-${effectIndex}` : undefined
        });
      }
    }
  }
  
  // Add effects from class features
  const classFeatures = getClassFeatures(buildData.classId);
  if (classFeatures) {
    for (const feature of classFeatures.coreFeatures) {
      // Direct feature effects
      if (feature.effects) {
        for (const effect of feature.effects) {
          effects.push({
            ...effect,
            source: {
              type: 'class_feature',
              id: feature.featureName,
              name: feature.featureName,
              description: feature.description,
              category: `${classFeatures.className} Level ${feature.levelGained}`
            },
            resolved: true
          });
        }
      }
      
      // Benefits within features
      if (feature.benefits) {
        for (const benefit of feature.benefits) {
          if (benefit.effects) {
            for (const effect of benefit.effects) {
              effects.push({
                ...effect,
                source: {
                  type: 'class_feature',
                  id: `${feature.featureName}_${benefit.name}`,
                  name: benefit.name,
                  description: benefit.description,
                  category: `${classFeatures.className} Level ${feature.levelGained}`
                },
                resolved: true
              });
            }
          }
        }
      }
      
      // Chosen options from feature choices
      if (feature.choices) {
        for (const choice of feature.choices) {
          const userChoice = buildData.featureChoices[choice.id];
          if (userChoice) {
            for (const option of choice.options) {
              if (userChoice === option.name || 
                  (Array.isArray(userChoice) && userChoice.includes(option.name))) {
                if (option.effects) {
                  for (const effect of option.effects) {
                    effects.push({
                      ...effect,
                      source: {
                        type: 'choice',
                        id: `${choice.id}_${option.name}`,
                        name: option.name,
                        description: option.description,
                        category: `${classFeatures.className} Choice`
                      },
                      resolved: true
                    });
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  return effects;
}

/**
 * Resolve user choices in effects
 */
function resolveEffectChoices(effects: AttributedEffect[], choices: TraitChoiceStorage): AttributedEffect[] {
  return effects.map(effect => {
    if (!effect.userChoice || !effect.dependsOnChoice) {
      return effect;
    }
    
    const chosenValue = choices[effect.dependsOnChoice];
    if (!chosenValue) {
      return effect; // Unresolved
    }
    
    // Resolve the choice
    let resolvedEffect = { ...effect };
    if (effect.target === 'any_attribute' && effect.type === 'MODIFY_ATTRIBUTE') {
      resolvedEffect.target = chosenValue;
      resolvedEffect.resolved = true;
      resolvedEffect.resolvedValue = chosenValue;
    } else if (effect.target === 'any_skill' && effect.type === 'GRANT_SKILL_EXPERTISE') {
      resolvedEffect.target = chosenValue;
      resolvedEffect.resolved = true;
      resolvedEffect.resolvedValue = chosenValue;
    } else if (effect.target === 'any_trade' && effect.type === 'GRANT_TRADE_EXPERTISE') {
      resolvedEffect.target = chosenValue;
      resolvedEffect.resolved = true;
      resolvedEffect.resolvedValue = chosenValue;
    }
    
    return resolvedEffect;
  });
}

/**
 * Create detailed stat breakdown
 */
function createStatBreakdown(
  statName: string, 
  baseValue: number, 
  effects: AttributedEffect[]
): EnhancedStatBreakdown {
  const relevantEffects = effects.filter(effect => {
    if (!effect.resolved) return false;
    
    // Map effect types to stat names
    if (effect.type === 'MODIFY_ATTRIBUTE') {
      return statName === `attribute_${effect.target}` || statName === effect.target;
    }
    if (effect.type === 'MODIFY_STAT') {
      return statName === effect.target;
    }
    
    return false;
  });
  
  const breakdown: EnhancedStatBreakdown = {
    statName,
    base: baseValue,
    effects: relevantEffects.map(effect => ({
      source: effect.source,
      value: effect.value as number,
      condition: effect.condition,
      description: `${effect.source.name}: ${effect.value > 0 ? '+' : ''}${effect.value}${effect.condition ? ` (${effect.condition})` : ''}`,
      isActive: !effect.condition // For now, assume conditional effects are not active
    })),
    total: baseValue + relevantEffects.reduce((sum, effect) => {
      if (!effect.condition) { // Only count non-conditional effects in total
        return sum + (effect.value as number);
      }
      return sum;
    }, 0)
  };
  
  // Calculate conditional total
  breakdown.conditionalTotal = baseValue + relevantEffects.reduce((sum, effect) => {
    return sum + (effect.value as number);
  }, 0);
  
  return breakdown;
}

/**
 * Validate attribute limits
 */
function validateAttributeLimits(buildData: EnhancedCharacterBuildData, effects: AttributedEffect[]): Record<string, AttributeLimit> {
  const limits: Record<string, AttributeLimit> = {};
  
  for (const attr of attributesData) {
    const baseValue = (buildData as any)[`attribute_${attr.id}`] || 0;
    const traitBonuses = effects
      .filter(effect => 
        effect.resolved && 
        effect.type === 'MODIFY_ATTRIBUTE' && 
        effect.target === attr.id
      )
      .reduce((sum, effect) => sum + (effect.value as number), 0);
    
    const current = baseValue + traitBonuses;
    const max = 3; // Level 1 limit
    
    limits[attr.id] = {
      current,
      base: baseValue,
      traitBonuses,
      max,
      exceeded: current > max,
      canIncrease: current < max,
      canDecrease: baseValue > -2
    };
  }
  
  return limits;
}

/**
 * Get unresolved choices for character creation UI
 */
function getUnresolvedChoices(effects: AttributedEffect[]): UnresolvedChoice[] {
  return effects
    .filter(effect => effect.userChoice && !effect.resolved)
    .map(effect => {
      const options = getOptionsForEffect(effect);
      
      return {
        traitId: effect.source.id,
        traitName: effect.source.name,
        effectIndex: 0, // Would need to track this properly
        effect,
        prompt: effect.userChoice!.prompt,
        options,
        isRequired: true
      };
    });
}

/**
 * Get choice options for an effect
 */
function getOptionsForEffect(effect: AttributedEffect): ChoiceOption[] {
  const baseOptions = effect.userChoice?.options || [];
  
  if (effect.type === 'MODIFY_ATTRIBUTE' && baseOptions.length === 0) {
    return attributesData.map(attr => ({
      value: attr.id,
      displayName: attr.name,
      description: attr.description,
      isValid: true // Would need proper validation
    }));
  }
  
  if (effect.type === 'GRANT_SKILL_EXPERTISE' && baseOptions.length === 0) {
    return skillsData.map(skill => ({
      value: skill.id,
      displayName: skill.name,
      description: skill.description,
      isValid: true
    }));
  }
  
  if (effect.type === 'GRANT_TRADE_EXPERTISE' && baseOptions.length === 0) {
    return tradesData.map(trade => ({
      value: trade.id,
      displayName: trade.name,
      description: trade.description,
      isValid: true
    }));
  }
  
  return baseOptions.map(option => ({
    value: option,
    displayName: option,
    isValid: true
  }));
}

/**
 * Main calculation function with detailed breakdowns
 */
export function calculateCharacterWithBreakdowns(
  buildData: EnhancedCharacterBuildData
): EnhancedCalculationResult {
  
  // 1. Aggregate all effects with source attribution
  const rawEffects = aggregateAttributedEffects(buildData);
  
  // 2. Resolve user choices
  const resolvedEffects = resolveEffectChoices(rawEffects, buildData.selectedTraitChoices);
  
  // 3. Calculate base stats
  const classProgressionData = getClassProgressionData(buildData.classId);
  const baseHP = 0; // Will calculate from level progression
  const baseSP = 0; // Will calculate from level progression  
  const baseMP = 0; // Will calculate from level progression
  
  // 4. Create detailed breakdowns
  const breakdowns: Record<string, EnhancedStatBreakdown> = {};
  
  // Attributes
  for (const attr of attributesData) {
    const baseValue = (buildData as any)[`attribute_${attr.id}`] || 0;
    breakdowns[`attribute_${attr.id}`] = createStatBreakdown(attr.id, baseValue, resolvedEffects);
  }
  
  // Calculate final attribute values
  const finalMight = breakdowns.attribute_might.total;
  const finalAgility = breakdowns.attribute_agility.total;
  const finalCharisma = breakdowns.attribute_charisma.total;
  const finalIntelligence = breakdowns.attribute_intelligence.total;
  
  // Derived stats
  const combatMastery = buildData.combatMastery;
  
  // Health & Resources - sum from level progression + modifiers
  let finalHPMax = finalMight; // Base from Might
  let finalSPMax = 0;
  let finalMPMax = 0;
  
  // Calculate from level progression if available
  if (classProgressionData?.levelProgression) {
    for (let level = 1; level <= buildData.level; level++) {
      const levelData = classProgressionData.levelProgression.find((lp: any) => lp.level === level);
      if (levelData) {
        finalHPMax += levelData.healthPoints || 0;
        finalSPMax += levelData.staminaPoints || 0;
        finalMPMax += levelData.manaPoints || 0;
      }
    }
  } else {
    // Fallback to base calculation
    finalHPMax += baseHP + (buildData.level - 1);
    finalSPMax = baseSP + finalAgility;
    finalMPMax = baseMP + finalIntelligence;
  }
  
  // Apply effect modifiers
  finalHPMax += resolvedEffects.filter(e => e.type === 'MODIFY_STAT' && e.target === 'hpMax').reduce((sum, e) => sum + (e.value as number), 0);
  finalSPMax += resolvedEffects.filter(e => e.type === 'MODIFY_STAT' && e.target === 'spMax').reduce((sum, e) => sum + (e.value as number), 0);
  finalMPMax += resolvedEffects.filter(e => e.type === 'MODIFY_STAT' && e.target === 'mpMax').reduce((sum, e) => sum + (e.value as number), 0);
  
  // Defenses with modifiers
  const basePD = 8 + combatMastery + finalAgility + finalIntelligence;
  const baseAD = 8 + combatMastery + finalMight + finalCharisma;
  const pdModifiers = resolvedEffects.filter(e => e.type === 'MODIFY_STAT' && e.target === 'pd').reduce((sum, e) => sum + (e.value as number), 0);
  const adModifiers = resolvedEffects.filter(e => e.type === 'MODIFY_STAT' && e.target === 'ad').reduce((sum, e) => sum + (e.value as number), 0);
  const finalPD = buildData.manualPD ?? (basePD + pdModifiers);
  const finalAD = buildData.manualAD ?? (baseAD + adModifiers);
  const finalPDR = buildData.manualPDR ?? 0;
  
  // Calculate prime attribute first
  const maxValue = Math.max(finalMight, finalAgility, finalCharisma, finalIntelligence);
  
  // Calculate other derived stats first
  const finalSaveDC = 8 + combatMastery + maxValue;
  const finalSaveMight = finalMight + combatMastery;
  const finalSaveAgility = finalAgility + combatMastery;
  const finalSaveCharisma = finalCharisma + combatMastery;
  const finalSaveIntelligence = finalIntelligence + combatMastery;
  const finalDeathThreshold = maxValue + combatMastery; // Prime + Combat Mastery (usually -4)
  const finalMoveSpeed = 5 + resolvedEffects.filter(e => e.type === 'MODIFY_STAT' && e.target === 'moveSpeed').reduce((sum, e) => sum + (e.value as number), 0);
  const finalJumpDistance = finalAgility + resolvedEffects.filter(effect => effect.type === 'MODIFY_STAT' && effect.target === 'jumpDistance').reduce((sum, effect) => sum + (effect.value as number), 0);
  const finalRestPoints = finalHPMax; // Rest Points = HP
  const finalGritPoints = Math.max(0, 2 + finalCharisma); // 2 + Charisma (minimum 0)
  const finalInitiativeBonus = finalAgility;
  
  // Create breakdowns for derived stats
  breakdowns.hpMax = createStatBreakdown('hpMax', finalHPMax, resolvedEffects);
  breakdowns.spMax = createStatBreakdown('spMax', finalSPMax, resolvedEffects);
  breakdowns.mpMax = createStatBreakdown('mpMax', finalMPMax, resolvedEffects);
  breakdowns.pd = createStatBreakdown('pd', basePD, resolvedEffects);
  breakdowns.ad = createStatBreakdown('ad', baseAD, resolvedEffects);
  
  // Movement breakdowns
  breakdowns.move_speed = createStatBreakdown('moveSpeed', finalMoveSpeed, resolvedEffects);
  breakdowns.jump_distance = createStatBreakdown('jumpDistance', finalJumpDistance, resolvedEffects);
  
  // Combat breakdowns
  const attackSpellCheckBase = combatMastery + maxValue;
  breakdowns.attack_spell_check = createStatBreakdown('attackSpellCheck', attackSpellCheckBase, resolvedEffects);
  breakdowns.save_dc = createStatBreakdown('saveDC', finalSaveDC, resolvedEffects);
  
  // Martial check is Attack/Spell Check + Action Points bonus (calculated at runtime)
  // For now, just use the base attack/spell check value
  breakdowns.martial_check = createStatBreakdown('martialCheck', attackSpellCheckBase, resolvedEffects);
  
  // Other stats
  const primeAttribute = ['might', 'agility', 'charisma', 'intelligence'].find(attr => {
    return breakdowns[`attribute_${attr}`].total === maxValue;
  }) || 'might';
  
  // 5. Validation
  const attributeLimits = validateAttributeLimits(buildData, resolvedEffects);
  const validation: ValidationResult = {
    isValid: !Object.values(attributeLimits).some(limit => limit.exceeded),
    errors: [],
    warnings: [],
    attributeLimits,
    masteryLimits: {
      maxSkillMastery: 1, // Default for level 1
      maxTradeMastery: 1,
      currentAdeptCount: 0,
      maxAdeptCount: 1,
      canSelectAdept: true
    }
  };
  
  // 6. Collect abilities and features
  const grantedAbilities = resolvedEffects
    .filter(effect => effect.resolved && effect.type === 'GRANT_ABILITY')
    .map(effect => ({
      name: effect.target,
      description: effect.value as string,
      source: effect.source,
      type: 'active' as const,
      isConditional: !!effect.condition,
      condition: effect.condition
    }));
  
  // 7. Conditional modifiers
  const conditionalModifiers = resolvedEffects
    .filter(effect => effect.resolved && effect.condition)
    .map(effect => ({
      effect,
      condition: effect.condition!,
      description: `${effect.source.name}: ${effect.value > 0 ? '+' : ''}${effect.value} ${effect.target} while ${effect.condition}`,
      affectedStats: [effect.target]
    }));
  
  // 8. Get unresolved choices
  const unresolvedChoices = getUnresolvedChoices(resolvedEffects);
  
  return {
    stats: {
      finalMight,
      finalAgility,
      finalCharisma,
      finalIntelligence,
      finalHPMax,
      finalSPMax,
      finalMPMax,
      finalPD,
      finalAD,
      finalPDR,
      finalMoveSpeed,
      finalJumpDistance,
      finalDeathThreshold,
      finalSaveDC,
      finalSaveMight,
      finalSaveAgility,
      finalSaveCharisma,
      finalSaveIntelligence,
      finalInitiativeBonus,
      finalRestPoints,
      finalGritPoints,
      
      // Prime modifier and combat mastery (needed for UI compatibility)
      finalPrimeModifierValue: maxValue,
      finalPrimeModifierAttribute: primeAttribute,
      finalCombatMastery: combatMastery,
      
      // Class and ancestry info for UI
      className: getClassFeatures(buildData.classId)?.className || 'Unknown',
      ancestry1Name: ancestriesData.find(a => a.id === buildData.ancestry1Id)?.name,
      ancestry2Name: ancestriesData.find(a => a.id === buildData.ancestry2Id)?.name
    },
    breakdowns,
    grantedAbilities,
    conditionalModifiers,
    combatTraining: [],
    resistances: [],
    vulnerabilities: [],
    senses: [],
    movements: [],
    validation,
    unresolvedChoices,
    cacheTimestamp: Date.now(),
    isFromCache: false
  };
}
```

## File: src/lib/rulesdata/_new_schema/traits.ts
```typescript
import type { Trait } from '../schemas/character.schema';

export const traitsData: Trait[] = [
	// Human Traits (p. 108)
	{
		id: 'human_attribute_increase',
		name: 'Attribute Increase',
		description:
			'Grants 1 Attribute Point to spend on any Attribute (up to the Attribute Limit).',
		cost: 2,
		effects: [
			{
				type: 'MODIFY_STAT',
				target: 'attributePoints',
				value: 1
			}
		]
	},
	{
		id: 'human_skill_expertise',
		name: 'Skill Expertise',
		description:
			'Choose a Skill. Your Mastery Cap and Mastery Level in the chosen Skill both increase by 1. You can only benefit from 1 Feature that increases your Skill Mastery Limit at a time.',
		cost: 2,
		effects: [
			{
				type: 'MODIFY_STAT',
				target: 'skillPoints',
				value: 1
			},
			{
				type: 'GRANT_SKILL_EXPERTISE',
				target: 'any_skill',
				value: { capIncrease: 1, levelIncrease: 1 },
				userChoice: { prompt: 'Choose a skill for Expertise' }
			}
		]
	},
	{
		id: 'human_resolve',
		name: 'Human Resolve',
		description: 'Your Deaths Door Threshold value is expanded by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'deathThresholdModifier', value: 1 }]
	},
	{
		id: 'human_undying',
		name: 'Undying',
		description: 'You have ADV on Saves against the Doomed Condition.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_SAVE', target: 'Doomed', value: 'ADV' }]
	},
	{
		id: 'human_trade_expertise',
		name: 'Trade Expertise',
		description:
			'Choose a Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1. You can only benefit from 1 Feature that increases your Trade Mastery Limit at a time.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				target: 'any_trade',
				value: { capIncrease: 1, levelIncrease: 1 },
				userChoice: { prompt: 'Choose a Trade for Expertise' }
			}
		]
	},
	{
		id: 'human_determination',
		name: 'Human Determination',
		description:
			'Once per Combat, you can give yourself ADV on an Attack Check or Spell Check while Bloodied.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_ABILITY',
				target: 'determination',
				value: 'Once per Combat, you can give yourself ADV on an Attack Check or Spell Check while Bloodied.'
			}
		]
	},
	{
		id: 'human_unbreakable',
		name: 'Unbreakable',
		description: 'You have ADV on Death Saves.',
		cost: 1,
		effects: [{ type: 'GRANT_ADV_ON_SAVE', target: 'Death_Save', value: 'ADV' }]
	},
	{
		id: 'human_attribute_decrease',
		name: 'Attribute Decrease',
		description:
			'Choose an Attribute. You decrease the chosen Attribute by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [
			{
				type: 'MODIFY_ATTRIBUTE',
				target: 'any_attribute',
				value: -1,
				userChoice: { prompt: 'Choose an Attribute to decrease by 1', options: ['might', 'agility', 'charisma', 'intelligence'] }
			}
		]
	},

	// Elf Traits (p. 108)
	{
		id: 'elf_elven_will',
		name: 'Elven Will',
		description: 'You have ADV on Checks and Saves against being Charmed and put to Sleep.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Charmed', value: 'ADV' },
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Sleep_Magic', value: 'ADV' }
		]
	},
	{
		id: 'elf_nimble',
		name: 'Nimble',
		description:
			'When you take the Dodge Action, you instead gain the benefits of the Full Dodge Action.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ABILITY', target: 'nimble', value: 'When you take the Dodge Action, you gain the benefits of the Full Dodge Action.' }
		]
	},
	{
		id: 'elf_agile_explorer',
		name: 'Agile Explorer',
		description: 'You are not affected by Difficult Terrain.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'agile_explorer', value: 'You are not affected by Difficult Terrain.' }]
	},
	{
		id: 'elf_discerning_sight',
		name: 'Discerning Sight',
		description: 'You have ADV on Checks and Saves made to discern through visual illusions.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_CHECK', target: 'Discern Visual Illusions', value: 'ADV' }]
	},
	{
		id: 'elf_quick_reactions',
		name: 'Quick Reactions',
		description: 'While you are not wearing Armor, you gain +1 PD.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'pd', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'elf_peerless_sight',
		name: 'Peerless Sight',
		description:
			'You do not have DisADV as a result of making an Attack with a Weapon at Long Range',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'peerless_sight', value: 'You do not have DisADV on Ranged Weapon Attacks at Long Range.' }]
	},
	{
		id: 'elf_climb_speed',
		name: 'Climb Speed',
		description: 'You gain a Climb Speed equal to your Movement Speed.',
		cost: 1,
		effects: [{ type: 'GRANT_MOVEMENT', target: 'climb', value: 'equal_to_speed' }]
	},
	{
		id: 'elf_speed_increase',
		name: 'Speed Increase',
		description: 'Your Speed increases by 1 Space.',
		cost: 2,
		effects: [{ type: 'MODIFY_STAT', target: 'moveSpeed', value: 1 }]
	},
	{
		id: 'elf_trade_expertise_elf',
		name: 'Trade Expertise (Elf)',
		description:
			'Choose a Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1. You can only benefit from 1 Feature that increases your Trade Mastery Limit at a time.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				target: 'any_trade',
				value: { capIncrease: 1, levelIncrease: 1 },
				userChoice: { prompt: 'Choose a Trade for Expertise' }
			}
		]
	},
	{
		id: 'elf_plant_knowledge',
		name: 'Plant Knowledge',
		description:
			'While within forests, jungles, and swamps, you have ADV on Survival Checks. Additionally, you have ADV on Nature Checks made to recall information about plants.',
		cost: 0,
		isMinor: true,
		effects: [
			{ type: 'GRANT_ABILITY', target: 'plant_knowledge', value: 'You have ADV on Survival Checks in forests, jungles, and swamps, and ADV on Nature Checks about plants.' }
		]
	},
	{
		id: 'elf_brittle',
		name: 'Brittle',
		description: 'Your AD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_STAT', target: 'ad', value: -1 }]
	},
	{
		id: 'elf_frail',
		name: 'Frail',
		description: 'Your HP maximum decreases by 2.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_STAT', target: 'hpMax', value: -2 }]
	},
	{
		id: 'elf_might_decrease',
		name: 'Might Decrease',
		description: 'Your Might decreases by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'might', value: -1 }]
	},

	// Dwarf Traits (p. 109)
	{
		id: 'dwarf_tough',
		name: 'Tough',
		description: 'Your HP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'hpMax', value: 1 }]
	},
	{
		id: 'dwarf_toxic_fortitude',
		name: 'Toxic Fortitude',
		description: 'You have Poison Resistance (Half) and ADV on Saves against being Poisoned.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE', target: 'Poison', value: 'half' },
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Poisoned', value: 'ADV' }
		]
	},
	{
		id: 'dwarf_physically_sturdy',
		name: 'Physically Sturdy',
		description: 'You have ADV on Saves against being Impaired, Deafened, or Petrified.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Impaired', value: 'ADV' },
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Deafened', value: 'ADV' },
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Petrified', value: 'ADV' }
		]
	},
	{
		id: 'dwarf_iron_stomach',
		name: 'Iron Stomach',
		description: 'You have ADV on Saves against effects that come from consuming food or liquids.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'iron_stomach', value: 'You have ADV on Saves against effects from consuming food or liquids.' }]
	},
	{
		id: 'dwarf_thick_skinned',
		name: 'Thick-Skinned',
		description: 'While you are not wearing Armor, you gain +1 AD.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'ad', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'dwarf_natural_combatant',
		name: 'Natural Combatant',
		description: 'You gain Combat Training with Heavy Armor and All Shields.',
		cost: 1,
		effects: [
			{ type: 'GRANT_COMBAT_TRAINING', target: 'Heavy_Armor', value: true },
			{ type: 'GRANT_COMBAT_TRAINING', target: 'All_Shields', value: true }
		]
	},
	{
		id: 'dwarf_stone_blood',
		name: 'Stone Blood',
		description:
			'You have ADV on Saves against Bleeding. Additionally, you can spend 1 AP to end the Bleeding Condition on yourself.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Bleeding', value: 'ADV' },
			{ type: 'GRANT_ABILITY', target: 'stone_blood', value: 'You can spend 1 AP to end the Bleeding Condition on yourself.' }
		]
	},
	{
		id: 'dwarf_minor_tremorsense',
		name: 'Minor Tremorsense',
		description: 'You have Tremorsense 3 Spaces.',
		cost: 1,
		effects: [{ type: 'GRANT_SENSE', target: 'tremorsense', value: 3 }]
	},
	{
		id: 'dwarf_stubborn',
		name: 'Stubborn',
		description: 'You have ADV on Saves against being Taunted and against being forcibly moved.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Taunted', value: 'ADV' },
			{ type: 'GRANT_ABILITY', target: 'stubborn', value: 'You have ADV on Saves against being forcibly moved.' }
		]
	},
	{
		id: 'dwarf_earthen_knowledge',
		name: 'Earthen Knowledge',
		description:
			'While underground, you have ADV on Survival Checks. Additionally, you have ADV on Nature Checks made to recall information about stones, gems, and metals.',
		cost: 0,
		isMinor: true,
		effects: [
			{ type: 'GRANT_ABILITY', target: 'earthen_knowledge', value: 'You have ADV on Survival Checks while underground and ADV on Nature Checks about stones, gems, and metals.' }
		]
	},
	{
		id: 'dwarf_charisma_attribute_decrease',
		name: 'Charisma Decrease',
		description: 'Your Charisma decreases by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'charisma', value: -1 }]
	},
	{
		id: 'dwarf_short_legged',
		name: 'Short-Legged',
		description: 'Your Speed decreases by 1 Space.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_STAT', target: 'moveSpeed', value: -1 }]
	},

	// Halfling Traits (p. 109)
	{
		id: 'halfling_small_sized',
		name: 'Small-Sized',
		description: 'Your Size is considered Small.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'small_size', value: 'Your Size is considered Small.' }]
	},
	{
		id: 'halfling_elusive',
		name: 'Elusive',
		description: 'When you take the Disengage Action, you instead gain the benefits of the Full Disengage Action.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'elusive', value: 'When you take the Disengage Action, you gain the benefits of the Full Disengage Action.' }]
	},
	{
		id: 'halfling_bravery',
		name: 'Halfling Bravery',
		description: 'You have ADV on Saves against being Intimidated, Rattled, or Frightened',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Intimidated', value: 'ADV' },
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Rattled', value: 'ADV' },
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Frightened', value: 'ADV' }
		]
	},
	{
		id: 'halfling_endurance',
		name: 'Halfling Endurance',
		description: 'You have Exhaustion Resistance.',
		cost: 1,
		effects: [{ type: 'GRANT_RESISTANCE', target: 'Exhaustion', value: 'condition' }]
	},
	{
		id: 'halfling_deft_footwork',
		name: 'Deft Footwork',
		description: 'You can move through the space of a hostile creature 1 size larger than you as if it were Difficult Terrain.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'deft_footwork', value: 'You can move through the space of a hostile creature 1 size larger as if it were Difficult Terrain.' }]
	},
	{
		id: 'halfling_beast_whisperer',
		name: 'Beast Whisperer',
		description: 'You can speak to Beasts in a limited manner. They can understand the meanings of simple words, concepts, or states of emotion.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'beast_whisperer', value: 'You can speak to Beasts in a limited manner.' }]
	},
	{
		id: 'halfling_beast_insight',
		name: 'Beast Insight',
		description: 'You can understand Beasts in a limited manner. You can understand the meaning of their noises and behaviors.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'beast_insight', value: 'You can understand Beasts in a limited manner.' }]
	},
	{
		id: 'halfling_burst_of_bravery',
		name: 'Burst of Bravery',
		description: 'Once per Combat, you can end the Intimidated, Rattled, or Frightened Condition on yourself for free at any time.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'burst_of_bravery', value: 'Once per Combat: end Intimidated, Rattled, or Frightened on yourself for free.' }]
	},
	{
		id: 'halfling_trade_expertise',
		name: 'Trade Expertise',
		description: 'Choose a Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				target: 'any_trade',
				value: { capIncrease: 1, levelIncrease: 1 },
				userChoice: { prompt: 'Choose a Trade for Expertise' }
			}
		]
	},
	{
		id: 'halfling_critter_knowledge',
		name: 'Critter Knowledge',
		description: 'You have ADV on Nature, Survival, and Animal Checks involving Small size creatures and smaller.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'critter_knowledge', value: 'You have ADV on Nature, Survival, and Animal Checks involving Small creatures.' }]
	},
	{
		id: 'halfling_brittle',
		name: 'Brittle',
		description: 'Your AD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_STAT', target: 'ad', value: -1 }]
	},
	{
		id: 'halfling_intelligence_attribute_decrease',
		name: 'Intelligence Decrease',
		description: 'Your Intelligence decreases by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'intelligence', value: -1 }]
	},
	{
		id: 'halfling_short_legged',
		name: 'Short-Legged',
		description: 'Your Speed decreases by 1 Space.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_STAT', target: 'moveSpeed', value: -1 }]
	},

	// Gnome Traits (p. 110) 
	{
		id: 'gnome_small_sized',
		name: 'Small-Sized',
		description: 'Your Size is considered Small.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'small_size', value: 'Your Size is considered Small.' }]
	},
	{
		id: 'gnome_escape_artist',
		name: 'Escape Artist',
		description: 'You have ADV on Checks and Saves to avoid or escape being Grappled or Restrained.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'escape_artist', value: 'You have ADV on Checks and Saves to avoid or escape being Grappled or Restrained.' }]
	},
	{
		id: 'gnome_magnified_vision',
		name: 'Magnified Vision',
		description: 'You have ADV on Investigation Checks made on something you are holding or touching.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'magnified_vision', value: 'You have ADV on Investigation Checks on things you are holding or touching.' }]
	},
	{
		id: 'gnome_mental_clarity',
		name: 'Mental Clarity',
		description: 'You have ADV on Saves against being Dazed or Stunned.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Dazed', value: 'ADV' },
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Stunned', value: 'ADV' }
		]
	},
	{
		id: 'gnome_strong_minded',
		name: 'Strong-Minded',
		description: 'You gain Psychic Resistance (1).',
		cost: 1,
		effects: [{ type: 'GRANT_RESISTANCE', target: 'Psychic', value: 1 }]
	},
	{
		id: 'gnome_predict_weather',
		name: 'Predict Weather',
		description: 'You can naturally tell what the weather is going to be in the next hour in the area within 1 mile of you. You do not have DisADV on Checks or Saves as a result of naturally occurring weather.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'predict_weather', value: 'You can predict weather within 1 mile for the next hour and ignore DisADV from natural weather.' }]
	},
	{
		id: 'gnome_mana_increase',
		name: 'Mana Increase',
		description: 'Your MP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'mpMax', value: 1 }]
	},
	{
		id: 'gnome_trapper',
		name: 'Trapper',
		description: 'You have ADV on Investigation Checks to spot Traps and on Trickery Checks to Hide Traps.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'trapper', value: 'You have ADV on Investigation Checks to spot Traps and on Trickery Checks to Hide Traps.' }]
	},
	{
		id: 'gnome_lightning_insulation',
		name: 'Lightning Insulation',
		description: 'You have Lightning Resistance (Half) and cannot be struck by natural lightning.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE', target: 'Lightning', value: 'half' },
			{ type: 'GRANT_ABILITY', target: 'lightning_insulation', value: 'You can\'t be struck by natural lightning.' }
		]
	},
	{
		id: 'gnome_trade_expertise',
		name: 'Trade Expertise',
		description: 'Choose a Crafting or Subterfuge Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				target: 'crafting_or_subterfuge_trade',
				value: { capIncrease: 1, levelIncrease: 1 },
				userChoice: { prompt: 'Choose a Crafting or Subterfuge Trade for Expertise' }
			}
		]
	},

	// Orc Traits (p. 110)
	{
		id: 'orc_cursed_mind',
		name: 'Cursed Mind',
		description: 'You gain Psychic Vulnerability (1).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_VULNERABILITY', target: 'Psychic', value: 1 }]
	},
	{
		id: 'orc_rush',
		name: 'Orc Rush',
		description: 'Once per Combat when you willingly move toward an enemy, you can spend 1 AP to gain Temp HP equal to your Prime Modifier.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'orc_rush', value: 'Once per Combat: spend 1 AP to gain Temp HP equal to Prime Modifier when moving toward enemy.' }]
	},
	{
		id: 'orc_brutal_strikes',
		name: 'Brutal Strikes',
		description: 'You deal +1 damage when you score a Brutal or Critical Hit with a Melee Weapon or Unarmed Strike.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'brutal_strikes', value: '+1 damage on Brutal or Critical Hits with Melee Attacks.' }]
	},
	{
		id: 'orc_tough',
		name: 'Tough',
		description: 'Your HP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'hpMax', value: 1 }]
	},
	{
		id: 'orc_reckless',
		name: 'Reckless',
		description: 'Your PD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_STAT', target: 'pd', value: -1 }]
	},

	// Dragonborn Traits (p. 111)
	{
		id: 'dragonborn_darkvision',
		name: 'Darkvision',
		description: 'You have Darkvision 10 Spaces.',
		cost: 1,
		effects: [{ type: 'GRANT_SENSE', target: 'darkvision', value: 10 }]
	},
	{
		id: 'dragonborn_draconic_resistance',
		name: 'Draconic Resistance',
		description: 'You gain Resistance (Half) to your Draconic damage type.',
		cost: 2,
		effects: [{ type: 'GRANT_RESISTANCE', target: 'Draconic_damage_type', value: 'half' }]
	},
	{
		id: 'dragonborn_draconic_breath_weapon',
		name: 'Draconic Breath Weapon',
		description: 'You gain a Breath Weapon that you can use by spending 2 AP. You can use this ability once per Long Rest, and regain the ability when you roll for Initiative.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'draconic_breath', value: 'Breath Weapon: 2 AP, once per Long Rest, regain on Initiative.' }]
	},
	{
		id: 'dragonborn_thick_skinned',
		name: 'Thick-Skinned',
		description: 'While you aren\'t wearing Armor, you gain +1 AD.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'ad', value: 1, condition: 'not_wearing_armor' }]
	},

	// Giantborn Traits (p. 112)
	{
		id: 'giantborn_giant_blood',
		name: 'Giant Blood',
		description: 'Your Size is considered Large.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'large_size', value: 'Your Size is considered Large.' }]
	},
	{
		id: 'giantborn_tough',
		name: 'Tough',
		description: 'Your HP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'hpMax', value: 1 }]
	},
	{
		id: 'giantborn_throw_ally',
		name: 'Throw Ally',
		description: 'You can throw willing allies as a Combat Action.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'throw_ally', value: 'You can throw willing allies as a Combat Action.' }]
	},
	{
		id: 'giantborn_clumsy',
		name: 'Clumsy',
		description: 'Your PD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_STAT', target: 'pd', value: -1 }]
	},

	// Angelborn Traits (p. 113)
	{
		id: 'angelborn_divine_resistance',
		name: 'Divine Resistance',
		description: 'You have Holy Resistance (Half).',
		cost: 1,
		effects: [{ type: 'GRANT_RESISTANCE', target: 'Holy', value: 'half' }]
	},
	{
		id: 'angelborn_healing_hands',
		name: 'Healing Hands',
		description: 'Once per Long Rest, you can touch a creature to heal them for 1d4 + your Prime Modifier HP.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'healing_hands', value: 'Once per Long Rest: heal 1d4 + Prime Modifier HP by touch.' }]
	},
	{
		id: 'angelborn_light_sensitivity',
		name: 'Light Sensitivity',
		description: 'While in bright light, you have DisADV on Attack Checks.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'light_sensitivity', value: 'DisADV on Attack Checks in bright light.' }]
	},

	// Fiendborn Traits (p. 114)
	{
		id: 'fiendborn_darkvision',
		name: 'Darkvision',
		description: 'You have Darkvision 10 Spaces.',
		cost: 1,
		effects: [{ type: 'GRANT_SENSE', target: 'darkvision', value: 10 }]
	},
	{
		id: 'fiendborn_hellish_resistance',
		name: 'Hellish Resistance',
		description: 'You have Fire Resistance (Half).',
		cost: 1,
		effects: [{ type: 'GRANT_RESISTANCE', target: 'Fire', value: 'half' }]
	},
	{
		id: 'fiendborn_infernal_legacy',
		name: 'Infernal Legacy',
		description: 'You know one Cantrip from the Fiendborn Ancestry Spells.',
		cost: 1,
		effects: [{ type: 'GRANT_SPELL', target: 'fiendborn_cantrip', value: 'One Cantrip from Fiendborn Ancestry Spells.' }]
	},
	{
		id: 'fiendborn_holy_vulnerability',
		name: 'Holy Vulnerability',
		description: 'You have Holy Vulnerability (1).',
		cost: -2,
		isNegative: true,
		effects: [{ type: 'GRANT_VULNERABILITY', target: 'Holy', value: 1 }]
	},

	// Beastborn Traits (p. 115)
	{
		id: 'beastborn_keen_senses',
		name: 'Keen Senses',
		description: 'You have ADV on Awareness Checks that rely on hearing or smell.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'keen_senses', value: 'ADV on Awareness Checks using hearing or smell.' }]
	},
	{
		id: 'beastborn_natural_weapons',
		name: 'Natural Weapons',
		description: 'Your claws and teeth are Natural Weapons that deal 1 Slashing or Piercing damage.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'natural_weapons', value: 'Claws and teeth are Natural Weapons dealing 1 damage.' }]
	},
	{
		id: 'beastborn_thick_hide',
		name: 'Thick Hide',
		description: 'While you aren\'t wearing Armor, you gain +1 AD.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'ad', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'beastborn_wild_mind',
		name: 'Wild Mind',
		description: 'You have DisADV on Intelligence-based Checks.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'wild_mind', value: 'DisADV on Intelligence-based Checks.' }]
	},

	// Angelborn Traits
	{
		id: 'angelborn_radiant_resistance',
		name: 'Radiant Resistance',
		description: 'You have Resistance (Half) to Radiant damage.',
		cost: 1,
		effects: [{ type: 'GRANT_RESISTANCE', target: 'Radiant', value: 'half' }]
	},
	{
		id: 'angelborn_celestial_magic',
		name: 'Celestial Magic',
		description:
			'You learn 1 Spell of your choice from the Divine Spell List (Holy & Restoration during the Beta). Once per Long Rest, you can cast the chosen Spell spending 1 less MP than normal (minimum of 0 MP). The Spells total MP cost (before all reductions) still can\'t exceed your Mana Spend Limit.',
		cost: 2,
		effects: [
			{ type: 'GRANT_SPELL', target: 'Divine_Spell_List', value: 1 },
			{ type: 'GRANT_ABILITY', target: 'reduced_mp_cost', value: 'Once per Long Rest, cast chosen spell for 1 less MP (minimum 0).' }
		]
	},
	{
		id: 'angelborn_healing_touch',
		name: 'Healing Touch',
		description:
			'Once per Combat, you can spend 1 AP to touch a creature and Heal it. Make a DC 10 Spell Check. Success: You can restore up to 2 HP to the target. Success (each 5): +1 HP. Failure: You only restore 2 HP.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'healing_touch', value: 'Once per Combat, 1 AP: Touch heal (DC 10 Spell Check), 2+ HP restored.' }]
	},
	{
		id: 'angelborn_divine_glow',
		name: 'Divine Glow',
		description: 'Your body can emit a Bright Light in a 5 Space radius around you at will.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'divine_glow', value: 'Emit Bright Light in 5 Space radius at will.' }]
	},
	{
		id: 'angelborn_mana_increase',
		name: 'Mana Increase',
		description: 'Your MP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'mp', value: 1 }]
	},
	{
		id: 'angelborn_celestial_clarity',
		name: 'Celestial Clarity',
		description: 'You have ADV on Saves against being Blinded or Deafened.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Blinded', value: true },
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Deafened', value: true }
		]
	},
	{
		id: 'angelborn_angelic_insight',
		name: 'Angelic Insight',
		description:
			'Once per Long Rest you can grant yourself ADV on an Insight Check to see if someone is lying.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'angelic_insight', value: 'Once per Long Rest: ADV on Insight Check to detect lies.' }]
	},
	{
		id: 'angelborn_gift_of_the_angels',
		name: 'Gift of the Angels',
		description:
			'Once per Combat you can spend 1 AP and 1 MP and touch a creature to heal them over time. The creature recovers 1 HP at the start of each of their turns for 1 minute (5 Rounds).',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'gift_of_angels', value: 'Once per Combat, 1 AP + 1 MP: Touch heal over time (1 HP/turn for 5 rounds).' }]
	},
	{
		id: 'angelborn_blinding_light',
		name: 'Blinding Light',
		description:
			'Once per Combat, you can spend 1 AP to choose a creature within 5 Spaces and make a Spell Check contested by its Physical Save. Success: The target is Blinded until the end of your next turn.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'blinding_light', value: 'Once per Combat, 1 AP: Spell Check vs Physical Save to Blind target (5 Spaces, until end of next turn).' }]
	},
	{
		id: 'angelborn_glide_speed',
		name: 'Glide Speed',
		description:
			'You have a set of wings that you can use to horizontally glide and slow your descent. Provided you aren\'t Incapacitated, you gain the following benefits while in the air: Controlled Falling: You suffer no damage from Controlled Falling. Altitude Drop: If you end your turn midair, you Controlled Fall 4 Spaces. Glide Speed: You can use your movement to glide horizontally.',
		cost: 2,
		effects: [{ type: 'GRANT_MOVEMENT', target: 'glide', value: 'wings' }]
	},
	{
		id: 'angelborn_pacifist',
		name: 'Pacifist',
		description:
			'Your divine call is to put others before yourself and resist doing harm. You suffer a -1 penalty to all Checks and Saves made during the first round of Combat.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'pacifist', value: '-1 penalty to all Checks and Saves during first round of Combat.' }]
	},
	{
		id: 'angelborn_umbral_weakness',
		name: 'Umbral Weakness',
		description: 'You have Umbral Vulnerability (1).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_VULNERABILITY', target: 'Umbral', value: 1 }]
	},

	// Dwarf Traits
	{
		id: 'dwarf_trade_expertise',
		name: 'Trade Expertise',
		description:
			'Choose a Crafting or Services Trade. Your Mastery Cap and Mastery Level in the chosen Trade both increase by 1.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_TRADE_EXPERTISE',
				target: 'any_crafting_or_services_trade',
				value: { capIncrease: 1, levelIncrease: 1 },
				userChoice: { prompt: 'Choose a Crafting or Services Trade for Expertise' }
			}
		]
	},

	// Gnome Traits
	{
		id: 'gnome_agility_attribute_decrease',
		name: 'Agility Decrease',
		description: 'You decrease your Agility by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'agility', value: -1 }]
	},
	{
		id: 'gnome_short_legged',
		name: 'Short-Legged',
		description: 'Your Speed decreases by 1 Space.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_STAT', target: 'moveSpeed', value: -1 }]
	},
	{
		id: 'gnome_storm_knowledge',
		name: 'Storm Knowledge',
		description:
			'While within rainy, snowy, or stormy environments, you have ADV on Survival Checks. Additionally, you have ADV on Knowledge Checks made to recall information about rain, snow, and storms.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_CHECK', target: 'Survival', value: 'rainy_snowy_stormy_environments' },
			{ type: 'GRANT_ADV_ON_CHECK', target: 'Knowledge', value: 'rain_snow_storms_information' }
		]
	},

	// Orc Traits
	{
		id: 'orc_already_cursed',
		name: 'Already Cursed',
		description: 'You have ADV on Saves against Curses.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_SAVE', target: 'Curses', value: true }]
	},
	{
		id: 'orc_dash',
		name: 'Orc Dash',
		description:
			'Once per Combat you can use your Minor Action to move, as long as that movement is towards an enemy.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'orc_dash', value: 'Once per Combat: Use Minor Action to move toward enemy.' }]
	},
	{
		id: 'orc_finishing_blow',
		name: 'Finishing Blow',
		description: 'You deal +1 damage to creatures who are Well-Bloodied.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'finishing_blow', value: '+1 damage to Well-Bloodied creatures.' }]
	},
	{
		id: 'orc_imposing_presence',
		name: 'Imposing Presence',
		description:
			'Once per Combat when a creature makes an Attack against you, you can force them to make a Charisma Save. Save Failure: They must choose a new target for the Attack. If there are no other targets, then the Attack is wasted.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'imposing_presence', value: 'Once per Combat: Force attacker to retarget (Charisma Save).' }]
	},
	{
		id: 'orc_intimidating_shout',
		name: 'Intimidating Shout',
		description:
			'Once per Combat, you can spend 1 AP to let out an Intimidating Shout. All creatures within 5 Spaces that can hear you must make a Charisma Save contested by your Attack Check. Failure: A target is Hindered on the next Attack Check or Spell Attack it makes before the start of your next turn.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'intimidating_shout', value: 'Once per Combat, 1 AP: AoE Hinder effect (5 Spaces, Charisma Save vs Attack Check).' }]
	},
	{
		id: 'orc_orcish_resolve',
		name: 'Orcish Resolve',
		description: 'You gain 1 additional AP while on Death\'s Door.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'orcish_resolve', value: '+1 AP while on Death\'s Door.' }]
	},
	{
		id: 'orc_provocation',
		name: 'Provocation',
		description: 'You have DisADV on Checks and Saves against being Taunted.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'provocation', value: 'DisADV on Checks and Saves vs Taunted.' }]
	},

	// Dragonborn Traits
	{
		id: 'dragonborn_concussive_breath',
		name: 'Concussive Breath',
		description:
			'When you use your Draconic Breath Weapon, you can force all targets to make a Physical Save. Save Failure: The target is pushed 1 Space away +1 additional Space for every 5 it fails its Save by.',
		cost: 1,
		prerequisites: ['dragonborn_draconic_breath_weapon'],
		effects: [{ type: 'GRANT_ABILITY', target: 'concussive_breath', value: 'Draconic Breath pushes targets (Physical Save, 1+ Spaces).' }]
	},
	{
		id: 'dragonborn_draconic_affinity',
		name: 'Draconic Affinity',
		description:
			'When you take damage of the same type as your Draconic damage, your next Draconic Breath Weapon deals +1 bonus damage.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'draconic_affinity', value: '+1 damage on next Draconic Breath when taking same damage type.' }]
	},
	{
		id: 'dragonborn_draconic_protection',
		name: 'Draconic Protection',
		description:
			'Once per Combat, when an ally within 20 Spaces is on Death\'s Door, you begin to surge with an ancient power. While they remain on Death\'s Door their PD and AD increases by 5 until Combat ends.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'draconic_protection', value: 'Once per Combat: +5 PD/AD to ally on Death\'s Door (20 Spaces).' }]
	},
	{
		id: 'dragonborn_draconic_ward',
		name: 'Draconic Ward',
		description:
			'Once per Combat when you enter Death\'s Door, you gain 2 Temp HP. Whenever you\'re Hit by a Melee Attack while you have this Temp HP, your Attacker takes 1 Draconic damage.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'draconic_ward', value: 'Death\'s Door: +2 Temp HP, attackers take 1 Draconic damage.' }]
	},
	{
		id: 'dragonborn_dying_breath',
		name: 'Dying Breath',
		description:
			'Once per Combat when you enter Death\'s Door, you regain a use of your Draconic Breath Weapon and can immediately use it as a Reaction for free (0 AP).',
		cost: 1,
		prerequisites: ['dragonborn_draconic_breath_weapon'],
		effects: [{ type: 'GRANT_ABILITY', target: 'dying_breath', value: 'Death\'s Door: Regain and use Draconic Breath as Reaction (0 AP).' }]
	},
	{
		id: 'dragonborn_glide_speed',
		name: 'Glide Speed',
		description:
			'You have a set of wings that you can use to horizontally glide and slow your descent. Provided you aren\'t Incapacitated, you gain the following benefits while in the air: Controlled Falling: You suffer no damage from Controlled Falling. Altitude Drop: If you end your turn midair, you Controlled Fall 4 Spaces. Glide Speed: You can use your movement to glide horizontally.',
		cost: 2,
		effects: [{ type: 'GRANT_MOVEMENT', target: 'glide', value: 'wings' }]
	},
	{
		id: 'dragonborn_guardians_bond',
		name: 'Guardian\'s Bond',
		description:
			'Once per Combat when an ally enters Death\'s Door within 20 Spaces of you, you take an amount of True damage equal to your Prime Modifier.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'guardians_bond', value: 'Take True damage (Prime Modifier) when ally enters Death\'s Door.' }]
	},
	{
		id: 'dragonborn_mana_increase',
		name: 'Mana Increase',
		description: 'Your MP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'mp', value: 1 }]
	},
	{
		id: 'dragonborn_reptilian_superiority',
		name: 'Reptilian Superiority',
		description:
			'You have ADV on Intimidation Checks against reptilian creatures of Medium Size and smaller (not including other Dragonborn).',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ADV_ON_CHECK', target: 'Intimidation', value: 'vs_reptilian_medium_small' }]
	},
	{
		id: 'dragonborn_second_breath',
		name: 'Second Breath',
		description:
			'You can now use your Draconic Breath Weapon twice per Combat. Additionally, whenever you use your Draconic Breath Weapon, you can spend 2 uses to increase the damage by 2 if its an Area, or by 4 if its Focused.',
		cost: 1,
		prerequisites: ['dragonborn_draconic_breath_weapon'],
		effects: [{ type: 'GRANT_ABILITY', target: 'second_breath', value: 'Draconic Breath twice per Combat, enhanced damage option.' }]
	},

	// Fiendborn Traits
	{
		id: 'fiendborn_charming_gaze',
		name: 'Charming Gaze',
		description:
			'You can spend 1 AP to gaze upon a creature you can see within 10 Spaces that can also see you. Make a Spell Check contested by the target\'s Repeated Charisma Save. Success: The creature becomes Charmed by you for 1 minute. You can use this ability once per Long Rest, and when you roll for Initiative, or meet some other unique criteria at the GM\'s discretion, this ability recharges.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'charming_gaze', value: 'Once per Long Rest, 1 AP: Charm target (Spell Check vs Charisma Save, 10 Spaces, 1 minute).' }]
	},
	{
		id: 'fiendborn_divine_dampening',
		name: 'Divine Dampening',
		description: 'You recover 1 less HP when healed from divine sources.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'divine_dampening', value: '-1 HP from divine healing sources.' }]
	},
	{
		id: 'fiendborn_fiendish_aura',
		name: 'Fiendish Aura',
		description:
			'You learn the Sorcery Cantrip, but you must choose the type of energy that\'s the same as your Fiendish Origin.',
		cost: 1,
		effects: [
			{ type: 'GRANT_CANTRIP', target: 'Sorcery', value: 1 },
			{ type: 'GRANT_ABILITY', target: 'sorcery_energy_type', value: 'Must match Fiendish Origin energy type.' }
		]
	},
	{
		id: 'fiendborn_fiendish_magic',
		name: 'Fiendish Magic',
		description:
			'You learn 1 Spell of your choice from the Arcane Spell List from the Destruction or Enchantment Spell Schools. If the Spell deals damage, it must be the same damage type as your Fiendish damage. Once per Long Rest, you can cast the chosen Spell spending 1 less MP than normal (minimum of 0 MP). The Spells total MP cost (before all reductions) still can\'t exceed your Mana Spend Limit.',
		cost: 2,
		effects: [
			{ type: 'GRANT_SPELL', target: 'Arcane_Destruction_Enchantment', value: 1 },
			{ type: 'GRANT_ABILITY', target: 'reduced_mp_cost', value: 'Once per Long Rest, cast chosen spell for 1 less MP (minimum 0).' }
		]
	},
	{
		id: 'fiendborn_fiendish_resistance',
		name: 'Fiendish Resistance',
		description: 'You gain Resistance (Half) to your Fiendish damage type.',
		cost: 2,
		effects: [{ type: 'GRANT_RESISTANCE', target: 'Fiendish_damage_type', value: 'half' }]
	},
	{
		id: 'fiendborn_glide_speed',
		name: 'Glide Speed',
		description:
			'You have a set of wings that you can use to horizontally glide and slow your descent. Provided you aren\'t Incapacitated, you gain the following benefits while in the air: Controlled Falling: You suffer no damage from Controlled Falling. Altitude Drop: If you end your turn midair, you Controlled Fall 4 Spaces. Glide Speed: You can use your movement to glide horizontally.',
		cost: 2,
		effects: [{ type: 'GRANT_MOVEMENT', target: 'glide', value: 'wings' }]
	},
	{
		id: 'fiendborn_infernal_bravery',
		name: 'Infernal Bravery',
		description: 'You have ADV on Saves against being Intimidated.',
		cost: 1,
		effects: [{ type: 'GRANT_ADV_ON_SAVE', target: 'Intimidated', value: true }]
	},
	{
		id: 'fiendborn_intimidator',
		name: 'Intimidator',
		description: 'Once per Combat you can take the Intimidate Action as a Minor Action.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'intimidator', value: 'Once per Combat: Intimidate as Minor Action.' }]
	},
	{
		id: 'fiendborn_lights_bane',
		name: 'Light\'s Bane',
		description: 'You can spend 1 AP to snuff out a mundane light source within 5 Spaces of you.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'lights_bane', value: '1 AP: Snuff out mundane light source (5 Spaces).' }]
	},
	{
		id: 'fiendborn_mana_increase',
		name: 'Mana Increase',
		description: 'Your MP maximum increases by 1.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'mp', value: 1 }]
	},
	{
		id: 'fiendborn_radiant_weakness',
		name: 'Radiant Weakness',
		description: 'You have Radiant Vulnerability (1).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_VULNERABILITY', target: 'Radiant', value: 1 }]
	},
	{
		id: 'fiendborn_silver_tongued',
		name: 'Silver-Tongued',
		description:
			'Once per Long Rest you can grant yourself ADV on an Influence Check when trying to deceive someone.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'silver_tongued', value: 'Once per Long Rest: ADV on Influence Check to deceive.' }]
	},
	{
		id: 'fiendborn_superior_darkvision',
		name: 'Superior Darkvision',
		description: 'Your Darkvision increases to 20 Spaces.',
		cost: 1,
		prerequisites: ['fiendborn_darkvision'],
		effects: [{ type: 'GRANT_SENSE', target: 'darkvision', value: 20 }]
	},

	// Giantborn Traits
	{
		id: 'giantborn_brute',
		name: 'Brute',
		description: 'Once per Combat, you can take the Shove or Grapple Action as a Minor Action.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'brute', value: 'Once per Combat: Shove or Grapple as Minor Action.' }]
	},
	{
		id: 'giantborn_clumsiness',
		name: 'Clumsiness',
		description: 'You have DisADV on Agility Checks.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'clumsiness', value: 'DisADV on Agility Checks.' }]
	},
	{
		id: 'giantborn_giants_fortitude',
		name: 'Giant\'s Fortitude',
		description: 'You also gain the benefits of your Giant\'s Resolve Trait while Well-Bloodied.',
		cost: 2,
		prerequisites: ['giantborn_giants_resolve'],
		effects: [{ type: 'GRANT_ABILITY', target: 'giants_fortitude', value: 'Giant\'s Resolve benefits also apply while Well-Bloodied.' }]
	},
	{
		id: 'giantborn_giants_resolve',
		name: 'Giant\'s Resolve',
		description: 'While on Death\'s Door, you reduce all damage taken by 1.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'giants_resolve', value: 'Reduce all damage by 1 while on Death\'s Door.' }]
	},
	{
		id: 'giantborn_heavy_riser',
		name: 'Heavy Riser',
		description: 'You have to spend 4 Spaces of movement to stand up from Prone.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'heavy_riser', value: '4 Spaces of movement to stand up from Prone.' }]
	},
	{
		id: 'giantborn_intelligence_attribute_decrease',
		name: 'Intelligence Decrease',
		description: 'You decrease your Intelligence by 1 (to a minimum of -2).',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_ATTRIBUTE', target: 'intelligence', value: -1 }]
	},
	{
		id: 'giantborn_mighty_hurl',
		name: 'Mighty Hurl',
		description:
			'You throw creatures 1 Space farther than normal, and objects (including Weapons) 5 Spaces farther than normal.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'mighty_hurl', value: 'Throw creatures +1 Space, objects +5 Spaces farther.' }]
	},
	{
		id: 'giantborn_mighty_leap',
		name: 'Mighty Leap',
		description:
			'You can use your Might instead of Agility to determine your Jump Distance and the damage you take from Falling.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'mighty_leap', value: 'Use Might for Jump Distance and Falling damage.' }]
	},
	{
		id: 'giantborn_powerful_build',
		name: 'Powerful Build',
		description: 'You increase by 1 Size, but you occupy the Space of a creature 1 Size smaller.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'powerful_build', value: '+1 Size but occupy 1 Size smaller space.' }]
	},
	{
		id: 'giantborn_strong_body',
		name: 'Strong Body',
		description:
			'Once per Combat when you take damage from an Attack, you can reduce the damage taken by an amount equal to your Might or Agility (your choice).',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'strong_body', value: 'Once per Combat: Reduce damage by Might or Agility.' }]
	},
	{
		id: 'giantborn_titanic_toss',
		name: 'Titanic Toss',
		description:
			'You have ADV on Checks made to throw creatures. Additionally, you don\'t have DisADV as a result of making an Attack with a Weapon with the Toss or Thrown Property at Long Range.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'titanic_toss', value: 'ADV on throwing creatures, no DisADV for long-range thrown weapons.' }]
	},
	{
		id: 'giantborn_unstoppable',
		name: 'Unstoppable',
		description: 'You have ADV on Saves against being Slowed or Stunned.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Slowed', value: true },
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Stunned', value: true }
		]
	},
	{
		id: 'giantborn_unyielding_movement',
		name: 'Unyielding Movement',
		description: 'You\'re immune to being Slowed 2 (or higher).',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'unyielding_movement', value: 'Immune to Slowed 2 or higher.' }]
	},

	// Beastborn Traits (Essential Selection)
	{
		id: 'beastborn_burrow_speed',
		name: 'Burrow Speed',
		description: 'You gain a Burrow Speed equal to half your Movement Speed.',
		cost: 2,
		effects: [{ type: 'GRANT_MOVEMENT', target: 'burrow', value: 'half_speed' }]
	},
	{
		id: 'beastborn_camouflage',
		name: 'Camouflage',
		description:
			'You can change the color and pattern of your body. You have ADV on Stealth Checks while motionless.',
		cost: 2,
		effects: [{ type: 'GRANT_ADV_ON_CHECK', target: 'Stealth', value: 'while_motionless' }]
	},
	{
		id: 'beastborn_charge',
		name: 'Charge',
		description:
			'If you move at least 2 Spaces in a straight line before making a Melee Attack, the damage of the Attack increases by 1.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'charge', value: '+1 damage on Melee Attack after moving 2+ Spaces straight.' }]
	},
	{
		id: 'beastborn_climb_speed',
		name: 'Climb Speed',
		description: 'You gain a Climb Speed equal to your Ground Speed.',
		cost: 1,
		effects: [{ type: 'GRANT_MOVEMENT', target: 'climb', value: 'equal_to_speed' }]
	},
	{
		id: 'beastborn_cold_resistance',
		name: 'Cold Resistance',
		description:
			'You have Cold Resistance (Half) and Resistance to Exhaustion from cold temperatures.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE', target: 'Cold', value: 'half' },
			{ type: 'GRANT_ABILITY', target: 'cold_exhaustion_resistance', value: 'Resistance to cold temperature Exhaustion.' }
		]
	},
	{
		id: 'beastborn_darkvision',
		name: 'Darkvision',
		description: 'You have Darkvision 10 Spaces.',
		cost: 1,
		effects: [{ type: 'GRANT_SENSE', target: 'darkvision', value: 10 }]
	},
	{
		id: 'beastborn_echolocation',
		name: 'Echolocation',
		description:
			'You can spend 1 AP to roar, scream, or screech to gain Blindsight in a 10 Spaces radius that lasts until the start of your next turn. The sound can be heard from up to 100 Spaces away. You gain no benefit from this Trait in an area of Silence.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'echolocation', value: '1 AP: Blindsight 10 Spaces until next turn (100 Spaces audible).' }]
	},
	{
		id: 'beastborn_natural_weapon',
		name: 'Natural Weapon',
		description:
			'You have up to 2 Natural Weapons (claws, horns, fangs, tail, etc.) which you can use to make Unarmed Strikes that deal 1 Bludgeoning, Piercing, or Slashing damage (your choice upon gaining this Trait). You can perform Attack Maneuvers with your Natural Weapons.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_ABILITY',
				target: 'natural_weapon',
				value: '2 Natural Weapons for Unarmed Strikes (1 damage, chosen type).',
				userChoice: { prompt: 'Choose damage type: Bludgeoning, Piercing, or Slashing' }
			}
		]
	},
	{
		id: 'beastborn_swim_speed',
		name: 'Swim Speed',
		description: 'You gain a Swim Speed equal to your Ground Speed.',
		cost: 1,
		effects: [{ type: 'GRANT_MOVEMENT', target: 'swim', value: 'equal_to_speed' }]
	},
	{
		id: 'beastborn_fire_resistance',
		name: 'Fire Resistance',
		description:
			'You have Fire Resistance (Half) and Resistance to Exhaustion from hot temperatures.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE', target: 'Fire', value: 'half' },
			{ type: 'GRANT_ABILITY', target: 'heat_exhaustion_resistance', value: 'Resistance to hot temperature Exhaustion.' }
		]
	},
	{
		id: 'beastborn_natural_armor',
		name: 'Natural Armor',
		description: 'While you aren\'t wearing Armor, you gain +1 AD.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'ad', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'beastborn_keen_sense',
		name: 'Keen Sense',
		description:
			'Choose 1 of the following senses: hearing, sight, or smell. You make Awareness Checks with ADV using the chosen sense.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_ADV_ON_CHECK',
				target: 'Awareness',
				value: 'chosen_sense',
				userChoice: { prompt: 'Choose a sense: hearing, sight, or smell' }
			}
		]
	},
	{
		id: 'beastborn_small_sized',
		name: 'Small-Sized',
		description: 'Your Size is considered Small.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'small_sized', value: 'Size is considered Small.' }]
	},
	{
		id: 'beastborn_sunlight_sensitivity',
		name: 'Sunlight Sensitivity',
		description:
			'While you or your target is in sunlight, you have DisADV on Attacks and Awareness Checks that rely on sight.',
		cost: -2,
		isNegative: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'sunlight_sensitivity', value: 'DisADV on Attacks and sight-based Awareness in sunlight.' }]
	},
	{
		id: 'beastborn_speed_increase',
		name: 'Speed Increase',
		description: 'Your Speed increases by 1 Space.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'moveSpeed', value: 1 }]
	},

	// Additional Beastborn Traits (Part 1)
	{
		id: 'beastborn_extended_natural_weapon',
		name: 'Extended Natural Weapon',
		description: 'Your Natural Weapon now has the Reach Property.',
		cost: 2,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_ABILITY', target: 'extended_natural_weapon', value: 'Natural Weapon gains Reach Property.' }]
	},
	{
		id: 'beastborn_fast_reflexes',
		name: 'Fast Reflexes',
		description:
			'You gain ADV on Initiative Checks and on the first Attack Check you make in Combat.',
		cost: 2,
		effects: [
			{ type: 'GRANT_ADV_ON_CHECK', target: 'Initiative', value: true },
			{ type: 'GRANT_ABILITY', target: 'first_attack_adv', value: 'ADV on first Attack Check in Combat.' }
		]
	},
	{
		id: 'beastborn_flyby',
		name: 'Flyby',
		description: 'You don\'t provoke Opportunity Attacks when you Fly out of an enemy\'s reach.',
		cost: 1,
		prerequisites: ['beastborn_limited_flight'],
		effects: [{ type: 'GRANT_ABILITY', target: 'flyby', value: 'No Opportunity Attacks when flying out of reach.' }]
	},
	{
		id: 'beastborn_full_flight',
		name: 'Full Flight',
		description: 'You have a Fly Speed equal to your Ground Speed.',
		cost: 2,
		prerequisites: ['beastborn_limited_flight'],
		effects: [{ type: 'GRANT_MOVEMENT', target: 'fly', value: 'equal_to_speed' }]
	},
	{
		id: 'beastborn_glide_speed',
		name: 'Glide Speed',
		description:
			'You have a set of wings that you can use to horizontally glide and slow your descent. Provided you aren\'t Incapacitated, you gain the following benefits while in the air: Controlled Falling: You suffer no damage from Controlled Falling. Altitude Drop: If you end your turn midair, you Controlled Fall 4 Spaces. Glide Speed: You can use your movement to glide horizontally.',
		cost: 2,
		effects: [{ type: 'GRANT_MOVEMENT', target: 'glide', value: 'wings' }]
	},
	{
		id: 'beastborn_hard_shell',
		name: 'Hard Shell',
		description:
			'You have a large shell around your body for protection. Your AD increases by 1 (while you\'re not wearing Armor), your Movement Speed decreases by 1, and you\'re immune to being Flanked.',
		cost: 1,
		prerequisites: ['beastborn_thick_skinned'],
		effects: [
			{ type: 'MODIFY_STAT', target: 'ad', value: 1, condition: 'not_wearing_armor' },
			{ type: 'MODIFY_STAT', target: 'moveSpeed', value: -1 },
			{ type: 'GRANT_ABILITY', target: 'immune_flanking', value: 'Immune to being Flanked.' }
		]
	},
	{
		id: 'beastborn_hazardous_hide',
		name: 'Hazardous Hide',
		description:
			'You have spikes, retractable barbs, poisonous skin, or some other form of defense mechanism to keep creatures from touching you. Choose 1 of the following damage types: Corrosion, Piercing, or Poison. While you are physically Grappled, your Grappler takes 1 damage of the chosen type at the start of each of its turns. Creatures that start their turn Grappled by you also take this damage.',
		cost: 1,
		effects: [
			{
				type: 'GRANT_ABILITY',
				target: 'hazardous_hide',
				value: 'Grapplers take 1 damage (chosen type) per turn.',
				userChoice: { prompt: 'Choose damage type: Corrosion, Piercing, or Poison' }
			}
		]
	},
	{
		id: 'beastborn_intimidating_shout',
		name: 'Intimidating Shout',
		description:
			'Once per Combat, you can spend 1 AP to let out an Intimidating Shout. All creatures within 5 Spaces that can hear you must make a Charisma Save contested by your Attack Check. Failure: A target is Hindered on the next Attack Check or Spell Attack it makes before the start of your next turn.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'intimidating_shout', value: 'Once per Combat, 1 AP: AoE Hinder effect (5 Spaces).' }]
	},

	// Additional Beastborn Traits (Part 2)
	{
		id: 'beastborn_jumper',
		name: 'Jumper',
		description:
			'Your Jump Distance increases by 2, and you can take the Jump Action as a Minor Action.',
		cost: 1,
		effects: [
			{ type: 'GRANT_ABILITY', target: 'increased_jump', value: 'Jump Distance +2.' },
			{ type: 'GRANT_ABILITY', target: 'jump_minor_action', value: 'Jump Action as Minor Action.' }
		]
	},
	{
		id: 'beastborn_limited_flight',
		name: 'Limited Flight',
		description:
			'You have a set of wings that grant you limited flight. Provided you aren\'t Incapacitated, you gain the following benefits: Vertical Ascent: You can spend 2 Spaces of movement to ascend 1 Space vertically. Hover: When you end your turn in the air, you maintain your altitude.',
		cost: 2,
		prerequisites: ['beastborn_glide_speed'],
		effects: [{ type: 'GRANT_MOVEMENT', target: 'limited_flight', value: 'vertical_ascent_hover' }]
	},
	{
		id: 'beastborn_long_limbed',
		name: 'Long-Limbed',
		description: 'When you make a Melee Martial Attack, your reach is 1 Space greater than normal.',
		cost: 3,
		effects: [{ type: 'GRANT_ABILITY', target: 'long_limbed', value: 'Melee reach +1 Space.' }]
	},
	{
		id: 'beastborn_mimicry',
		name: 'Mimicry',
		description:
			'You can mimic simple sounds that you\'ve heard (such as a baby\'s crying, the creak of a door, or single words) and repeat short 3 word phrases that sound identical to what you heard. A creature can make an Insight Check contested by your Trickery Check to determine if this sound is real.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'mimicry', value: 'Mimic simple sounds and 3-word phrases (Trickery vs Insight).' }]
	},
	{
		id: 'beastborn_natural_projectile',
		name: 'Natural Projectile',
		description:
			'You can use your Natural Weapon to make a Ranged Martial Attack with a Range of 10 Spaces. The Natural Weapon might produce a spine, barb, fluid, or other harmful projectile (your choice).',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_ABILITY', target: 'natural_projectile', value: 'Natural Weapon ranged attack (10 Spaces).' }]
	},
	{
		id: 'beastborn_natural_weapon_passive',
		name: 'Natural Weapon Passive',
		description:
			'You can choose 1 Weapon Style that fits your desired Natural Weapon. You can benefit from the chosen Weapon Style\'s passive with your Natural Weapon.',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [
			{
				type: 'GRANT_ABILITY',
				target: 'weapon_style_passive',
				value: 'Natural Weapon gains chosen Weapon Style passive.',
				userChoice: { prompt: 'Choose a Weapon Style' }
			}
		]
	},
	{
		id: 'beastborn_powerful_build',
		name: 'Powerful Build',
		description: 'You increase by 1 Size, but you occupy the Space of a creature 1 Size smaller.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'powerful_build', value: '+1 Size but occupy smaller space.' }]
	},
	{
		id: 'beastborn_prehensile_appendage',
		name: 'Prehensile Appendage',
		description:
			'You have a prehensile tail or trunk that has a reach of 1 Space and can lift up an amount of pounds equal to your Might times 5 (or half as many kilograms). You can use it to lift, hold, or drop objects, and to push, pull, or grapple creatures. It can\'t wield Weapons or Shields, you can\'t use tools with it that require manual precision, and you can\'t use it in place of Somatic Components for Spells.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'prehensile_appendage', value: 'Prehensile tail/trunk (1 Space reach, Might×5 lbs capacity).' }]
	},

	// Additional Beastborn Traits (Part 3 - Final)
	{
		id: 'beastborn_prowler',
		name: 'Prowler',
		description: 'You have ADV on Stealth Checks while in Darkness.',
		cost: 1,
		effects: [{ type: 'GRANT_ADV_ON_CHECK', target: 'Stealth', value: 'while_in_darkness' }]
	},
	{
		id: 'beastborn_quick_reactions',
		name: 'Quick Reactions',
		description: 'While you aren\'t wearing Armor, you gain +1 PD.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'pd', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'beastborn_reckless',
		name: 'Reckless',
		description: 'Your PD decreases by 1.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_STAT', target: 'pd', value: -1 }]
	},
	{
		id: 'beastborn_rend',
		name: 'Rend',
		description:
			'You can spend 1 AP when making an Attack Check with your Natural Weapon to force the target to make a Physical Save. Failure: Target begins Bleeding.',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_ABILITY', target: 'rend', value: '1 AP: Natural Weapon causes Bleeding (Physical Save).' }]
	},
	{
		id: 'beastborn_retractable_natural_weapon',
		name: 'Retractable Natural Weapon',
		description:
			'Your Natural Weapon is able to be concealed or retracted and gains the Concealable Property (gain ADV on the first Attack Check you make in Combat).',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_ABILITY', target: 'retractable_weapon', value: 'Natural Weapon gains Concealable Property.' }]
	},
	{
		id: 'beastborn_secondary_arms',
		name: 'Secondary Arms',
		description:
			'You have 2 slightly smaller secondary arms below your primary pair of arms. They function just like your primary arms, but they can\'t wield Weapons with the Heavy Property or Shields.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'secondary_arms', value: '2 secondary arms (no Heavy weapons or Shields).' }]
	},
	{
		id: 'beastborn_spider_climb',
		name: 'Spider Climb',
		description:
			'You can walk without falling on the ceiling and vertical surfaces normally without needing to Climb.',
		cost: 1,
		prerequisites: ['beastborn_climb_speed'],
		effects: [{ type: 'GRANT_ABILITY', target: 'spider_climb', value: 'Walk on vertical surfaces and ceilings.' }]
	},
	{
		id: 'beastborn_sprint',
		name: 'Sprint',
		description:
			'You can use your Minor Action to take the Move Action. Once you use this Trait, you can\'t use it again until you take a turn without taking the Move Action.',
		cost: 2,
		effects: [{ type: 'GRANT_ABILITY', target: 'sprint', value: 'Move Action as Minor Action (cooldown: no Move Action).' }]
	},
	{
		id: 'beastborn_thick_skinned',
		name: 'Thick-Skinned',
		description: 'While you aren\'t wearing Armor, you gain +1 AD.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'ad', value: 1, condition: 'not_wearing_armor' }]
	},
	{
		id: 'beastborn_tough',
		name: 'Tough',
		description: 'Your HP maximum increases by 2.',
		cost: 1,
		effects: [{ type: 'MODIFY_STAT', target: 'hp', value: 2 }]
	},
	{
		id: 'beastborn_toxic_fortitude',
		name: 'Toxic Fortitude',
		description: 'You have Poison Resistance (Half) and ADV on Saves against being Poisoned.',
		cost: 2,
		effects: [
			{ type: 'GRANT_RESISTANCE', target: 'Poison', value: 'half' },
			{ type: 'GRANT_ADV_ON_SAVE', target: 'Poisoned', value: true }
		]
	},
	{
		id: 'beastborn_venomous_natural_weapon',
		name: 'Venomous Natural Weapon',
		description:
			'You can spend 1 AP when making an Attack Check with your Natural Weapon to force the target to make a Physical Save. Failure: Target becomes Poisoned for 1 minute.',
		cost: 1,
		prerequisites: ['beastborn_natural_weapon'],
		effects: [{ type: 'GRANT_ABILITY', target: 'venomous_weapon', value: '1 AP: Natural Weapon causes Poisoned (Physical Save, 1 minute).' }]
	},
	{
		id: 'beastborn_water_breathing',
		name: 'Water Breathing',
		description: 'You can breathe both air and water.',
		cost: 1,
		effects: [{ type: 'GRANT_ABILITY', target: 'water_breathing', value: 'Breathe air and water.' }]
	},
	{
		id: 'beastborn_web_walk',
		name: 'Web Walk',
		description: 'You ignore movement restrictions caused by webs.',
		cost: 0,
		isMinor: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'web_walk', value: 'Ignore web movement restrictions.' }]
	},
	{
		id: 'beastborn_winged_arms',
		name: 'Winged Arms',
		description: 'Your arms are replaced by wings. You can\'t hold items with your hands while using your wings for flight.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'GRANT_ABILITY', target: 'winged_arms', value: 'Arms are wings (can\'t hold items while flying).' }]
	},
	{
		id: 'beastborn_short_legged',
		name: 'Short-Legged',
		description: 'Your Speed decreases by 1 Space.',
		cost: -1,
		isNegative: true,
		effects: [{ type: 'MODIFY_STAT', target: 'moveSpeed', value: -1 }]
	}
];

// Helper functions for accessing trait data
export const getTraitData = (id: string): Trait | undefined => {
	return traitsData.find(trait => trait.id === id);
};

export const getTraitsByAncestry = (ancestryId: string): Trait[] => {
	return traitsData.filter(trait => trait.id.startsWith(ancestryId + '_'));
};
```

## File: src/App.tsx
```typescript
import { useState } from 'react';
import { createGlobalStyle } from 'styled-components';
import { CharacterProvider } from './lib/stores/characterContext';
import CharacterCreation from './routes/character-creation/CharacterCreation.tsx';
import LoadCharacter from './routes/character-creation/LoadCharacter.tsx';
import CharacterSheetRouter from './routes/character-sheet/CharacterSheetRouter';
import type { SavedCharacter } from './lib/utils/characterEdit';
import LevelUp from './routes/character-creation/LevelUp.tsx';
import { getAllSavedCharacters, saveAllCharacters } from './lib/utils/storageUtils';
import Menu from './components/Menu.tsx';
import {
	StyledApp,
	StyledHeader,
	StyledBackButton,
	StyledMain
} from './styles/App.styles';

// Import static assets
import blackBgImage from '/BlackBG.png';
import cinzelFont from './types/Fonts/Cinzel-VariableFont_wght.ttf';
import urbanistFont from './types/Fonts/Urbanist-VariableFont_wght.ttf';

const GlobalStyle = createGlobalStyle`
  @font-face {
    font-family: 'Cinzel';
    src: url('${cinzelFont}') format('truetype');
    font-weight: 100 900;
    font-style: normal;
  }
  
  @font-face {
    font-family: 'Urbanist';
    src: url('${urbanistFont}') format('truetype');
    font-weight: 100 900;
    font-style: normal;
  }

  * {
    box-sizing: border-box;
  }
  
  html, body {
    margin: 0;
    padding: 0;
    font-family: 'Urbanist', 'Georgia', 'Times New Roman', serif;
    background: url('${blackBgImage}') center/cover no-repeat fixed;
    color: #e5e7eb;
    min-height: 100vh;
    font-weight: 400;
  }
  
  h1, h2, h3, h4, h5, h6 {
    font-family: 'Cinzel', 'Georgia', 'Times New Roman', serif;
  }
  
  #root {
    min-height: 100vh;
  }
  
  /* Remove default focus outlines */
  button:focus {
    outline: none;
  }
  
  /* Custom scrollbar */
  ::-webkit-scrollbar {
    width: 12px;
  }
  
  ::-webkit-scrollbar-track {
    background: #1e1b4b;
  }
  
  ::-webkit-scrollbar-thumb {
    background: #fbbf24;
    border-radius: 6px;
  }
  
  ::-webkit-scrollbar-thumb:hover {
    background: #f1bf3eff;
  }
  
  /* Selection colors */
  ::selection {
    background: #fbbf24;
    color: #1e1b4b;
  }
  
  ::-moz-selection {
    background: #fbbf24;
    color: #1e1b4b;
  }
`;

function App() {
	const [currentView, setCurrentView] = useState<'menu' | 'create' | 'load' | 'sheet' | 'levelup'>(
		'menu'
	);
	const [selectedCharacterId, setSelectedCharacterId] = useState<string | null>(null);
	const [editCharacter, setEditCharacter] = useState<SavedCharacter | null>(null);
	const [levelUpCharacter, setLevelUpCharacter] = useState<SavedCharacter | null>(null);

	const handleCreateCharacter = () => {
		setEditCharacter(null); // Clear edit mode
		setCurrentView('create');
	};

	const handleLoadCharacter = () => {
		setCurrentView('load');
	};

	const handleEditCharacter = (character: SavedCharacter) => {
		setEditCharacter(character);
		setCurrentView('create');
	};

	const handleLevelUp = (character: SavedCharacter) => {
		setLevelUpCharacter(character);
		setCurrentView('levelup');
	};

	const handleViewCharacterSheet = (characterId: string) => {
		setSelectedCharacterId(characterId);
		setCurrentView('sheet');
	};



	const handleBackToMenu = () => {
		setCurrentView('menu');
		setSelectedCharacterId(null);
		setEditCharacter(null);
		setLevelUpCharacter(null);
	};

	const renderCurrentView = () => {
		switch (currentView) {
			case 'menu':
				return (
					<Menu onCreateCharacter={handleCreateCharacter} onLoadCharacter={handleLoadCharacter} />
				);
			case 'create':
				return (
					<CharacterProvider>
						<StyledHeader>
							<StyledBackButton onClick={handleBackToMenu}>← Back to Menu</StyledBackButton>
						</StyledHeader>
						<StyledMain>
							<CharacterCreation
								onNavigateToLoad={handleLoadCharacter}
								onBackToMenu={handleBackToMenu}
								editCharacter={editCharacter || undefined}
							/>
						</StyledMain>
					</CharacterProvider>
				);
			case 'load':
				return (
					<LoadCharacter
						onBack={handleBackToMenu}
						onSelectCharacter={handleViewCharacterSheet}
						onEditCharacter={handleEditCharacter}
						onLevelUp={handleLevelUp}
					/>
				);
			case 'levelup':
				return (
					<CharacterProvider>
						<StyledHeader>
							<StyledBackButton onClick={handleBackToMenu}>← Back to Menu</StyledBackButton>
							<span>Level Up Character</span>
						</StyledHeader>
						<StyledMain>
							<LevelUp
								character={levelUpCharacter!}
								onComplete={(updatedCharacter: SavedCharacter) => {
									// Update the character in the list and go back to load screen
									const savedCharacters = getAllSavedCharacters();
									const characterIndex = savedCharacters.findIndex((c: SavedCharacter) => c.id === updatedCharacter.id);
									if (characterIndex !== -1) {
										savedCharacters[characterIndex] = updatedCharacter;
										saveAllCharacters(savedCharacters);
									}
									handleLoadCharacter();
								}}
								onBack={handleBackToMenu}
							/>
						</StyledMain>
					</CharacterProvider>
				);
			case 'sheet':
				return selectedCharacterId ? (
					<CharacterSheetRouter characterId={selectedCharacterId} onBack={handleBackToMenu} />
				) : null;

			default:
				return null;
		}
	};

	return (
		<>
			<GlobalStyle />
			<StyledApp>
				{renderCurrentView()}
			</StyledApp>
		</>
	);
}

export default App;
```

## File: src/lib/stores/characterContext.tsx
```typescript
import React, { createContext, useContext, useReducer, useMemo, ReactNode } from 'react';
import type { CharacterInProgress } from '@prisma/client';
import { traitsData } from '../rulesdata/_new_schema/traits';
import { findClassByName } from '../rulesdata/loaders/class-features.loader';
import { classesData } from '../rulesdata/loaders/class.loader';
import { calculateTraitCosts } from '../utils/traitCosts';

// Define the shape of the data stored in the character store
export interface CharacterInProgressStoreData extends Omit<CharacterInProgress, 'selectedTraitIds' | 'selectedFeatureChoices' | 'skillsJson' | 'tradesJson' | 'languagesJson' | 'selectedTraitChoices' | 'selectedSpells' | 'selectedManeuvers'> {
    currentStep: number;
    overflowTraitId: string | null;
    overflowAttributeName: string | null;
    level: number;
    combatMastery: number;
    selectedTraitIds: string[];
    selectedFeatureChoices: Record<string, any>;
    selectedTraitChoices: Record<string, string>;
    skillsData: Record<string, number>;
    tradesData: Record<string, number>;
    languagesData: Record<string, { fluency: 'limited' | 'fluent' }>;
    cachedEffectResults?: string;
    cacheTimestamp?: number;
    selectedSpells: string[];
    selectedManeuvers: string[];
    skillToTradeConversions?: number;
    tradeToSkillConversions?: number;
    tradeToLanguageConversions?: number;
    schemaVersion?: number;
}

// Initial state for the store
const initialCharacterInProgressState: CharacterInProgressStoreData = {
    id: '',
    attribute_might: -2,
    attribute_agility: -2,
    attribute_charisma: -2,
    attribute_intelligence: -2,
    pointsSpent: 0,
    level: 1,
    combatMastery: 1,
    ancestry1Id: null,
    ancestry2Id: null,
    selectedTraitIds: [],
    ancestryPointsSpent: 0,
    classId: null,
    selectedFeatureChoices: {},
    saveMasteryMight: false,
    saveMasteryAgility: false,
    saveMasteryCharisma: false,
    saveMasteryIntelligence: false,
    finalName: null,
    finalPlayerName: null,
    createdAt: new Date(),
    updatedAt: new Date(),
    currentStep: 1,
    overflowTraitId: null,
    overflowAttributeName: null,
    skillsData: {},
    tradesData: {},
    languagesData: { common: { fluency: 'fluent' } },
    selectedTraitChoices: {},
    cachedEffectResults: undefined,
    cacheTimestamp: undefined,
    selectedSpells: [],
    selectedManeuvers: [],
    skillToTradeConversions: 0,
    tradeToSkillConversions: 0,
    tradeToLanguageConversions: 0,
    schemaVersion: 2
};

// Action types
type CharacterAction =
    | { type: 'UPDATE_ATTRIBUTE'; attribute: string; value: number }
    | { type: 'UPDATE_SKILLS'; skillsData: Record<string, number> }
    | { type: 'UPDATE_TRADES'; tradesData: Record<string, number> }
    | { type: 'UPDATE_LANGUAGES'; languagesData: Record<string, { fluency: 'limited' | 'fluent' }> }
    | { type: 'SET_CLASS'; classId: string | null }
    | { type: 'SET_ANCESTRY'; ancestry1Id: string | null; ancestry2Id: string | null }
    | { type: 'SET_TRAITS'; selectedTraitIds: string[] }
    | { type: 'SET_FEATURE_CHOICES'; selectedFeatureChoices: Record<string, any> }
    | { type: 'UPDATE_TRAIT_CHOICE'; traitId: string; effectIndex: number; choice: string }
    | { type: 'INVALIDATE_CACHE' }
    | { type: 'UPDATE_SPELLS_AND_MANEUVERS'; spells: string[]; maneuvers: string[] }
    | { type: 'UPDATE_STORE'; updates: Partial<CharacterInProgressStoreData> }
    | { type: 'INITIALIZE_FROM_SAVED'; character: CharacterInProgressStoreData }
    | { type: 'NEXT_STEP' }
    | { type: 'PREVIOUS_STEP' }
    | { type: 'SET_STEP'; step: number }
    | { type: 'SET_CONVERSIONS'; conversions: { skillToTrade?: number; tradeToSkill?: number; tradeToLanguage?: number } };

// Reducer function
function characterReducer(
    state: CharacterInProgressStoreData,
    action: CharacterAction
): CharacterInProgressStoreData {
    switch (action.type) {
        case 'UPDATE_ATTRIBUTE':
            return { ...state, [action.attribute]: action.value };
        case 'UPDATE_SKILLS':
            return { ...state, skillsData: action.skillsData };
        case 'UPDATE_TRADES':
            return { ...state, tradesData: action.tradesData };
        case 'UPDATE_LANGUAGES':
            return { ...state, languagesData: action.languagesData };
        case 'SET_CLASS':
            return { ...state, classId: action.classId };
        case 'SET_ANCESTRY':
            return { ...state, ancestry1Id: action.ancestry1Id, ancestry2Id: action.ancestry2Id };
        case 'SET_TRAITS':
            return { ...state, selectedTraitIds: action.selectedTraitIds };
        case 'SET_FEATURE_CHOICES':
            return { ...state, selectedFeatureChoices: action.selectedFeatureChoices };
        case 'UPDATE_TRAIT_CHOICE': {
            const currentChoices = { ...state.selectedTraitChoices };
            const choiceKey = `${action.traitId}-${action.effectIndex}`;
            if (action.choice === '') {
                delete currentChoices[choiceKey];
            } else {
                currentChoices[choiceKey] = action.choice;
            }
            return { ...state, selectedTraitChoices: currentChoices, cachedEffectResults: undefined, cacheTimestamp: undefined };
        }
        case 'INVALIDATE_CACHE':
            return { ...state, cachedEffectResults: undefined, cacheTimestamp: undefined };
        case 'UPDATE_SPELLS_AND_MANEUVERS':
            return { ...state, selectedSpells: action.spells, selectedManeuvers: action.maneuvers };
        case 'UPDATE_STORE':
            return { ...state, ...action.updates };
        case 'INITIALIZE_FROM_SAVED':
            return { ...action.character };
        case 'NEXT_STEP':
            return { ...state, currentStep: Math.min(state.currentStep + 1, 7) };
        case 'PREVIOUS_STEP':
            return { ...state, currentStep: Math.max(state.currentStep - 1, 1) };
        case 'SET_STEP':
            return { ...state, currentStep: Math.max(1, Math.min(action.step, 7)) };
        case 'SET_CONVERSIONS':
            return {
                ...state,
                skillToTradeConversions: action.conversions.skillToTrade ?? state.skillToTradeConversions ?? 0,
                tradeToSkillConversions: action.conversions.tradeToSkill ?? state.tradeToSkillConversions ?? 0,
                tradeToLanguageConversions: action.conversions.tradeToLanguage ?? state.tradeToLanguageConversions ?? 0
            };
        default:
            return state;
    }
}

// Context type
interface CharacterContextType {
    state: CharacterInProgressStoreData;
    dispatch: React.Dispatch<CharacterAction>;
    attributePointsRemaining: number;
    attributePointsSpent: number;
    totalAttributePoints: number;
    ancestryPointsRemaining: number;
    ancestryPointsSpent: number;
    totalAncestryPoints: number;
    combatMastery: number;
    primeModifier: { name: string; value: number };
}

const CharacterContext = createContext<CharacterContextType | undefined>(undefined);

export function CharacterProvider({ children }: { children: ReactNode }) {
    const [state, dispatch] = useReducer(characterReducer, initialCharacterInProgressState);

    const derivedValues = useMemo(() => {
        const selectedTraitIds: string[] = state.selectedTraitIds;
        
        const bonusAttributePoints = selectedTraitIds.reduce((total, traitId) => {
            const trait = traitsData.find(t => t.id === traitId);
            return total + (trait?.effects.reduce((subTotal, effect) => {
                if (effect.type === 'MODIFY_STAT' && effect.target === 'attributePoints') {
                    return subTotal + (effect.value as number);
                }
                return subTotal;
            }, 0) || 0);
        }, 0);

        const totalAttributePoints = 12 + bonusAttributePoints;
        const attributePointsSpent = (state.attribute_might + 2) + (state.attribute_agility + 2) + (state.attribute_charisma + 2) + (state.attribute_intelligence + 2);
        const attributePointsRemaining = totalAttributePoints - attributePointsSpent;

        const ancestryPointsSpent = calculateTraitCosts(selectedTraitIds);
        const totalAncestryPoints = 5; // This can be enhanced later to include bonuses
        const ancestryPointsRemaining = totalAncestryPoints - ancestryPointsSpent;

        const combatMastery = Math.ceil((state.level ?? 1) / 2);

        const attributes = [
            { name: 'Might', value: state.attribute_might },
            { name: 'Agility', value: state.attribute_agility },
            { name: 'Charisma', value: state.attribute_charisma },
            { name: 'Intelligence', value: state.attribute_intelligence }
        ];
        const primeModifier = attributes.reduce((prev, curr) => (curr.value > prev.value ? curr : prev));

        return {
            attributePointsRemaining,
            attributePointsSpent,
            totalAttributePoints,
            ancestryPointsRemaining,
            ancestryPointsSpent,
            totalAncestryPoints,
            combatMastery,
            primeModifier
        };
    }, [state]);

    const contextValue: CharacterContextType = {
        state,
        dispatch,
        ...derivedValues
    };

    return <CharacterContext.Provider value={contextValue}>{children}</CharacterContext.Provider>;
}

export function useCharacter() {
    const context = useContext(CharacterContext);
    if (context === undefined) {
        throw new Error('useCharacter must be used within a CharacterProvider');
    }
    return context;
}
```

## File: src/routes/character-creation/components/BackgroundPointsManager.tsx
```typescript
import React from 'react';
import { traitsData } from '../../../lib/rulesdata/_new_schema/traits';

// Mastery system interfaces and data
export interface MasteryInfo {
	level: number;
	name: string;
	bonus: number;
	available: boolean;
}

export interface MasteryValidation {
	valid: boolean;
	adeptCount: number;
	message?: string;
}

export interface MasteryLimits {
	maxSkillMastery: number;
	maxTradeMastery: number;
	level1Validation: MasteryValidation;
}

export const MASTERY_TABLE = [
	{ level: 0, name: 'Untrained', bonus: 0 },
	{ level: 1, name: 'Novice', bonus: 2 },
	{ level: 2, name: 'Adept', bonus: 4 },
	{ level: 3, name: 'Expert', bonus: 6 },
	{ level: 4, name: 'Master', bonus: 8 },
	{ level: 5, name: 'Grandmaster', bonus: 10 }
];

export interface BackgroundPointsData {
	skillPointsUsed: number;
	tradePointsUsed: number;
	languagePointsUsed: number;
	baseSkillPoints: number;
	baseTradePoints: number;
	baseLanguagePoints: number;
	availableSkillPoints: number;
	availableTradePoints: number;
	availableLanguagePoints: number;
}

export interface PointConversions {
	skillToTradeConversions: number;
	tradeToSkillConversions: number;
	tradeToLanguageConversions: number;
}

export interface ConversionActions {
	convertSkillToTrade: () => void;
	convertTradeToSkill: () => void;
	convertTradeToLanguage: () => void;
	resetConversions: () => void;
}

// Mastery utility functions
export const getBaseMasteryLimit = (characterLevel: number): number => {
	if (characterLevel >= 20) return 5; // Grandmaster
	if (characterLevel >= 15) return 4; // Master
	if (characterLevel >= 10) return 3; // Expert
	if (characterLevel >= 5) return 2; // Adept
	if (characterLevel >= 1) return 2; // Level 1 characters can reach Adept (level 2)
	return 1; // Novice
};

export const getClassMasteryBonuses = (
	classFeatures: any,
	selectedFeatureChoices: Record<string, string>,
	type: 'skill' | 'trade'
): number => {
	if (!classFeatures || !selectedFeatureChoices) return 0;

	let bonus = 0;
	try {
		const selectedChoices: { [key: string]: string } = selectedFeatureChoices;
		const level1Features = classFeatures.coreFeatures?.filter(
			(feature: any) => feature.levelGained === 1
		);

		level1Features?.forEach((feature: any) => {
			if (feature.choices) {
				feature.choices.forEach((choice: any, choiceIndex: number) => {
					const choiceId = `${classFeatures.className.toLowerCase()}_${feature.featureName
						.toLowerCase()
						.replace(/\s+/g, '_')}_${choiceIndex}`;
					const selectedOptions = selectedChoices[choiceId];

					if (selectedOptions) {
						let optionsToProcess: string[] = [];
						try {
							optionsToProcess = JSON.parse(selectedOptions);
							if (!Array.isArray(optionsToProcess)) {
								optionsToProcess = [selectedOptions];
							}
						} catch {
							optionsToProcess = [selectedOptions];
						}

						optionsToProcess.forEach((optionName) => {
							const selectedOption = choice.options?.find(
								(opt: any) => opt.name === optionName
							);
							if (selectedOption) {
								const description = selectedOption.description.toLowerCase();

								if (type === 'skill') {
									if (
										description.includes('skill mastery limit') ||
										description.includes('skill mastery cap')
									) {
										const masteryMatch = description.match(/increases? by (\d+)/i);
										if (masteryMatch) {
											bonus += parseInt(masteryMatch[1]);
										}
									}
								} else if (type === 'trade') {
									if (
										description.includes('mastery limit') &&
										(description.includes('trade') || description.includes('knowledge'))
									) {
										const masteryMatch = description.match(/increases? by (\d+)/i);
										if (masteryMatch) {
											bonus += parseInt(masteryMatch[1]);
										}
									}
								}
							}
						});
					}
				});
			}
		});
	} catch (error) {
		console.warn('Error calculating class mastery bonuses:', error);
	}
	return bonus;
};

export const validateLevel1MasteryRule = (
	skills: Record<string, number>,
	trades: Record<string, number>
): MasteryValidation => {
	const allMasteries = { ...skills, ...trades };
	const adeptCount = Object.values(allMasteries).filter((level) => level === 2).length;

	return {
		valid: adeptCount <= 1,
		adeptCount,
		message:
			adeptCount > 1
				? `Level 1 characters can only have ONE Adept skill/trade (currently: ${adeptCount})`
				: undefined
	};
};

// Separate validation for skills only
export const validateLevel1SkillMasteryRule = (
	skills: Record<string, number>
): MasteryValidation => {
	const skillAdeptCount = Object.values(skills).filter((level) => level === 2).length;

	return {
		valid: skillAdeptCount <= 1,
		adeptCount: skillAdeptCount,
		message:
			skillAdeptCount > 1
				? `Level 1 characters can only have ONE Adept skill (currently: ${skillAdeptCount})`
				: undefined
	};
};

export const getMasteryInfo = (level: number, maxMastery: number): MasteryInfo => {
	const masteryData = MASTERY_TABLE[level] || MASTERY_TABLE[0];
	return {
		level,
		name: masteryData.name,
		bonus: masteryData.bonus,
		available: level <= maxMastery
	};
};

export const useBackgroundPoints = (
	skillPointsUsed: number,
	tradePointsUsed: number,
	languagePointsUsed: number,
	intelligenceModifier: number,
	characterLevel: number = 1,
	classFeatures: any = null,
	selectedFeatureChoices: Record<string, string> = {},
	currentSkills: Record<string, number> = {},
	currentTrades: Record<string, number> = {},
	selectedTraitIds: string | string[] = '',
	state: any = null
) => {
	const [skillToTradeConversions, setSkillToTradeConversions] = React.useState(0);
	const [tradeToSkillConversions, setTradeToSkillConversions] = React.useState(0);
	const [tradeToLanguageConversions, setTradeToLanguageConversions] = React.useState(0);

	// Calculate bonus points from traits and class features
	const calculateBonusPoints = (targetStat: string): number => {
		let bonusPoints = 0;

		// From traits - FIXED: Handle both array (new) and JSON string (legacy) formats
		if (selectedTraitIds && state) {
			try {
				const selectedTraitIdsList: string[] = Array.isArray(selectedTraitIds) 
					? selectedTraitIds 
					: JSON.parse(selectedTraitIds);
				
				selectedTraitIdsList.forEach(traitId => {
					const trait = traitsData.find((t: any) => t.id === traitId);
					
					if (trait) {
						trait.effects.forEach((effect: any) => {
							if (effect.type === 'MODIFY_STAT' && effect.target === targetStat) {
								bonusPoints += (effect.value as number);
							}
						});
					}
				});
			} catch (error) {
				console.warn(`Error calculating ${targetStat} from traits:`, error);
			}
		}

		// From class features
		if (classFeatures && selectedFeatureChoices) {
			try {
				const selectedChoices: { [key: string]: string } = selectedFeatureChoices;
				const level1Features = classFeatures.coreFeatures.filter(
					(feature: any) => feature.levelGained === 1
				);

				level1Features.forEach((feature: any) => {
					// Check for direct feature effects first
					if (feature.effects) {
						feature.effects.forEach((effect: any) => {
							if (effect.type === 'MODIFY_STAT' && effect.target === targetStat) {
								bonusPoints += (effect.value as number);
							}
						});
					}

					// Check for choice-based effects
					if (feature.choices) {
						feature.choices.forEach((choice: any, choiceIndex: number) => {
							const choiceId = `${classFeatures.className.toLowerCase()}_${feature.featureName.toLowerCase().replace(/\s+/g, '_')}_${choiceIndex}`;
							const selectedOptions = selectedChoices[choiceId];

							if (selectedOptions) {
								let optionsToProcess: string[] = [];
								
								try {
									optionsToProcess = JSON.parse(selectedOptions);
									if (!Array.isArray(optionsToProcess)) {
										optionsToProcess = [selectedOptions];
									}
								} catch {
									optionsToProcess = [selectedOptions];
								}

								optionsToProcess.forEach((optionName) => {
									const selectedOption = choice.options?.find((opt: any) => opt.name === optionName);
									
									if (selectedOption && selectedOption.effects) {
										selectedOption.effects.forEach((effect: any) => {
											if (effect.type === 'MODIFY_STAT' && effect.target === targetStat) {
												bonusPoints += (effect.value as number);
											}
										});
									}
								});
							}
						});
					}
				});
			} catch (error) {
				console.warn(`Error calculating ${targetStat} from class features:`, error);
			}
		}

		return bonusPoints;
	};

	// Base points according to DC20 rules
	const bonusSkillPoints = calculateBonusPoints('skillPoints');
	const bonusTradePoints = calculateBonusPoints('tradePoints');
	const bonusLanguagePoints = calculateBonusPoints('languagePoints');
	

	
	const baseSkillPoints = 5 + intelligenceModifier + bonusSkillPoints;
	const baseTradePoints = 3 + bonusTradePoints;
	const baseLanguagePoints = 2 + bonusLanguagePoints;

	// Calculate available points after conversions
	const availableSkillPoints =
		baseSkillPoints - skillToTradeConversions + Math.floor(tradeToSkillConversions / 2);
	const availableTradePoints =
		baseTradePoints -
		tradeToSkillConversions +
		skillToTradeConversions * 2 -
		tradeToLanguageConversions;
	const availableLanguagePoints = baseLanguagePoints + tradeToLanguageConversions * 2;

	// Conversion functions
	const convertSkillToTrade = () => {
		if (skillPointsUsed + 1 <= availableSkillPoints) {
			setSkillToTradeConversions((prev) => prev + 1);
		}
	};

	const convertTradeToSkill = () => {
		if (
			tradeToSkillConversions + 2 <= baseTradePoints + skillToTradeConversions * 2 &&
			tradePointsUsed + 2 <= availableTradePoints
		) {
			setTradeToSkillConversions((prev) => prev + 2);
		}
	};

	const convertTradeToLanguage = () => {
		if (availableTradePoints - tradePointsUsed >= 1) {
			setTradeToLanguageConversions((prev) => prev + 1);
		}
	};

	const resetConversions = () => {
		setSkillToTradeConversions(0);
		setTradeToSkillConversions(0);
		setTradeToLanguageConversions(0);
	};

	// Calculate mastery limits
	const baseMasteryLimit = getBaseMasteryLimit(characterLevel);
	const skillMasteryBonus = getClassMasteryBonuses(classFeatures, selectedFeatureChoices, 'skill');
	const tradeMasteryBonus = getClassMasteryBonuses(classFeatures, selectedFeatureChoices, 'trade');
	
	const maxSkillMastery = Math.min(5, baseMasteryLimit + skillMasteryBonus);
	const maxTradeMastery = Math.min(5, baseMasteryLimit + tradeMasteryBonus);
	
	const level1Validation = characterLevel === 1 
		? validateLevel1MasteryRule(currentSkills, currentTrades)
		: { valid: true, adeptCount: 0 };

	const masteryLimits: MasteryLimits = {
		maxSkillMastery,
		maxTradeMastery,
		level1Validation
	};

	const pointsData: BackgroundPointsData = {
		skillPointsUsed,
		tradePointsUsed,
		languagePointsUsed,
		baseSkillPoints,
		baseTradePoints,
		baseLanguagePoints,
		availableSkillPoints,
		availableTradePoints,
		availableLanguagePoints
	};

	const conversions: PointConversions = {
		skillToTradeConversions,
		tradeToSkillConversions,
		tradeToLanguageConversions
	};

	const actions: ConversionActions = {
		convertSkillToTrade,
		convertTradeToSkill,
		convertTradeToLanguage,
		resetConversions
	};

	return { pointsData, conversions, actions, masteryLimits };
};
```

## File: src/routes/character-creation/CharacterCreation.tsx
```typescript
import React, { useState, useEffect } from 'react';
import { useCharacter } from '../../lib/stores/characterContext';
import { classesData } from '../../lib/rulesdata/loaders/class.loader';
import { findClassByName } from '../../lib/rulesdata/loaders/class-features.loader';
import AncestrySelector from './AncestrySelector.tsx';
import SelectedAncestries from './SelectedAncestries.tsx';
import Attributes from './Attributes.tsx';
import ClassSelector from './ClassSelector.tsx';
import ClassFeatures from './ClassFeatures.tsx';
import Background from './Background.tsx';
import SpellsAndManeuvers from './SpellsAndManeuvers.tsx';
import CharacterName from './CharacterName.tsx';
import Snackbar from '../../components/Snackbar.tsx';
import { completeCharacter } from '../../lib/services/characterCompletion';
import {
	completeCharacterEdit,
	convertCharacterToInProgress,
	type SavedCharacter
} from '../../lib/utils/characterEdit';
import { convertToEnhancedBuildData, calculateCharacterWithBreakdowns } from '../../lib/services/enhancedCharacterCalculator';
import { traitsData } from '../../lib/rulesdata/_new_schema/traits';
import {
	StyledContainer,
	StyledTitle,
	StyledStepIndicator,
	StyledStepsContainer,
	StyledStep,
	StyledStepNumber,
	StyledStepLabel,
	StyledNavigationButtons,
	StyledButton
} from './styles/CharacterCreation.styles';

interface CharacterCreationProps {
	onNavigateToLoad: () => void;
	onBackToMenu: () => void;
	editCharacter?: SavedCharacter; // If provided, we're in edit mode
	isLevelUp?: boolean; // If true, we're in level up mode
}

const CharacterCreation: React.FC<CharacterCreationProps> = ({
	onNavigateToLoad,
	editCharacter,
	onBackToMenu,
	isLevelUp
}) => {
	const { state, dispatch, attributePointsRemaining, ancestryPointsRemaining } = useCharacter();
	const [snackbarMessage, setSnackbarMessage] = useState('');
	const [showSnackbar, setShowSnackbar] = useState(false);

	// Initialize character state for edit mode
	useEffect(() => {
		if (editCharacter) {
			console.log('🔄 CharacterCreation: Initializing edit mode for character:', editCharacter);
			const characterInProgress = convertCharacterToInProgress(editCharacter);
			console.log('🔄 CharacterCreation: Converted to in-progress format:', {
				selectedSpells: characterInProgress.selectedSpells,
				selectedManeuvers: characterInProgress.selectedManeuvers
			});

			// Initialize the character state with the existing character data
			dispatch({ type: 'INITIALIZE_FROM_SAVED', character: characterInProgress });
		}
	}, [editCharacter, dispatch]);

	const steps = [
		{ number: 1, label: 'Class & Features' },
		{ number: 2, label: 'Ancestry' },
		{ number: 3, label: 'Attributes' },
		{ number: 4, label: 'Background' },
		{ number: 5, label: 'Spells & Maneuvers' },
		{ number: 6, label: 'Character Name' }
	];

	const handleStepClick = (step: number) => {
		dispatch({ type: 'SET_STEP', step });
	};

	const handleNext = async () => {
		if (state.currentStep === 6 && areAllStepsCompleted()) {
			// Character is complete - check if we're editing or creating new
			if (editCharacter) {
				// Edit mode: use the enhanced completion that preserves manual modifications
				// Use enhanced calculator for character editing
				const supportedClasses = ['barbarian', 'cleric', 'hunter', 'champion', 'wizard', 'monk', 'rogue', 'sorcerer', 'spellblade', 'warlock', 'bard', 'druid', 'commander'];
				
				if (supportedClasses.includes(state.classId || '')) {
					// Convert to enhanced format and calculate
					const enhancedData = convertToEnhancedBuildData(state);
					const enhancedResult = calculateCharacterWithBreakdowns(enhancedData);
					
                    // Create a calculation function that returns the enhanced result (including breakdowns)
                    const enhancedCalculatorFn = async () => ({ 
                        ...enhancedResult.stats,
                        grantedAbilities: enhancedResult.grantedAbilities,
                        conditionalModifiers: enhancedResult.conditionalModifiers,
                        breakdowns: enhancedResult.breakdowns
                    });
					
					await completeCharacterEdit(editCharacter.id, state, enhancedCalculatorFn);
				} else {
					// All classes are now migrated to the enhanced calculator
					throw new Error(`Class "${state.classId}" is not supported. All classes should be migrated to the enhanced calculator.`);
				}
				setSnackbarMessage('Character updated successfully! Manual modifications preserved.');
				setShowSnackbar(true);
				setTimeout(() => onNavigateToLoad(), 2000);
			} else {
				// Create mode: use standard completion
				await completeCharacter(state, {
					onShowSnackbar: (message: string) => {
						setSnackbarMessage(message);
						setShowSnackbar(true);
					},
					onNavigateToLoad: onNavigateToLoad
				});
			}
			return;
		} else {
			dispatch({ type: 'NEXT_STEP' });
		}
	};

	const handlePrevious = () => {
		if (state.currentStep === 1) {
			onBackToMenu(); // Go back to home screen when on first step
		} else {
			dispatch({ type: 'PREVIOUS_STEP' });
		}
	};

	const isStepCompleted = (step: number) => {
		switch (step) {
			case 1: {
				if (state.classId === null) return false;

				// Check if all required feature choices have been made
				const selectedClass = classesData.find((c) => c.id.toLowerCase() === state.classId?.toLowerCase());
				if (!selectedClass) return false;

				// Check if all required feature choices have been made
				const selectedClassFeatures = findClassByName(selectedClass.name);
				if (!selectedClassFeatures) return false;

				// FIXED: Use typed data instead of JSON parsing
				const selectedFeatureChoices: { [key: string]: string } = state.selectedFeatureChoices || {};

				// Check if spell school choices are required and have been made
				const spellList = selectedClassFeatures.spellcastingPath?.spellList;
				if (spellList) {
					// Check Warlock-style spell school selection
					if (spellList.type === 'all_schools' && spellList.schoolCount) {
						const choiceId = `${selectedClassFeatures.className.toLowerCase()}_spell_schools`;
						const choice = selectedFeatureChoices[choiceId];
						if (!choice) return false;
						// Expect arrays directly (no more legacy JSON string support)
						const selectedSchools = Array.isArray(choice) ? choice : [choice];
						if (selectedSchools.length !== spellList.schoolCount) return false;
					}

					// Check Spellblade-style additional school selection
					if (spellList.type === 'schools' && spellList.schoolCount && spellList.schoolCount > 0) {
						const choiceId = `${selectedClassFeatures.className.toLowerCase()}_additional_spell_schools`;
						const choice = selectedFeatureChoices[choiceId];
						if (!choice) return false;
						if (spellList.schoolCount > 1) {
							const selectedSchools = Array.isArray(choice) ? choice : [choice];
							if (selectedSchools.length !== spellList.schoolCount) return false;
						}
					}

					// Check Wizard-style feature-based spell school choices
					const level1Features = selectedClassFeatures.coreFeatures.filter(
						(feature) => feature.levelGained === 1
					);
					for (const feature of level1Features) {
						const description = feature.description.toLowerCase();
						// Only include features that are character creation choices, not in-game tactical choices
						const isCharacterCreationChoice =
							(description.includes('choose a spell school') ||
								description.includes('choose 1 spell school')) &&
							// Exclude in-game features like Arcane Sigil
							!description.includes('when you create') &&
							!description.includes('when you cast') &&
							!description.includes('you can spend') &&
							// Include features that are clearly character creation (like training/specialization)
							(description.includes('training') ||
								description.includes('specialize') ||
								description.includes('initiate') ||
								description.includes('you gain the following benefits'));

						if (isCharacterCreationChoice) {
							const choiceId = `${selectedClassFeatures.className.toLowerCase()}_${feature.featureName.toLowerCase().replace(/\s+/g, '_')}_school`;
							if (!selectedFeatureChoices[choiceId]) return false;
						}
					}
				}

				return true;
			}
			case 2: {
				const isValid = state.ancestry1Id !== null && ancestryPointsRemaining >= 0;
				console.log('🔍 Step 2 (Ancestry) validation:', {
					ancestry1Id: state.ancestry1Id,
					ancestryPointsRemaining,
					isValid
				});
				return isValid;
			}
			case 3:
				return attributePointsRemaining === 0;
			case 4: {
				// Background: check if ALL available points have been spent
				// Parse current selections
				let skillPointsUsed = 0;
				let tradePointsUsed = 0;
				let languagePointsUsed = 0;

				// FIXED: Use typed skillsData instead of JSON parsing
				if (state.skillsData && Object.keys(state.skillsData).length > 0) {
					skillPointsUsed = Object.values(state.skillsData).reduce(
						(sum: number, level: number) => sum + level,
						0
					);
				}

				// FIXED: Use typed tradesData instead of JSON parsing
				if (state.tradesData && Object.keys(state.tradesData).length > 0) {
					tradePointsUsed = Object.values(state.tradesData).reduce(
						(sum: number, level: number) => sum + level,
						0
					);
				}

				// FIXED: Use typed languagesData instead of JSON parsing
				if (state.languagesData && Object.keys(state.languagesData).length > 0) {
					languagePointsUsed = Object.entries(state.languagesData).reduce(
						(sum, [langId, data]: [string, { fluency?: string }]) => {
							if (langId === 'common') return sum; // Common is free
							return (
								sum +
								(data.fluency === 'basic'
									? 1
									: data.fluency === 'advanced'
										? 2
										: data.fluency === 'fluent'
											? 3
											: 0)
							);
						},
						0
					);
				}

                // Available points should match BackgroundPointsManager (include bonus points and conversions)
                const intelligenceModifier = state.attribute_intelligence;
                
                // Calculate bonus skill points from traits and class features (same logic as BackgroundPointsManager)
                let bonusSkillPoints = 0;
                
                // From traits - FIXED: Use typed data instead of JSON parsing
                if (state.selectedTraitIds && Array.isArray(state.selectedTraitIds)) {
                    const selectedTraitIdsList: string[] = state.selectedTraitIds;
                    
                    console.log('🔍 Selected trait IDs:', selectedTraitIdsList);
                    
                    selectedTraitIdsList.forEach((traitId: string) => {
                            const trait = traitsData.find((t: any) => t.id === traitId);
                            console.log(`🔍 Processing trait ${traitId}:`, trait);
                            if (trait) {
                                trait.effects.forEach((effect: any) => {
                                    if (effect.type === 'MODIFY_STAT' && effect.target === 'skillPoints') {
                                        console.log(`🔍 Found skillPoints bonus: +${effect.value} from trait ${traitId}`);
                                        bonusSkillPoints += (effect.value as number);
                                    }
                                });
                            } else {
                                console.warn(`🚨 Trait not found: ${traitId}`);
                            }
                        });
                }
                
                // From class features  
                if (state.classId && state.selectedFeatureChoices) {
                    try {
                        const selectedClass = classesData.find((c) => c.id.toLowerCase() === state.classId?.toLowerCase());
                        const classFeatures = selectedClass ? findClassByName(selectedClass.name) : null;
                        
                        if (classFeatures) {
                            // FIXED: Use typed data instead of JSON parsing
                            const selectedChoices: { [key: string]: string } = state.selectedFeatureChoices || {};
                            const level1Features = classFeatures.coreFeatures.filter(
                                (feature: any) => feature.levelGained === 1
                            );

                            level1Features.forEach((feature: any) => {
                                // Check for direct feature effects first
                                if (feature.effects) {
                                    feature.effects.forEach((effect: any) => {
                                        if (effect.type === 'MODIFY_STAT' && effect.target === 'skillPoints') {
                                            bonusSkillPoints += (effect.value as number);
                                        }
                                    });
                                }

                                // Check for choice-based effects
                                if (feature.choices) {
                                    feature.choices.forEach((choice: any, choiceIndex: number) => {
                                        const choiceId = `${classFeatures.className.toLowerCase()}_${feature.featureName.toLowerCase().replace(/\s+/g, '_')}_${choiceIndex}`;
                                        const selectedOptions = selectedChoices[choiceId];

                                        if (selectedOptions) {
                                            let optionsToProcess: string[] = [];
                                            
                                            // Expect arrays directly (no more legacy JSON string support)
                                            if (Array.isArray(selectedOptions)) {
                                                optionsToProcess = selectedOptions;
                                            } else {
                                                optionsToProcess = [selectedOptions];
                                            }

                                            optionsToProcess.forEach((optionName) => {
                                                const selectedOption = choice.options?.find((opt: any) => opt.name === optionName);
                                                if (selectedOption && selectedOption.effects) {
                                                    selectedOption.effects.forEach((effect: any) => {
                                                        if (effect.type === 'MODIFY_STAT' && effect.target === 'skillPoints') {
                                                            bonusSkillPoints += (effect.value as number);
                                                        }
                                                    });
                                                }
                                            });
                                        }
                                    });
                                }
                            });
                        }
                    } catch (error) {
                        // Ignore parsing errors
                    }
                }
                
                const baseSkillPoints = Math.max(1, 5 + intelligenceModifier + bonusSkillPoints);
                
                console.log('🔍 Skill Points Calculation:', {
                    base: 5,
                    intelligence: intelligenceModifier,
                    bonusFromTraits: bonusSkillPoints,
                    total: baseSkillPoints
                });
                const skillToTrade = state.skillToTradeConversions || 0;
                const tradeToSkill = state.tradeToSkillConversions || 0;
                const availableSkillPoints = baseSkillPoints - skillToTrade + Math.floor(tradeToSkill / 2);

                // For completion, require exact spend of available skill points
                const skillPointsRemaining = availableSkillPoints - skillPointsUsed;
				const hasExactlySpentAllSkillPoints = skillPointsRemaining === 0;
				// Calculate available trade and language points using same logic as BackgroundPointsManager
				let bonusTradePoints = 0;
				let bonusLanguagePoints = 0;
				
				// Check for ancestry bonuses (simplified calculation)
				const baseTradePoints = 3 + bonusTradePoints;
				const baseLanguagePoints = 2 + bonusLanguagePoints;
				
				const availableTradePoints = baseTradePoints + Math.floor(skillToTrade / 2) - Math.floor(tradeToSkill / 2);
				const availableLanguagePoints = baseLanguagePoints; // No conversions affect language points currently
				
				// Allow completion if all skill points are spent AND either:
				// 1. Some trade/language points were spent, OR 
				// 2. No trade/language points are available to spend
				const hasSpentSomeTradeOrLanguagePoints = tradePointsUsed > 0 || languagePointsUsed > 0;
				const hasNoTradeOrLanguagePointsToSpend = availableTradePoints <= 0 && availableLanguagePoints <= 0;
				
				const isValid = hasExactlySpentAllSkillPoints && (hasSpentSomeTradeOrLanguagePoints || hasNoTradeOrLanguagePointsToSpend);

				console.log('🔍 Step 4 (Background) validation:', {
					baseSkillPoints,
					bonusSkillPoints,
					skillToTrade,
					tradeToSkill,
					availableSkillPoints,
					skillPointsUsed,
					skillPointsRemaining,
					baseTradePoints,
					baseLanguagePoints,
					availableTradePoints,
					availableLanguagePoints,
					tradePointsUsed,
					languagePointsUsed,
					hasExactlySpentAllSkillPoints,
					hasSpentSomeTradeOrLanguagePoints,
					hasNoTradeOrLanguagePointsToSpend,
					isValid
				});

				return isValid;
			}
			case 5:
				// Spells & Maneuvers step - validate based on class requirements
				if (!state.classId) return false;

				// Get class data to determine what's required
				const selectedClass = classesData.find((c) => c.id.toLowerCase() === state.classId?.toLowerCase());
				if (!selectedClass) return false;

				const selectedClassFeatures = findClassByName(selectedClass.name);
				if (!selectedClassFeatures) return false;

				// Parse current selections
				let selectedSpells: string[] = [];
				let selectedManeuvers: string[] = [];

				// Use typed arrays directly
				selectedSpells = state.selectedSpells || [];
				selectedManeuvers = state.selectedManeuvers || [];

				// Check if class has spellcasting
				const hasSpellcasting = selectedClassFeatures.spellcastingPath?.spellList;
				
				// Check if class has maneuvers (simplified check based on class features)
				// For now, we'll use a simple heuristic: classes that are primarily martial have maneuvers
				const martialClasses = ['barbarian', 'champion', 'hunter', 'monk', 'rogue'];
				const hasManeuvers = martialClasses.includes(selectedClass.name.toLowerCase());

				// If class has spellcasting, require spell selections
				if (hasSpellcasting) {
					// For classes with spellcasting, require at least some spell selections
					// The exact number depends on the class, but we'll require at least 1
					if (selectedSpells.length === 0) return false;
				}

				// If class has maneuvers, require maneuver selections
				if (hasManeuvers) {
					// For classes with maneuvers, require at least some maneuver selections
					// The exact number depends on the class, but we'll require at least 1
					if (selectedManeuvers.length === 0) return false;
				}

				// If class has neither spells nor maneuvers, step is complete
				if (!hasSpellcasting && !hasManeuvers) {
					return true;
				}

				// Step is complete if all required selections are made
				return true;
			case 6:
				return (
					state.finalName !== null &&
					state.finalName !== '' &&
					state.finalPlayerName !== null &&
					state.finalPlayerName !== ''
				);
			default:
				return false;
		}
	};

	const areAllStepsCompleted = () => {
		const results = steps.map((step) => ({
			step: step.number,
			label: step.label,
			completed: isStepCompleted(step.number)
		}));
		
		const allCompleted = results.every((result) => result.completed);
		
		console.log('🔍 areAllStepsCompleted check:', {
			results,
			allCompleted
		});
		
		return allCompleted;
	};

	const renderCurrentStep = () => {
		switch (state.currentStep) {
			case 1:
				return (
					<>
						<ClassSelector />
						<ClassFeatures />
					</>
				);
			case 2:
				return (
					<>
						<AncestrySelector />
						<SelectedAncestries />
					</>
				);
			case 3:
				return <Attributes />;
			case 4:
				return <Background />;
			case 5:
				return <SpellsAndManeuvers />;
			case 6:
				return <CharacterName />;
			default:
				return null;
		}
	};

	return (
		<div>
			<StyledTitle>
				{editCharacter ? `Edit Character: ${editCharacter.finalName}` : 'Character Creation'}
			</StyledTitle>

			<StyledStepIndicator>
				<StyledNavigationButtons>
					<StyledButton
						$variant="secondary"
						onClick={handlePrevious}
					>
						← Previous
					</StyledButton>
				</StyledNavigationButtons>

				<StyledStepsContainer>
					{steps.map((step) => (
						<StyledStep
							key={step.number}
							$active={state.currentStep === step.number}
							$completed={isStepCompleted(step.number)}
							onClick={() => handleStepClick(step.number)}
						>
							<StyledStepNumber
								$active={state.currentStep === step.number}
								$completed={isStepCompleted(step.number)}
							>
								{isStepCompleted(step.number) ? '✓' : step.number}
							</StyledStepNumber>
							<StyledStepLabel
								$active={state.currentStep === step.number}
								$completed={isStepCompleted(step.number)}
							>
								{step.label}
							</StyledStepLabel>
						</StyledStep>
					))}
				</StyledStepsContainer>

				<StyledNavigationButtons>
					<StyledButton
						$variant="primary"
						onClick={handleNext}
						disabled={state.currentStep === 6 && !areAllStepsCompleted()}
					>
						{state.currentStep === 6 ? 'Complete' : 'Next →'}
					</StyledButton>
				</StyledNavigationButtons>
			</StyledStepIndicator>

			<StyledContainer>{renderCurrentStep()}</StyledContainer>

			<Snackbar
				message={snackbarMessage}
				isVisible={showSnackbar}
				onClose={() => setShowSnackbar(false)}
				duration={3000}
			/>
		</div>
	);
};

export default CharacterCreation;
```

## File: src/routes/character-sheet/CharacterSheetClean.tsx
```typescript
import React, { useState, useEffect } from 'react';

// Import types
import type {
	CharacterSheetProps,
	CharacterSheetData,
	SkillData,
	TradeData,
	LanguageData,
	FeatureData,
	CurrentValues,
	AttackData,
	SpellData,
	InventoryItemData,
	CharacterState
} from '../../types';
import type { Spell } from '../../lib/rulesdata/spells-data/types/spell.types';
import type { Weapon } from '../../lib/rulesdata/inventoryItems';
import type { InventoryItem } from '../../lib/rulesdata/inventoryItems';
import type { ManeuverData } from './components/Maneuvers';
import type { Maneuver } from '../../lib/rulesdata/maneuvers';
import {
	getVersatileDamage,
	getWeaponRange,
	getWeaponFeatures,
	parseDamage
} from '../../lib/utils/weaponUtils';
import { getAllSavedCharacters, getCharacterById } from '../../lib/utils/storageUtils';
import type { SavedCharacter } from '../../lib/types/dataContracts';

// Legacy JSON parsing function - removed in favor of typed data contracts

// Import new component modules
import LeftColumn from './components/LeftColumn';
import Currency from './components/Currency';
import Resources from './components/Resources';
import Defenses from './components/Defenses';
import Combat from './components/Combat';
import Attacks from './components/Attacks';
import Spells from './components/Spells';
import Maneuvers from './components/Maneuvers';
import Inventory from './components/Inventory';
import Features from './components/Features';
import Movement from './components/Movement';
import RightColumnResources from './components/RightColumnResources';
import DeathExhaustion from './components/DeathExhaustion';

import PlayerNotes from './components/PlayerNotes';
import DiceRoller from './components/DiceRoller';

// Import modal components
import FeaturePopup from './components/FeaturePopup';
import SpellPopup from './components/SpellPopup';
import AttackPopup from './components/AttackPopup';
import InventoryPopup from './components/InventoryPopup';

// Import character state management utilities
import {
	getCharacterState,
	initializeCharacterState,
	saveCharacterState,
	updateCharacterState,
	revertToOriginal,
	characterStateToCurrentValues
} from '../../lib/utils/characterState';

// Import defense notes utilities
import { clearDefenseNotesForField } from '../../lib/utils/defenseNotes';

// Import rules data
import { skillsData } from '../../lib/rulesdata/skills';
import { tradesData } from '../../lib/rulesdata/trades';
import { knowledgeData } from '../../lib/rulesdata/knowledge';
import { traitsData } from '../../lib/rulesdata/_new_schema/traits';
import {
	findClassByName,
	getClassSpecificInfo,
	getLegacyChoiceId,
	getDisplayLabel
} from '../../lib/rulesdata/loaders/class-features.loader';
import { ancestriesData } from '../../lib/rulesdata/ancestries';
import { getDetailedClassFeatureDescription } from '../../lib/utils/classFeatureDescriptions';

// Import styled components
import {
	StyledContainer,
	StyledBackButton,
	StyledCharacterSheet,
	StyledMainGrid,
	StyledLeftColumn,
	StyledMiddleColumn,
	StyledRightColumn,
	StyledMobileNav,
	StyledMobileNavButton,
	StyledActionButtons,
	StyledActionButton
} from './styles/Layout';

import { StyledHeader, StyledHeaderSection, StyledLabel, StyledValue } from './styles/Header';

import { calculateDeathThreshold } from '../../lib/rulesdata/death';
import { allSpells } from '../../lib/rulesdata/spells-data/spells';
import { allManeuvers } from '../../lib/rulesdata/maneuvers';

// Character data service - NOW OPTIMIZED: trusts stored data as single source of truth
const getCharacterData = async (characterId: string): Promise<CharacterSheetData> => {
	console.log('Loading character data for ID:', characterId);

	// Use new typed storage utility
	const character = getCharacterById(characterId);

	if (!character) {
		throw new Error(`Character with ID "${characterId}" not found in localStorage`);
	}

	console.log('🔍 getCharacterData: Raw character data from storage:', {
		id: character.id,
		name: character.finalName,
		hasSpells: !!character.spells,
		spellsLength: character.spells?.length || 0,
		spells: character.spells,
		hasSelectedSpells: !!(character as any).selectedSpells,
		selectedSpells: (character as any).selectedSpells
	});

	// Return the character data as-is since it's already calculated, but ensure trait and feature data is included
	// Fix missing or invalid prime modifier values (legacy data compatibility)
	const fixedCharacter = { ...character };

	// Handle legacy selectedSpells conversion if needed
	if ((!fixedCharacter.spells || fixedCharacter.spells.length === 0) && (character as any).selectedSpells) {
		try {
			const selectedSpellNames = JSON.parse((character as any).selectedSpells);
			console.log('🔍 Converting legacy selectedSpells to SpellData[]:', selectedSpellNames);

			if (Array.isArray(selectedSpellNames) && selectedSpellNames.length > 0) {
				// Convert selected spell names to SpellData objects
				const userSelectedSpells = selectedSpellNames.map((spellName: string) => {
					const fullSpell = allSpells.find(s => s.name === spellName);
					if (fullSpell) {
						return {
							id: `spell_${Date.now()}_${Math.random()}`,
							spellName: fullSpell.name,
							school: fullSpell.school,
							isCantrip: fullSpell.isCantrip,
							cost: fullSpell.cost,
							range: fullSpell.range,
							duration: fullSpell.duration,
							isPrepared: true,
							notes: ''
						};
					}
					return null;
				}).filter(Boolean);

				fixedCharacter.spells = userSelectedSpells;
				console.log('🔍 getCharacterData: Converted spells:', userSelectedSpells.map(s => s.spellName));
			}
		} catch (error) {
			console.error('🔍 getCharacterData: Error parsing selectedSpells:', error);
		}
	}



	// Recalculate prime modifier if missing or invalid
	if (!fixedCharacter.finalPrimeModifierValue || isNaN(fixedCharacter.finalPrimeModifierValue)) {
		const attributes = {
			might: fixedCharacter.finalMight || 0,
			agility: fixedCharacter.finalAgility || 0,
			charisma: fixedCharacter.finalCharisma || 0,
			intelligence: fixedCharacter.finalIntelligence || 0
		};

		const maxValue = Math.max(...Object.values(attributes));
		const primeAttribute = Object.keys(attributes).find(
			key => attributes[key as keyof typeof attributes] === maxValue
		) || 'might';

		fixedCharacter.finalPrimeModifierValue = maxValue;
		fixedCharacter.finalPrimeModifierAttribute = primeAttribute;
	}

	// Fix missing combat mastery
	if (!fixedCharacter.finalCombatMastery || isNaN(fixedCharacter.finalCombatMastery)) {
		fixedCharacter.finalCombatMastery = Math.ceil((fixedCharacter.finalLevel || 1) / 2);
	}

	// OPTIMIZED: Trust the stored data - it's the single source of truth
	// No recalculation needed! This provides 50%+ performance improvement
	console.log('🚀 OPTIMIZED: Using stored data as single source of truth (no recalculation needed)');
	
	return {
		...fixedCharacter,
		// Ensure compatibility fields for legacy components
		selectedTraitIds: Array.isArray(fixedCharacter.selectedTraitIds) 
			? JSON.stringify(fixedCharacter.selectedTraitIds)
			: (fixedCharacter.selectedTraitIds || '[]'),
		selectedFeatureChoices: typeof fixedCharacter.selectedFeatureChoices === 'object'
			? JSON.stringify(fixedCharacter.selectedFeatureChoices)
			: (fixedCharacter.selectedFeatureChoices || '{}')
	} as CharacterSheetData;
};

// LEGACY: saveManualDefense function removed - now handled by CharacterSheetProvider

const CharacterSheet: React.FC<CharacterSheetProps> = ({ characterId, onBack }) => {
	const [characterData, setCharacterData] = useState<CharacterSheetData | null>(null);
	const [characterState, setCharacterState] = useState<CharacterState | null>(null);
	// Keep currentValues for backwards compatibility with existing components
	const [currentValues, setCurrentValues] = useState<CurrentValues>({
		currentHP: 0,
		currentSP: 0,
		currentMP: 0,
		currentGritPoints: 0,
		currentRestPoints: 0,
		tempHP: 0,
		actionPointsUsed: 0,
		exhaustionLevel: 0,
		// Currency
		goldPieces: 0,
		silverPieces: 0,
		copperPieces: 0,
		electrumPieces: 0,
		platinumPieces: 0
	});
	const [loading, setLoading] = useState(true);
	const [error, setError] = useState<string | null>(null);
	const [selectedFeature, setSelectedFeature] = useState<FeatureData | null>(null);
	const [selectedSpell, setSelectedSpell] = useState<Spell | null>(null);
	const [selectedManeuver, setSelectedManeuver] = useState<Maneuver | null>(null);
	const [selectedAttack, setSelectedAttack] = useState<{
		attack: AttackData;
		weapon: Weapon | null;
	} | null>(null);
	const [selectedInventoryItem, setSelectedInventoryItem] = useState<{
		inventoryData: InventoryItemData;
		item: InventoryItem | null;
	} | null>(null);
	const [attacks, setAttacks] = useState<AttackData[]>([]);
	const [spells, setSpells] = useState<SpellData[]>([]);
	const [maneuvers, setManeuvers] = useState<ManeuverData[]>([]);
	const [inventory, setInventory] = useState<InventoryItemData[]>([]);



	// Mobile navigation state
	type MobileSection = 'character' | 'combat' | 'features' | 'info';
	const [activeMobileSection, setActiveMobileSection] = useState<MobileSection>('character');
	const [isMobile, setIsMobile] = useState(false);

	// Check if mobile resolution
	useEffect(() => {
		const checkMobile = () => {
			setIsMobile(window.innerWidth <= 768);
		};

		checkMobile();
		window.addEventListener('resize', checkMobile);
		return () => window.removeEventListener('resize', checkMobile);
	}, []);

	// Save character current values back to localStorage using comprehensive state management
	const saveCharacterData = (characterId: string, currentValues: CurrentValues) => {
		updateCharacterState(characterId, {
			resources: {
				original: characterState?.resources.original || {
					maxHP: characterData?.finalHPMax || 0,
					maxSP: characterData?.finalSPMax || 0,
					maxMP: characterData?.finalMPMax || 0,
					maxGritPoints: characterData?.finalGritPoints || 0,
					maxRestPoints: characterData?.finalRestPoints || 0
				},
				current: {
					currentHP: currentValues.currentHP,
					currentSP: currentValues.currentSP,
					currentMP: currentValues.currentMP,
					currentGritPoints: currentValues.currentGritPoints,
					currentRestPoints: currentValues.currentRestPoints,
					tempHP: currentValues.tempHP,
					actionPointsUsed: currentValues.actionPointsUsed,
					exhaustionLevel: currentValues.exhaustionLevel
				}
			},
			currency: {
				original: characterState?.currency.original || {
					goldPieces: 0,
					silverPieces: 0,
					copperPieces: 0,
					electrumPieces: 0,
					platinumPieces: 0
				},
				current: {
					goldPieces: currentValues.goldPieces,
					silverPieces: currentValues.silverPieces,
					copperPieces: currentValues.copperPieces,
					electrumPieces: currentValues.electrumPieces,
					platinumPieces: currentValues.platinumPieces
				}
			}
		});
	};

	// Save attacks to comprehensive state
	const saveAttacksData = (newAttacks: AttackData[]) => {
		updateCharacterState(characterId, {
			attacks: {
				original: characterState?.attacks.original || [],
				current: newAttacks
			}
		});
	};

	// Save spells to comprehensive state
	const saveSpellsData = (newSpells: SpellData[]) => {
		updateCharacterState(characterId, {
			spells: {
				original: characterState?.spells.original || [],
				current: newSpells
			}
		});
	};

	// Save maneuvers to comprehensive state
	const saveManeuversData = (newManeuvers: ManeuverData[]) => {
		updateCharacterState(characterId, {
			maneuvers: {
				original: characterState?.maneuvers.original || [],
				current: newManeuvers
			}
		});
	};

	// Save inventory to comprehensive state
	const saveInventoryData = (newInventory: InventoryItemData[]) => {
		updateCharacterState(characterId, {
			inventory: {
				original: characterState?.inventory.original || [],
				current: newInventory
			}
		});
	};

	// Wrapper for setAttacks that also saves to comprehensive state
	const updateAttacks = (newAttacks: AttackData[] | ((prev: AttackData[]) => AttackData[])) => {
		setAttacks((prev) => {
			const result = typeof newAttacks === 'function' ? newAttacks(prev) : newAttacks;
			saveAttacksData(result);
			return result;
		});
	};

	// Wrapper for setSpells that also saves to comprehensive state
	const updateSpells = (newSpells: SpellData[] | ((prev: SpellData[]) => SpellData[])) => {
		setSpells((prev) => {
			const result = typeof newSpells === 'function' ? newSpells(prev) : newSpells;
			saveSpellsData(result);
			return result;
		});
	};

	// Wrapper for setManeuvers that also saves to comprehensive state
	const updateManeuvers = (newManeuvers: ManeuverData[] | ((prev: ManeuverData[]) => ManeuverData[])) => {
		setManeuvers((prev) => {
			const result = typeof newManeuvers === 'function' ? newManeuvers(prev) : newManeuvers;
			saveManeuversData(result);
			return result;
		});
	};

	// Wrapper for setInventory that also saves to comprehensive state
	const updateInventory = (
		newInventory: InventoryItemData[] | ((prev: InventoryItemData[]) => InventoryItemData[])
	) => {
		setInventory((prev) => {
			const result = typeof newInventory === 'function' ? newInventory(prev) : newInventory;
			saveInventoryData(result);
			return result;
		});
	};

	// Load character data
	useEffect(() => {
		const loadCharacterData = async () => {
			try {
				setLoading(true);
				setError(null);

				// Load the character data from API
				const data = await getCharacterData(characterId);
				setCharacterData(data);

				// Get existing character state from localStorage
				const existingState = getCharacterState(characterId);

				// Initialize comprehensive character state
				const initialState = initializeCharacterState(data, existingState);
				setCharacterState(initialState);

				// Save the initial state to localStorage if it doesn't exist
				if (!existingState) {
					saveCharacterState(characterId, initialState);
					console.log('Initial character state saved to localStorage');
				}

				// Update component states from the comprehensive state
				const legacyCurrentValues = characterStateToCurrentValues(initialState);
				setCurrentValues(legacyCurrentValues);
				setAttacks(initialState.attacks?.current || []);
				setSpells(initialState.spells?.current || []);
				setManeuvers(initialState.maneuvers?.current || []);
				setInventory(initialState.inventory?.current || []);

				console.log('Character sheet loaded with spells:', {
					spellsOriginal: initialState.spells?.original,
					spellsCurrent: initialState.spells?.current,
					spellsLength: initialState.spells?.current?.length || 0
				});

				console.log('Character data and state loaded:', {
					characterData: data,
					characterState: initialState,
					legacyCurrentValues
				});
			} catch (err) {
				setError(err instanceof Error ? err.message : 'An error occurred');
			} finally {
				setLoading(false);
			}
		};

		loadCharacterData();
	}, [characterId]);

	// Calculate original defense values using enhanced calculator for supported classes
	const getCalculatedDefenses = () => {
		if (!characterData)
			return {
				calculatedPD: 0,
				calculatedPDR: 0,
				calculatedAD: 0,
				pdBreakdown: '',
				adBreakdown: '',
				pdrBreakdown: ''
			};

		// OPTIMIZED: Trust stored defense values and breakdowns (no recalculation needed)
		let calculatedPD, calculatedAD, calculatedPDR;
		let pdBreakdown, adBreakdown, pdrBreakdown;

		// Use stored values - they are the single source of truth
		calculatedPD = characterData.finalPD;
		calculatedAD = characterData.finalAD;
		calculatedPDR = characterData.finalPDR;

		// Use stored breakdowns if available, otherwise create simple fallback
		const storedBreakdowns = (characterData as any).breakdowns || {};
		
		pdBreakdown = storedBreakdowns.pd?.effects ?
			storedBreakdowns.pd.effects.map((e: any) => `${e.value > 0 ? '+' : ''}${e.value} (${e.source.name || e.source})`).join(' ') + ` = ${calculatedPD}` :
			`8 (base) + ${characterData.finalCombatMastery} (Combat Mastery) + ${characterData.finalAgility} (Agility) + ${characterData.finalIntelligence} (Intelligence) = ${calculatedPD}`;

		adBreakdown = storedBreakdowns.ad?.effects ?
			storedBreakdowns.ad.effects.map((e: any) => `${e.value > 0 ? '+' : ''}${e.value} (${e.source.name || e.source})`).join(' ') + ` = ${calculatedAD}` :
			`8 (base) + ${characterData.finalCombatMastery} (Combat Mastery) + ${characterData.finalMight} (Might) + ${characterData.finalCharisma} (Charisma) = ${calculatedAD}`;

		pdrBreakdown = calculatedPDR > 0
			? `${calculatedPDR} (from stored calculation)`
			: '0 (no PDR)';

		console.log('🚀 OPTIMIZED: Using stored defense values (no recalculation needed)');

		return {
			calculatedPD,
			calculatedPDR,
			calculatedAD,
			pdBreakdown,
			adBreakdown,
			pdrBreakdown
		};
	};

	// Resource management functions with auto-save
	const adjustResource = (resource: keyof CurrentValues, amount: number) => {
		setCurrentValues((prev) => {
			const newValue = prev[resource] + amount;
			let maxValue = 999;

			switch (resource) {
				case 'currentHP':
					// HP can go up to normal max + temp HP
					maxValue = (characterData?.finalHPMax || 0) + prev.tempHP;
					break;
				case 'currentSP':
					maxValue = characterData?.finalSPMax || 0;
					break;
				case 'currentMP':
					maxValue = characterData?.finalMPMax || 0;
					break;
				case 'currentGritPoints':
					maxValue = characterData?.finalGritPoints || 0;
					break;
				case 'currentRestPoints':
					maxValue = characterData?.finalRestPoints || 0;
					break;
				case 'actionPointsUsed':
					maxValue = 4; // Standard AP limit
					break;
				case 'exhaustionLevel':
					maxValue = 5; // Max exhaustion level
					break;
			}

			const newValues = {
				...prev,
				[resource]: Math.max(0, Math.min(newValue, maxValue))
			};

			// Special case: when reducing temp HP, cap current HP to new effective max
			if (resource === 'tempHP' && amount < 0) {
				const newEffectiveMaxHP = (characterData?.finalHPMax || 0) + newValues.tempHP;
				if (prev.currentHP > newEffectiveMaxHP) {
					newValues.currentHP = newEffectiveMaxHP;
				}
			}

			// Save to localStorage after state update
			if (characterData?.id) {
				setTimeout(() => saveCharacterData(characterData.id, newValues), 0);
			}

			return newValues;
		});
	};

	const handleResourceInputChange = (resource: keyof CurrentValues, value: string) => {
		const numValue = parseInt(value) || 0;
		let maxValue = 999;

		switch (resource) {
			case 'currentHP':
				// HP can go up to normal max + temp HP
				maxValue = (characterData?.finalHPMax || 0) + currentValues.tempHP;
				break;
			case 'currentSP':
				maxValue = characterData?.finalSPMax || 0;
				break;
			case 'currentMP':
				maxValue = characterData?.finalMPMax || 0;
				break;
			case 'currentGritPoints':
				maxValue = characterData?.finalGritPoints || 0;
				break;
			case 'currentRestPoints':
				maxValue = characterData?.finalRestPoints || 0;
				break;
			case 'actionPointsUsed':
				maxValue = 4;
				break;
			case 'exhaustionLevel':
				maxValue = 5;
				break;
		}

		setCurrentValues((prev) => {
			const newValues = {
				...prev,
				[resource]: Math.max(0, Math.min(numValue, maxValue))
			};

			// Special case: when changing temp HP directly, cap current HP to new effective max
			if (resource === 'tempHP') {
				const newEffectiveMaxHP = (characterData?.finalHPMax || 0) + newValues.tempHP;
				if (prev.currentHP > newEffectiveMaxHP) {
					newValues.currentHP = newEffectiveMaxHP;
				}
			}

			// Save to localStorage after state update
			if (characterData?.id) {
				setTimeout(() => saveCharacterData(characterData.id, newValues), 0);
			}

			return newValues;
		});
	};

	const handleManualDefenseChange = (
		field: 'manualPD' | 'manualPDR' | 'manualAD',
		value: number | undefined
	) => {
		if (!characterData?.id) return;

		// Save to localStorage
		saveManualDefense(characterData.id, field, value);

		// Update local character data
		setCharacterData((prev) => {
			if (!prev) return prev;
			return {
				...prev,
				[field]: value
			};
		});
	};

	// Parse skills data from character - show ALL skills with their proficiency levels and calculated bonuses
	const getSkillsData = (): SkillData[] => {
		// Parse character's skill proficiencies (if any)
		let characterSkills: Record<string, number> = {};
		if (characterData?.skillsData) {
			characterSkills = characterData.skillsData;
		} else if (characterData?.skillsJson) {
			try {
				characterSkills = JSON.parse(characterData.skillsJson);
			} catch (error) {
				console.error('Error parsing skills JSON:', error);
			}
		}

		// Create skill data for ALL skills from rules data, merging with character's proficiencies
		return skillsData.map((skill) => {
			const proficiency = characterSkills[skill.id] || 0;
			const masteryBonus = proficiency * 2;

			// Get attribute modifier based on skill's attribute association
			let attributeModifier = 0;
			switch (skill.attributeAssociation.toLowerCase()) {
				case 'might':
					attributeModifier = characterData?.finalMight || 0;
					break;
				case 'agility':
					attributeModifier = characterData?.finalAgility || 0;
					break;
				case 'charisma':
					attributeModifier = characterData?.finalCharisma || 0;
					break;
				case 'intelligence':
					attributeModifier = characterData?.finalIntelligence || 0;
					break;
				case 'prime':
					// For prime skills, use the prime modifier value
					attributeModifier = characterData?.finalPrimeModifierValue || 0;
					break;
				default:
					attributeModifier = 0;
			}

			const totalBonus = attributeModifier + masteryBonus;

			return {
				id: skill.id,
				name: skill.name,
				attribute: skill.attributeAssociation,
				proficiency,
				bonus: totalBonus
			};
		});
	};

	// Parse trades data from character - show ONLY selected trades with their proficiency levels and calculated bonuses
	const getTradesData = (): TradeData[] => {
		// Parse character's trade proficiencies (if any)
		let characterTrades: Record<string, number> = {};
		if (characterData?.tradesData) {
			characterTrades = characterData.tradesData;
		} else if (characterData?.tradesJson) {
			try {
				characterTrades = JSON.parse(characterData.tradesJson);
			} catch (error) {
				console.error('Error parsing trades JSON:', error);
			}
		}

		// Only show trades that have been selected (proficiency > 0) from tradesData only
		return tradesData
			.filter((trade) => characterTrades[trade.id] && characterTrades[trade.id] > 0)
			.map((trade) => {
				const proficiency = characterTrades[trade.id] || 0;
				const masteryBonus = proficiency * 2;

				// Get attribute modifier based on trade's attribute association
				let attributeModifier = 0;
				switch (trade.attributeAssociation.toLowerCase()) {
					case 'might':
						attributeModifier = characterData?.finalMight || 0;
						break;
					case 'agility':
						attributeModifier = characterData?.finalAgility || 0;
						break;
					case 'charisma':
						attributeModifier = characterData?.finalCharisma || 0;
						break;
					case 'intelligence':
						attributeModifier = characterData?.finalIntelligence || 0;
						break;
					default:
						attributeModifier = 0;
				}

				const totalBonus = attributeModifier + masteryBonus;

				return {
					id: trade.id,
					name: trade.name,
					proficiency,
					bonus: totalBonus
				};
			});
	};

	// Parse knowledge data from character - show ALL knowledge with their proficiency levels and calculated bonuses
	const getKnowledgeData = (): TradeData[] => {
		// Parse character's trade proficiencies (if any) - knowledge is stored in tradesData
		let characterTrades: Record<string, number> = {};
		if (characterData?.tradesData) {
			characterTrades = characterData.tradesData;
		} else if (characterData?.tradesJson) {
			try {
				characterTrades = JSON.parse(characterData.tradesJson);
			} catch (error) {
				console.error('Error parsing trades JSON:', error);
			}
		}

		// Show ALL knowledge skills with their proficiency levels and calculated bonuses
		return knowledgeData.map((knowledge) => {
			const proficiency = characterTrades[knowledge.id] || 0;
			const masteryBonus = proficiency * 2;

			// Get attribute modifier based on knowledge's attribute association
			let attributeModifier = 0;
			switch (knowledge.attributeAssociation.toLowerCase()) {
				case 'might':
					attributeModifier = characterData?.finalMight || 0;
					break;
				case 'agility':
					attributeModifier = characterData?.finalAgility || 0;
					break;
				case 'charisma':
					attributeModifier = characterData?.finalCharisma || 0;
					break;
				case 'intelligence':
					attributeModifier = characterData?.finalIntelligence || 0;
					break;
				default:
					attributeModifier = 0;
			}

			const totalBonus = attributeModifier + masteryBonus;

			return {
				id: knowledge.id,
				name: knowledge.name,
				proficiency,
				bonus: totalBonus
			};
		});
	};

	// Parse languages data from character
	const getLanguagesData = (): LanguageData[] => {
		if (!characterData?.languagesData && !characterData?.languagesJson) {
			return [];
		}

		try {
			const languagesFromDB = characterData.languagesData || JSON.parse(characterData.languagesJson || '[]');

			return Object.entries(languagesFromDB)
				.filter(([_, data]: [string, any]) => data.fluency !== 'none')
				.map(([langId, data]: [string, any]) => ({
					id: langId,
					name: data.name || langId.charAt(0).toUpperCase() + langId.slice(1),
					fluency: data.fluency as 'limited' | 'fluent'
				}));
		} catch (error) {
			console.error('Error parsing languages JSON:', error);
			return [];
		}
	};

	// Get class-specific display information generically
	const getClassDisplayInfo = (): { label: string; value: string }[] => {
		if (!characterData?.className || !characterData?.selectedFeatureChoices) {
			return [];
		}

		const { displayInfo } = getClassSpecificInfo(
			characterData.className,
			characterData.selectedFeatureChoices
		);
		return displayInfo;
	};

	// Get all features (traits and class features) for the character
	const getFeaturesData = (): FeatureData[] => {
		if (!characterData) return [];

		const features: FeatureData[] = [];

		// Get ancestry default traits
		const ancestry1 = ancestriesData.find((a) => a.name === characterData.ancestry1Name);
		if (ancestry1) {
			ancestry1.defaultTraitIds?.forEach((traitId) => {
				const trait = traitsData.find((t) => t.id === traitId);
				if (trait) {
					features.push({
						id: trait.id,
						name: trait.name,
						description: trait.description,
						source: 'ancestry',
						sourceDetail: `${ancestry1.name} (Default)`
					});
				}
			});
		}

		// Get selected ancestry traits
		if (characterData.selectedTraitIds) {
			try {
				const selectedTraitIds: string[] = Array.isArray(characterData.selectedTraitIds) 
					? characterData.selectedTraitIds 
					: JSON.parse(characterData.selectedTraitIds);
				selectedTraitIds.forEach((traitId) => {
					const trait = traitsData.find((t) => t.id === traitId);
					if (trait) {
						// Check if this trait is not already added as default
						const alreadyAdded = features.some((f) => f.id === trait.id);
						if (!alreadyAdded) {
							const sourceAncestry = ancestriesData.find(
								(a) => a.expandedTraitIds.includes(traitId) || a.defaultTraitIds?.includes(traitId)
							);
							features.push({
								id: trait.id,
								name: trait.name,
								description: trait.description,
								source: 'ancestry',
								sourceDetail: `${sourceAncestry?.name || 'Unknown'} (Selected)`
							});
						}
					}
				});
			} catch (error) {
				console.error('Error parsing selected traits JSON:', error);
			}
		}

		// Get class features from the new class features structure
		const selectedClassFeatures = findClassByName(characterData.className);

		if (selectedClassFeatures) {
			// Add level 1 core features
			selectedClassFeatures.coreFeatures
				.filter((feature) => feature.levelGained === 1)
				.forEach((feature) => {
					features.push({
						id: feature.featureName,
						name: feature.featureName,
						description: feature.description,
						source: 'class',
						sourceDetail: `${selectedClassFeatures.className} (Lvl 1)`
					});
				});

			// Add selected feature choices
			if (characterData.selectedFeatureChoices) {
				try {
					const selectedChoices: { [key: string]: string } = JSON.parse(
						characterData.selectedFeatureChoices
					);

					// Process each core feature that has choices
					selectedClassFeatures.coreFeatures.forEach((feature) => {
						if (feature.choices) {
							feature.choices.forEach((choice, choiceIndex) => {
								// Use the same mapping logic as the class-features loader
								const choiceId = getLegacyChoiceId(
									selectedClassFeatures.className,
									feature.featureName,
									choiceIndex
								);
								const selectedOptionValues = selectedChoices[choiceId];

								if (selectedOptionValues && choice.options) {
									if (choice.count > 1) {
										// Handle multiple selections (like cleric domains)
										const selectedValueArray: string[] = JSON.parse(selectedOptionValues);

										selectedValueArray.forEach((value) => {
											const selectedOption = choice.options?.find((opt) => opt.name === value);

											if (selectedOption) {
												// Get the detailed description
												let description = selectedOption.description || 'Feature choice selected.';
												const detailedDescription = getDetailedClassFeatureDescription(
													choiceId,
													value
												);
												if (detailedDescription) {
													description = detailedDescription;
												}

												// Use generic display label
												const displayLabel = getDisplayLabel(
													selectedClassFeatures.className,
													feature.featureName,
													choiceIndex
												);
												const sourceDetail = `${selectedClassFeatures.className} (${displayLabel})`;

												const featureToAdd = {
													id: `${choiceId}_${value}`,
													name: selectedOption.name,
													description: description,
													source: 'choice' as const,
													sourceDetail: sourceDetail
												};
												features.push(featureToAdd);
											}
										});
									} else {
										// Handle single selections
										const selectedOption = choice.options?.find(
											(opt) => opt.name === selectedOptionValues
										);
										if (selectedOption) {
											// Get the detailed description
											let description = selectedOption.description || 'Feature choice selected.';
											const detailedDescription = getDetailedClassFeatureDescription(
												choiceId,
												selectedOptionValues
											);
											if (detailedDescription) {
												description = detailedDescription;
											}

											// Use generic display label
											const displayLabel = getDisplayLabel(
												selectedClassFeatures.className,
												feature.featureName,
												choiceIndex
											);
											const sourceDetail = `${selectedClassFeatures.className} (${displayLabel})`;

											features.push({
												id: `${choiceId}_${selectedOptionValues}`,
												name: selectedOption.name,
												description: description,
												source: 'choice',
												sourceDetail: sourceDetail
											});
										}
									}
								}
							});
						}
					});
				} catch (error) {
					console.error('Error parsing selected feature choices JSON:', error);
				}
			}
		}

		return features;
	};

	// Handle feature popup
	const openFeaturePopup = (feature: FeatureData) => {
		setSelectedFeature(feature);
	};

	const closeFeaturePopup = () => {
		setSelectedFeature(null);
	};

	// Handle spell popup
	const openSpellPopup = (spell: Spell) => {
		setSelectedSpell(spell);
	};

	const closeSpellPopup = () => {
		setSelectedSpell(null);
	};

	const openManeuverPopup = (maneuver: Maneuver) => {
		setSelectedManeuver(maneuver);
	};

	const closeManeuverPopup = () => {
		setSelectedManeuver(null);
	};

	// Handle attack popup
	const openAttackPopup = (attack: AttackData, weapon: Weapon | null) => {
		setSelectedAttack({ attack, weapon });
	};

	const closeAttackPopup = () => {
		setSelectedAttack(null);
	};

	// Handle inventory popup
	const openInventoryPopup = (inventoryData: InventoryItemData, item: InventoryItem | null) => {
		setSelectedInventoryItem({ inventoryData, item });
	};

	const closeInventoryPopup = () => {
		setSelectedInventoryItem(null);
	};

	// Navigation functions


	// Currency management function
	const handleCurrencyChange = (currency: string, value: number) => {
		setCurrentValues((prev) => {
			const newValues = {
				...prev,
				[currency]: value
			};

			// Save to localStorage after state update
			if (characterData?.id) {
				setTimeout(() => saveCharacterData(characterData.id, newValues), 0);
			}

			return newValues;
		});
	};

	// Handle exhaustion level changes
	const handleExhaustionChange = (level: number) => {
		setCurrentValues((prev) => {
			const newLevel = prev.exhaustionLevel === level ? level - 1 : level;
			const newValues = {
				...prev,
				exhaustionLevel: Math.max(0, Math.min(5, newLevel))
			};

			// Save to localStorage after state update
			if (characterData?.id) {
				setTimeout(() => saveCharacterData(characterData.id, newValues), 0);
			}

			return newValues;
		});
	};

	// Handle death step changes
	const handleDeathStepChange = (step: number) => {
		if (!characterData) return;

		const deathThreshold = calculateDeathThreshold(
			characterData.finalPrimeModifierValue,
			characterData.finalCombatMastery
		);
		const targetHP = -step;

		// Don't allow going below death threshold
		if (targetHP < deathThreshold) {
			setCurrentValues((prev) => {
				const newValues = { ...prev, currentHP: deathThreshold };
				// Save to localStorage after state update
				if (characterData?.id) {
					setTimeout(() => saveCharacterData(characterData.id, newValues), 0);
				}
				return newValues;
			});
		} else {
			setCurrentValues((prev) => {
				const newValues = { ...prev, currentHP: targetHP };
				// Save to localStorage after state update
				if (characterData?.id) {
					setTimeout(() => saveCharacterData(characterData.id, newValues), 0);
				}
				return newValues;
			});
		}
	};

	// Helper function to safely calculate fill percentage
	const getFillPercentage = (current: number, max: number): number => {
		if (max === 0) return 0;
		return Math.max(0, Math.min(100, (current / max) * 100));
	};

	// Copy character data to clipboard
	// Revert character data to original values
	const handleRevertToOriginal = (
		dataType: 'resources' | 'currency' | 'attacks' | 'spells' | 'maneuvers' | 'inventory' | 'all'
	) => {
		if (dataType === 'all') {
			// Revert all data types
			revertToOriginal(characterId, 'resources');
			revertToOriginal(characterId, 'currency');
			revertToOriginal(characterId, 'attacks');
			revertToOriginal(characterId, 'spells');
			revertToOriginal(characterId, 'maneuvers');
			revertToOriginal(characterId, 'inventory');

			// Also clear all manual defense overrides (PDR, PD, AD)
			clearDefenseNotesForField(characterId, 'manualPD');
			clearDefenseNotesForField(characterId, 'manualPDR');
			clearDefenseNotesForField(characterId, 'manualAD');

			// Clear the manual defense values in localStorage
			saveManualDefense(characterId, 'manualPD', undefined);
			saveManualDefense(characterId, 'manualPDR', undefined);
			saveManualDefense(characterId, 'manualAD', undefined);

			// Reload the page to reflect changes
			window.location.reload();
		} else {
			revertToOriginal(characterId, dataType);

			// Update local state based on what was reverted
			if (dataType === 'resources') {
				setCurrentValues((prev) => ({
					...prev,
					currentHP: characterData?.finalHPMax || 0,
					currentSP: characterData?.finalSPMax || 0,
					currentMP: characterData?.finalMPMax || 0,
					currentGritPoints: characterData?.finalGritPoints || 0,
					currentRestPoints: characterData?.finalRestPoints || 0,
					tempHP: 0,
					actionPointsUsed: 0,
					exhaustionLevel: 0
				}));
			} else if (dataType === 'currency') {
				setCurrentValues((prev) => ({
					...prev,
					goldPieces: 0,
					silverPieces: 0,
					copperPieces: 0,
					electrumPieces: 0,
					platinumPieces: 0
				}));
			} else if (dataType === 'attacks') {
				// Reset to default attacks
				const defaultAttacks: AttackData[] = [
					{
						id: '1',
						weaponName: '',
						name: '',
						attackBonus: 0,
						damage: '',
						damageType: '',
						critRange: '',
						critDamage: '',
						brutalDamage: '',
						heavyHitEffect: ''
					},
					{
						id: '2',
						weaponName: '',
						name: '',
						attackBonus: 0,
						damage: '',
						damageType: '',
						critRange: '',
						critDamage: '',
						brutalDamage: '',
						heavyHitEffect: ''
					},
					{
						id: '3',
						weaponName: '',
						name: '',
						attackBonus: 0,
						damage: '',
						damageType: '',
						critRange: '',
						critDamage: '',
						brutalDamage: '',
						heavyHitEffect: ''
					}
				];
				setAttacks(defaultAttacks);
			} else if (dataType === 'spells') {
				// Use the original spells from character state
				if (characterState?.spells?.original) {
					setSpells([...characterState.spells.original]);
				}
			} else if (dataType === 'maneuvers') {
				// Use the original maneuvers from character state
				if (characterState?.maneuvers?.original) {
					setManeuvers([...characterState.maneuvers.original]);
				}
			} else if (dataType === 'inventory') {
				setInventory([]);
			}
		}
	};

	const copyCharacterToClipboard = async () => {
		try {
			if (!characterData) {
				alert('Character data not found');
				return;
			}

			const character = getCharacterFromStorage(characterData.id);
			if (!character) {
				alert('Character data not found in storage');
				return;
			}

			const characterBackup = {
				...character,
				exportedAt: new Date().toISOString(),
				exportVersion: '1.0'
			};

			const jsonString = JSON.stringify(characterBackup, null, 2);
			await navigator.clipboard.writeText(jsonString);

			// Show success message
			alert('Character data copied to clipboard! You can save this as a backup.');
		} catch (error) {
			console.error('Failed to copy character data:', error);
			alert('Failed to copy character data to clipboard');
		}
	};

	const handlePrintCharacterSheet = () => {
		try {
			if (!characterData) {
				alert('Character data not found');
				return;
			}

			// Create a new window for printing
			const printWindow = window.open('', '_blank');
			if (!printWindow) {
				alert('Please allow popups to print the character sheet');
				return;
			}

			// Get the character sheet element
			const characterSheetElement = document.querySelector('.character-sheet-content');
			if (!characterSheetElement) {
				alert('Character sheet content not found');
				return;
			}

			// Get current data for printing
			const currentAttacks = attacks;
			const currentSpells = spells.length > 0 ? spells : (characterState?.spells?.current || []);
			const currentManeuvers = maneuvers.length > 0 ? maneuvers : (characterState?.maneuvers?.current || []);

			// Debug logging
			console.log('Print function - currentSpells:', currentSpells);
			console.log('Print function - spells state:', spells);
			console.log('Print function - characterState?.spells?.current:', characterState?.spells?.current);
			console.log('Print function - currentManeuvers:', currentManeuvers);

			// Create print-friendly HTML
			const printHTML = `
				<!DOCTYPE html>
				<html>
				<head>
					<title>${characterData.finalName} - DC20 Character Sheet</title>
					<style>
						@page {
							size: A4;
							margin: 1cm;
						}
						body {
							font-family: 'Georgia', serif;
							color: #2d2d2d;
							background: white;
							margin: 0;
							padding: 20px;
							line-height: 1.4;
						}
						.character-sheet {
							max-width: 100%;
							border: 2px solid #8b4513;
							border-radius: 8px;
							padding: 20px;
							background: white;
							margin-bottom: 30px;
						}
						.page-break {
							page-break-before: always;
						}
						.header {
							display: grid;
							grid-template-columns: 1fr 1fr 1fr auto;
							gap: 20px;
							margin-bottom: 20px;
							padding-bottom: 15px;
							border-bottom: 2px solid #8b4513;
						}
						.header-section {
							display: flex;
							flex-direction: column;
							gap: 5px;
						}
						.label {
							font-weight: bold;
							font-size: 0.9rem;
							color: #8b4513;
						}
						.value {
							font-size: 1.1rem;
							font-weight: bold;
						}
						.dc20-logo {
							font-size: 2rem;
							font-weight: bold;
							color: #8b4513;
							text-align: center;
							align-self: center;
						}
						.main-grid {
							display: grid;
							grid-template-columns: 300px 1fr 250px;
							gap: 20px;
						}
						.column {
							display: flex;
							flex-direction: column;
							gap: 15px;
						}
						.section {
							border: 1px solid #ccc;
							border-radius: 6px;
							padding: 15px;
							background: #f9f9f9;
						}
						.section-title {
							font-weight: bold;
							font-size: 1.1rem;
							color: #8b4513;
							margin-bottom: 10px;
							border-bottom: 1px solid #8b4513;
							padding-bottom: 5px;
						}
						.resource-circle {
							display: inline-block;
							width: 60px;
							height: 60px;
							border: 3px solid #8b4513;
							border-radius: 50%;
							text-align: center;
							line-height: 60px;
							font-weight: bold;
							font-size: 1.2rem;
							margin: 5px;
							background: white;
						}
						.defense-box {
							display: inline-block;
							padding: 10px 15px;
							border: 2px solid #8b4513;
							border-radius: 6px;
							text-align: center;
							margin: 5px;
							background: white;
						}
						.defense-label {
							font-size: 0.8rem;
							color: #666;
						}
						.defense-value {
							font-size: 1.3rem;
							font-weight: bold;
							color: #8b4513;
						}
						.skill-row {
							display: flex;
							justify-content: space-between;
							padding: 3px 0;
							border-bottom: 1px solid #eee;
						}
						.skill-name {
							font-weight: bold;
						}
						.skill-bonus {
							color: #8b4513;
							font-weight: bold;
						}
						.attack-row {
							display: flex;
							justify-content: space-between;
							align-items: center;
							padding: 5px 0;
							border-bottom: 1px solid #eee;
						}
						.spell-grid {
							display: grid;
							grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
							gap: 10px;
						}
						.spell-item {
							border: 1px solid #ccc;
							border-radius: 4px;
							padding: 8px;
							background: white;
							font-size: 0.9rem;
						}
						.spell-card {
							page-break-inside: avoid;
							break-inside: avoid;
						}
						.maneuver-card {
							page-break-inside: avoid;
							break-inside: avoid;
						}
						.inventory-item {
							display: flex;
							justify-content: space-between;
							padding: 3px 0;
							border-bottom: 1px solid #eee;
						}
						@media print {
							body { margin: 0; }
							.character-sheet { border: none; }
						}
					</style>
				</head>
				<body>
					<div class="character-sheet">
						<div class="header">
							<div class="header-section">
								<div class="label">Player Name</div>
								<div class="value">${characterData.finalPlayerName || 'Unknown'}</div>
								<div class="label">Character Name</div>
								<div class="value">${characterData.finalName}</div>
							</div>
							<div class="header-section">
								<div class="label">Class & Subclass</div>
								<div class="value">${characterData.className}</div>
								<div class="label">Ancestry & Background</div>
								<div class="value">${characterData.ancestry1Name || 'Unknown'}</div>
							</div>
							<div class="header-section">
								<div class="label">Level</div>
								<div class="value">${characterData.finalLevel}</div>
								<div class="label">Combat Mastery</div>
								<div class="value">+${characterData.finalCombatMastery}</div>
							</div>
							<div class="dc20-logo">DC20</div>
						</div>
						
						<div class="main-grid">
							<div class="column">
								<div class="section">
									<div class="section-title">Resources</div>
									<div style="text-align: center;">
										<div class="resource-circle">${currentValues.currentHP}/${characterData.finalHPMax}</div>
										<div class="resource-circle">${currentValues.currentSP}/${characterData.finalSPMax}</div>
										<div class="resource-circle">${currentValues.currentMP}/${characterData.finalMPMax}</div>
									</div>
								</div>
								
								<div class="section">
									<div class="section-title">Defenses</div>
									<div style="text-align: center;">
										<div class="defense-box">
											<div class="defense-label">PD</div>
											<div class="defense-value">${getCalculatedDefenses().calculatedPD}</div>
										</div>
										<div class="defense-box">
											<div class="defense-label">AD</div>
											<div class="defense-value">${getCalculatedDefenses().calculatedAD}</div>
										</div>
										<div class="defense-box">
											<div class="defense-label">PDR</div>
											<div class="defense-value">${getCalculatedDefenses().calculatedPDR}</div>
										</div>
									</div>
								</div>
								
								<div class="section">
									<div class="section-title">Attributes</div>
									<div class="skill-row">
										<span class="skill-name">Might</span>
						<span class="skill-bonus">+${characterData.finalMight}</span>
					</div>
					<div class="skill-row">
						<span class="skill-name">Agility</span>
						<span class="skill-bonus">+${characterData.finalAgility}</span>
					</div>
					<div class="skill-row">
						<span class="skill-name">Charisma</span>
						<span class="skill-bonus">+${characterData.finalCharisma}</span>
					</div>
					<div class="skill-row">
						<span class="skill-name">Intelligence</span>
						<span class="skill-bonus">+${characterData.finalIntelligence}</span>
					</div>
				</div>
				
				<div class="section">
					<div class="section-title">Skills</div>
					${Object.entries(skillsByAttribute).map(([attr, skills]) => 
						skills.length > 0 ? `
							<div style="margin-bottom: 10px;">
								<div style="font-weight: bold; color: #8b4513; margin-bottom: 5px;">${attr.charAt(0).toUpperCase() + attr.slice(1)}</div>
								${skills.map(skill => `
									<div class="skill-row">
										<span class="skill-name">${skill.name}</span>
										<span class="skill-bonus">+${skill.bonus}</span>
									</div>
								`).join('')}
							</div>
						` : ''
					).join('')}
				</div>
			</div>
			
			<div class="column">
				<div class="section">
					<div class="section-title">Attacks</div>
					${currentAttacks.map(attack => `
						<div class="attack-row">
							<span class="skill-name">${attack.name}</span>
							<span class="skill-bonus">+${attack.attackBonus}</span>
						</div>
					`).join('')}
				</div>
				

				

				
				<div class="section">
					<div class="section-title">Features</div>
					${features.map(feature => `
						<div style="margin-bottom: 8px; padding: 5px; border: 1px solid #ddd; border-radius: 4px; background: white;">
							<strong>${feature.name}</strong><br>
							<small>${feature.source}</small>
						</div>
					`).join('')}
				</div>
			</div>
			
			<div class="column">
				<div class="section">
					<div class="section-title">Inventory</div>
					${inventory.map(item => `
						<div class="inventory-item">
							<span>${item.itemName}</span>
							<span>${item.count}</span>
						</div>
					`).join('')}
				</div>
				
				<div class="section">
					<div class="section-title">Languages</div>
					${languages.map(lang => `
						<div class="skill-row">
							<span class="skill-name">${lang.name}</span>
							<span class="skill-bonus">${lang.fluency}</span>
						</div>
					`).join('')}
				</div>
				
				<div class="section">
					<div class="section-title">Trades</div>
					${trades.map(trade => `
						<div class="skill-row">
							<span class="skill-name">${trade.name}</span>
							<span class="skill-bonus">+${trade.bonus}</span>
						</div>
					`).join('')}
				</div>
			</div>
		</div>
	</div>

	${characterData.className && findClassByName(characterData.className)?.spellcastingPath && currentSpells.length > 0 ? `
	<div class="page-break"></div>
	<div class="character-sheet">
		<div class="header">
			<div class="header-section">
				<div class="label">Character</div>
				<div class="value">${characterData.finalName}</div>
			</div>
			<div class="header-section">
				<div class="label">Class</div>
				<div class="value">${characterData.className}</div>
			</div>
			<div class="header-section">
				<div class="label">Level</div>
				<div class="value">${characterData.finalLevel}</div>
			</div>
			<div class="dc20-logo">DC20</div>
		</div>
		
		<h2 style="text-align: center; color: #8b4513; margin-bottom: 30px;">Spells</h2>
		
		<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px;">
			${currentSpells.map(spell => {
				const fullSpell = allSpells.find(s => s.name === spell.spellName);
				return `
					<div class="spell-card" style="border: 2px solid #e0e0e0; border-radius: 10px; padding: 20px; background: #f8f9fa; margin-bottom: 20px;">
						<div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
							<div>
								<h3 style="margin: 0 0 5px 0; color: #2c3e50; font-size: 1.4rem;">${spell.spellName}</h3>
							</div>
							<div>
								<span style="background: #3498db; color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; font-weight: bold; text-transform: uppercase;">${spell.school}</span>
								${spell.isCantrip ? '<span style="background: #e74c3c; color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; font-weight: bold; margin-left: 8px;">Cantrip</span>' : ''}
							</div>
						</div>
						
						<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-bottom: 15px;">
							<div>
								<span style="font-weight: bold; color: #7f8c8d; font-size: 0.8rem; text-transform: uppercase;">Cost</span><br>
								<span style="color: #2c3e50; font-size: 0.9rem;">${spell.cost.ap} AP${spell.cost.mp ? `, ${spell.cost.mp} MP` : ''}</span>
							</div>
							<div>
								<span style="font-weight: bold; color: #7f8c8d; font-size: 0.8rem; text-transform: uppercase;">Range</span><br>
								<span style="color: #2c3e50; font-size: 0.9rem;">${spell.range}</span>
							</div>
							<div>
								<span style="font-weight: bold; color: #7f8c8d; font-size: 0.8rem; text-transform: uppercase;">Duration</span><br>
								<span style="color: #2c3e50; font-size: 0.9rem;">${spell.duration}</span>
							</div>
						</div>
						
						${fullSpell && fullSpell.effects && fullSpell.effects.length > 0 ? `
							<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">
								<h4 style="color: #2c3e50; margin: 0 0 10px 0; font-size: 1.1rem;">Description</h4>
								${fullSpell.effects.map((effect, index) => `
									<div style="margin-bottom: ${index < fullSpell.effects.length - 1 ? '15px' : '0'};">
										${effect.title ? `<strong style="color: #2c3e50; font-size: 1rem;">${effect.title}:</strong><br />` : ''}
										<span style="color: #34495e; line-height: 1.6; font-size: 0.95rem;">${effect.description}</span>
									</div>
								`).join('')}
							</div>
						` : ''}
						
						${fullSpell && fullSpell.cantripPassive ? `
							<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">
								<h4 style="color: #2c3e50; margin: 0 0 10px 0; font-size: 1.1rem;">Cantrip Passive</h4>
								<p style="color: #34495e; line-height: 1.6; margin: 0; font-size: 0.95rem;">${fullSpell.cantripPassive}</p>
							</div>
						` : ''}
						
						${fullSpell && fullSpell.enhancements && fullSpell.enhancements.length > 0 ? `
							<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">
								<h4 style="color: #2c3e50; margin: 0 0 10px 0; font-size: 1.1rem;">Enhancements</h4>
								${fullSpell.enhancements.map((enhancement, index) => `
									<div style="margin-top: 10px; padding: 10px; background-color: #f0f0f0; border-radius: 4px;">
										<strong style="color: #2c3e50; font-size: 0.95rem;">${enhancement.name}</strong> (${enhancement.type} ${enhancement.cost})
										<br />
										<span style="color: #34495e; line-height: 1.6; font-size: 0.9rem;">${enhancement.description}</span>
									</div>
								`).join('')}
							</div>
						` : ''}
						
						${spell.notes ? `
							<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">
								<h4 style="color: #2c3e50; margin: 0 0 10px 0; font-size: 1.1rem;">Notes</h4>
								<p style="color: #34495e; line-height: 1.6; margin: 0; font-size: 0.95rem;">${spell.notes}</p>
							</div>
						` : ''}
					</div>
				`;
			}).join('')}
		</div>
	</div>
	` : ''}

	${characterData.className && findClassByName(characterData.className)?.martialPath && currentManeuvers.length > 0 ? `
	<div class="page-break"></div>
	<div class="character-sheet">
		<div class="header">
			<div class="header-section">
				<div class="label">Character</div>
				<div class="value">${characterData.finalName}</div>
			</div>
			<div class="header-section">
				<div class="label">Class</div>
				<div class="value">${characterData.className}</div>
			</div>
			<div class="header-section">
				<div class="label">Level</div>
				<div class="value">${characterData.finalLevel}</div>
			</div>
			<div class="dc20-logo">DC20</div>
		</div>
		
		<h2 style="text-align: center; color: #8b4513; margin-bottom: 30px;">Maneuvers</h2>
		
		<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px;">
			${currentManeuvers.map(maneuver => {
				const fullManeuver = allManeuvers.find(m => m.name === maneuver.maneuverName);
				return `
					<div class="maneuver-card" style="border: 2px solid #e0e0e0; border-radius: 10px; padding: 20px; background: #f8f9fa; margin-bottom: 20px;">
						<div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
							<div>
								<h3 style="margin: 0 0 5px 0; color: #2c3e50; font-size: 1.4rem;">${maneuver.maneuverName}</h3>
							</div>
							<div>
								<span style="background: #27ae60; color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; font-weight: bold; text-transform: uppercase;">${maneuver.type}</span>
								${maneuver.isReaction ? '<span style="background: #e67e22; color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; font-weight: bold; margin-left: 8px;">Reaction</span>' : ''}
							</div>
						</div>
						
						<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-bottom: 15px;">
							<div>
								<span style="font-weight: bold; color: #7f8c8d; font-size: 0.8rem; text-transform: uppercase;">Cost</span><br>
								<span style="color: #2c3e50; font-size: 0.9rem;">${maneuver.cost.ap} AP${maneuver.cost.mp ? `, ${maneuver.cost.mp} MP` : ''}</span>
							</div>
							${fullManeuver && fullManeuver.trigger ? `
								<div>
									<span style="font-weight: bold; color: #7f8c8d; font-size: 0.8rem; text-transform: uppercase;">Trigger</span><br>
									<span style="color: #2c3e50; font-size: 0.9rem;">${fullManeuver.trigger}</span>
								</div>
							` : ''}
							${fullManeuver && fullManeuver.requirement ? `
								<div>
									<span style="font-weight: bold; color: #7f8c8d; font-size: 0.8rem; text-transform: uppercase;">Requirement</span><br>
									<span style="color: #2c3e50; font-size: 0.9rem;">${fullManeuver.requirement}</span>
								</div>
							` : ''}
						</div>
						
						${fullManeuver && fullManeuver.description ? `
							<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">
								<h4 style="color: #2c3e50; margin: 0 0 10px 0; font-size: 1.1rem;">Description</h4>
								<p style="color: #34495e; line-height: 1.6; margin: 0; font-size: 0.95rem;">${fullManeuver.description}</p>
							</div>
						` : ''}
						
						${fullManeuver && fullManeuver.trigger ? `
							<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">
								<h4 style="color: #2c3e50; margin: 0 0 10px 0; font-size: 1.1rem;">Trigger</h4>
								<p style="color: #34495e; line-height: 1.6; margin: 0; font-size: 0.95rem; font-style: italic;">${fullManeuver.trigger}</p>
							</div>
						` : ''}
						
						${fullManeuver && fullManeuver.requirement ? `
							<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">
								<h4 style="color: #2c3e50; margin: 0 0 10px 0; font-size: 1.1rem;">Requirement</h4>
								<p style="color: #34495e; line-height: 1.6; margin: 0; font-size: 0.95rem;">${fullManeuver.requirement}</p>
							</div>
						` : ''}
						
						${maneuver.notes ? `
							<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">
								<h4 style="color: #2c3e50; margin: 0 0 10px 0; font-size: 1.1rem;">Notes</h4>
								<p style="color: #34495e; line-height: 1.6; margin: 0; font-size: 0.95rem;">${maneuver.notes}</p>
							</div>
						` : ''}
					</div>
				`;
			}).join('')}
		</div>
	</div>
	` : ''}
</body>
</html>
			`;

			// Write the HTML to the new window
			printWindow.document.write(printHTML);
			printWindow.document.close();

			// Wait for content to load, then print
			printWindow.onload = () => {
				setTimeout(() => {
					printWindow.print();
					printWindow.close();
				}, 500);
			};
		} catch (error) {
			console.error('Failed to print character sheet:', error);
			alert('Failed to print character sheet');
		}
	};

	// Helper function to get character from localStorage
	const getCharacterFromStorage = (characterId: string) => {
		const savedCharacters = JSON.parse(localStorage.getItem('savedCharacters') || '[]');
		return savedCharacters.find((char: any) => char.id === characterId);
	};

	// Helper function for HP fill percentage (shows current HP vs total effective HP)
	const getHPFillPercentage = (currentHP: number, maxHP: number, tempHP: number): number => {
		const totalEffectiveHP = maxHP + tempHP;
		if (totalEffectiveHP === 0) return 0;
		return Math.max(0, (currentHP / totalEffectiveHP) * 100);
	};

	// Group skills by attribute like in the official sheet
	const getSkillsByAttribute = () => {
		const skills = getSkillsData();
		return {
			might: skills.filter((skill) => skill.attribute === 'might'),
			agility: skills.filter((skill) => skill.attribute === 'agility'),
			charisma: skills.filter((skill) => skill.attribute === 'charisma'),
			intelligence: skills.filter((skill) => skill.attribute === 'intelligence'),
			prime: skills.filter((skill) => skill.attribute === 'prime')
		};
	};

	// Get data from character or empty defaults if no character data
	const trades = characterData ? getTradesData() : [];
	const knowledge = characterData ? getKnowledgeData() : [];
	const languages = characterData ? getLanguagesData() : [];
	const features = characterData ? getFeaturesData() : [];
	const skillsByAttribute = characterData
		? getSkillsByAttribute()
		: { might: [], agility: [], charisma: [], intelligence: [], prime: [] };

	if (loading) {
		return (
			<StyledContainer>
				<div style={{ textAlign: 'center', padding: '4rem' }}>
					<h2>Loading character sheet...</h2>
				</div>
			</StyledContainer>
		);
	}

	if (error || !characterData) {
		return (
			<StyledContainer>
				<div style={{ textAlign: 'center', padding: '4rem' }}>
					<h2>Error loading character sheet</h2>
					<p>{error}</p>
					<StyledBackButton onClick={onBack}>← Back</StyledBackButton>
				</div>
			</StyledContainer>
		);
	}



	return (
		<StyledContainer style={{ position: 'relative' }}>
			{/* Action Buttons - Hidden on mobile */}
			<StyledActionButtons>
				<StyledActionButton
					$variant="danger"
					onClick={() => handleRevertToOriginal('all')}
					title="Revert all modifications back to calculated defaults"
				>
					🔄 Revert All
				</StyledActionButton>
				<StyledActionButton
					onClick={copyCharacterToClipboard}
					title="Copy character data to clipboard for backup"
				>
					📋 Copy to Clipboard
				</StyledActionButton>
				<StyledActionButton
					onClick={handlePrintCharacterSheet}
					title="Print character sheet as PDF"
				>
					🖨️ Print PDF
				</StyledActionButton>
			</StyledActionButtons>

			<StyledBackButton onClick={onBack}>
				<span className="desktop-text">← Back to Menu</span>
				<span className="mobile-text">←</span>
			</StyledBackButton>

			<StyledCharacterSheet className="character-sheet-content">
				{/* Header Section */}
				<StyledHeader>
					<StyledHeaderSection>
						<StyledLabel>Player Name</StyledLabel>
						<StyledValue>{characterData.finalPlayerName || 'Unknown'}</StyledValue>
						<StyledLabel style={{ marginTop: '0.5rem' }}>Character Name</StyledLabel>
						<StyledValue>{characterData.finalName}</StyledValue>
					</StyledHeaderSection>

					<StyledHeaderSection>
						<StyledLabel>Class & Subclass</StyledLabel>
						<StyledValue>{characterData.className}</StyledValue>
						{(() => {
							const classDisplayInfo = getClassDisplayInfo();
							return classDisplayInfo.map((info, index) => (
								<div key={index}>
									<StyledLabel style={{ marginTop: '0.25rem', fontSize: '0.8rem' }}>
										{info.label}
									</StyledLabel>
									<StyledValue style={{ fontSize: '0.9rem' }}>{info.value}</StyledValue>
								</div>
							));
						})()}
						<StyledLabel style={{ marginTop: '0.5rem' }}>Ancestry & Background</StyledLabel>
						<StyledValue>{characterData.ancestry1Name || 'Unknown'}</StyledValue>
					</StyledHeaderSection>

					<StyledHeaderSection>
						<StyledLabel>Level</StyledLabel>
						<StyledValue>{characterData.finalLevel}</StyledValue>
						<StyledLabel style={{ marginTop: '0.5rem' }}>Combat Mastery</StyledLabel>
						<StyledValue>+{characterData.finalCombatMastery}</StyledValue>
					</StyledHeaderSection>

					<div style={{ textAlign: 'center', alignSelf: 'center' }}>
						<div style={{ fontSize: '2rem', fontWeight: 'bold', color: '#8b4513' }}>DC20</div>
					</div>
				</StyledHeader>

				{/* Mobile Navigation - Only show on mobile */}
				{isMobile && (
					<StyledMobileNav>
						<StyledMobileNavButton
							$isActive={activeMobileSection === 'character'}
							onClick={() => setActiveMobileSection('character')}
						>
							🎯 Skills
						</StyledMobileNavButton>
						<StyledMobileNavButton
							$isActive={activeMobileSection === 'combat'}
							onClick={() => setActiveMobileSection('combat')}
						>
							⚔️ Combat
						</StyledMobileNavButton>
						<StyledMobileNavButton
							$isActive={activeMobileSection === 'features'}
							onClick={() => setActiveMobileSection('features')}
						>
							🎒 Items
						</StyledMobileNavButton>
						<StyledMobileNavButton
							$isActive={activeMobileSection === 'info'}
							onClick={() => setActiveMobileSection('info')}
						>
							ℹ️ Info
						</StyledMobileNavButton>
					</StyledMobileNav>
				)}

				{/* Desktop Layout - Only show on desktop */}
				{!isMobile && (
					<StyledMainGrid>
						{/* Left Column - Attributes with Skills */}
						<StyledLeftColumn>
							<LeftColumn
								characterData={characterData}
								skillsByAttribute={skillsByAttribute}
								knowledge={knowledge}
								trades={trades}
								languages={languages}
								breakdowns={characterState?.calculation?.breakdowns}
							/>
						</StyledLeftColumn>

						{/* Middle Column - Resources, Combat, and Core Stats */}
						<StyledMiddleColumn>
							{/* Resources Section - Circular design like official sheet */}
							<Resources
								characterData={characterData}
								currentValues={currentValues}
								onAdjustResource={adjustResource}
								onResourceInputChange={handleResourceInputChange}
								getFillPercentage={getFillPercentage}
								getHPFillPercentage={getHPFillPercentage}
								breakdowns={characterState?.calculation?.breakdowns}
								isMobile={false}
							/>

							{/* Defenses - Shield-like design */}
							<Defenses
								characterData={{
									...characterData,
									manualPD: characterData?.manualPD,
									manualPDR: characterData?.manualPDR,
									manualAD: characterData?.manualAD
								}}
								calculatedDefenses={getCalculatedDefenses()}
								onUpdateManualDefense={handleManualDefenseChange}
								breakdowns={characterState?.calculation?.breakdowns}
								isMobile={false}
							/>

							{/* Combat Section */}
							<Combat
								characterData={characterData}
								currentValues={currentValues}
								setCurrentValues={setCurrentValues}
								breakdowns={characterState?.calculation?.breakdowns}
							/>

							{/* Death & Exhaustion */}
							<DeathExhaustion
								characterData={characterData}
								currentValues={currentValues}
								onExhaustionChange={handleExhaustionChange}
								onDeathStepChange={handleDeathStepChange}
							/>





							{/* Attacks Section */}
							<Attacks
								attacks={attacks}
								setAttacks={updateAttacks}
								characterData={characterData}
								onAttackClick={openAttackPopup}
							/>

							{/* Inventory */}
							<Inventory
								inventory={inventory}
								setInventory={updateInventory}
								onItemClick={openInventoryPopup}
							/>

							{/* Player Notes */}
							<PlayerNotes characterId={characterData.id} />
						</StyledMiddleColumn>

						{/* Right Column - Movement, Resources, Inventory, Features */}
						<StyledRightColumn>
							{/* Movement & Utility */}
							<Movement 
								characterData={characterData} 
								breakdowns={characterState?.calculation?.breakdowns}
							/>

							{/* Resources */}
							<RightColumnResources
								characterData={characterData}
								currentValues={currentValues}
								onResourceInputChange={handleResourceInputChange}
							/>

							{/* Features */}
							<Features features={features} onFeatureClick={openFeaturePopup} />

							{/* Currency Section */}
							<Currency currentValues={currentValues} onCurrencyChange={handleCurrencyChange} />
						</StyledRightColumn>
					</StyledMainGrid>
				)}

				{/* Spells Section - Full width, after main content */}
				{characterData.className && findClassByName(characterData.className)?.spellcastingPath && (
					<div style={{ marginTop: '2rem', padding: '1rem', background: 'white', borderRadius: '8px', border: '2px solid #e0e0e0' }}>
						<h2 style={{ color: '#2c3e50', marginBottom: '1rem', textAlign: 'center' }}>Spells</h2>
						{console.log('🔍 Rendering Spells component with:', { spellsCount: spells.length, spellNames: spells.map(s => s.spellName) })}
						<Spells
							spells={spells}
							setSpells={updateSpells}
							characterData={characterData}
							onSpellClick={openSpellPopup}
							readOnly={true}
						/>
					</div>
				)}

				{/* Maneuvers Section - Full width, after main content */}
				{characterData.className && findClassByName(characterData.className)?.martialPath && (
					<div style={{ marginTop: '2rem', padding: '1rem', background: 'white', borderRadius: '8px', border: '2px solid #e0e0e0' }}>
						<h2 style={{ color: '#2c3e50', marginBottom: '1rem', textAlign: 'center' }}>Maneuvers</h2>
						<Maneuvers
							maneuvers={maneuvers}
							setManeuvers={updateManeuvers}
							characterData={characterData}
							onManeuverClick={openManeuverPopup}
						/>
					</div>
				)}

				{/* Mobile Layout - Only show on mobile */}
				{isMobile && (
					<div>
						{/* Skills Tab - Mobile */}
						{activeMobileSection === 'character' && (
							<div>
								<LeftColumn
									characterData={characterData}
									skillsByAttribute={skillsByAttribute}
									knowledge={knowledge}
									trades={trades}
									languages={languages}
									breakdowns={characterState?.calculation?.breakdowns}
								/>
								<Features features={features} onFeatureClick={openFeaturePopup} />
							</div>
						)}

						{/* Combat Tab - Mobile */}
						{activeMobileSection === 'combat' && (
							<div>
								<Resources
									characterData={characterData}
									currentValues={currentValues}
									onAdjustResource={adjustResource}
									onResourceInputChange={handleResourceInputChange}
									getFillPercentage={getFillPercentage}
									getHPFillPercentage={getHPFillPercentage}
									breakdowns={characterState?.calculation?.breakdowns}
									isMobile={true}
								/>
								<Defenses
									characterData={{
										...characterData,
										manualPD: characterData?.manualPD,
										manualPDR: characterData?.manualPDR,
										manualAD: characterData?.manualAD
									}}
									calculatedDefenses={getCalculatedDefenses()}
									onUpdateManualDefense={handleManualDefenseChange}
									breakdowns={characterState?.calculation?.breakdowns}
									isMobile={true}
								/>
								<Combat
									characterData={characterData}
									currentValues={currentValues}
									setCurrentValues={setCurrentValues}
									breakdowns={characterState?.calculation?.breakdowns}
								/>
								<DeathExhaustion
									characterData={characterData}
									currentValues={currentValues}
									onExhaustionChange={handleExhaustionChange}
									onDeathStepChange={handleDeathStepChange}
								/>
								<Spells
									spells={spells}
									setSpells={updateSpells}
									characterData={characterData}
									onSpellClick={openSpellPopup}
								/>
								<Attacks
									attacks={attacks}
									setAttacks={updateAttacks}
									characterData={characterData}
									onAttackClick={openAttackPopup}
								/>
								{characterData.className && findClassByName(characterData.className)?.spellcastingPath && (
									<Spells
										spells={spells}
										setSpells={updateSpells}
										characterData={characterData}
										onSpellClick={openSpellPopup}
										readOnly={true}
									/>
								)}
								{characterData.className && findClassByName(characterData.className)?.martialPath && (
									<Maneuvers
										maneuvers={maneuvers}
										setManeuvers={updateManeuvers}
										characterData={characterData}
										onManeuverClick={openManeuverPopup}
									/>
								)}
								<Movement 
									characterData={characterData} 
									breakdowns={characterState?.calculation?.breakdowns}
								/>
								<RightColumnResources
									characterData={characterData}
									currentValues={currentValues}
									onResourceInputChange={handleResourceInputChange}
								/>
							</div>
						)}

						{/* Items Tab - Mobile */}
						{activeMobileSection === 'features' && (
							<div>
								<Inventory
									inventory={inventory}
									setInventory={updateInventory}
									onItemClick={openInventoryPopup}
								/>
								<Currency currentValues={currentValues} onCurrencyChange={handleCurrencyChange} />
							</div>
						)}

						{/* Info Tab - Mobile */}
						{activeMobileSection === 'info' && (
							<div>
								<div
									style={{
										border: '2px solid #8b4513',
										borderRadius: '8px',
										padding: '1rem',
										background: 'white',
										marginBottom: '1rem'
									}}
								>
									<h3
										style={{
											color: '#8b4513',
											marginTop: '0',
											marginBottom: '1rem',
											textAlign: 'center',
											fontSize: '1.2rem'
										}}
									>
										Character Information
									</h3>

									<div style={{ marginBottom: '1rem' }}>
										<StyledLabel>Player Name</StyledLabel>
										<StyledValue>{characterData.finalPlayerName || 'Unknown'}</StyledValue>
									</div>

									<div style={{ marginBottom: '1rem' }}>
										<StyledLabel>Character Name</StyledLabel>
										<StyledValue>{characterData.finalName}</StyledValue>
									</div>

									<div style={{ marginBottom: '1rem' }}>
										<StyledLabel>Class & Subclass</StyledLabel>
										<StyledValue>{characterData.className}</StyledValue>
										{(() => {
											const classDisplayInfo = getClassDisplayInfo();
											return classDisplayInfo.map((info, index) => (
												<div key={index}>
													<StyledLabel style={{ marginTop: '0.25rem', fontSize: '0.8rem' }}>
														{info.label}
													</StyledLabel>
													<StyledValue style={{ fontSize: '0.9rem' }}>{info.value}</StyledValue>
												</div>
											));
										})()}
									</div>

									<div style={{ marginBottom: '1rem' }}>
										<StyledLabel>Ancestry & Background</StyledLabel>
										<StyledValue>{characterData.ancestry1Name || 'Unknown'}</StyledValue>
									</div>

									<div style={{ marginBottom: '1rem' }}>
										<StyledLabel>Level</StyledLabel>
										<StyledValue>{characterData.finalLevel}</StyledValue>
									</div>

									<div style={{ marginBottom: '1rem' }}>
										<StyledLabel>Combat Mastery</StyledLabel>
										<StyledValue>+{characterData.finalCombatMastery}</StyledValue>
									</div>

									<div style={{ textAlign: 'center', marginTop: '1.5rem' }}>
										<div style={{ fontSize: '2rem', fontWeight: 'bold', color: '#8b4513' }}>
											DC20
										</div>
									</div>
								</div>
								<PlayerNotes characterId={characterData.id} />
							</div>
						)}
					</div>
				)}
			</StyledCharacterSheet>

			{/* Feature Popup */}
			<FeaturePopup feature={selectedFeature} onClose={closeFeaturePopup} />

			{/* Spell Popup Modal */}
			{selectedSpell && (
				<StyledFeaturePopupOverlay onClick={closeSpellPopup}>
					<StyledFeaturePopupContent onClick={(e) => e.stopPropagation()}>
						<StyledFeaturePopupHeader>
							<StyledFeaturePopupTitle>{selectedSpell.name}</StyledFeaturePopupTitle>
							<StyledFeaturePopupClose onClick={closeSpellPopup}>×</StyledFeaturePopupClose>
						</StyledFeaturePopupHeader>
						<StyledFeaturePopupDescription>
							<strong>School:</strong> {selectedSpell.school}
							<br />
							<strong>AP Cost:</strong> {selectedSpell.cost.ap}
							<br />
							{selectedSpell.cost.mp && (
								<>
									<strong>MP Cost:</strong> {selectedSpell.cost.mp}
									<br />
								</>
							)}
							<strong>Range:</strong> {selectedSpell.range}
							<br />
							<strong>Duration:</strong> {selectedSpell.duration}
							<br />
							{selectedSpell.isCantrip && (
								<>
									<strong>Type:</strong> Cantrip
									<br />
								</>
							)}
							{selectedSpell.isRitual && (
								<>
									<strong>Ritual:</strong> Yes
									<br />
								</>
							)}
							<br />
							<strong>Description:</strong>
							<br />
							{selectedSpell.effects?.map((effect, index) => (
								<div key={index} style={{ marginBottom: '0.5rem' }}>
									{effect.title && <strong>{effect.title}:</strong>}
									<br />
									{effect.description}
								</div>
							)) || 'No description available.'}
							{selectedSpell.cantripPassive && (
								<>
									<br />
									<br />
									<strong>Cantrip Passive:</strong> {selectedSpell.cantripPassive}
								</>
							)}
							{selectedSpell.enhancements?.length > 0 && (
								<>
									<br />
									<br />
									<strong>Enhancements:</strong>
									{selectedSpell.enhancements.map((enhancement, index) => (
										<div key={index} style={{ marginTop: '0.5rem', padding: '0.5rem', backgroundColor: '#f5f5f5', borderRadius: '4px' }}>
											<strong>{enhancement.name}</strong> ({enhancement.type} {enhancement.cost})
											<br />
											{enhancement.description}
										</div>
									))}
								</>
							)}
						</StyledFeaturePopupDescription>
					</StyledFeaturePopupContent>
				</StyledFeaturePopupOverlay>
			)}

			{/* Maneuver Popup Modal */}
			{selectedManeuver && (
				<StyledFeaturePopupOverlay onClick={closeManeuverPopup}>
					<StyledFeaturePopupContent onClick={(e) => e.stopPropagation()}>
						<StyledFeaturePopupHeader>
							<StyledFeaturePopupTitle>{selectedManeuver.name}</StyledFeaturePopupTitle>
							<StyledFeaturePopupClose onClick={closeManeuverPopup}>×</StyledFeaturePopupClose>
						</StyledFeaturePopupHeader>
						<StyledFeaturePopupDescription>
							<strong>Type:</strong> {selectedManeuver.type}
							<br />
							<strong>AP Cost:</strong> {selectedManeuver.cost.ap}
							<br />
							<strong>Action Type:</strong> {selectedManeuver.isReaction ? 'Reaction' : 'Action'}
							<br />
							{selectedManeuver.trigger && (
								<>
									<strong>Trigger:</strong> {selectedManeuver.trigger}
									<br />
								</>
							)}
							{selectedManeuver.requirement && (
								<>
									<strong>Requirement:</strong> {selectedManeuver.requirement}
									<br />
								</>
							)}
							<br />
							<strong>Description:</strong>
							<br />
							{selectedManeuver.description}
						</StyledFeaturePopupDescription>
					</StyledFeaturePopupContent>
				</StyledFeaturePopupOverlay>
			)}
			<SpellPopup spell={selectedSpell} onClose={closeSpellPopup} />

			{/* Attack Popup Modal */}
			<AttackPopup selectedAttack={selectedAttack} onClose={closeAttackPopup} />

			{/* Inventory Popup Modal */}
			<InventoryPopup selectedInventoryItem={selectedInventoryItem} onClose={closeInventoryPopup} />

			{/* Draconic Dice Roller */}
			<DiceRoller
				onRoll={(results, total, rollMode) => {
					console.log('Dice rolled:', { results, total, rollMode });
				}}
			/>
		</StyledContainer>
	);
};

export default CharacterSheet;
```
